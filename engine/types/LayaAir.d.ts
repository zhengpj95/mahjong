/**
 * @en Laya is the reference entry for global objects.
 * - The Laya class refers to some commonly used global objects, such as Laya.stage: stage, Laya.timer: time manager, Laya.loader: loading manager. Pay attention to case when using.
 * @zh Laya是全局对象的引用入口集。
 * - Laya类引用了一些常用的全局对象，比如Laya.stage：舞台，Laya.timer：时间管理器，Laya.loader：加载管理器，使用时注意大小写。
 */
declare class Laya {
    /**
     * @en Reference to the stage object.
     * @zh 舞台对象的引用。
     */
    static stage: Laya.Stage;
    /**
     * @ignore
     * @en System clock manager, used by the engine internally.
     * @zh 系统时钟管理器，引擎内部使用。
     */
    static systemTimer: Laya.Timer;
    /**
     * @ignore
     * @en physics clock manager for components.
     * @zh 组件的物理时钟管理器
     */
    static physicsTimer: Laya.Timer;
    /**
     * @en Main game timer, also manages scene, animation, tween effects clock. By controlling this timer's scale, fast-forward and slow-motion effects can be achieved.
     * @zh 游戏主时针，同时也是管理场景，动画，缓动等效果时钟，通过控制本时针缩放，达到快进慢播效果。
     */
    static timer: Laya.Timer;
    /**
     * @en Reference to the loading manager.
     * @zh 加载管理器的引用。
     */
    static loader: Laya.Loader;
    /**
     * @ignore
     * @en Reference to the Render class.
     * @zh Render类的引用。
     */
    static render: Laya.Render;
    private static _inited;
    private static _initCallbacks;
    private static _beforeInitCallbacks;
    private static _afterInitCallbacks;
    private static _evcode;
    private static isNativeRender_enable;
    /**
     * @en Initialize the engine. To use the engine, you need to initialize it first.
     * @param stageConfig Stage settings used to initialize the engine
     * @zh 初始化引擎。使用引擎需要先初始化引擎。
     * @param stageConfig 初始化引擎的舞台设置。
     */
    static init(stageConfig?: Laya.IStageConfig): Promise<void>;
    /**
     * @en Initialize the engine. To use the engine, you need to initialize it first.
     * @param width The width of the initialized game window, also known as design width.
     * @param height The height of the initialized game window, also known as design height.
     * @zh 初始化引擎。使用引擎需要先初始化引擎。
     * @param width 初始化的游戏窗口宽度，又称设计宽度。
     * @param height 初始化的游戏窗口高度，又称设计高度。
     */
    static init(width: number, height: number): Promise<void>;
    /**
     * @en Initialize 2D rendering.
     * @param stageConfig Settings used to initialize 2D rendering.
     * @zh 初始化2D渲染。
     * @param stageConfig 用于初始化2D的设置。
     */
    static initRender2D(stageConfig: Laya.IStageConfig): void;
    /**
     * @en Pop up error information, suitable for mobile devices and other convenient debugging.
     * @param value Indicates whether to capture global errors and display a prompt. When set to true, detailed error stacks can be thrown in a pop-up window if unknown errors occur. The default is false.
     * @zh 弹出错误信息，适用于移动设备等不方便调试的时候，
     * @param value 表示是否捕获全局错误并弹出提示。设置为true后，如有未知错误，可以弹窗抛出详细错误堆栈,默认为false。
     */
    static alertGlobalError(value: boolean): void;
    /**
     * @en Enable DebugPanel.
     * @param debugJsPath Path to the laya.debugtool.js file.
     * @zh 开启DebugPanel。
     * @param debugJsPath laya.debugtool.js文件路径。
     */
    static enableDebugPanel(debugJsPath?: string): void;
    /**
     * @en Adds an initialization function. Various engine modules, such as physics, pathfinding, etc., can register their initialization logic here if needed.
     * Developers typically do not use this directly. All registered callbacks are executed in parallel.
     * @param callback The initialization function of the module.
     * @zh 新增初始化函数，引擎各个模块，例如物理，寻路等，如果有初始化逻辑可以在这里注册初始化函数。
     * 开发者一般不直接使用。所有注册的回调是并行执行。
     * @param callback 模块的初始化函数。
     */
    static addInitCallback(callback: () => void | Promise<void>): void;
    /**
     * @en Execute custom logic before engine initialization. At this time, the Stage has not been created yet, so you can modify stageConfig to implement dynamic stage configuration. All registered callbacks are executed in the order of registration.
     * @param callback The initialization function of the module.
     * @zh 在引擎初始化前执行自定义逻辑。
     * 此时 Stage 尚未创建，可以修改 stageConfig 实现动态舞台配置。所有注册的回调按注册顺序依次执行。
     * @param callback 模块的初始化函数。
     */
    static addBeforeInitCallback(callback: (stageConfig: Laya.IStageConfig) => void | Promise<void>): void;
    /**
     * @en Execute custom logic after engine initialization. All registered callbacks are executed in the order of registration.
     * @param callback The initialization function of the module.
     * @zh 在引擎初始化后执行自定义逻辑。所有注册的回调按注册顺序依次执行。
     * @param callback 模块的初始化函数。
     */
    static addAfterInitCallback(callback: () => void | Promise<void>): void;
}
declare var addInitCallback: typeof Laya.addInitCallback;
declare var addBeforeInitCallback: typeof Laya.addBeforeInitCallback;
declare var addAfterInitCallback: typeof Laya.addAfterInitCallback;
/**
 * @en Laya3D class is used to initialize 3D settings.
 * @zh Laya3D类用于初始化3D设置。
 */
declare class Laya3D {
    /**
     * @en Physics creation manager.
     * @zh 物理创建管理器。
     */
    static _PhysicsCreateUtil: Laya.IPhysicsCreateUtil;
    /**
     * @en The physics creation manager.
     * @zh 物理创建管理器。
     */
    static get PhysicsCreateUtil(): Laya.IPhysicsCreateUtil;
    static set PhysicsCreateUtil(value: Laya.IPhysicsCreateUtil);
    /**
     * @en Whether physics is enabled.
     * @zh 是否启用物理。
     * @returns {boolean} True if physics is enabled, false otherwise.
     * @returns {boolean} 如果启用了物理则返回true，否则返回false。
     */
    static get enablePhysics(): any;
}
declare module Laya {
    /**
     * @en Config is used to set some global parameters. If you need to change them, please set them before initializing the engine.
     * @zh Config类用于配置一些全局参数。如需更改，请在初始化引擎之前设置。
     */
    class Config {
        /**
         * @en Canvas setting for anti-aliasing, only effective for 2D(WebGL). 3D anti-aliasing is controlled on the camera or RT.
         * @zh 画布设置是否抗锯齿，只对2D(WebGL)有效,3D抗锯齿在camera或RT上面控制。
         */
        static isAntialias: boolean;
        /**
         * @en Whether to use WebGL2
         * @zh 是否使用WebGL2
         */
        static useWebGL2: boolean;
        /**
         * @en FPS limit
         * @zh 限制FPS
         */
        static FPS: number;
        /**
         * @en Whether to use retina mode, which may create larger RT on iOS for better effects
         * @zh 是否使用视网膜模式，在iOS上面可能会创建更大的RT，来达到更佳的效果
         */
        static useRetinalCanvas: boolean;
        /**
         * @en Default playback interval for 2D animation, in milliseconds.
         * @zh 2D动画 Animation 的默认播放时间间隔，单位为毫秒。
         */
        static animationInterval: number;
        /**
         * @en When using WebGL to render 2D, whether to allocate enough cache for 64k vertices each time a VB is created. This can improve efficiency.
         * @zh 当使用WebGL渲染2D的时候，每次创建VB是否直接分配足够64k个顶点的缓存。这样可以提高效率。
         */
        static webGL2D_MeshAllocMaxMem: boolean;
        /**
         * @en Default text size, default is 12
         * @zh 默认文本大小，默认为12
         */
        static defaultFontSize: number;
        /**
         * @en Default font, default is Arial
         * @zh 默认文本字体，默认为Arial
         */
        static defaultFont: string;
        /**
         * @en Set whether the canvas is transparent, only effective for 2D(WebGL) and 3D.
         * @zh 设置画布是否透明，只对2D(WebGL)、3D有效。
         */
        static isAlpha: boolean;
        /**
         * @en Set whether the canvas contains depth
         * @zh 设置画布是否包含深度
         */
        static isDepth: boolean;
        /**
         * @en Boolean value indicating whether to create this context in a system with low performance
         * @zh 表明在一个系统性能低的环境是否创建该上下文
         */
        static isfailIfMajorPerformanceCaveat: boolean;
        /**
         * @en Power preference for the WebGL/WebGPU context. Hints the browser about the desired GPU configuration.
         * - "default": Let the browser decide. In WebGPU mode, this is automatically set to "high-performance".
         * - "high-performance": Prefer high-performance GPU. Use for graphically intensive applications.
         * - "low-power": Prefer low-power GPU. Suitable for energy-efficient applications.
         * @zh 图形（WebGL/WebGPU）上下文的电源偏好设置。向浏览器提示所需的 GPU 配置。
         * - "default"：让浏览器决定。在 WebGPU 模式下，`default`会让引擎自动设置为`high-performance`。
         * - "high-performance"：倾向于高性能 GPU。用于图形密集型应用。
         * - "low-power"：倾向于低功耗 GPU。适用于节能的应用。
         */
        static powerPreference: WebGLPowerPreference;
        /**
         * @en Set whether the canvas is pre-multiplied, only effective for 2D(WebGL) and 3D.
         * @zh 设置画布是否预乘，只对2D(WebGL)、3D有效。
         */
        static premultipliedAlpha: boolean;
        /**
         * @en Set whether to enable stencil buffer for the canvas, only effective for 2D(WebGL) and 3D.
         * @zh 设置画布的是否开启模板缓冲，只对2D(WebGL)、3D有效。
         */
        static isStencil: boolean;
        /**
         * @en Whether to preserve the drawing buffer.
         * @zh 是否保留渲染缓冲区。
         */
        static preserveDrawingBuffer: boolean;
        /**
         * @en Whether to print WebGL instructions and locate WebGL errors
         * @zh 是否打印WebGL指令，同时定位WebGL报错
         */
        static printWebglOrder: boolean;
        /**
         * @en On iOS, some fonts may not be found. The engine provides font mapping functionality. For example, by default, "黑体" is mapped to "黑体-简". More mappings can be added.
         * @zh 在iOS下，一些字体会找不到，引擎提供了字体映射功能，比如默认会把 "黑体" 映射为 "黑体-简"，更多映射，可以自己添加
         */
        static fontFamilyMap: any;
        /**
         * @en Whether to use a fixed frame rate for rendering and updates.
         * - When true: Rendering and logic updates are limited to the frame rate defined by Config.FPS. Ensures consistent application speed across different devices.
         * - When false: Updates occur on every requestAnimationFrame callback. Can lead to varying application speeds on different devices.
         * @zh 是否使用固定帧率进行渲染和更新。
         * - 当为 true 时：渲染和逻辑更新被限制在由 Config.FPS 定义的帧率内。确保在不同设备上应用程序运行速度一致。
         * - 当为 false 时：在每次 requestAnimationFrame 回调时进行更新。可能导致在不同设备上应用程序运行速度不同。
         */
        static fixedFrames: boolean;
        /**
         * @en Whether to immediately delete resources when the reference parameter is 0. If not immediate deletion, please call DestrotyUnUse
         * @zh 资源引用参数为0是否立即删除资源，如果不立即删除请调用DestrotyUnUse
         */
        static destroyResourceImmediatelyDefault: boolean;
    }
    const PlayerConfig: {
        physics2D?: any;
        physics3D?: any;
        spineVersion?: string;
        workerLoaderLib?: string;
        [key: string]: any;
    };
    /**
     * @en Config3D class is used to create 3D initialization configuration.
     * @zh Config3D 类用于创建3D初始化配置。
     */
    class Config3D {
        /**
         * @en Whether to enable dynamic batch
         * @zh 是否启用动态合并
         */
        static enableDynamicBatch: boolean;
        /**
         * @en Whether to enable static batch
         * @zh 是否启用静态合并
         */
        static enableStaticBatch: boolean;
        /**
         * @en Whether to enable UniformBuffer
         * @zh 是否启用UniformBuffer
         */
        static enableUniformBufferObject: boolean;
        /**
         * @en Set 3D RT resolution multiplier
         * @zh 设置3D RT分辨率倍数
         */
        static pixelRatio: number;
        /**
         * @en Set custom resolution
         * @zh 设置自定义分辨率
         */
        static customResolution: boolean;
        /**
         * @en Set the maximum value cached by RendertexturePool
         * @zh 设置最大RendertexturePool缓存的值
         */
        static defaultCacheRTMemory: number;
        /**
         * @en Default physics function initialization memory, in MB.
         * @zh 默认物理功能初始化内存，单位为M。
         */
        static defaultPhysicsMemory: number;
        /**
         * @en Whether to enable multiple lights. If the scene doesn't need multiple lights, turning it off can improve performance.
         * @zh 是否启用多光源。如果场景不需要多光源，关闭后可提升性能。
         */
        static enableMultiLight: boolean;
        /**
         * @en Maximum number of lights.
         * @zh 最大光源数量。
         */
        static maxLightCount: number;
        /**
         * @en Number of light clusters on X, Y, Z axes. The Z value affects the number of area lights (point lights, spotlights) that a Cluster can receive. Math.floor(2048 / lightClusterCount.z - 1) * 4 is the maximum average number of area lights each Cluster can receive. If the average number of light sources affecting each Cluster is greater than this value, the more distant Clusters will ignore the excess light effects.
         * @zh X、Y、Z轴的光照集群数量。Z值会影响Cluster接受区域光（点光、聚光）影响的数量。Math.floor(2048 / lightClusterCount.z - 1) * 4 为每个Cluster的最大平均接受区域光数量。如果每个Cluster所接受光源影响的平均数量大于该值，则较远的Cluster会忽略其中多余的光照影响。
         */
        static lightClusterCount: Vector3;
        /**
         * @en Maximum number of morph targets
         * @zh 最大形变数量
         */
        static maxMorphTargetCount: number;
        /**
         * @en Set resolution size (not the actual rendering resolution)
         * @param width Set resolution width, unit: pixel
         * @param height Set resolution height, unit: pixel
         * @zh 设置分辨率大小（并不是实际渲染分辨率）
         * @param width 设置分辨率宽度，单位为像素
         * @param height 设置分辨率高度，单位为像素
         */
        static setResolution(width: number, height: number): void;
        /**
         * @en Whether to use BVH culling
         * @zh 是否使用BVH裁剪
         */
        static useBVHCull: boolean;
        /**
         * @en Maximum number of cells in a BVH node, nodes exceeding this number will be separated
         * @zh 一个BVH节点最大的cell数，超过这个数会分离
         */
        static BVH_max_SpatialCount: number;
        /**
         * @en Maximum size of BVH node
         * @zh 最大BVH节点的大小
         */
        static BVH_limit_size: number;
        /**
         * @en Minimum number of cellbuilds, if less than this number, BVH construction will not occur
         * @zh 最小cellbuild数，如果小于这个数，不会进行BVH构建
         */
        static BVH_Min_Build_nums: number;
    }
    type FEnumDescriptor = {
        name: string;
        value: any;
        extend?: FEnumDescriptor;
        [index: string]: any;
    }[] | any[] | Object | string;
    type FPropertyType = string | Function | Object | [
        FPropertyType
    ] | [
        "Record",
        FPropertyType
    ];
    interface FPropertyDescriptor {
        /**
        * @en Property name. Generally does not need to be set.
        * @zh 属性名称。一般不需要设定。
        */
        name: string;
        /**
         * @en Property type.
         * Basic types are: "number", "string", "boolean", "any", note that these are used as strings, not types.
         * Composite types are: arrays, expressed as ["number"]; dictionaries, expressed as ["Record", "number"], where the first element is fixed as "Record" and the second element is the actual type.
         * Other object types can directly use the class name, but note that the class must use the regClass decorator. Enum types are also supported. Enum types do not need regClass.
         * If type is not provided, it indicates that it is only used for UI style, has no actual corresponding data, and will not be serialized.
         * @zh 属性类型。
         * 基础类型有：number,string,boolean,any，注意是使用字符串，不是类型。
         * 复合类型有：数组，使用类似["number"]这样的方式表达；字典，使用类似["Record", "number"]这样的方式表达，第一个元素固定为Record，第二个元素为实际类型。
         * 其他对象类型可以直接使用类名，但要注意该类必须有使用regClass装饰器。也支持枚举类型。枚举类型不需要regClass。
         * 如果不提供type，表示只用于ui样式，没有实际对应数据，和不会序列化
         */
        type: FPropertyType;
        /**
         * @en The initial value of the property in the prototype. This value is also used for comparison during serialization, so if they are the same, this property will not be serialized. It must be ensured that the value set here is the initial value of the variable in the class.
         * @zh 该属性在原型中的初始值。这个值也用于序列化时比较，如果相同则不序列化这个属性，所以必须保证这里设置的值就是类中变量的初始值。
         */
        default?: any;
        /**
         * @en Title. If not provided, the name will be used.
         * @zh 标题。如果不提供，则使用name。
         */
        caption: string;
        /**
         * @en Tooltip text
         * @zh 提示文字
         */
        tips: string;
        /**
         * @en Property category. Setting the same value for multiple properties can display them in the same Inspector category.
         * @zh 属性栏目。为多个属性设置相同的值，可以将它们显示在同一个属性栏目内。
         */
        catalog: string;
        /**
         * @en Category title. If not provided, the category name will be used directly.
         * @zh 栏目标题。不提供则直接使用栏目名称。
         */
        catalogCaption: string;
        /**
         * @en The display order of the category, lower values are displayed in front. If not provided, it follows the order in which properties appear.
         * @zh 栏目的显示顺序，数值越小显示在前面。不提供则按属性出现的顺序。
         */
        catalogOrder: number;
        /**
         * @en The control for editing this property. Built-in ones include: number, string, boolean, color, vec2, vec3, vec4, asset
         * - number : Number input.
         * - string : String input. Default is single-line input, for multi-line, need to activate the multiline option.
         * - boolean : Boolean input, used for checkboxes or radio buttons.
         * - color : A color box + palette + color picker
         * - vec2 : Combination of X and Y inputs
         * - vec3 : Combination of X, Y, and Z inputs
         * - vec4 : Combination of X, Y, Z, and W inputs
         * - asset : Select resource
         * - Generally, you don't need to set this option, the editor will automatically select the appropriate control based on the property type, but in some cases you may need to specify it forcefully.
         * - For example, if the data type is Vector4, but it actually expresses a color, the default control for editing Vector4 is not suitable, and you need to set it to "color" here.
         * - Explicitly setting inspector to null will not construct an inspector for the property. This is different from setting hidden to true. When hidden is true, it is created but not visible,
         * while when inspector is null, it is not created at all.
         * @zh 编辑这个属性的控件。内置有：number,string,boolean,color,vec2,vec3,vec4,asset
         * - number : 数字输入。
         * - string : 字符串输入。默认为单行输入，如果是多行，需要激活multiline选项。
         * - boolean : 布尔值输入，用于单选框或多选框。
         * - color : 一个颜色框+调色盘+拾色器
         * - vec2 : XY输入的组合
         * - vec3 : XYZ输入的组合
         * - vec4 : XYZW输入的组合
         * - asset : 选择资源
         * - 一般来说，不需要设置这个选项，编辑器会自动根据属性类型选择适合的控件，但在某些情况下可以需要强制指定。
         * - 例如，如果数据类型是Vector4，但其实它表达的是颜色，用默认编辑Vector4的控件不适合，需要在这里设置为"color"。
         * - 显式设置inspector为null，则不会为属性构造inspector。这与hidden设置为true不同。hidden为true是创建但不可见，
         * inspector为null的话则是完全不创建。
         */
        inspector: string;
        /**
         * @en Hide control: true to hide, false to show. Often used in cases of associated properties.
         * - 1. Can use expressions by putting condition expressions in strings to get boolean type calculation results, for example "!data.a && !data.b" means when properties a and b are both empty, the condition is true, and this property is hidden.
         * - 2. Here, data is the object data of the current component, data.a and data.b property fields a and b refer to the a and b property values in the current component, by this method to get the property values in the component object data, used for conditional judgment, acting on whether the current property is hidden.
         * @zh 隐藏控制:true隐藏，false显示。常用于关联属性的情况。
         * - 1. 可以用表达式，通过将条件表达式放到字符串里，获得布尔类型的运算结果，例如"!data.a && !data.b"，表示属性a和属性b均为空时，条件成立（true），隐藏这个属性。
         * - 2. 这里的data为当前组件的对象数据，data.a与data.b属性字段的a与b就是指当前组件中的a与b属性值，通过这种方法取到组件对象数据中的属性值，用于条件判断，作用于当前属性是否隐藏。
         */
        hidden: boolean | string;
        /**
         * @en Read-only control.
         * - 1. Can use expressions by putting condition expressions in strings to get boolean type calculation results, for example "!data.a && !data.b" means when properties a and b are both empty, the condition is true, and this property is read-only.
         * - 2. Here, data is the object data of the current component, data.a and data.b property fields a and b refer to the a and b property values in the current component, by this method to get the property values in the component object data, used for conditional judgment, acting on whether the current property is hidden.
         * @zh 只读控制。
         * - 1. 可以用表达式，通过将条件表达式放到字符串里，获得布尔类型的运算结果，例如"!data.a && !data.b"，表示属性a和属性b均为空时，条件成立（true），该属性只读。
         * - 2. 这里的data为当前组件的对象数据，data.a与data.b属性字段的a与b就是指当前组件中的a与b属性值，通过这种方法取到组件对象数据中的属性值，用于条件判断，作用于当前属性是否隐藏。
         */
        readonly: boolean | string;
        /**
         * @en Data checking mechanism.
         * - 1. Pass in a string including expressions to judge whether it meets the conditions of the expression. If it meets the conditions, it needs to return an error message.
         * - 2. Usage example: "if(value == data.a) return 'Cannot be the same as the value of a'"
         * Where value is the value entered by the user for this property, data is the object data of the current component, data.a is the a property value in the current component
         * @zh 数据检查机制。
         * - 1. 将包括表达式的字符串传入，用于判断检查是否符合表达式的条件。符合条件，需要返回报错信息。
         * - 2. 使用示例为："if(value == data.a) return '不能与a的值相同'"
         * 其中的value为当前用户在该属性输入的值，data为当前组件的对象数据，data.a是当前组件中的a属性值
         */
        validator: string;
        /**
         * @en Whether to allow the data to be empty.
         * Can use expressions to return true or false results.
         * @zh 是否允许数据为空值。
         * 可以用表达式，返回true或者false的结果。
         */
        required: boolean | string;
        /**
         * @en Whether to serialize
         * @zh 是否序列化
         */
        serializable: boolean;
        /**
         * @en When the property does not participate in serialization, if its data may be affected by other serializable properties, fill in the names of other properties here. This is usually used to determine whether prefab properties are overridden.
         * @zh 属性在不参与序列化时，如果它的数据可能受其他可序列化的属性影响，在这里填写其他属性名称。这通常用于判断预制体属性是否覆盖。
         */
        affectBy: string;
        /**
         * @en Whether it's multi-line text input
         * @zh 是否多行文本输入
         */
        multiline: boolean;
        /**
         * @en Whether it's password input
         * @zh 是否密码输入
         */
        password: boolean;
        /**
         * @en If true or default, text input is submitted every time; otherwise, it's only submitted when losing focus
         * @zh 如果true或者缺省，文本输入每次输入都提交；否则只有在失焦时才提交
         */
        submitOnTyping: boolean;
        /**
         * @en If it's a text type, it's the prompt information for input text; if it's a boolean type, it's the title of the checkbox.
         * @zh 如果是文本类型，是输入文本的提示信息；如果是布尔类型，是多选框的标题。
         */
        prompt: string;
        /**
         * @en Define enumeration
         * @zh 定义枚举
         */
        enumSource: FEnumDescriptor;
        /**
         * @en Hide this property when the data source is empty
         * @zh 当数据源为空时，隐藏这个属性
         */
        hideIfEnumSourceEmpty: boolean;
        /**
         * @en Whether to invert the boolean value. For example, when the property value is true, the checkbox is displayed as unchecked.
         * @zh 是否反转布尔值。例如当属性值为true时，多选框显示为不勾选。
         */
        reverseBool: boolean;
        /**
         * @en Whether null values are allowed. Default is true. Sometimes it is necessary to explicitly set it to true, e.g. to display a checkbox for a color/vec2/vec3/vec4 inspector to determine whether the property value is null.
         * @zh 是否允许null值。默认为true。有时需要显式设置为true，例如为了显示一个color/vec2/vec3/vec4检查器的checkbox，决定属性值是否为null。
         */
        nullable: boolean;
        /**
         * @en For a property that can switch between null and non-null, when switching from a null value to a non-null value, the value here will be used.
         * @zh 对于可以在null和非null之间切换的属性，从null值切换到非null值时，会使用这里的值。
         */
        nonNullDefault?: any;
        /**
         * @en Minimum value for numbers
         * @zh 数字的最小值
         */
        min: number;
        /**
         * @en Maximum value for numbers
         * @zh 数字的最大值
         */
        max: number;
        /**
         * @en Value range, equivalent to setting min and max at once.
         * @zh 数值范围，等同于一次性设置min和max。
         */
        range: [
            number,
            number
        ];
        /**
         * @en The magnitude of value change each time when changing the value by dragging.
         * @zh 拖动方式改变数值时，每次数值改变的幅度。
         */
        step: number;
        /**
         * @en Number of decimal places
         * @zh 小数点后的位数
         */
        fractionDigits: number;
        /**
         * @en Display as percentage
         * @zh 显示为百分比
         */
        percentage: boolean;
        /**
         * @en Applicable to array type properties. Indicates that the array is of fixed length and not allowed to be modified.
         * @zh 对数组类型属性适用。表示数组是固定长度，不允许修改。
         */
        fixedLength: boolean;
        /**
         * @en Applicable to array type properties. If not provided, it means the array allows all operations, if provided, only the listed operations are allowed.
         * @zh 对数组类型属性适用。如果不提供，则表示数组允许所有操作，如果提供，则只允许列出的操作。
         */
        arrayActions: Array<"append" | "insert" | "delete" | "move">;
        /**
         * @en Applicable to array type properties. Here you can define the properties of array elements
         * @zh 对数组类型属性适用。这里可以定义数组元素的属性
         */
        elementProps: Partial<FPropertyDescriptor>;
        /**
         * @en Applicable to color type properties. Indicates whether to provide modification of the transparency a value.
         * @zh 对颜色类型属性适用。表示是否提供透明度a值的修改。
         */
        showAlpha: boolean;
        /**
         * @deprecated Use 'nonNullDefault' instead.
         */
        defaultColor: any;
        /**
         * @deprecated Explicitly set 'nullable' to true to display a checkbox.
         */
        colorNullable: boolean;
        /**
         * @en Applicable to color type properties. When storing hexadecimal color values, this property determines the position of each channel. If the color value does not include an alpha channel, the default value is 'rgb'; if it does, the default value is 'argb'.
         * @zh 对颜色类型属性适用。存储十六进制颜色值时，这个属性决定每个通道的位置。如果颜色值不包含alpha通道，则默认值是'rgb'；如果包含，则默认值是'argb'。
         */
        colorFormat?: 'rgb' | 'argb' | 'abgr';
        /**
         * @en Applicable to object type properties. If true, hide the object's title, and the display indentation of the properties under the object will be reduced by one level.
         * @zh 对对象类型属性适用。如果为true，隐藏对象的标题，同时对象下的属性的显示缩进会减少一级。
         */
        hideHeader: boolean;
        /**
         * @en Applicable to object type properties. When creating an object, you can select a type from a dropdown menu. If explicitly set to null, the menu is disabled. By default, a menu for creating the base class is displayed.
         * @zh 对对象类型属性适用。对象创建时可以下拉选择一个类型。如果显示设置为null，则禁止菜单。默认是显示一个创建基类的菜单。
         */
        createObjectMenu: Array<string>;
        /**
         * @en Applicable to object type properties. Indicates that this property type has struct-like behavior characteristics, that is, it is always used as a whole.
         * For example, if the value of property b of object obj is a1, a1 is an instance of type T, and the structLike of type T is true, then when the properties of a1 change, the editor will simultaneously call obj.b = a1.
         * Default is false.
         * @zh 对对象类型属性适用。表示这个属性类型有类似结构体的行为特性，即总是作为一个整体使用。
         * 例如，obj对象的某个属性b的值是a1，a1是T类型的实例，且T类型的structLike为true，那么当a1的属性改变时，编辑器将同时调用obj.b = a1。
         * 默认为false。
         */
        structLike: boolean;
        /**
         * @en Indicates that this property is a reference to a resource
         * @zh 说明此属性是引用一个资源
         */
        isAsset: boolean;
        /**
         * @en Applicable to resource type properties. Multiple resource types are separated by commas, for example "Image,Audio".
         * @zh 对资源类型的属性适用。多个资源类型用逗号分隔，例如"Image,Audio"。
         */
        assetTypeFilter: string;
        /**
         * @en If the property type is string, and when selecting a resource, this option determines whether the property value is the original path of the resource or in the format of res://uuid. If true, it's the original path of the resource. Default is false.
         * @zh 如果属性类型是string，并且进行资源选择时，这个选项决定属性值是资源原始路径还是res://uuid这样的格式。如果是true，则是资源原始路径。默认false。
         */
        useAssetPath: boolean;
        /**
         * @en Applicable to resource type properties. Whether to allow selection of internal resources when choosing a resource
         * @zh 对资源类型的属性适用。选择资源时是否允许选择内部资源
         */
        allowInternalAssets: boolean;
        /**
         * @en Applicable to resource type properties. You can set a custom filter. The filter needs to be registered first through EditorEnv.assetMgr.customAssetFilters.
         * @zh 对资源类型的属性适用。可以设置一个自定义的过滤器。过滤器需要先通过EditorEnv.assetMgr.customAssetFilters注册。
         */
        customAssetFilter: string;
        /**
         * @en Applicable to properties of type Node or Component. It sets a filter for the node/component types that can be selected. If not provided, all node types can be selected.
         * @zh 对类型是Node或者Component的属性适用。设置可以选择的节点/组件类型过滤器。如果不提供，则可以选择所有节点类型。
         */
        nodeTypeFilter: Array<string>;
        /**
         * @en Applicable to properties of type Node or Component. If not null, when deserialization is performed in the actual runtime environment, the referenced object is no longer instantiated, but its serialized data is saved as-is to the specified property.
         * @zh 对类型是Node或者Component的属性适用。如果不为null，当在实际运行环境里执行反序列化时，引用对象不再实例化，而是将它的序列化数据原样保存到指定的属性中。
         */
        toTemplate: string;
        /**
         * @en Display position. Syntax: before xxx/after xxx/first/last.
         * @zh 显示位置。语法：before xxx/after xxx/first/last。
         */
        position: string;
        /**
         * @en Increase indentation, unit is level, not pixels.
         * @zh 增加缩进，单位是层级，不是像素。
         */
        addIndent?: number;
        /**
         * @en Default collapsed state of sub-properties
         * @zh 子属性默认折叠状态
         */
        collapsed?: boolean;
        /**
         * @en Indicates that the property is a private property. Private properties will not be displayed in the Inspector, but will be serialized and saved.
         * @zh 表示属性是私有属性。私有属性不会显示在Inspector里，但会序列化保存。
         */
        "private": boolean;
        /**
         * @en Indicates whether the property is allowed to be edited in multiple selection situations. Default is true.
         * @zh 表示属性是否允许多选情况下编辑。默认true。
         */
        allowMultipleObjects: boolean;
        /**
         * @en Indicates that the property is not displayed in the property table of derived classes
         * @zh 表示属性不显示在派生类的属性表中
         */
        hideInDeriveType: boolean;
        /**
         * @en When the property changes, additionally call a function of the object, this is the function name.
         * The function prototype is func(key?:string). Where key is passed when changing internal properties of members.
         * For example, when changing the internal properties of an element of the data, key is the index of this element.
         * @zh 属性改变时额外调用对象的一个函数，这里是函数名称。
         * 函数原型是func(key?:string)。其中key在改变成员内部属性时会传递。
         * 例如改变数据某个元素的内部属性，则key是这个元素的索引。
         */
        onChange: string;
        /**
         * @en Additional options
         * @zh 额外的选项
         */
        options: Record<string, any>;
    }
    interface FTypeDescriptor {
        /**
         * @en Title. If not provided, the name will be used.
         * @zh 标题。如果不提供，则使用name。
         */
        caption: string;
        /**
         * @en URL of the help documentation.
         * @zh 帮助文档url地址。
         */
        help: string;
        /**
         * @en Add to the component menu.
         * @zh 添加到组件菜单。
         */
        menu: string;
        /**
         * @en Icon.
         * @zh 图标。
         */
        icon: string;
        /**
         * @en Whether it's a resource type.
         * @zh 是否资源类型。
         */
        isAsset: boolean;
        /**
         * @en Applicable to properties of resource types. Multiple resource types are separated by commas, e.g., "Image,Audio".
         * Available values can be found in editor/public/IAssetInfo.ts.
         * @zh 对资源类型的属性适用。多个资源类型用逗号分隔，例如"Image,Audio"。
         * 可用值参考editor/public/IAssetInfo.ts。
         */
        assetTypeFilter: string;
        /**
         * @en Indicates that this type has struct-like behavior, i.e., it's always used as a whole.
         * For example, if the value of property b of object obj is a1, a1 is an instance of type T,
         * and T's structLike is true, then when a1's properties change, the editor will also call obj.b = a1.
         * Default is false.
         * @zh 表示这个类型有类似结构体的行为特性，即总是作为一个整体使用。
         * 例如，obj对象的某个属性b的值是a1，a1是T类型的实例，且T类型的structLike为true，
         * 那么当a1的属性改变时，编辑器将同时调用obj.b = a1。
         * 默认为false。
         */
        structLike: boolean;
        /**
         * @en Initial value. This value is only used in the panel, it specifies the initial value
         * given to the property when creating an object from the interface.
         * @zh 初始值。这个值只在面板中使用，它指从界面上创建对象时赋予属性的初始值。
         */
        init: any;
        /**
         * @en List of properties.
         * @zh 属性列表。
         */
        properties: Array<Partial<FPropertyDescriptor>>;
        /**
         * @en Control for editing instances of this class.
         * @zh 编辑这个类实例的控件。
         */
        inspector: string;
        /**
         * @en Applicable to Components, indicates the type of node this component can be mounted on. Default is null.
         * @zh 对Component使用，表示这个组件允许挂载的节点类型。默认null。
         */
        worldType: "2d" | "3d" | null;
        /**
         * @en Applicable to Components, when AddComponent, add dependent Components at the same time.
         * @zh 对Component适用，当AddComponent时同时添加依赖的Component。
         */
        requireComponents?: Array<string>;
        /**
         * @en When creating a new node or adding a component, the dependent engine library is automatically added for Node and Component. For example: ["laya. physicals3D"]
         * @zh 对Node和Component使用，当新建Node或者添加Component时，自动添加依赖的引擎库。例如：["laya.physics3D"]
         */
        requireEngineLibs?: Array<string>;
        /**
         * @en Used for Component, if true and menu property is defined, this component will also
         * be displayed in the new object menu of the hierarchy panel.
         * @zh 对Component使用，如果为true，并且定义了menu属性，则这个组件还会显示在层级面板的新建对象菜单上。
         */
        inHierarchyMenu: boolean;
        /**
         * @en Additional options.
         * @zh 额外的选项。
         */
        options: Record<string, any>;
    }
    /**
     * @en Register a class so it can be automatically saved and loaded by the serialization system.
     * @param assetId The asset ID for the class.
     * @zh 注册一个类型，注册后才能被序列化系统自动保存和载入。
     * @param assetId 类型的资源ID。
     */
    function regClass(assetId?: string): any;
    /**
     * @en Set additional information for a class type.
     * @param info Additional information for the class type.
     * @zh 设置类型的额外信息。
     * @param info 类型的额外信息。
     */
    function classInfo(info?: Partial<FTypeDescriptor>): any;
    /**
     * @en Set the component to execute a complete lifecycle in the editor environment.
     * @param constructor The constructor of the component.
     * @zh 设置组件可以在编辑器环境中执行完整生命周期。
     * @param constructor 组件的构造函数。
     */
    function runInEditor(constructor: Function): void;
    /**
     * @en Allow multiple instances of the component to be added to the same node.
     * @param constructor The constructor of the component.
     * @zh 设置组件可以添加多个实例到同一个节点上。
     * @param constructor 组件的构造函数。
     */
    function allowMultiple(constructor: Function): void;
    /**
     * @en Use this decorator to make a property visible in the editor's property panel and serializable.
     * @param info The type of the property, such as Number, "number", [Number], ["Record", Number], etc.
     * Or pass an object describing detailed information, e.g., { type: "string", multiline: true }.
     * @zh 使用这个装饰器，可以使属性显示在编辑器属性设置面板上，并且能序列化保存。
     * @param info 属性的类型，如: Number,"number",[Number],["Record", Number]等。
     * 或传递对象描述详细信息，例如{ type: "string", multiline: true }。
     */
    function property(info: FPropertyType | Partial<FPropertyDescriptor>): any;
    /**
     * @en Register a resource loader.
     * @param fileExtensions File extensions that this loader can handle.
     * @param type Type identifier. If this resource needs to support identification without extension,
     * or if one extension corresponds to multiple resource types, specifying the type parameter is a best practice.
     * @param hotReloadable Whether it supports hot reloading.
     * @zh 注册一种资源装载器。
     * @param fileExtensions 扩展名。
     * @param type 类型标识。如果这种资源需要支持识别没有扩展名的情况，
     * 或者一个扩展名对应了多种资源类型的情况，那么指定type参数是个最优实践。
     * @param hotReloadable 是否支持热重载。
     */
    function regLoader(fileExtensions: string[], type?: string, hotReloadable?: boolean): (constructor: Function) => void;
    /**
     * @en Schedule at start of playback.
     * @zh 开始播放时调度。
     * @eventType Event.PLAYED
     * */
    /**
     * @en Schedule when paused.
     * @zh 暂停时调度。
     * @eventType Event.PAUSED
     * */
    /**
     * @en Schedule upon completion of one cycle.
     * @zh 完成一次循环时调度。
     * @eventType Event.COMPLETE
     * */
    /**
     * @enSchedule when stopped.
     * @zh 停止时调度。
     * @eventType Event.STOPPED
     * */
    /**
     * @en The AnimationPlayer class is used for animation players.
     * @zh AnimationPlayer类用于动画播放器。
     */
    class AnimationPlayer extends EventDispatcher {
        /**
         * @en Whether to cache.
         * @zh 是否缓存。
         */
        isCache: boolean;
        /**
         * @en The playback rate of the animation.
         * @zh 播放速率。
         */
        playbackRate: number;
        /**
         * @en Whether to return to zero when stopped.
         * @zh 停止时是否归零。
         */
        returnToZeroStopped: boolean;
        /**
         * @en The animation data template.  Note: Modifying this value incurs computational overhead.
         * @zh 动画数据模板。注意：修改此值会有计算开销。
         */
        get templet(): AnimationTemplet;
        set templet(value: AnimationTemplet);
        /**
         * @en The start time position of the animation playback.
         * @zh 动画播放的起始时间位置。
         */
        get playStart(): number;
        /**
         * @en The end time position of the animation playback.
         * @zh 动画播放的结束时间位置。
         */
        get playEnd(): number;
        /**
         * @en The total duration of one playback of the animation.
         * @zh 动画播放一次的总时间。
         */
        get playDuration(): number;
        /**
         * @en The total duration of the animation playback.
         * @zh 动画播放的总时间
         */
        get overallDuration(): number;
        /**
         * @en The current animation clip index.
         * @zh 当前动画索引。
         */
        get currentAnimationClipIndex(): number;
        /**
         * @en The current keyframe index.
         * @zh 当前帧数。
         */
        get currentKeyframeIndex(): number;
        /**
         * @en The current precise time, excluding replay time.
         * @zh 当前精确时间，不包括重播时间。
         */
        get currentPlayTime(): number;
        /**
         * @en The current frame time, excluding replay time.
         * @zh 当前帧时间，不包括重播时间。
         */
        get currentFrameTime(): number;
        /**
         * @en The cached playback rate. The default value is 1.0, note: Modifying this value incurs computational overhead.
         * @zh 缓存播放速率。默认值为1.0,注意：修改此值会有计算开销。
         */
        get cachePlayRate(): number;
        set cachePlayRate(value: number);
        /**
         * @en The default frame rate. The default is 60 frames per second, note: Modifying this value incurs computational overhead.
         * @zh 默认帧率。默认为每秒60帧，注意：修改此值会有计算开销。
         */
        get cacheFrameRate(): number;
        set cacheFrameRate(value: number);
        /**
         * @en The current playback position.
         * @zh 当前播放位置。
         */
        set currentTime(value: number);
        /**
         * @en Whether the animation is currently paused.
         * @zh 当前是否暂停。
         */
        get paused(): boolean;
        set paused(value: boolean);
        /**
         * @en The cached frame rate interval time.
         * @zh 缓存帧率间隔时间。
         */
        get cacheFrameRateInterval(): number;
        /**
         * @en The current playback state of the animation.
         * @zh 当前动画的播放状态。
         */
        get state(): number;
        /**
         * @en If the animation instance has been destroyed.
         * @zh 动画实例是否已被销毁。
         */
        get destroyed(): boolean;
        /**
         * @en Constructor method of AnimationPlayer.
         * @zh 动画播放器的构造方法。
         */
        constructor();
        /**
         * @private
         */
        private _setPlayParams;
        /**
         * @private
         * 动画停止了对应的参数。目前都是设置时间为最后
         */
        private _setPlayParamsWhenStop;
        /**
         * @en Play animation based on time.
         * @param index The index of the animation to play.
         * @param playbackRate The rate at which to play the animation.
         * @param overallDuration The duration to play the animation (0 for once, Number.MAX_VALUE for loop play).
         * @param playStart The start time position of the playback.
         * @param playEnd The end time position of the playback (0 for the longest end time position of one loop of the animation).
         * @zh 基于时间来播放动画。
         * @param	index 动画索引。
         * @param	playbackRate 播放速率。
         * @param	overallDuration 播放时长（0为1次,Number.MAX_VALUE为循环播放）。
         * @param	playStart 播放的起始时间位置。
         * @param	playEnd 播放的结束时间位置。（0为动画一次循环的最长结束时间位置）。
         */
        play(index?: number, playbackRate?: number, overallDuration?: number, playStart?: number, playEnd?: number): void;
        /**
         * @en Play animation based on frame parameters.
         * @param index The index of the animation to play.
         * @param playbackRate The rate at which to play the animation.
         * @param overallDuration The duration to play the animation (0 for once, Number.MAX_VALUE for loop play).
         * @param playStartFrame The original start frame rate position for playback.
         * @param playEndFrame The original end frame rate position for playback (0 for the longest end time position of one loop of the animation).
         * @param fpsIn3DBuilder The frames per second in the 3D builder.
         * @zh 基于帧的参数来播放动画。
         * @param	index 动画索引。
         * @param	playbackRate 播放速率。
         * @param	overallDuration 播放时长（0为1次,Number.MAX_VALUE为循环播放）。
         * @param	playStartFrame 播放的原始起始帧率位置。
         * @param	playEndFrame 播放的原始结束帧率位置。（0为动画一次循环的最长结束时间位置）。
         * @param	fpsIn3DBuilder 3D构建器中的帧率。
         */
        playByFrame(index?: number, playbackRate?: number, overallDuration?: number, playStartFrame?: number, playEndFrame?: number, fpsIn3DBuilder?: number): void;
        /**
         * @en Stop playing the current animation.
         * If you don't stop immediately, wait for the animation to finish playing before stopping
         * @param immediate Whether to stop immediately. The default value is true.
         * @zh 停止播放当前动画。
         * 如果不是立即停止，则会等待动画播放完成后再停止。
         * @param	immediate 是否立即停止，默认为true。
         */
        stop(immediate?: boolean): void;
        /**
         * @private
         */
        destroy(): void;
    }
    /**
     * @en The AnimationTemplate class is used for animation template resources.
     * @zh AnimationTemplet类用于动画模板资源。
     */
    class AnimationTemplet extends Resource {
        /**
         * @en Interpolation function
         * @zh 插值函数
         */
        static interpolation: any[];
        /**
         * @private
         */
        private static _LinearInterpolation_0;
        /**
         * @private
         */
        private static _QuaternionInterpolation_1;
        /**
         * @private
         */
        private static _AngleInterpolation_2;
        /**
         * @private
         */
        private static _RadiansInterpolation_3;
        /**
         * @private
         */
        private static _Matrix4x4Interpolation_4;
        /**
         * @private
         */
        private static _NoInterpolation_5;
        /**
         * @private
         */
        private static _BezierInterpolation_6;
        /**
         * @private
         */
        private static _BezierInterpolation_7;
        /**@private */
        protected unfixedCurrentFrameIndexes: Uint32Array;
        /**@private */
        protected unfixedCurrentTimes: Float32Array;
        /**@private */
        protected unfixedKeyframes: KeyFramesContent[];
        /**@private */
        protected unfixedLastAniIndex: number;
        /**@private
         * 记录每个骨骼当前在动画的第几帧。这个是为了去掉缓存的帧索引数据。
        */
        private _boneCurKeyFrm;
        constructor();
        /**
         * @en Get the number of animations.
         * @zh 获取动画的数量。
         */
        getAnimationCount(): number;
        /**
         * @en Retrieve an animation by its index.
         * @param aniIndex The index of the animation to retrieve.
         * @zh 通过索引获取动画。
         * @param aniIndex 要获取的动画的索引。
         */
        getAnimation(aniIndex: number): any;
        /**
         * @en Get the duration of an animation.
         * @param aniIndex The index of the animation to check.
         * @zh 获取动画时长。
         * @param aniIndex 要检查的动画的索引。
         */
        getAniDuration(aniIndex: number): number;
        /**
         * @en Get information about the nodes involved in an animation.
         * @param aniIndex The index of the animation.
         * @zh 获取动画的nodes信息。
         * @param aniIndex 指定动画的索引。
         */
        getNodes(aniIndex: number): any;
        /**
         * @en Retrieve the index of a bone by its name within an animation.
         * @param aniIndex The index of the animation.
         * @param name The name of the bone to retrieve.
         * @returns The index of the bone.
         * @zh 通过名称获取动画中的骨骼索引。
         * @param aniIndex 动画的索引。
         * @param name 要检索的骨骼名称。
         * @returns 骨骼的索引。
         */
        getNodeIndexWithName(aniIndex: number, name: string): number;
        /**
         * @en Get the count of nodes in an animation.
         * @param aniIndex The index of the animation.
         * @returns The number of nodes in the animation.
         * @zh 获取动画中的nodes数量。
         * @param aniIndex 动画的索引。
         * @returns 动画中的nodes数量。
         */
        getNodeCount(aniIndex: number): number;
        /**
         * @en Get the total length of keyframes in an animation.
         * @param aniIndex The index of the animation.
         * @returns The total number of keyframes.
         * @zh 获取动画关键帧长度。
         * @param aniIndex 动画的索引。
         * @returns 动画关键帧总数。
         */
        getTotalkeyframesLength(aniIndex: number): number;
        /**
         * @en Get the public extension data associated with the animation.
         * @returns The ArrayBuffer containing the public extension data.
         * @zh 获取动画的附加数据。
         * @returns 包含附加数据的ArrayBuffer。
         */
        getPublicExtData(): ArrayBuffer;
        /**
         * @en Retrieve animation data with caching mechanism.
         * @param key The key associated with the data to retrieve.
         * @param cacheDatas The cache data storage.
         * @param aniIndex The index of the animation.
         * @param frameIndex The index of the frame to retrieve data from.
         * @returns The Float32Array containing the animation data, or null if not found.
         * @zh 使用缓存机制获取动画数据。
         * @param key 与要检索的数据关联的键。
         * @param cacheDatas 缓存数据存储。
         * @param aniIndex 动画的索引。
         * @param frameIndex 要检索数据的帧索引。
         * @returns 包含动画数据的Float32Array，如果未找到则返回null。
         */
        getAnimationDataWithCache(key: any, cacheDatas: any, aniIndex: number, frameIndex: number): Float32Array;
        /**
         * @en Set animation data with caching mechanism.
         * @param key The key associated with the data to set.
         * @param cacheDatas The array of cache data storages.
         * @param aniIndex The index of the animation.
         * @param frameIndex The index of the frame to set data to.
         * @param data The data to set.
         * @zh 设置动画数据并使用缓存机制。
         * @param key 与要设置的数据关联的键。
         * @param cacheDatas 缓存数据存储数组。
         * @param aniIndex 动画的索引。
         * @param frameIndex 要设置数据的帧索引。
         * @param data 要设置的数据。
         */
        setAnimationDataWithCache(key: any, cacheDatas: any[], aniIndex: number, frameIndex: number, data: any): void;
        /**
         * @en Calculate which keyframe corresponds to the current time.
         * - There is an issue with the last frame. For example, if the time of the second to last frame is 0.033ms,the next two frames are very close together. When the actual last frame is given, the time calculated based on the frame number actually falls on the second to last frame. Using accumulated time consistent with AnimationPlayer will resolve this issue.
         * @param nodeframes The keyframe data for the current bone.
         * @param nodeid The bone ID, used for updating the _boneCurKeyFrm.
         * @param tm The current time in the animation.
         * @returns The index of the keyframe that corresponds to the current time.
         * @zh 计算当前时间应该对应关键帧的哪一帧。
         * - 最后一帧有问题，例如倒数第二帧时间是0.033ms,则后两帧非常靠近，
         * 当实际给最后一帧的时候，根据帧数计算出的时间实际上落在倒数第二帧使用与AnimationPlayer一致的累积时间就行
         * @param nodeframes 当前骨骼的关键帧数据。
         * @param nodeid 骨骼ID，用于更新 _boneCurKeyFrm。
         * @param tm 当前动画的时间。
         * @returns 对应当前时间的关键帧的索引。
         */
        getNodeKeyFrame(nodeframes: KeyFramesContent[], nodeid: number, tm: number): number;
        /**
         * @en Retrieve and fill the original animation data for a specific frame and time.
         * @param aniIndex The index of the animation.
         * @param originalData A Float32Array to be filled with the retrieved animation data. This array is modified in-place.
         * @param nodesFrameIndices An array containing frame indices for each node (Note: This parameter is not used in the current implementation).
         * @param frameIndex The index of the frame to retrieve data for (Note: This parameter is not used in the current implementation).
         * @param playCurTime The current play time in the animation (in milliseconds).
         * @zh 获取并填充特定帧和时间的原始动画数据。
         * @param aniIndex 动画的索引。
         * @param originalData 用于存储检索到的动画数据的Float32Array。此数组会被直接修改。
         * @param nodesFrameIndices 包含每个节点的帧索引的数组（注意：当前实现中已删除此参数，为保持旧版本兼容而保留）。
         * @param frameIndex 要获取数据的帧索引（注意：当前实现中已删除此参数，为保持旧版本兼容而保留）。
         * @param playCurTime 动画的当前播放时间（毫秒）。
         */
        getOriginalData(aniIndex: number, originalData: Float32Array, nodesFrameIndices: any[], frameIndex: number, playCurTime: number): void;
        /**
         * @en Get the current frame index for each node in the specified animation.
         * @param aniIndex The index of the animation to retrieve node information from.
         * @param playCurTime The current play time of the animation in milliseconds.
         * @returns A Uint32Array containing the current frame index for each node.
         * @zh 获取指定动画中每个节点的当前帧索引。
         * @param aniIndex 要检索节点信息的动画索引。
         * @param playCurTime 动画的当前播放时间（毫秒）。
         * @returns 包含每个节点当前帧索引的Uint32Array。
         */
        getNodesCurrentFrameIndex(aniIndex: number, playCurTime: number): Uint32Array;
        /**
         * @en Retrieve and fill the original animation data at a specific time for the given animation.
         * @param aniIndex The index of the animation to retrieve data from.
         * @param originalData A Float32Array to be filled with the retrieved animation data. This array is modified in-place.
         * @param playCurTime The current play time of the animation in milliseconds.
         * @zh 获取并填充指定动画在特定时间的原始动画数据。
         * @param aniIndex 要检索数据的动画索引。
         * @param originalData 用于存储检索到的动画数据的Float32Array。此数组会被直接修改。
         * @param playCurTime 动画的当前播放时间（毫秒）。
         */
        getOriginalDataUnfixedRate(aniIndex: number, originalData: Float32Array, playCurTime: number): void;
    }
    /**
     * @private
     * @en The `Bone` class , used for skeletal animations.
     * @zh 骨骼类,用于骨骼动画
     */
    class Bone {
        /**
         * @en The visibility state of bones.
         * @zh 骨骼的可见性状态。
         */
        static ShowBones: any;
        /**
         * @en The name of the bone.
         * @zh 骨骼的名称。
         */
        name: string;
        /**
         * @en The root bone of the skeleton.
         * @zh 骨骼的根骨骼。
         */
        root: Bone;
        /**
         * @en The parent bone of this bone.
         * @zh 此骨骼的父骨骼。
         */
        parentBone: Bone;
        /**
         * @en The length of the bone, default is 10.
         * @zh 骨骼的长度，默认为 10。
         */
        length: number;
        /**
         * @en The transform properties of the bone.
         * @zh 骨骼的变换属性。
         */
        transform: Transform;
        /**
         * @en The result transform of the bone after applying all transformations.
         * @zh 应用所有变换后骨骼的结果变换。
         */
        resultTransform: Transform;
        /**
         * @en The result matrix of the bone after applying all transformations.
         * @zh 应用所有变换后骨骼的结果矩阵。
         */
        resultMatrix: Matrix;
        /**
         * @en Whether the bone inherits scale from its parent.
         * @zh 是否从父骨骼继承缩放。
         */
        inheritScale: boolean;
        /**
         * @en Whether the bone inherits rotation from its parent.
         * @zh 是否从父骨骼继承旋转。
         */
        inheritRotation: boolean;
        /**
         * @en The rotation of the bone in degrees.
         * @zh 骨骼的旋转角度，以度为单位。
         */
        rotation: number;
        /**
         * @en The result rotation of the bone after applying all transformations.
         * @zh 应用所有变换后骨骼的结果旋转。
         */
        resultRotation: number;
        d: number;
        constructor();
        /**
         * @en Sets the temporary matrix for this bone and recursively for all child bones.
         * @param matrix The matrix to set as the temporary matrix.
         * @zh 为这个骨骼及其所有子骨骼设置临时矩阵。
         * @param matrix 要设置为临时矩阵的矩阵。
         */
        setTempMatrix(matrix: Matrix): void;
        /**
         * @en Updates the transformation of this bone and recursively updates all child bones.
         * @param pMatrix An optional matrix to apply to the transformation.
         * @zh 更新此骨骼的变换并递归更新所有子骨骼。
         * @param pMatrix 一个可选的矩阵，用于应用到变换中。
         */
        update(pMatrix?: Matrix | null): void;
        /**
         * @en Updates all child bones of this bone.
         * @zh 更新此骨骼的所有子骨骼。
         */
        updateChild(): void;
        /**
         * @en Convert the rotation of bone sprites from radians to degrees.
         * @param rd The rotation in radians.
         * @zh 将骨骼精灵的旋转从弧度转换为度。
         * @param rd 弧度值。
         */
        setRotation(rd: number): void;
        /**
         * @en Updates the drawing of the bone and its sprite at the specified position.
         * @param x The x-coordinate position to draw the bone.
         * @param y The y-coordinate position to draw the bone.
         * @zh 在指定的位置更新骨骼及其精灵的绘制。
         * @param x 绘制骨骼的 x 坐标位置。
         * @param y 绘制骨骼的 y 坐标位置。
         */
        updateDraw(x: number, y: number): void;
        /**
         * @en Adds a bone as a child to this bone.
         * @param bone The bone to be added as a child.
         * @zh 将一个骨骼添加为此骨骼的子骨骼。
         * @param bone 要添加为子骨骼的骨骼。
         */
        addChild(bone: Bone): void;
        /**
         * @en Finds a bone by its name in the hierarchy of this bone.
         * @param boneName The name of the bone to find.
         * @returns The bone if found, otherwise null.
         * @zh 在此骨骼的层级结构中按名称查找骨骼。
         * @param boneName 要查找的骨骼名称。
         * @returns 如果找到返回骨骼，否则返回 null。
         */
        findBone(boneName: string): Bone | null;
        /**
         * @en Converts local coordinates to world coordinates using this bone's transformation matrix.
         * @param local The local coordinates array to be converted.
         * @zh 使用此骨骼的变换矩阵将本地坐标转换为世界坐标。
         * @param local 要转换的本地坐标数组。
         */
        localToWorld(local: number[]): void;
    }
    /**
     * @en The `BoneSlot` class represents a slot in a skeletal animation that can display different skins or attachments.
     * @zh `BoneSlot` 类代表骨骼动画中的一个插槽，可以显示不同的皮肤或附件。
     */
    class BoneSlot {
        /**
         * @en The name of the slot.
         * @zh 插槽的名称。
         */
        name: string;
        /**
         * @en The name of the bone to which the slot is attached.
         * @zh 插槽绑定的骨骼名称。
         */
        parent: string;
        /**
         * @en The name of the current display data or attachment.
         * @zh 插槽显示数据数据的名称。
         */
        attachmentName: string;
        /**
         * @en The original index of the data.
         * @zh 原始数据的索引。
         */
        srcDisplayIndex: number;
        /**
         * @en Used to determine if it is the original object.
         * @zh 判断对象是否是原对象。
         */
        type: string;
        /**
         * @en The pointer to the template.
         * @zh 模板的指针。
         */
        templet: Templet;
        /**
         * @en The current slot data that the slot corresponds to.
         * @zh 当前插槽对应的数据。
         */
        currSlotData: SlotData;
        /**
         * @en The current texture that the slot is displaying.
         * @zh 当前插槽显示的纹理。
         */
        currTexture: Texture | null;
        /**
         * @en The data corresponding to the display object.
         * @zh 显示对象对应的数据。
         */
        currDisplayData: SkinSlotDisplayData | null;
        /**
         * @en The index of the displayed skin.
         * @zh 显示皮肤的索引。
         */
        displayIndex: number;
        /** @private */
        originalIndex: number;
        /** @private 变形动画数据 */
        deformData: any[];
        /**
         * @en Sets the slot data to be displayed.
         * @param slotData The slot data to display.
         * @param freshIndex Whether to reset the texture, default is true.
         * @zh 设置要显示的插槽数据。
         * @param slotData 要显示的插槽数据。
         * @param freshIndex 是否重置纹理，默认为 true。
         */
        showSlotData(slotData: SlotData, freshIndex?: boolean): void;
        /**
         * @en Displays the specified object by name.
         * @param name The name of the object to display.
         * @zh 通过名字显示指定对象。
         * @param name 要显示的对象的名称。
         */
        showDisplayByName(name: string): void;
        /**
         * @en Replaces the texture by name.
         * @param tarName The name of the texture to be replaced.
         * @param newName The name of the new texture to replace with.
         * @zh 替换贴图名。
         * @param	tarName 要替换的贴图名
         * @param	newName 替换后的贴图名
         */
        replaceDisplayByName(tarName: string, newName: string): void;
        /**
         * @en Replaces the display by index.
         * @param tarIndex The index of the display to be replaced.
         * @param newIndex The new index to replace with.
         * @zh 替换贴图索引。
         * @param	tarIndex 要替换的索引
         * @param	newIndex 替换后的索引
         */
        replaceDisplayByIndex(tarIndex: number, newIndex: number): void;
        /**
         * @en Displays the object by index.
         * @param index The index of the display object.
         * @zh 指定显示对象。
         * @param index 要显示的对象索引。
         */
        showDisplayByIndex(index: number): void;
        /**
         * @en Replaces the skin with a custom texture.
         * @param _texture The custom texture to replace the skin.
         * @zh 替换皮肤。
         * @param _texture 要替换的自定义皮肤。
         */
        replaceSkin(_texture: Texture): void;
        /**
         * @en Saves the index of the parent matrix.
         * @param parentMatrix The parent matrix to save.
         * @zh 保存父矩阵的索引。
         * @param parentMatrix 要保存的父矩阵。
         */
        setParentMatrix(parentMatrix: Matrix): void;
        private _mVerticleArr;
        /**
         * @en Create SkinGraphic Mesh data.
         * @zh 创建SkinGraphic网格数据
         */
        static createSkinMesh(): any;
        private static isSameArr;
        private getSaveVerticle;
        /**
         * @en Compares two matrices to check if they are identical.
         * @param mtA The first matrix.
         * @param mtB The second matrix.
         * @returns Whether the matrices are identical.
         * @zh 比较两个矩阵是否相同
         * @param mtA 第一个矩阵。
         * @param mtB 第二个矩阵。
         * @returns 是否相同
         */
        static isSameMatrix(mtA: Matrix, mtB: Matrix): boolean;
        private _preGraphicMatrix;
        private static useSameMatrixAndVerticle;
        private getSaveMatrix;
        /**
         * @en Draws the texture onto the Graphics object.
         * @param graphics The Graphics object to draw the texture onto.
         * @param boneMatrixArray An array of matrices corresponding to bone transformations.
         * @param noUseSave If true, do not use the shared matrix object _tempResultMatrix; only set to true when calculating in real-time.
         * @param alpha The alpha value for the texture being drawn, default is 1 (fully opaque).
         * @zh 将纹理绘制到 Graphics 对象上。
         * @param graphics 要在其上绘制纹理的Graphics对象。
         * @param boneMatrixArray 对应骨骼变换的矩阵数组。
         * @param noUseSave 如果为 true，则不使用共享的矩阵对象 _tempResultMatrix；仅在实时计算时设置为 true。
         * @param alpha 绘制纹理的透明度值，默认为 1（完全不透明）。
         */
        draw(graphics: GraphicsAni, boneMatrixArray: any[], noUseSave?: boolean, alpha?: number): void;
        /**
         * 显示蒙皮动画
         * @param	boneMatrixArray 当前帧的骨骼矩阵
         */
        private skinMesh;
        /**
         * @en Draws the bone's origin point for debugging purposes.
         * @param graphics The Graphics object to draw the bone origin point.
         * @zh 绘制骨骼的起始点，方便调试。
         * @param graphics 要绘制骨骼起始点的 Graphics 对象。
         */
        drawBonePoint(graphics: Graphics): void;
        /**
         * 得到显示对象的矩阵
         * @return
         */
        private getDisplayMatrix;
        /**
         * @en Gets the matrix of the slot.
         * @zh 获取插槽的矩阵。
         */
        getMatrix(): Matrix;
        /**
         * @en Copies the original data to create a new instance.
         * @returns A new BoneSlot instance copied from the original data.
         * @zh 使用原始数据拷贝出一个新实例。
         * @returns 返回从原始数据拷贝出的新 BoneSlot 实例。
         */
        copy(): BoneSlot;
    }
    /**
     * @en Mesh data
     * @zh 网格数据
     */
    class MeshData {
        /**
         * @en Texture
         * @zh 纹理
         */
        texture: Texture;
        /**
         * @en UV data
         * @zh UV数据
         */
        uvs: Float32Array;
        /**
         * @en Vertex data
         * @zh 顶点数据
         */
        vertices: Float32Array;
        /**
         * @en Vertex indices
         * @zh 顶点索引
         */
        indexes: Uint16Array;
        /**
         * @en UV transform matrix
         * @zh UV变换矩阵
         */
        uvTransform: Matrix;
        /**
         * @en Whether to use UV transform matrix
         * @zh 是否使用UV变换矩阵
         */
        useUvTransform: boolean;
        /**
         * @en Extended pixels used to remove black edges
         * @zh 扩展像素，用于去除黑边
         */
        canvasPadding: number;
        /**
         * @en Calculate the bounds of the mesh
         * @returns Rectangle representing the bounds of the mesh
         * @zh 计算网格的边界
         * @returns 表示网格边界的矩形
         */
        getBounds(): Rectangle;
    }
    /**
     * @en Create SkinGraphic Mesh data.
     * @zh 创建SkinGraphic网格数据
     */
    class SkinMeshForGraphic extends MeshData {
        /**
         * @en Constructor method. Create SkinGraphic Mesh data.
         * @zh 构造方法，创建SkinGraphic网格数据
         */
        constructor();
        /**
         * @en Transform matrix
         * @zh 变换矩阵
         */
        transform: Matrix | null;
        /**
         * @en Create Texture MeshData
         * @param texture Texture
         * @param ps Index data
         * @param verticles Vertex data
         * @param uvs UV data
         * @zh 创建纹理网格数据
         * @param texture 纹理
         * @param ps 索引数据
         * @param verticles 顶点数据
         * @param uvs UV数据
         */
        init2(texture: Texture, ps: any[], verticles: any[], uvs: any[]): void;
    }
    /**
     * @en Event data of Skeleton animation.
     * @zh 骨骼动画事件数据
     */
    class EventData {
        /**
         * @en The name of the event.
         * @zh 事件的名称。
         */
        name: string;
        /**
         * @en An integer data.
         * @zh 整数数据。
         */
        intValue: number;
        /**
         * @en A single-precision floating point data.
         * @zh 单精度浮点数数据。
         */
        floatValue: number;
        /**
         * @en String data.
         * @zh 字符串数据。
         */
        stringValue: string;
        /**
         * @en Multimedia data.
         * @zh 多媒体数据。
         */
        audioValue: string;
        /**
         * @en Time data.
         * @zh 时间数据。
         */
        time: number;
        constructor();
    }
    /**
     * @en Animation start playback scheduling
     * @zh 动画开始播放调度
     * @eventType Event.PLAYED
     * */
    /**
     * @en Animation stop playback scheduling
     * @zh 动画停止播放调度
     * @eventType Event.STOPPED
     * */
    /**
     * @en Animation resume playback scheduling
     * @zh 动画暂停播放调度
     * @eventType Event.PAUSED
     * */
    /**
     * @en Custom events.
     * @zh 自定义事件。
     * @eventType Event.LABEL
     */
    /**
     * @en Skeleton animation consists of three parts: Template, AnimationPlayer, and Skeleton.
     * @zh 骨骼动画由Templet，AnimationPlayer，Skeleton三部分组成。
     */
    class Skeleton extends Sprite {
        private _animationName;
        private _loop;
        /**
         * @en Constructs method of Skeleton animation.
         * @param aniMode - Animation mode, 0 for no costume changes support, 1 or 2 for costume changes support.
         * @zh 骨骼动画的构造方法
         * @param	aniMode	动画模式，0不支持换装，1、2支持换装
         */
        constructor(aniMode?: number);
        /**
         * @private
         * @en The frame index.
         * @zh 帧索引。
         */
        get index(): number;
        /** @private */
        set index(value: number);
        /**
         * @en The total number of frames.
         * @zh 总帧数。
         */
        get total(): number;
        /**
         * @en The reference to the animation player.
         * @zh 动画播放器的引用。
         */
        get player(): AnimationPlayer;
        /**
         * @en The skin name.
         * @zh 皮肤名称。
         */
        get skinName(): string;
        set skinName(value: string);
        /**
         * @en The animation name.
         * @zh 动画名称。
         */
        get animationName(): string;
        set animationName(value: string);
        /**
         * @en Whether the animation is looped.
         * @zh 动画是否循环播放。
         */
        get loop(): boolean;
        set loop(value: boolean);
        /**
         * @en The reference to the animation template.
         * @zh 动画模板的引用。
         */
        get templet(): Templet;
        set templet(value: Templet);
        /**
         * @en Animation address
         * @zh 动画地址
         */
        get source(): string;
        set source(value: string);
        /**
         * @en Animation types with their descriptions.
         * - Mode 0: Uses template buffer data which cannot be modified. (Low memory overhead, low computation overhead, does not support costume changes)
         * - Mode 1: Uses the animation's own buffer. Each animation has its own buffer, which is quite memory-intensive. (High memory overhead, low computation overhead, supports costume changes)
         * - Mode 2: Uses a dynamic approach for real-time drawing. (Low memory overhead, high computation overhead, supports costume changes, not recommended)
         * @zh 动画类型及其描述。
         * - 模式 0: 使用模板缓冲数据，不允许修改。（内存开销小，计算开销小，不支持换装）
         * - 模式 1: 使用动画自己的缓冲区，每个动画都有自己的缓冲区，相当耗费内存。（内存开销大，计算开销小，支持换装）
         * - 模式 2: 使用动态方式进行实时绘制。（内存开销小，计算开销大，支持换装，不建议使用）
         */
        get aniMode(): number;
        set aniMode(value: number);
        /**
         * 初始化动画
         * @param	templet		模板
         */
        protected init(templet: Templet): void;
        /**
         * @en Load and create an animation directly from a path.
         * @param path The path of the animation file to load.
         * @param complete The callback function when the loading is complete.
         * @zh 通过路径直接加载并创建动画。
         * @param path 要加载的动画文件路径。
         * @param complete 加载完成后的回调函数。
         */
        load(path: string, complete?: Handler): void;
        private _checkIsAllParsed;
        /*******************************************定义接口*************************************************/
        /**
         * @en Get the number of current animations.
         * @return The number of current animations.
         * @zh 获取当前动画的数量。
         * @return 当前动画的数量
         */
        getAnimNum(): number;
        /**
         * @en Get the name of the animation by its index.
         * @param index The index of the animation.
         * @zh 通过索引获取动画的名称。
         * @param index 动画的索引
         */
        getAniNameByIndex(index: number): string;
        /**
         * @en Get the reference to a bone slot by its name.
         * @param name The name of the bone slot.
         * @return The reference to the bone slot.
         * @zh 通过名称获取插槽的引用。
         * @param name 动画的名字
         * @return 插槽的引用
         */
        getSlotByName(name: string): BoneSlot;
        /**
         * @en Display a set of skins by name.
         * @param name The name of the skin.
         * @param freshSlotIndex Whether to reset the slot textures to the initial state, default is true.
         * @zh 通过名称显示一套皮肤。
         * @param name 皮肤的名字
         * @param freshSlotIndex 是否将插槽纹理重置到初始状态，默认为true。
         */
        showSkinByName(name: string, freshSlotIndex?: boolean): void;
        /**
         * @en Display a set of skins by index.
         * @param skinIndex The index of the skin.
         * @param freshSlotIndex Whether to reset the slot textures to the initial state, default is true.
         * @zh 通过索引显示一套皮肤。
         * @param skinIndex 皮肤索引
         * @param freshSlotIndex 是否将插槽纹理重置到初始状态，默认为true。
         */
        showSkinByIndex(skinIndex: number, freshSlotIndex?: boolean): void;
        /**
         * @en Set the skin for a specific slot by index.
         * @param slotName The name of the slot.
         * @param index The index of the slot's skin.
         * @zh 通过索引设置某插槽的皮肤。
         * @param slotName 插槽名称
         * @param index 插槽的皮肤索引
         */
        showSlotSkinByIndex(slotName: string, index: number): void;
        /**
         * @en Set the skin for a specific slot by name.
         * @param slotName The name of the slot.
         * @param name The name of the skin.
         * @zh 通过名称设置某插槽的皮肤。
         * @param slotName 插槽名称
         * @param name 皮肤名称
         */
        showSlotSkinByName(slotName: string, name: string): void;
        /**
         * @en Replace the texture name of a slot.
         * @param slotName The name of the slot.
         * @param oldName The old texture name that will be replaced.
         * @param newName The new texture name to replace with.
         * @zh 替换插槽的贴图名称。
         * @param slotName 插槽名称
         * @param oldName 要替换的贴图名
         * @param newName 替换后的贴图名
         */
        replaceSlotSkinName(slotName: string, oldName: string, newName: string): void;
        /**
         * @en Replace the texture index of a slot.
         * @param slotName The name of the slot.
         * @param oldIndex The old texture index that will be replaced.
         * @param newIndex The new texture index to replace with.
         * @zh 替换插槽的贴图索引。
         * @param slotName 插槽名称
         * @param oldIndex 要替换的索引
         * @param newIndex 替换后的索引
         */
        replaceSlotSkinByIndex(slotName: string, oldIndex: number, newIndex: number): void;
        /**
         * @en Set custom skin for a slot.
         * @param slotName The name of the slot.
         * @param texture The custom texture to be applied.
         * @zh 为指定的插槽设置自定义皮肤。
         * @param slotName 插糟的名字
         * @param texture 自定义的纹理
         */
        setSlotSkin(slotName: string, texture: Texture): void;
        /**
         * @en Play an animation.
         * @param nameOrIndex The name or index of the animation to play.
         * @param loop Whether to loop the animation.
         * @param force If false, the animation will not take effect if the same one is already playing. If true, it will force the animation to play.
         * @param start The start time of the animation.
         * @param end The end time of the animation.
         * @param freshSkin Whether to refresh the skin data.
         * @param playAudio Whether to play the animation's audio.
         * @zh 播放动画。
         * @param nameOrIndex 动画名字或者索引
         * @param loop 是否循环播放
         * @param force false,如果要播的动画跟上一个相同就不生效,true,强制生效
         * @param start 起始时间
         * @param end 结束时间
         * @param freshSkin 是否刷新皮肤数据
         * @param playAudio 是否播放音频
         */
        play(nameOrIndex: any, loop: boolean, force?: boolean, start?: number, end?: number, freshSkin?: boolean, playAudio?: boolean): void;
        /**
         * @en Stop the animation.
         * @zh 停止动画。
         */
        stop(): void;
        /**
         * @en Set the playback rate of the animation.
         * @param value The playback rate, where 1 is the standard rate.
         * @zh 设置动画的播放速率。
         * @param value	1为标准速率
         */
        playbackRate(value: number): void;
        /**
         * @en Pause the animation.
         * @zh 暂停动画。
         */
        paused(): void;
        /**
         * @en Resume playing the animation.
         * @zh 恢复动画的播放。
         */
        resume(): void;
        /**
         * @override
         * @en Destroy the current animation node.
         * @param destroyChild Whether to destroy child nodes.
         * @zh 销毁当前动画节点。
         * @param destroyChild 是否销毁子节点
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * @en Slot display data
     * @zh 插槽显示数据
     */
    class SkinSlotDisplayData {
        /**
         * @en The name of the slot.
         * @zh 插槽的名称。
         */
        name: string;
        /**
         * @en The name of the attachment.
         * @zh 附件的名称。
         */
        attachmentName: string;
        /**
         * @en The type of the slot display.
         * @zh 插槽显示的类型。
         */
        type: number;
        /**
         * @en The transformation data of the slot.
         * @zh 插槽的变换数据。
         */
        transform: Transform;
        /**
         * @en The width of the slot.
         * @zh 插槽的宽度。
         */
        width: number;
        /**
         * @en The height of the slot.
         * @zh 插槽的高度。
         */
        height: number;
        /**
         * @en The texture of the slot.
         * @zh 插槽的纹理。
         */
        texture: Texture;
        /**
         * @en The bone data array.
         * @zh 骨骼数据数组。
         */
        bones: any[];
        /**
         * @en The UV data array.
         * @zh UV数据数组。
         */
        uvs: any[];
        /**
         * @en The weight data array.
         * @zh 权重数据数组。
         */
        weights: any[];
        /**
         * @en The triangle data array.
         * @zh 三角面数据数组。
         */
        triangles: any[];
        /**
         * @en The vertex data array.
         * @zh 顶点数据数组。
         */
        vertices: any[];
        /**
         * @en The length data array.
         * @zh 长度数据数组。
         */
        lengths: any[];
        /**
         * @en The version.
         * @zh 版本号。
         */
        verLen: number;
        /**
         * @en Create and update the texture for the slot based on the current texture.
         * @param currTexture The current texture to be used for creating the slot's texture.
         * @return The created and updated texture.
         * @zh 根据当前纹理创建并更新插槽纹理。
         * @param currTexture 用于创建槽纹理的当前纹理。
         * @return 新的插槽纹理。
         */
        createTexture(currTexture: Texture): Texture;
        /**
         * @en Destroy and clean up the resources used by the slot's texture.
         * @zh 销毁并清理插槽纹理所使用的资源。
         */
        destory(): void;
    }
    /**
     * Represents the data of a slot, which includes the slot's name and an array of display data.
     * @zh 表示插槽的数据，包括插槽名称和显示数据数组。
     */
    class SlotData {
        /**
        * @en The name of the slot.
        * @zh 插槽的名称。
        */
        name: string;
        /**
         * @en An array of display data that this slot contains.
         * @zh 此插槽包含的显示数据数组。
         */
        displayArr: any[];
        /**
         * @en Get the index of the display data by attachment name.
         * @param name The name of the attachment to search for.
         * @zh 通过附件名称获取显示数据的位置。
         * @param name 附件名称。
         */
        getDisplayByName(name: string): number;
    }
    /**
     * @en Animation template class
     * @zh 动画模板类
     */
    class Templet extends AnimationTemplet {
        /**
         * @en The frame rate of the animation
         * @zh 动画的帧率
         */
        rate: number;
        /**
         * @en Stores the original bone information.
         * @zh 存放原始骨骼信息。
         */
        srcBoneMatrixArr: any[];
        /**
         * @en IK (Inverse Kinematics) data array.
         * @zh IK数据数组。
         */
        ikArr: any[];
        /**
         * @en Transform data array.
         * @zh transform数据数组。
         */
        tfArr: any[];
        /**
         * @en Path data array.
         * @zh path数据数组。
         */
        pathArr: any[];
        /**
         * @en Dictionary for storing slot data.
         * @zh 存放插槽数据的字典。
         */
        boneSlotDic: any;
        /**
         * @en Dictionary for binding slot data.
         * @zh 绑定插槽数据的字典。
         */
        bindBoneBoneSlotDic: any;
        /**
         * @en Array for storing slot data.
         * @zh 存放插槽数据的数组。
         */
        boneSlotArray: any[];
        /**
         * @en Skin data array.
         * @zh 皮肤数据数组。
         */
        skinDataArray: any[];
        /**
         * @en Dictionary for skin data.
         * @zh 皮肤的字典数据。
         */
        skinDic: any;
        /**
         * @en Dictionary for storing texture data.
         * @zh 存放纹理数据的字典。
         */
        subTextureDic: Record<string, Texture>;
        /**
         * @en Indicates whether parsing has failed.
         * @zh 是否解析失败。
         */
        isParseFail: boolean;
        /**
         * @en The reverse matrix, some bone animations need to be reversed to be displayed correctly.
         * @zh 反转矩阵，有些骨骼动画需要反转才能正确显示。
         */
        yReverseMatrix: Matrix;
        /**
         * @en Render order animation data array.
         * @zh 渲染顺序动画数据数组。
         */
        drawOrderAniArr: any[];
        /**
         * @en Event animation data array.
         * @zh 事件动画数据数组。
         */
        eventAniArr: any[];
        /** @private 索引对应的名称 */
        attachmentNames: any[];
        /**
         * @en Vertex animation data array.
         * @zh 顶点动画数据数组。
         */
        deformAniArr: any[];
        /**
         * @en Actual display object list for destruction purposes.
         * @zh 实际显示对象列表，用于销毁用。
         */
        skinSlotDisplayDataArr: SkinSlotDisplayData[];
        aniSectionDic: any;
        /**@private */
        tMatrixDataLen: number;
        /**
         * @en Root bone of the skeleton
         * @zh 骨骼的根骨骼
         */
        mRootBone: Bone;
        /**
         * @en Array of all bones in the skeleton
         * @zh 骨骼中所有骨骼的数组
         */
        mBoneArr: Bone[];
        /**
         * @en Create skeletal animation.
         * - 0: Use the template's buffer data, which cannot be modified. (Low memory overhead, low computation overhead, does not support costume changes)
         * - 1: Use the animation's own buffer. Each animation will have its own buffer, which is quite memory-intensive. (High memory overhead, low computation overhead, supports costume changes)
         * - 2: Use a dynamic approach for real-time drawing. (Low memory overhead, high computation overhead, supports costume changes, not recommended)
         * @param aniMode The animation mode: 0 for no costume change support, 1 or 2 for costume change support.
         * @return The created instance.
         * @zh 创建骨骼动画。
         * - 0: 使用模板缓冲的数据，不允许修改。（内存开销小，计算开销小，不支持换装）
         * - 1: 使用动画自己的缓冲区，每个动画都会有自己的缓冲区，相当耗费内存。（内存开销大，计算开销小，支持换装）
         * - 2: 使用动态方式进行实时绘制。（内存开销小，计算开销大，支持换装，不建议使用）
         * @param aniMode 动画模式，0:不支持换装；1、2支持换装
         * @return 创建的实例。
         */
        buildArmature(aniMode?: number): Skeleton;
        _parse(texture: Texture, createURL: string, skeletonData: ArrayBuffer): void;
        /**
         * @en Get the specified texture by its name.
         * @param name The name of the texture.
         * @returns The requested texture object.
         * @zh 通过名称获取指定的纹理。
         * @param	name	纹理的名字
         * @returns 所请求的纹理对象。
         */
        getTexture(name: string): Texture;
        /**
         * @private
         * @en Display the specified skin using the bone slot dictionary and skin index.
         * @param boneSlotDic The dictionary of bone slots.
         * @param skinIndex The index of the skin to display.
         * @param freshDisplayIndex Whether to reset the slot textures, default is true.
         * @return Whether the skin was successfully displayed.
         * @zh 使用插槽字典和皮肤索引显示指定的皮肤。
         * @param	boneSlotDic	插槽字典的引用
         * @param	skinIndex	要显示的皮肤的索引
         * @param	freshDisplayIndex	是否重置插槽纹理，默认为true
         * @return	是否显示皮肤成功
         */
        showSkinByIndex(boneSlotDic: any, skinIndex: number, freshDisplayIndex?: boolean): boolean;
        /**
         * @en Retrieves the index of a skin based on its name.
         * @param skinName The name of the skin.
         * @return The index of the skin, or -1 if not found.
         * @zh 通过皮肤名称获取皮肤索引。
         * @param	skinName	皮肤名称
         * @return	皮肤索引，找不到返回-1
         */
        getSkinIndexByName(skinName: string): number;
        /**
         * @en Retrieves the name of an animation based on its index.
         * @param index The index of the animation.
         * @return The name of the animation, or null if not found.
         * @zh 通过索引获取动画名称。
         * @param index 动画索引
         * @return 动画名称，找不到返回null
         */
        getAniNameByIndex(index: number): string;
        /**
         * @private
         * @en Retrieves the buffered graphics data for a specific animation frame.
         * @param aniIndex The index of the animation.
         * @param frameIndex The index of the frame within the animation.
         * @return The graphics object for the specified animation frame, or null if not available.
         * @zh 获取特定动画帧的缓冲图形数据。
         * @param	aniIndex	动画索引
         * @param	frameIndex	帧索引
         * @return	指定动画帧的对象，如果不存在则返回null
         */
        getGrahicsDataWithCache(aniIndex: number, frameIndex: number): Graphics;
        /**
         * @private
         * @en Saves graphics data to the cache for a specific animation frame.
         * @param aniIndex The index of the animation.
         * @param frameIndex The index of the frame within the animation.
         * @param graphics The graphics object to cache.
         * @zh 保存特定动画帧的图形数据到缓冲区。
         * @param	aniIndex	动画索引
         * @param	frameIndex	帧索引
         * @param	graphics	要缓存的数据
         */
        setGrahicsDataWithCache(aniIndex: number, frameIndex: number, graphics: Graphics): void;
        /**
         * @en Deletes animation data at the specified index.
         * @param aniIndex The index of the animation data to delete.
         * @zh 删除指定索引的动画数据。
         * @param	aniIndex	要删除的动画索引
         */
        deleteAniData(aniIndex: number): void;
        protected _disposeResource(): void;
    }
    /**
     * @en The `Transform` class represents a 2D transformation matrix, used to apply rotations, scaling, skewing, and translation to objects.
     * @zh `Transform` 类表示一个2D变换矩阵，用于对对象应用旋转、缩放、倾斜和位移。
     */
    class Transform {
        /**
        * @en The rotation angle around the X-axis (in degrees).
        * @zh 绕X轴旋转的角度（以度为单位）。
        */
        skX: number;
        /**
         * @en The rotation angle around the Y-axis (in degrees).
         * @zh 绕Y轴旋转的角度（以度为单位）。
         */
        skY: number;
        /**
         * @en The scaling factor along the X-axis.
         * @zh 沿X轴的缩放系数。
         */
        scX: number;
        /**
         * @en The scaling factor along the Y-axis.
         * @zh 沿Y轴的缩放系数。
         */
        scY: number;
        /**
         * @en The translation along the X-axis.
         * @zh 沿X轴的平移。
         */
        x: number;
        /**
         * @en The translation along the Y-axis.
         * @zh 沿Y轴的平移。
         */
        y: number;
        /**
         * @en The skew angle along the X-axis (in degrees).
         * @zh 沿X轴的倾斜角度（以度为单位）。
         */
        skewX: number;
        /**
         * @en The skew angle along the Y-axis (in degrees).
         * @zh 沿Y轴的倾斜角度（以度为单位）。
         */
        skewY: number;
        /**
         * @en The internal matrix used for transformations.
         * @zh 用于变换的内部矩阵。
         * @private
         */
        private mMatrix;
        /**
         * @en Initializes the transform data with the provided values.
         * @param data The data object containing transformation properties.
         * @zh 使用提供的数据初始化变换。
         * @param data 数据对象，包含变换属性。
         */
        initData(data: any): void;
        /**
         * @en Gets the current matrix.
         * @returns The transformation matrix.
         * @zh 获取当前矩阵。
         * @returns 变换矩阵。
         */
        getMatrix(): Matrix;
        /**
         * @en Applies skew to the matrix based on the given angles.
         * @param m The matrix to apply the skew transformation to.
         * @param x The horizontal skew angle, in radians.
         * @param y The vertical skew angle, in radians.
         * @returns The modified matrix with skew applied.
         * @zh 根据给定的角度对矩阵应用倾斜。
         * @param m 要应用倾斜变换的矩阵。
         * @param x 水平倾斜角度，以弧度为单位。
         * @param y 垂直倾斜角度，以弧度为单位。
         * @returns 应用倾斜后的矩阵。
         */
        skew(m: Matrix, x: number, y: number): Matrix;
    }
    /**
     * @en Graphic animation class.
     * @zh 图形动画类。
     */
    class GraphicsAni extends Graphics {
        /**
         * @private
         * @en Draws a custom skinned mesh for graphic animation.
         * @param skinA The skin mesh object for graphic.
         * @param alpha The opacity value to apply to the graphic.
         * @zh 绘制自定义蒙皮动画。
         * @param skinA 图形的蒙皮网格对象。
         * @param alpha 要应用于图形的不透明度值。
         */
        drawSkin(skinA: SkinMeshForGraphic, alpha: number): void;
        private static _caches;
        /**
         * @en Retrieves an instance of GraphicsAni from the cache or creates a new one if none are available.
         * @returns An instance of GraphicsAni.
         * @zh 从缓存中获取一个 GraphicsAni 实例，如果没有可用的实例则创建一个新的。
         * @returns GraphicsAni 的一个实例。
         */
        static create(): GraphicsAni;
        /**
         * @en Recycles a GraphicsAni instance by clearing its content and adding it to the cache for future use.
         * @param graphics The GraphicsAni instance to recycle.
         * @zh 通过清除其内容并将其实例添加到缓存中来回收 GraphicsAni。
         * @param graphics 要回收的 GraphicsAni 实例。
         */
        static recycle(graphics: GraphicsAni): void;
    }
    /**
     * @en Keyframes
     * @zh 关键帧
     */
    class KeyFramesContent {
        /**
         * @en The start time of the keyframe in milliseconds.
         * @zh 关键帧的开始时间（毫秒）。
         */
        startTime: number;
        /**
         * @en The duration of the keyframe in milliseconds.
         * @zh 关键帧的持续时间（毫秒）。
         */
        duration: number;
        /**
         * @en Private interpolation data.
         * An array containing the interpolation types and their associated data in the format [type0, Data0, type1, Data1, ...].
         * Type represents the interpolation method, and Data is the associated interpolation data which can be null.
         * Note: The value 254 indicates linear interpolation throughout, and 255 indicates no interpolation.
         * @zh 私有插值数据。
         * 数组内包含插值类型和相关数据，格式为 [type0, Data0, type1, Data1, ...]。
         * Type 表示插值方法，Data 是相关的插值数据，可以为空。
         * 注意：值 254 表示全线性插值，255 表示不进行插值。
         */
        interpolationData: any[];
        /**
         * @en The keyframe data.
         * @zh 关键帧的数据。
         */
        data: Float32Array;
        /**
         * @en The change in keyframe data.
         * @zh 关键帧数据的变化量。
         */
        dData: Float32Array;
        /**
         * @en The data for the next keyframe.
         * @zh 下一个关键帧的数据。
         */
        nextData: Float32Array;
    }
    /**
     * @en The animation is scheduled after playing.
     * @zh 动画播放完毕后调度。
     * @eventType Event.COMPLETE
     */
    /**
     * @en Schedule after playing to a tag.
     * @zh 播放到某标签后调度。
     * @eventType Event.LABEL
     */
    /**
     * @en Schedule after loading.
     * @zh 加载完成后调度。
     * @eventType Event.LOADED
     */
    /**
     * @en Schedule after enter post frame.
     * @zh 进入帧后调度。
     * @eventType Event.FRAME
     */
    /**
     * @en MovieClip is used to play SWF animations that have been processed by tools.
     * @zh MovieClip 用于播放经过工具处理后的 swf 动画。
     */
    class MovieClip extends Sprite {
        /**
         * @en Resource root directory
         * @zh 资源根目录
         */
        basePath: string;
        private _source;
        /**
         * @en Playback interval (in milliseconds)
         * @zh 播放间隔(单位：毫秒)。
         */
        interval: number;
        /**
         * @en Whether to play in a loop
         * @zh 是否循环播放
         */
        loop: boolean;
        /**
         * @en Constructor method of MovieClip.
         * @param parentMovieClip The parent MovieClip, this parameter is not required when creating your own MovieClip.
         * @zh MovieClip构造方法
         * @param parentMovieClip 父 MovieClip，自己创建时不需要传该参数。
         */
        constructor(parentMovieClip?: MovieClip);
        /**
         * @override
         * @en Destroys this object and its referenced Texture.
         * @param destroyChild Whether to destroy child nodes simultaneously. If true, child nodes are destroyed; otherwise, they are not.
         * @zh 销毁此对象及其引用的Texture。
         * @param destroyChild 是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @private
         * @en Update the timeline of the MovieClip.
         * @zh 更新 MovieClip 的时间轴。
         */
        updates(): void;
        /**
         * @en The current playback index of the MovieClip.
         * @zh MovieClip 当前播放的索引。
         */
        get index(): number;
        set index(value: number);
        /**
         * @en Adds a label to a specified frame index. When played to this index, a label event will be dispatched.
         * @param label The name of the label.
         * @param index The frame index to add the label to.
         * @zh 在指定的帧索引上增加一个标签，播放到此索引后会派发label事件。
         * @param	label	标签名称
         * @param	index	索引位置
         */
        addLabel(label: string, index: number): void;
        /**
         * @en Remove the corresponding label from the specified label name.
         * @param label The name of the label to remove. If not provided, all labels are removed.
         * @zh 从指定的标签名字删除对应标签。
         * @param	label 标签名字，如果label为空，则删除所有Label
         */
        removeLabel(label: string): void;
        /**
         * @en The total number of frames in the MovieClip.
         * @zh MovieClip 中的帧总数。
         */
        get count(): number;
        /**
         * @en Whether the MovieClip is currently playing.
         * @zh MovieClip 是否正在播放中。
         */
        get playing(): boolean;
        /**
         * @en Stops the playback of the animation.
         * @zh 停止播放动画。
         */
        stop(): void;
        /**
         * @en Jumps to a specified frame and stops playing the animation.
         * @param index The frame index to jump to.
         * @zh 跳到指定帧并停止播放动画。
         * @param index 要跳到的帧
         */
        gotoAndStop(index: number): void;
        /**
         * @en Play Animation
         * @param	index frame index
         * @zh 播放动画。
         * @param	index 帧索引
         */
        play(index?: number, loop?: boolean): void;
        /**
         * @en The source of the MovieClip.
         * @zh MovieClip 的资源地址。
         */
        get source(): string;
        set source(value: string);
        /**
         * @deprecated 请使用Loader.load(url:string, type: ILaya.Loader.BUFFER)
         * @en Loads resources for the MovieClip.
         * @param url The URL of the SWF resource.
         * @param atlas Whether to use atlas resources.
         * @param atlasPath The path of the atlas, by default it uses the atlas with the same name as the SWF.
         * @zh 加载 MovieClip 资源。
         * @param url SWF 资源的 URL。
         * @param atlas 是否使用图集资源。
         * @param   atlasPath  图集路径，默认使用与swf同名的图集
         */
        load(url: string, atlas?: boolean, atlasPath?: string): void;
        /**
         * @en Plays the animation from the start index to the end index, and triggers the complete callback when finished.
         * @param start The starting frame index.
         * @param end The ending frame index.
         * @param complete End callback.
         * @zh 从开始索引播放到结束索引，结束后触发 complete 回调。
         * @param start 开始索引
         * @param end 结束索引
         * @param complete 结束回调
         */
        playTo(start: number, end: number, complete?: Handler): void;
    }
    /**
     * @en Animation condition types
     * @zh 动画条件类型
     */
    enum AniConditionType {
        /**
         * @en Greater than
         * @zh 大于
         */
        Greater = 0,
        /**
         * @en Less than
         * @zh 小于
         */
        Less = 1,
        /**
         * @en Equal to
         * @zh 等于
         */
        Equals = 2,
        /**
         * @en Not equal to
         * @zh 不等于
         */
        NotEqual = 3
    }
    /**
     * @en 2D animation types
     * @zh 2D动画类型
     */
    class Animation2DCondition {
        /**
         * @en ID number
         * @zh id编号
         */
        id: number;
        /**
         * @en Animation conditions
         * @zh 动画条件
         */
        type: AniConditionType;
        /**
         * @en Detection value
         * @zh 检测值
         */
        checkValue: any;
    }
    /**
     * @en Animation2DEvent class is used to implement animation events.
     * @zh Animation2DEvent 类用于实现动画事件。
     */
    class Animation2DEvent {
        /**
         * @en The time at which the event is triggered.
         * @zh 事件触发的时间。
         */
        time: number;
        /**
         * @en The name of the event that is triggered.
         * @zh 被触发的事件名称。
         */
        eventName: string;
        /**
         * @en Event triggering parameters
         * @zh 事件触发参数。
         */
        params: any[];
        /**
         * @en Constructor method, instance of Animation2DEvent.
         * @zh 2D动画事件类实例
         */
        constructor();
    }
    /**
     * @en Represents a parameter for 2D animation that includes a name, type, and value.
     * @zh 表示2D动画的参数，包括名称、类型和值。
     */
    class Animation2DParm {
        name: string;
        type: AniParmType;
        value: boolean | number;
    }
    /**
     * @en Class for parsing and storing 2D animation data.
     * @zh 用于处理2D动画片段的类。
     */
    class AnimationClip2D extends Resource {
        /**
         * @en Animation frame filling function
         * @zh 动画补帧函数
         */
        static tween: {
            Linear: (t: number, b: number, c: number, d: number) => number;
            Quad_EaseIn: (t: number, b: number, c: number, d: number) => number;
            Quad_EaseOut: (t: number, b: number, c: number, d: number) => number;
            Quad_EaseInOut: (t: number, b: number, c: number, d: number) => number;
            Cubic_EaseIn: (t: number, b: number, c: number, d: number) => number;
            Cubic_EaseOut: (t: number, b: number, c: number, d: number) => number;
            Cubic_EaseInOut: (t: number, b: number, c: number, d: number) => number;
            Quart_EaseIn: (t: number, b: number, c: number, d: number) => number;
            Quart_EaseOut: (t: number, b: number, c: number, d: number) => number;
            Quart_EaseInOut: (t: number, b: number, c: number, d: number) => number;
            Quint_EaseIn: (t: number, b: number, c: number, d: number) => number;
            Quint_EaseOut: (t: number, b: number, c: number, d: number) => number;
            Quint_EaseInOut: (t: number, b: number, c: number, d: number) => number;
            Sine_EaseIn: (t: number, b: number, c: number, d: number) => number;
            Sine_EaseOut: (t: number, b: number, c: number, d: number) => number;
            Sine_EaseInOut: (t: number, b: number, c: number, d: number) => number;
            Expo_EaseIn: (t: number, b: number, c: number, d: number) => number;
            Expo_EaseOut: (t: number, b: number, c: number, d: number) => number;
            Expo_EaseInOut: (t: number, b: number, c: number, d: number) => number;
            Circ_EaseIn: (t: number, b: number, c: number, d: number) => number;
            Circ_EaseOut: (t: number, b: number, c: number, d: number) => number;
            Circ_EaseInOut: (t: number, b: number, c: number, d: number) => number;
            Elastic_EaseIn: (t: number, b: number, c: number, d: number, a: number, p: number) => number;
            Elastic_EaseOut: (t: number, b: number, c: number, d: number, a: number, p: number) => number;
            Elastic_EaseInOut: (t: number, b: number, c: number, d: number, a: number, p: number) => number;
            Back_EaseIn: (t: number, b: number, c: number, d: number, s?: number) => number;
            Back_EaseOut: (t: number, b: number, c: number, d: number, s?: number) => number;
            Back_EaseInOut: (t: number, b: number, c: number, d: number, s?: number) => number;
            Bounce_EaseIn: (t: number, b: number, c: number, d: number) => number;
            Bounce_EaseOut: (t: number, b: number, c: number, d: number) => number;
            Bounce_EaseInOut: (t: number, b: number, c: number, d: number) => number;
            hermiteInterpolate: (outTangent: number, inTangent: number, startValue: number, endValue: number, t: number, dur: number) => number;
        };
        /**
         * @en Is it a loop?
         * @zh 是否循环
         */
        islooping: boolean;
        /**
         * @en Constructor method. ctructs a AnimationClip2D object.
         * @zh 构造方法，创建AnimationClip2D对象。
         */
        constructor();
        /**
         * @en Animation duration
         * @zh 动画时长
         */
        duration(): number;
        /**
         * @en hermite interpolation algorithm
         * @param frameValue The value of the previous keyframe.
         * @param frametime The time point of the previous keyframe.
         * @param frameOutWeight The weight of the outgoing tangent for the previous keyframe.
         * @param frameOutTangent The outgoing tangent value for the previous keyframe.
         * @param nextframeValue The value of the next keyframe.
         * @param nextframetime The time point of the next keyframe.
         * @param nextframeInweight The weight of the incoming tangent for the next keyframe.
         * @param nextframeIntangent The incoming tangent value for the next keyframe.
         * @param time The current time.
         * @returns The interpolated value at the specified time.
         * @zh hermite插值算法
         * @param frameValue 上一帧值
         * @param frametime 上一帧时间
         * @param frameOutWeight 上一帧权重
         * @param frameOutTangent 上一帧切线
         * @param nextframeValue 下一帧值
         * @param nextframetime 下一帧时间
         * @param nextframeInweight 下一帧权重
         * @param nextframeIntangent 下一帧切线
         * @param time 时间
         * @returns 指定时间的插值。
         */
        hermiteCurveSplineWeight(frameValue: number, frametime: number, frameOutWeight: number, frameOutTangent: number, nextframeValue: number, nextframetime: number, nextframeInweight: number, nextframeIntangent: number, time: number): number;
        /**
         * @en Adds an animation event to the animation timeline.
         * @param event The animation event to be added.
         * @zh 添加动画事件
         * @param event 动画事件
         */
        addEvent(event: Animation2DEvent): void;
    }
    /**
     * @en Class for AnimationClip resource parsing
     * @zh 用于AnimationClip资源解析
     */
    class AnimationClip2DParse01 {
    }
    /**
     * @en 2D animation components
     * @zh 2D动画组件
     */
    class Animator2D extends Component {
        /**
         * @en Constructor method of Animator2D Component.
         * @zh 2D动画组件构造方法。
         */
        constructor();
        /**
         * @en The 2D animation controller.
         * @zh 2D动画控制器。
         */
        get controller(): AnimatorController2D;
        set controller(val: AnimatorController2D);
        /**
         * @en The current 2D animation controller.
         * @zh 动画参数
         */
        get parameters(): Record<string, Animation2DParm>;
        set parameters(val: Record<string, Animation2DParm>);
        /**
         * @en The playback speed of the animation.
         * @zh 播放速度
         */
        get speed(): number;
        set speed(num: number);
        /**
         * @en If the animation is currently playing.
         * @zh 动画是否正在播放。
         */
        get isPlaying(): boolean;
        /**
         * @en Assigns data to a Node.
         * @param stateInfo The animation state information.
         * @param additive Indicates if it is additive.
         * @param weight The weight of the state.
         * @param isFirstLayer Indicates if it is the first layer.
         * @zh 赋值Node数据。
         * @param stateInfo 动画状态信息。
         * @param additive 是否为加法。
         * @param weight 状态的权重。
         * @param isFirstLayer 是否是第一层。
         */
        private _setClipDatasToNode;
        /**
         * @en Jump to the specified frame and stop playing the animation.
         * @param name The name of the animation.
         * @param layerIndex The index of the animation layer.
         * @param frame The specified frame to jump to.
         * @zh 跳转到指定帧并停止播放动画。
         * @param name 动画名称
         * @param layerIndex 动画层
         * @param frame 指定帧
         */
        gotoAndStopByFrame(name: string, layerIndex: number, frame: number): void;
        /**
         * @en Gets the controller layer.
         * @param layerIndex The layer index. Defaults to 0.
         * @returns The AnimatorControllerLayer at the specified index.
         * @zh 获取控制器层。
         * @param layerIndex 层索引。
         * @return 指定索引处的AnimatorControllerLayer。
         */
        getControllerLayer(layerIndex?: number): AnimatorControllerLayer2D;
        /**
         * @en Jump to the specified time and stop playing the animation.
         * @param name The name of the animation.
         * @param layerIndex The index of the layer.
         * @param normalizedTime The normalized playback time of the animation.
         * @zh 跳转到指定时间并停止播放动画。
         * @param name 动画名称
         * @param layerIndex 层索引
         * @param normalizedTime 归一化播放动画时间
         */
        gotoAndStop(name: string, layerIndex: number, normalizedTime: number): void;
        /**
         * @en Play animation
         * @param name The name of the animation.
         * @param layerIndex The index of the layer.
         * @param normalizedTime The normalized time.
         * @zh 播放动画
         * @param name 动画名称
         * @param layerIndex 层索引
         * @param normalizedTime 归一化时间
         */
        play(name?: string, layerIndex?: number, normalizedTime?: number): void;
        /**
         * @en Stop playing animation.
         * @zh 停止播放动画
         */
        stop(): void;
        /**
         * @en Frame Loop
         * @zh 帧循环
         */
        onUpdate(): void;
        /**
         * @en Adds an animator controller layer.
         * @param controllerLayer The animator controller layer to be added.
         * @zh 增加一个动画控制器层。
         * @param controllerLayer 动画控制器层.
         */
        addControllerLayer(controllerLayer: AnimatorControllerLayer2D): void;
        /**
         * @en Cross-fades between the current and target animation states.
         * @param name The name of the target animation state.
         * @param layerIndex The index of the layer.
         * @param normalizedTime The normalized start time for playback.
         * @param transitionDuration The duration of the transition in normalized time (between 0.0 and 1.0).
         * @zh 在当前动画状态和目标动画状态之间进行融合过渡播放。
         * @param	name 目标动画状态。
         * @param	layerIndex 层索引。
         * @param	normalizedTime 归一化的播放起始时间。
         * @param	transitionDuration 过渡时间,该值为当前动画状态的归一化时间，值在0.0~1.0之间。
         */
        crossFade(name: string, layerIndex: number, normalizedTime: number, transitionDuration: number): boolean;
        /**
         * @en Cross-fades between the current and target animation states with an optional transition duration.
         * @param name The name of the target animation state.
         * @param layerIndex The index of the layer.
         * @param normalizedTime The normalized start time for playback.
         * @zh 在当前动画状态和目标动画状态之间进行融合过渡播放。
         * @param name 目标动画状态的名称。
         * @param layerIndex 层的索引。
         * @param normalizedTime 归一化的播放起始时间。
         */
        crossFade(name: string, layerIndex: number, normalizedTime: number): boolean;
        /**
         * @en Get the default State Machine
         * @param layerIndex The index of the layer.
         * @zh 获取默认状态机
         * @param layerIndex 层索引
         */
        getDefaultState(layerIndex?: number): AnimatorState2D;
        /**
         * @en Set a parameter's trigger value.
         * @param name The name of the parameter.
         * @zh 设置参数Trigger值
         * @param name 名字
         */
        setParamsTrigger(name: string): void;
        /**
         * @en Set a parameter's float value.
         * @param name The name of the parameter.
         * @param value The value of the parameter.
         * @zh 设置参数Number值
         * @param name 名字
         * @param value 值
         */
        setParamsNumber(name: string, value: number): void;
        /**
         * @en Set a parameter's bool value.
         * @param name The name of the parameter.
         * @param value The value of the parameter.
         * @zh 设置参数Bool值
         * @param name 名字
         * @param value 值
         */
        setParamsBool(name: string, value: boolean): void;
        /**
         * @en Get a parameter's trigger value.
         * @param name The name of the parameter.
         * @zh 得到参数值
         * @param name 名字
         */
        getParamsvalue(name: number): number | boolean;
    }
    /**
     * @en 2D animation controller
     * @zh 2D动画控制器
     */
    class AnimatorController2D extends Resource {
        /**
         * @en Constructor method of 2D animation controller
         * @zh 2D动画控制器的构造方法
         */
        constructor(data: any);
        private _getAnimatorTransition2D;
    }
    /**
     * @en Layer of 2D animation controllers
     * @zh 2D动画控制器层
     */
    class AnimatorControllerLayer2D implements IClone {
        /**
         * @en Mixed Mode: Overwrite
         * @zh 混合模式_覆盖。
         */
        static BLENDINGMODE_OVERRIDE: number;
        /**
         * @en Mixed Mode: Stacking
         * @zh 混合模式_叠加。
         */
        static BLENDINGMODE_ADDTIVE: number;
        /**
         * @en layer name
         * @zh 层的名字
         */
        name: string;
        /**
         * @en Whether to play when the layer is started.
         * @zh 是否开始时播放
         */
        playOnWake: boolean;
        /**
         * @en Default weight
         * @zh 默认权重
         */
        defaultWeight: number;
        /**
         * @en Mixed Mode
         * @zh 混合模式
         */
        blendingMode: number;
        /**
         * @en Is it enabled
         * @zh 是否开启
         */
        enable: boolean;
        /**
         * @en Constructor method of 2D animator controller Layer.
         * @zh 2D动画控制器层的构造方法
         */
        constructor(name: string);
        /**
         * @en State machine
         * @zh 状态机
         */
        get states(): ReadonlyArray<AnimatorState2D>;
        set states(states: ReadonlyArray<AnimatorState2D>);
        /**
         * @en The default state name.
         * @zh 默认状态名称。
         */
        get defaultStateName(): string;
        set defaultStateName(str: string);
        /**
         * @en Default animation state machine
         * @zh 默认动画状态机。
         */
        get defaultState(): AnimatorState2D;
        set defaultState(value: AnimatorState2D);
        /**
         * 移除Clip
         * @param clipStateInfos
         * @param index
         * @param state
         */
        private _removeClip;
        /**
         * @en Gets the current play state of the animator.
         * @returns The play state of the animation.
         * @zh 获取当前的动画播放状态。
         * @returns 动画的播放状态。
         */
        getCurrentPlayState(): AnimatorPlayState2D;
        /**
         * @en Gets an animator state by its name.
         * @param str The name of the state to retrieve.
         * @returns The AnimatorState2D object if found, otherwise null.
         * @zh 通过状态机名称获取动画状态对象。
         * @param str 要检索的状态名称。
         * @returns 如果找到，返回 AnimatorState2D 对象，否则返回 null。
         */
        getStateByName(str: string): AnimatorState2D;
        /**
         * @en Adds an animation state to the animator.
         * @param state The AnimatorState2D to add.
         * @zh 向动画机添加动画状态。
         * @param state 要添加的 AnimatorState2D。
         */
        addState(state: AnimatorState2D): void;
        /**
         * @en Removes an animation state.
         * @param state The AnimatorState2D to remove.
         * @zh 移除动画状态。
         * @param state 要移除的 AnimatorState2D。
         */
        removeState(state: AnimatorState2D): void;
        /**
         * @en Clones the current animator controller layer.
         * @returns A clone of the current animator controller layer.
         * @zh 克隆当前的动画控制器层。
         * @returns 当前动画控制器层的克隆副本。
         */
        clone(): AnimatorControllerLayer2D;
        /**
         * @en Clones the current animator controller layer to a destination object.
         * @param destObject The destination object to clone to.
         * @zh 克隆当前的动画控制器层到目标对象。
         * @param destObject 克隆到的目标对象。
         */
        cloneTo(destObject: AnimatorControllerLayer2D): void;
        /**
         * @en Destroys the animator controller layer and all its states.
         * @zh 销毁动画控制器层及其所有状态。
         */
        destroy(): void;
    }
    interface TypeAnimatorControllerData {
        layerW: number;
        controllerLayers: TypeAnimatorLayer[];
        cullingMode?: number;
        enable?: boolean;
        animatorParams?: TypeAnimatorParams[];
    }
    interface TypeAnimatorParams {
        id: number;
        name: string;
        type: AniParmType;
        val: number | boolean;
    }
    interface TypeAnimatorLayer {
        defaultStateName?: string;
        name: string;
        blendingMode: number;
        states: TypeAnimatorState[];
        playOnWake: boolean;
        defaultWeight: number;
        avatarMask?: any;
        stageX?: number;
        stageY?: number;
        stageScale?: number;
    }
    enum AniParmType {
        Float = 0,
        Bool = 1,
        Trigger = 2
    }
    /**
     * @en Animation state condition types
     * @zh 动画状态条件类型
     */
    enum AniStateConditionType {
        Number = 0,
        Bool = 1,
        Trigger = 2
    }
    interface TypeAnimatorState {
        x: number;
        y: number;
        /**-1代表enter，-2代表exit，-3代表anyState */
        id: string;
        name: string;
        speed?: number;
        clipStart?: number;
        clipEnd?: number;
        loop?: number;
        yoyo?: boolean;
        soloTransitions?: TypeAnimatorTransition[];
        clip?: {
            _$uuid: string;
        };
        scripts?: string[];
        states?: TypeAnimatorState[];
        defaultStateName?: string;
        stageX?: number;
        stageY?: number;
        stageScale?: number;
    }
    interface TypeAnimatorTransition {
        id: string;
        name?: string;
        mute?: boolean;
        solo?: boolean;
        exitTime?: number;
        transduration?: number;
        transstartoffset?: number;
        exitByTime?: boolean;
        conditions?: TypeAnimatorConditions[];
    }
    interface TypeAnimatorConditions {
        id?: number;
        type?: AniStateConditionNumberCompressType;
        checkValue?: number | boolean;
        name?: string;
    }
    enum AniStateConditionNumberCompressType {
        Less = 0,
        Greater = 1
    }
    /**
     * @en Animation controller parsing and processing utility class.
     * @zh 解析和处理动画控制器数据的工具类。
     */
    class AnimatorControllerParse {
        /**
         * @en Parses the provided data to create a structured TypeAnimatorControllerData object..
         * @zh 解析提供的数据以创建结构化的 TypeAnimatorControllerData 对象。
         */
        static parse(data: TypeAnimatorControllerData): {
            ret: TypeAnimatorControllerData;
            clipsID: string[];
        };
        private static checkStates;
        private static checkNext;
        private static checkConditions;
        private static checkDefault;
        private static getStateByID;
    }
    /**
     * @en 2D Animator Play State.
     * @zh 2D 动画播放状态。
     */
    class AnimatorPlayState2D {
        _finish: boolean;
        /**
         * @en Total play time, not affected by negative speed values.
         * @zh 总播放时间，不受速度为负数的影响。
         */
        _playAllTime: number;
        /**
         * @en Indicates if the playback is in forward direction.
         * @zh 表示播放是否为正向。
         */
        _frontPlay: boolean;
        /**
         * @en The duration of the current animation, in seconds.
         * @zh 当前动画的持续时间，以秒为单位。
         */
        get duration(): number;
        /**
         * @en Animation state machine
         * @zh 动画状态机。
         */
        get animatorState(): AnimatorState2D;
        /**
         * @en Constructor method of AnimatorPlayState2D class.
         * @zh AnimatorPlayState2D类的构造方法
         */
        constructor();
    }
    /**
     * @en The Animator class is used to create animation components.
     * @zh Animator 类用于创建动画组件。
     */
    class AnimatorState2D extends EventDispatcher implements IClone {
        /**
         * @en Play on awake start offset
         * @zh 启动时播放偏移
         */
        cycleOffset: number;
        /**
         * @en name
         * @zh 名称
         */
        name: string;
        /**
         * @en Animation playback speed
         * @zh 动画播放速度
         */
        speed: number;
        /**
         * @en Action playback start time.
         * @zh 动作播放起始时间
         */
        clipStart: number;
        /**
         * @en The end time of the action playback.
         * @zh 动作播放结束时间。
         */
        clipEnd: number;
        /**
         * @en The number of animation loops. -1 or less than -1 to use the loop state of the clip, 1 for playing once, 2 for playing twice, 0 for infinite looping.
         * @zh 动画循环次数，-1或小于-1使用clip的循环状态，1表示播放一次，2表示播放两次，0表示无限循环。
         */
        loop: number;
        /**
         * @en Is it a one-time forward playback and one-time reverse playback mode
         * @zh 是否为一次正播放，一次倒播放模式
         */
        yoyo: boolean;
        /**
         * @en Animation Clip
         * @zh 动画剪辑
         */
        get clip(): AnimationClip2D | null;
        set clip(value: AnimationClip2D | null);
        /**
         * @en Dispatches the transition event and checks for transitions based on normalized time and parameters.
         * @param normalizeTime The normalized time for transition checking.
         * @param paramsMap The map of parameters for transition checking.
         * @param isReplay Whether to repeat playback.
         * @zh 派发过渡事件并根据归一化时间和参数检查过渡。
         * @param normalizeTime 用于检查过渡的归一化时间。
         * @param paramsMap 用于检查过渡的参数映射。
         * @param isReplay 是否重复播放
         */
        _eventtransition(normalizeTime: number, paramsMap: Record<string, Animation2DParm>, isReplay: boolean): AnimatorTransition2D;
        /**
         * @en Adds a script of the specified type to the animator state.
         * @param type The type of the script to be added.
         * @returns The added script instance.
         * @zh 向动画状态添加指定类型的脚本。
         * @param type 要添加的脚本类型。
         * @returns 添加的脚本实例。
         */
        addScript(type: typeof AnimatorState2DScript): AnimatorState2DScript;
        /**
         * @en Get the script of the specified type.
         * @param type The type of the script to retrieve.
         * @returns The script instance if found, or null if not found.
         * @zh 获取指定类型的脚本。
         * @param type 要检索的脚本类型。
         * @returns 如果找到则返回脚本实例，如果没有找到则返回 null。
         */
        getScript(type: typeof AnimatorState2DScript): AnimatorState2DScript | null;
        /**
         * @en Get the collection of scripts of the specified type.
         * @param type The type of scripts to retrieve.
         * @returns An array of scripts if found, or null if no scripts match the type.
         * @zh 获取指定类型的脚本集合。
         * @param type 要检索的脚本类型。
         * @returns 如果找到则返回脚本数组，如果没有找到匹配类型的脚本则返回 null。
         */
        getScripts(type: typeof AnimatorState2DScript): AnimatorState2DScript[] | null;
        /**
         * @en Clone of the current instance.
         * @returns A new instance of AnimatorState2D that is a clone of the current instance.
         * @zh 当前实例的克隆
         * @returns 一个新的 AnimatorState2D 实例，是当前实例的克隆。
         */
        clone(): AnimatorState2D;
        /**
         * @en Copies the properties of the current animator state to a target object.
         * @param destObject The target object to which the properties are copied.
         * @zh 将当前动画状态的属性拷贝到目标对象。
         * @param destObject 要拷贝属性的目标对象。
         */
        cloneTo(destObject: AnimatorState2D): void;
        /**
         * @en Destroys .
         * @zh 销毁。
         */
        destroy(): void;
    }
    /**
     * @en The AnimatorStateScript class is used as the parent class for animation state scripts. This class is abstract and does not allow instances.
     * @zh AnimatorStateScript 类用于动画状态脚本的父类,该类为抽象类,不允许实例。
     */
    class AnimatorState2DScript {
        /**
         * @en Constructor method of AnimatorStateScript.
         * @zh AnimatorStateScript的构造方法
         */
        constructor();
        /**
         * @en Executed when the animation state starts.
         * @zh 动画状态开始时执行。
         */
        onStateEnter(): void;
        /**
         * @en Called during the execution of the animation state, providing the normalized play time.
         * @param normalizeTime The normalized play time of the animation, ranging from 0 to 1.
         * @zh 在动画状态运行中调用，提供归一化的播放时间。
         * @param normalizeTime 动画的归一化播放时间，范围从0到1。
         */
        onStateUpdate(normalizeTime: number): void;
        /**
         * @en Executed when the animation state is about to exit.
         * @zh 动画状态退出时执行。
         */
        onStateExit(): void;
        /**
         * @en Executed at the end of each loop cycle if the animation is set to loop.
         * @zh 如果动画设置为循环，在每次循环结束时执行。
         */
        onStateLoop(): void;
    }
    /**
     * @en Animation state machine transition condition
     * @zh 动画状态机过渡条件
     */
    class AnimatorStateCondition {
        /**
         * @en Gets the unique ID associated with a name.
         * @param name The unique name.
         * @return The unique ID.
         * @zh 根据名称获取唯一的ID。
         * @param name 唯一的名称。
         * @return 唯一ID。
         */
        static conditionNameToID(name: string): number;
        /**
         * @en Gets the unique name associated with an ID.
         * @param id The condition ID.
         * @returns The unique name.
         * @zh 根据ID获取唯一的名称。
         * @param id 条件ID。
         * @returns 唯一名称。
         */
        static conditionIDToName(id: number): string;
        /**
         * @en Constructor method of AnimatorStateCondition.
         * @zh 动画状态机过渡条件的构造方法
         */
        constructor(name?: string);
        /**
         * @en The unique identifier of the condition.
         * @zh 条件的唯一标识符。
         */
        get id(): number;
        /**
         * @en The name of the condition.
         * @zh 条件的名称。
         */
        get name(): string;
        set name(value: string);
        /**
         * @en The type of the condition.
         * @zh 条件的类型。
         */
        get type(): AniStateConditionType;
    }
    /**
     * @en Numerical condition class. Used to handle conditions based on numerical comparisons.
     * @zh 数值条件类。用于处理基于数值比较的条件。
     */
    class AnimatorStateNumberCondition extends AnimatorStateCondition {
        /**
         * @en Constructor method of AnimatorStateNumberCondition.
         * @zh 创建number比较条件类的构造方法
         */
        constructor(name: string);
        /**
         * @en The number value.
         * @zh 数字值。
         */
        get numberValue(): number;
        set numberValue(value: number);
        /**
         * @en Determine type
         * @zh 判断类型
         */
        get compareFlag(): AniStateConditionNumberCompressType;
        set compareFlag(value: AniStateConditionNumberCompressType);
        /**
         * @en Checks if the state is triggered based on the comparison of the provided value with the number value.
         * @param value The value to compare.
         * @zh 根据提供的值与数值的比较结果检查状态是否触发。
         * @param value 要比较的值。
         */
        checkState(value: number): boolean;
    }
    /**
     * @en Boolean conditional class. Used to handle Boolean based conditions.
     * @zh 布尔条件类。用于处理基于布尔值的条件。
     */
    class AnimatorStateBoolCondition extends AnimatorStateCondition {
        /**
         * @en Constructor method.
         * @zh 构造方法
         */
        constructor(name: string);
        /**
         * @en Determine type
         * @zh 判断类型
         */
        get compareFlag(): boolean;
        set compareFlag(value: boolean);
        /**
         * @en Checks if the state is triggered based on the comparison of the provided boolean value with the comparison flag.
         * @param value The boolean value to compare.
         * @zh 根据提供的布尔值与比较标志的比较结果检查状态是否触发。
         * @param value 要比较的布尔值。
         */
        checkState(value: boolean): boolean;
    }
    /**
     * @en Trigger condition class. Used to handle trigger type conditions.
     * @zh 触发器条件类。用于处理触发器类型的条件。
     */
    class AnimatorStateTriggerCondition extends AnimatorStateCondition {
        /**
         * @en Constructor method.
         * @zh 触发器条件类的构造方法
         */
        constructor(name: string);
        /**
         * @en Check if the state is triggered. If the trigger is true, the condition is met.
         * @param value Boolean value.
         * @zh 检查状态是否触发,tigger 如果是true,就算条件达成
         * @param value 布尔值。
         */
        checkState(value: boolean): boolean;
    }
    /**
     * @en 2D animation transition
     * @zh 2D动画过渡
     */
    class AnimatorTransition2D {
        /**
         * @en Whether the state is muted.
         * @zh 状态是否被禁用。
         */
        mute: boolean;
        /**
         * @en The exit time of the state.
         * @zh 状态的退出时间。
         */
        exitTime: number;
        /**
         * @en Is the effective time set.
         * @zh 是否设置生效时间。
         */
        exitByTime: boolean;
        /**
         * @en The normalized playback position of the next state in the transition.
         * @zh 过渡中下一个状态的归一化播放位置。
         */
        transstartoffset: number;
        /**
         * @en The normalized transition duration.
         * @zh 归一化的过渡持续时间。
         */
        transduration: number;
        /**
         * @en Transition conditions
         * @zh 过渡条件。
         */
        conditions: AnimatorStateCondition[];
        /**
         * @en The destination state for the transition.
         * @zh 过渡的目标状态。
         */
        destState: AnimatorState2D;
        /**
         * @en Whether to use and operate when there are multiple conditions
         * @zh 当有多个条件的时候是否使用与操作
         */
        isAndOperEnabled: boolean;
        /**
         * @en Constructor method of Animatortransition2D.
         * @zh Animatortransition2D的构造方法
         */
        constructor();
        /**
         * @en Adds a state transition condition to the list of conditions.
         * @param condition The AnimatorStateCondition to be added.
         * @zh 向条件列表中添加一个状态转换条件。
         * @param condition 要添加的状态转换条件。
         */
        addCondition(condition: AnimatorStateCondition): void;
        /**
         * @en Removes a state transition condition from the list of conditions.
         * @param condition The AnimatorStateCondition to be removed.
         * @zh 从条件列表中删除一个状态转换条件。
         * @param condition 要删除的状态转换条件。
         */
        removeCondition(condition: AnimatorStateCondition): void;
        /**
         * @en Checks whether the transition is enabled based on the normalized time, condition parameters, and replay status.
         * @param normalizeTime The current normalized time (between 0 and 1) in the animation.
         * @param paramsMap Condition group
         * @param isReplay Whether to repeat playback.
         * @zh 根据归一化时间、条件参数和重播状态检查过渡是否启用。
         * @param normalizeTime 动画中当前的归一化时间（0到1之间）。
         * @param paramsMap 条件组
         * @param isReplay 是否重复播放
         */
        check(normalizeTime: number, paramsMap: Record<string, Animation2DParm>, isReplay: boolean): boolean;
    }
    /**
     * @en Animation update modes
     * @zh 动画更新模式
     */
    enum AnimatorUpdateMode {
        /**
         * @en Normal update mode
         * @zh 正常更新。
         */
        Normal = 0,
        /**
         * @en Low frame rate update mode
         * @zh 低频率更新。
         */
        LowFrame = 1,
        /**
         * @en Do not update thes animations based on time
         * @zh 不更新。
         */
        UnScaleTime = 2
    }
    /**
     * @en The Component class is used to create the base class for components.
     * @zh Component 类用于创建组件的基类。
     */
    class Component {
        /**@private */
        private _hideFlags;
        /**@private */
        private _enableState;
        /**
         * @en Gets the owner Node to which the component belongs.
         * @zh 获取组件所属的 Node 节点。
         */
        owner: Node;
        /**
         * @en Extra data of the node.
         * @zh 组件的额外数据。IDE内部使用。
         */
        _extra: IComponentExtra;
        /**
         * @en The hide flags that determine the hiding behavior of the component.
         * @zh 确定组件隐藏行为的标志。
         */
        get hideFlags(): number;
        set hideFlags(value: number);
        /**
         * @en Constructor method of Component.
         * @zh 组件的构造方法
         */
        constructor();
        /**
         * @en Checks if the component has a specific hide flag set.
         * @param flag The hide flag to check for.
         * @zh 检查组件是否设置了特定的隐藏标志。
         * @param flag 要检查的隐藏标志。
         */
        hasHideFlag(flag: number): boolean;
        /**
         * @en The unique identifier for the component.
         * @zh 组件的唯一标识。
         */
        get id(): number;
        /**
         * @en whether the component is enabled.
         * @zh 是否启用组件。
         */
        get enabled(): boolean;
        set enabled(value: boolean);
        /**
         * @en whether the component has been awakened.
         * @zh 组件是否已经被唤醒。
         */
        get awaked(): boolean;
        /**
         * @en whether the component has been destroyed.
         * @zh 组件是否已经被销毁。
         */
        get destroyed(): boolean;
        /**
         * @en Destroy components
         * @zh 销毁组件
         */
        destroy(): void;
        /**
         * @en Called after the component is added to a node. Unlike Awake, onAdded is called even if the node is not active.
         * @zh 组件被添加到节点后调用，与 onAwake 不同的是，即使节点未激活也会调用 onAdded。
         */
        onAdded(): void;
        /**
         * @en Resets the component's parameters to their default values. If this function is implemented, the component will be reset and automatically recycled for future use.
         * If not reset, it will not be recycled for reuse.
         * @zh 将组件的参数重置为默认值。如果实现了这个函数，组件将被重置并自动回收到对象池，方便下次复用。
         * 如果没有重置，则不会进行回收复用。
         */
        onReset?(): void;
        /**
         * @en Executed after the component is activated. At this point, all nodes and components have been created. This method is executed only once.
         * @zh 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次。
         */
        onAwake(): void;
        /**
         * @en Executed after the component is enabled, such as when the node is added to the stage.
         * @zh 组件被启用后执行，比如节点被添加到舞台后。
         */
        onEnable(): void;
        /**
         * @en Executed once, before the first update.
         * @zh 在第一次执行 update 之前执行，只会执行一次。
         */
        onStart?(): void;
        /**
         * @en Executed every frame during the update phase. Avoid writing complex loop logic or using the getComponent method here.
         * @zh 每帧更新时执行，在 update 阶段。尽量不要在这里写大循环逻辑或使用 getComponent 方法。
         */
        onUpdate?(): void;
        /**
         * @en Executed every frame during the late update phase, after the update phase.
         * @zh 每帧更新时执行，在 late update 阶段，update 阶段之后。
         */
        onLateUpdate?(): void;
        /**
         * @en Executed before rendering.
         * @zh 渲染之前执行。
         */
        onPreRender?(): void;
        /**
         * @en Executed after rendering.
         * @zh 渲染之后执行。
         */
        onPostRender?(): void;
        /**
         * @en Executed when the component is disabled, such as when the node is removed from the stage.
         * @zh 组件被禁用时执行，比如从节点从舞台移除后。
         */
        onDisable(): void;
        /**
         * @en Executed when the node is destroyed manually.
         * @zh 手动调用节点销毁时执行。
         */
        onDestroy(): void;
    }
    interface IComponentExtra {
    }
    /**
     * @en Core classes for managing and driving the lifecycle of components
     * @zh 用于管理和驱动组件生命周期的核心类
     */
    class ComponentDriver {
        private _onUpdates;
        private _onLateUpdates;
        private _onPreRenders;
        private _onPostRenders;
        private _toStarts;
        readonly _toDestroys: Set<Component>;
        /**
         * @en Error handling.
         * @zh 错误处理。
         */
        onError(err: any): void;
    }
    interface TypeAniKey {
        /**
         * @en The frame index.
         * @zh 第几帧
         */
        f: number;
        val: number | string | boolean;
        /**
         * @en Currently used for 2D animation, it is used to record the types of animation gaps, for example (Linear|Quad_EaseIn)...
         * @zh 目前用于2D动画，用于记录动画补间的类型，比如(Linear|Quad_EaseIn)...
         */
        tweenType?: string;
        /**
         * @en Extension
         * @zh 扩展，如果有一些其它数据需要加入到关键帧中可以写在这里
         */
        extend?: any;
        /**
         * @en The tween information.
         * @zh tween的信息
         */
        tweenInfo?: TypeTweenInfo;
    }
    interface TypeTweenInfo {
        outTangent?: number;
        outWeight?: number;
        inTangent?: number;
        inWeight?: number;
        inWeightLock?: boolean;
        outWeightLock?: boolean;
        broken?: boolean;
    }
    /**
     * @en Class used to represent 2D animation keyframes
     * @zh 用于表示2D动画关键帧的类
     */
    class Keyframe2D implements IClone {
        static defaultWeight: number;
        /**
         * @en time
         * @zh 时间。
         */
        time: number;
        /**
         * @en Specific data within the frame
         * @zh 帧里面的具体数据
         */
        data: TypeAniKey;
        /**
         * @en Creates a clone of the current keyframe.
         * @returns A new instance of Keyframe2D that is a clone of the current keyframe.
         * @zh 创建当前关键帧的克隆。
         * @returns 一个新实例的 Keyframe2D，是当前关键帧的克隆。
         */
        clone(): Keyframe2D;
        /**
         * @en Copies the properties of the current keyframe to another Keyframe2D instance.
         * @param destObject The Keyframe2D instance to which the properties are copied.
         * @zh 将当前关键帧的属性复制到另一个 Keyframe2D 实例。
         * @param destObject 要复制属性的 Keyframe2D 实例。
         */
        cloneTo(destObject: Keyframe2D): void;
    }
    /**
     * @en 2D animation keyframe nodes.
     * @zh 2D 动画关键帧节点的类。
     */
    class KeyframeNode2D {
        _ownerPath: string[];
        _propertys: string[];
        fullPath: string;
        nodePath: string;
        _indexInList: number;
        _keyFrames: Keyframe2D[];
        /**
         * @en Number of frames
         * @zh 帧个数。
         */
        get keyFramesCount(): number;
        _setOwnerPathCount(value: number): void;
        _setOwnerPathByIndex(index: number, value: string): void;
        _setPropertyCount(value: number): void;
        _setPropertyByIndex(index: number, value: string): void;
        _setKeyframeCount(value: number): void;
        _joinOwnerPath(sep: string): string;
        _joinProperty(sep: string): string;
        /**
         * @en Gets a keyframe by its index in the animation timeline.
         * @param index The index of the keyframe to retrieve.
         * @zh 通过索引获取动画时间线上的关键帧。
         * @param index 要检索的关键帧的索引。
         */
        getKeyframeByIndex(index: number): Keyframe2D;
        /**
         * @en The number of owner paths in the animation.
         * @zh 动画中的精灵路径个数。
         */
        get ownerPathCount(): number;
        /**
         * @en The number of property paths in the animation.
         * @zh 动画中的属性路径个数。
         */
        get propertyCount(): number;
        /**
         * @en Gets an owner path by its index in the list of owner paths.
         * @param index The index of the owner path to retrieve.
         * @zh 通过索引获取精灵路径列表中的精灵路径。
         * @param index 要检索的精灵路径的索引。
         */
        getOwnerPathByIndex(index: number): string;
        /**
         * @en Gets a property path by its index in the list of property paths.
         * @param index The index of the property path to retrieve.
         * @zh 通过索引获取属性路径列表中的属性路径。
         * @param index 要检索的属性路径的索引。
         */
        getPropertyByIndex(index: number): string;
    }
    /**
     * @en A class used to manage 2D keyframe nodes list.
     * @zh 用于管理2D关键帧节点的列表类。
     */
    class KeyframeNodeList2D {
        private _nodes;
        /**
         * @en The number of nodes in the list.
         * @zh 列表中的节点个数。
         */
        get count(): number;
        set count(value: number);
        /**
         * @en Retrieves node by its index in the list.
         * @param index The index of the node to retrieve.
         * @returns The node at the specified index.
         * @zh 通过索引获取列表中的节点。
         * @param index 要检索的节点的索引。
         * @returns 指定索引处的节点。
         */
        getNodeByIndex(index: number): KeyframeNode2D;
        /**
         * @en Sets a node by its index in the list.
         * @param index The index at which to set the node.
         * @param node The node to set at the specified index.
         * @zh 通过索引设置列表中的节点。
         * @param index 要设置节点的索引。
         * @param node 要设置的节点。
         */
        setNodeByIndex(index: number, node: KeyframeNode2D): void;
    }
    /**
     * @en The Script class is used to create the parent class of a script, which is an abstract class and does not allow instances.
     * @zh Script 类用于创建脚本的父类，该类为抽象类，不允许实例。
     */
    class Script extends Component {
        /**
         * @en Script belonging to sprite
         * @zh 脚本所属精灵
         */
        owner: Sprite | Sprite3D;
        /**
         * @en Called when a 3D physics trigger event or a 2D physics collision event begins.
         * @param other The collider component or base of the other object in the collision.
         * @param self The collider component or base of the object itself.
         * @param contact The contact point information.
         * @zh 开始碰撞时执行的3D物理触发器事件或2D物理碰撞事件。
         * @param other 其他对象的碰撞器组件。
         * @param self 自身的碰撞器组件。
         * @param contact 接触点信息。
         */
        onTriggerEnter?(other: PhysicsColliderComponent | ColliderBase, self?: ColliderBase, contact?: any): void;
        /**
         * @en Called during the frame a 3D physics trigger event or a 2D physics collision event stays collided.
         * @param other The collider component or base of the other object in the collision.
         * @param self The collider component or base of the object itself, if not provided it's assumed to be the owner of the script.
         * @param contact The contact point information, can be any type depending on the physics engine used.
         * @zh 持续碰撞时执行的3D物理触发器事件或2D物理碰撞事件。
         * @param other 其他对象的碰撞器组件。
         * @param self 自身的碰撞器组件。
         * @param contact 接触点信息。
         */
        onTriggerStay?(other: PhysicsColliderComponent | ColliderBase, self?: ColliderBase, contact?: any): void;
        /**
         * @en Called when a 3D physics trigger event or a 2D physics collision event ends.
         * @param other The collider component or base of the other object in the collision.
         * @param self The collider component or base of the object itself.
         * @param contact The contact point information.
         * @zh 结束碰撞时执行的3D物理触发器事件或2D物理碰撞事件。
         * @param other 其他对象的碰撞器组件或基类。
         * @param self 自身的碰撞器组件或基类。
         * @param contact 接触点信息。
         */
        onTriggerExit?(other: PhysicsColliderComponent | ColliderBase, self?: ColliderBase, contact?: any): void;
        /**
         * @en Called when a 3D physics collider event begins (not applicable to 2D).
         * @param collision The collision.
         * @zh 3D物理碰撞器事件开始时调用（不适用于2D）。
         * @param collision 碰撞器。
         */
        onCollisionEnter?(collision: Collision): void;
        /**
         * @en Called during the frame a 3D physics collider event stays collided (not applicable to 2D).
         * @param collision The collision.
         * @zh 3D物理碰撞器事件持续碰撞时调用（不适用于2D）。
         * @param collision 碰撞器。
         */
        onCollisionStay?(collision: Collision): void;
        /**
         * @en Called when a 3D physics collider event ends (not applicable to 2D).
         * @param collision The collision.
         * @zh 3D物理碰撞器事件结束碰撞时调用（不适用于2D）。
         * @param collision 碰撞器。
         */
        onCollisionExit?(collision: Collision): void;
        /**
         * @en Called when a joint is broken in the physics simulation.
         * @zh 物理模拟中关节断裂时调用。
         */
        onJointBreak?(): void;
        /**
         * @en Called when the mouse button is pressed down on the node.
         * @param evt The mouse event.
         * @zh 鼠标按下时执行。
         * @param evt 鼠标事件。
         */
        onMouseDown?(evt: Event): void;
        /**
         * @en Called when the mouse button is released from the node.
         * @param evt The mouse event.
         * @zh 鼠标抬起时执行。
         * @param evt 鼠标事件。
         */
        onMouseUp?(evt: Event): void;
        /**
         * @en Called when the right or middle mouse button is pressed down.
         * @param evt The mouse event.
         * @zh 鼠标右键或中键按下时执行。
         * @param evt 鼠标事件。
         */
        onRightMouseDown?(evt: Event): void;
        /**
         * @en Called when the right or middle mouse button is released.
         * @param evt The mouse event.
         * @zh 鼠标右键或中键抬起时执行。
         * @param evt 鼠标事件。
         */
        onRightMouseUp?(evt: Event): void;
        /**
         * @en Called when the mouse moves over the node.
         * @param evt The mouse event.
         * @zh 鼠标在节点上移动时执行。
         * @param evt 鼠标事件。
         */
        onMouseMove?(evt: Event): void;
        /**
         * @en Called when the mouse enters the node boundaries.
         * @param evt The mouse event.
         * @zh 鼠标进入节点时执行。
         * @param evt 鼠标事件。
         */
        onMouseOver?(evt: Event): void;
        /**
         * @en Called when the mouse leaves the node boundaries.
         * @param evt The mouse event.
         * @zh 鼠标离开节点时执行。
         * @param evt 鼠标事件。
         */
        onMouseOut?(evt: Event): void;
        /**
         * @en Called when the mouse is held down and an object is dragged.
         * @param evt The mouse event.
         * @zh 鼠标按住一个物体后，拖拽时执行。
         * @param evt 鼠标事件。
         */
        onMouseDrag?(evt: Event): void;
        /**
         * @en Called when the mouse button is released after dragging an object.
         * @param evt The mouse event.
         * @zh 鼠标按住一个物体，拖拽一定距离，释放鼠标按键后执行。
         * @param evt 鼠标事件。
         */
        onMouseDragEnd?(evt: Event): void;
        /**
         * @en Called when the mouse button is clicked (pressed and released) on the node.
         * @param evt The mouse event.
         * @zh 鼠标点击时执行。
         * @param evt 鼠标事件。
         */
        onMouseClick?(evt: Event): void;
        /**
         * @en Called when the mouse button is double-clicked on the node.
         * @param evt The mouse event.
         * @zh 鼠标双击时执行。
         * @param evt 鼠标事件。
         */
        onMouseDoubleClick?(evt: Event): void;
        /**
         * @en Called when the right mouse button is clicked on the node.
         * @param evt The mouse event.
         * @zh 鼠标右键点击时执行。
         * @param evt 鼠标事件。
         */
        onMouseRightClick?(evt: Event): void;
        /**
         * @en Called when a key is pressed down.
         * @param evt The keyboard event.
         * @zh 键盘按下时执行。
         * @param evt 键盘事件。
         */
        onKeyDown?(evt: Event): void;
        /**
         * @en Called when a key is pressed and holds long enough to generate a character.
         * @param evt The keyboard event.
         * @zh 键盘产生一个字符时执行。
         * @param evt 键盘事件。
         */
        onKeyPress?(evt: Event): void;
        /**
         * @en Called when a key is released.
         * @param evt The keyboard event.
         * @zh 键盘抬起时执行。
         * @param evt 键盘事件。
         */
        onKeyUp?(evt: Event): void;
    }
    /**
     * @en Relative layout Component.
     * @zh 相对布局组件
     */
    class Widget extends Component {
        /**
         * @en An static instance of a Widget that has been initialized.
         * @zh 一个已初始化的 Widget 静态实例。
         */
        static EMPTY: Widget;
        private _top;
        private _bottom;
        private _left;
        private _right;
        private _centerX;
        private _centerY;
        constructor();
        /**
         * @en Resets the boundaries and center coordinates of the object to null.
         * @zh 将对象的边界和中心坐标重置为 null。
         */
        onReset(): void;
        protected _onEnable(): void;
        protected _onDisable(): void;
        protected _onAdded(): void;
        /**
         * 父容器的 <code>Event.RESIZE</code> 事件侦听处理函数。
         */
        protected _onParentResize(): void;
        /**
         * @private
         * @en Resets the object's layout along the X-axis (horizontal direction).
         * @zh 重置对象的水平布局（X轴方向）。
         */
        resetLayoutX(): boolean;
        /**
         * @private
         * @en Resets the object's layout along the Y-axis (vertical direction).
         * @zh 重置对象的垂直布局（Y轴方向）。
         */
        resetLayoutY(): boolean;
        /**
         * @en Recalculate layout
         * @zh 重新计算布局
         */
        resetLayout(): void;
        /**
         * @en The distance from the top edge, in pixels.
         * @zh 距顶边的距离（以像素为单位）。
         */
        get top(): number;
        set top(value: number);
        /**
         * @en The distance from the bottom edge, in pixels.
         * @zh 距底边的距离（以像素为单位）。
         */
        get bottom(): number;
        set bottom(value: number);
        /**
         * @en The distance from the left edge, in pixels.
         * @zh 距左边的距离（以像素为单位）。
         */
        get left(): number;
        set left(value: number);
        /**
         * @en The distance from the right edge, in pixels.
         * @zh 距右边的距离（以像素为单位）。
         */
        get right(): number;
        set right(value: number);
        /**
         * @en The distance from the horizontal center axis, in pixels.
         * @zh 距水平方向中心轴的距离（以像素为单位）。
         */
        get centerX(): number;
        set centerX(value: number);
        /**
         * @en The distance from the vertical center axis, in pixels.
         * @zh 距垂直方向中心轴的距离（以像素为单位）。
         */
        get centerY(): number;
        set centerY(value: number);
    }
    /**
     * @private
     * 静态常量集合
     */
    class Const {
        static ENUM_TEXTALIGN_DEFAULT: number;
        static ENUM_TEXTALIGN_CENTER: number;
        static ENUM_TEXTALIGN_RIGHT: number;
        static INDEX_BYTES: number;
        static MAX_CLIP_SIZE: number;
    }
    /**
     * 节点标志
     */
    class NodeFlags {
        static NOT_ACTIVE: number;
        static ACTIVE_INHIERARCHY: number;
        static AWAKED: number;
        static NOT_READY: number;
        static DISPLAY: number;
        static HAS_ZORDER: number;
        static HAS_MOUSE: number;
        static DISPLAYED_INSTAGE: number;
        static DRAWCALL_OPTIMIZE: number;
        static PROCESS_COLLISIONS: number;
        static PROCESS_TRIGGERS: number;
        static HAS_SCRIPT: number;
        static ESCAPE_DRAWING_TO_TEXTURE: number;
        static DISABLE_INNER_CLIPPING: number;
        static DISABLE_OUTER_CLIPPING: number;
        static DISABLE_VISIBILITY: number;
        static EDITING_NODE: number;
        static HIDE_BY_EDITOR: number;
        static LOCK_BY_EDITOR: number;
    }
    class HideFlags {
        static HideInHierarchy: number;
        static HideInInspector: number;
        static DontSave: number;
        static HideAndDontSave: number;
    }
    /**
     * @en The AnimationClip class is used for animation clip resources.
     * @zh AnimationClip 类用于动画片段资源。
     */
    class AnimationClip extends Resource {
        /**
         * @deprecated 请使用Loader.load(url:string, type: ILaya.Loader.ANIMATIONCLIP)
         * @en Load animation clip.
         * @param url The URL of the animation clip.
         * @param complete Callback function when loading is complete.
         * @zh 加载动画片段。
         * @param url 动画片段地址。
         * @param complete 加载完成回调。
         */
        static load(url: string, complete: Handler): void;
        /**
         * @en Whether the animation is looping.
         * @zh 是否循环。
         */
        islooping: boolean;
        /**
         * @en Get the duration of the animation.
         * @returns The duration of the animation.
         * @zh 动画持续时间。
         * @returns 返回动画持续时间。
         */
        duration(): number;
        /**
         * @ignore
         * @en Creates an instance of AnimationClip.
         * @zh 创建一个AnimationClip实例。
         */
        constructor();
        /**
         * @en Whether is Weight mode.
         * @param weightMode The current weight mode.
         * @param nextweightMode The next weight mode.
         * @returns True if this animation segment uses Hermite interpolation.
         * @zh 是否是Weight模式。
         * @param weightMode 当前的权重模式。
         * @param nextweightMode 下一个权重模式。
         * @returns 返回true，表示此段动画插值使用埃尔米特插值。
         */
        private _weightModeHermite;
        private _hermiteInterpolateVector4;
        private _hermiteInterpolateVector2;
        private _hermiteCurveSplineWeight;
        private _curveInterpolate;
        private _evaluateFrameNodeVector3DatasRealTime;
        private _evaluateFrameNodeVector2DatasRealTime;
        private _evaluateFrameNodeVector4DatasRealTime;
        private _evaluateFrameNodeQuaternionDatasRealTime;
        private _binarySearchEventIndex;
        /**
         * @en Add an animation event.
         * @param event The animation event to be added.
         * @zh 添加动画事件。
         * @param event 动画事件。
         */
        addEvent(event: AnimationEvent): void;
    }
    /**
     * @en The AnimationEvent class is used to implement animation events.
     * @zh AnimationEvent 类用于实现动画事件。
     */
    class AnimationEvent {
        /**
         * @en The time at which the event is triggered.
         * @zh 事件触发的时间。
         */
        time: number;
        /**
         * @en The name of the triggered event.
         * @zh 触发的事件名称。
         */
        eventName: string;
        /**
         * @en The parameters of the triggered event.
         * @zh 触发事件的参数。
         */
        params: any[];
        /**
         * @ignore
         */
        constructor();
    }
    /**
     * @en The AnimatorStateScript class is the base class for animation state scripts. This is an abstract class and cannot be instantiated.
     * @zh AnimatorStateScript 类用于动画状态脚本的父类,该类为抽象类,不允许实例。
     */
    class AnimatorStateScript {
        /**
         * @ignore
         * @en Creates an instance of AnimatorStateScript.
         * @zh 创建 AnimatorStateScript 实例。
         */
        constructor();
        /**
         * @en Executed when the animation state begins.
         * @zh 动画状态开始时执行。
         */
        onStateEnter(): void;
        /**
         * @en Executed when the animation state is running.
         * @param normalizeTime The animation playback state (0-1).
         * @zh 动画状态运行中。
         * @param normalizeTime 0-1动画播放状态。
         */
        onStateUpdate(normalizeTime: number): void;
        /**
          * @en Executed when the animation state exits.
          * @zh 动画状态退出时执行。
          */
        onStateExit(): void;
        /**
         * @en Executed at the end of each loop if the animation is set to loop.
         * @zh 如果动画设置了循环，则在每次循环结束时执行。
         */
        onStateLoop(): void;
    }
    /**
     * @en The KeyframeNode class is used for animation keyframes.
     * @zh KeyframeNode 类用于动画关键帧。
     */
    class KeyframeNode {
        private _ownerPath;
        private _propertys;
        /**
         * @en The number of sprite paths.
         * @zh 精灵路径个数。
         */
        get ownerPathCount(): number;
        /**
         * @en The number of property paths.
         * @zh 属性路径个数。
         */
        get propertyCount(): number;
        /**
         * @en The number of keyframes.
         * @zh 帧个数。
         */
        get keyFramesCount(): number;
        /**
         * @en Get the sprite path by index.
         * @param index The index of the sprite path.
         * @returns The sprite path at the specified index.
         * @zh 通过索引获取精灵路径。
         * @param index 索引。
         * @returns 指定索引处的精灵路径。
         */
        getOwnerPathByIndex(index: number): string;
        /**
         * @en Get the property path by index.
         * @param index The index of the property path.
         * @returns The property path at the specified index.
         * @zh 通过索引获取属性路径。
         * @param index 索引。
         * @returns 指定索引处的属性路径。
         */
        getPropertyByIndex(index: number): string;
        /**
         * @en Get the keyframe by index.
         * @param index The index of the keyframe.
         * @returns The keyframe at the specified index.
         * @zh 通过索引获取帧。
         * @param index 索引。
         * @returns 指定索引处的关键帧。
         */
        getKeyframeByIndex(index: number): Keyframe;
    }
    /**
     * @en The KeyframeNodeList class is used to create a queue of KeyframeNode nodes.
     * @zh KeyframeNodeList 类用于创建 KeyframeNode 节点队列。
     */
    class KeyframeNodeList {
        /**
         * @en The number of nodes.
         * @zh 节点个数。
         */
        get count(): number;
        set count(value: number);
        /**
         * @ignore
         * @en Creates an instance of KeyframeNodeList.
         * @zh 创建一个KeyframeNodeList实例。
         */
        constructor();
        /**
         * @en Get a node by its index.
         * @param index The index of the node.
         * @returns The KeyframeNode at the specified index.
         * @zh 通过索引获取节点。
         * @param index 索引。
         * @returns 指定索引处的 KeyframeNode 节点。
         */
        getNodeByIndex(index: number): KeyframeNode;
        /**
         * @en Set a node at the specified index.
         * @param index The index at which to set the node.
         * @param node The KeyframeNode to set.
         * @zh 通过索引设置节点。
         * @param index 索引。
         * @param node 要设置的 KeyframeNode 节点。
         */
        setNodeByIndex(index: number, node: KeyframeNode): void;
    }
    type AnimatorParams = {
        [key: number]: number | boolean;
    };
    /**
     * @en The `Animator` class is used to create 3D animation components.
     * @zh `Animator` 类用于创建3D动画组件。
     */
    class Animator extends Component {
        /**
         * @en Culling mode: Always animate.
         * @zh 裁剪模式：始终播放动画。
         */
        static CULLINGMODE_ALWAYSANIMATE: number;
        /**
         * @en Culling mode: Don't animate when not visible.
         * @zh 裁剪模式：不可见时完全不播放动画。
         */
        static CULLINGMODE_CULLCOMPLETELY: number;
        /**
         * @en Culling mode，By default, when set to invisible, the animation will not play at all.
         * @zh 裁剪模式,默认为不可见时完全不播放动画。
         */
        cullingMode: number;
        private _LateUpdateEvents;
        /**
         * @en The animation controller.
         * @zh 动画控制器。
         */
        get controller(): AnimatorController;
        set controller(val: AnimatorController);
        /**
         * @en The playback speed of the animation. 1.0 is the normal playback speed.
         * @zh 动画的播放速度。1.0 为正常播放速度。
         */
        get speed(): number;
        set speed(value: number);
        /**
         * @en The update mode for the animator.
         * @zh 动画更新模式。
         */
        set updateMode(value: AnimatorUpdateMode);
        /**
         * @en Low update mode
         * @zh 低更新模式
         */
        set lowUpdateDelty(value: number);
        /**
         * @en The number of layers in the state machine animation.
         * @zh 状态机动画层的数量。
         */
        get controllerLayerCount(): number;
        /**
         * @en The map of animator parameters.
         * @zh 状态机参数map。
         */
        get animatorParams(): AnimatorParams;
        set animatorParams(values: AnimatorParams);
        /**
         * @en Whether to stop updating after the animation is completed.
         * @zh 动画完成后是否停止更新。
         */
        get sleep(): boolean;
        set sleep(value: boolean);
        /**
         * @en The constructor of Animator.
         * @zh 构造方法，创建动画组件。
         */
        constructor();
        /**
         * 启用过渡
         * @param layerindex
         * @param transition
         * @returns
         */
        private _applyTransition;
        private _applyVec2;
        private _applyVec3;
        private _applyVec4;
        private _applyColor;
        /**
         * 赋值Node数据
         * @param stateInfo 动画状态
         * @param additive 是否为addtive
         * @param weight state权重
         * @param isFirstLayer 是否是第一层
         */
        private _setClipDatasToNode;
        private _applyUpdateMode;
        /**
         * @en Gets the default animation state.
         * @param layerIndex The layer index.
         * @returns The default animation state.
         * @zh 获取默认动画状态。
         * @param	layerIndex 层索引。
         * @return 默认动画状态。
         */
        getDefaultState(layerIndex?: number): AnimatorState;
        /**
         * @en Adds an animation state.
         * @param state The animation state to add.
         * @param layerIndex The layer index.
         * @zh 添加动画状态。
         * @param	state 动画状态。
         * @param   layerIndex 层索引。
         */
        addState(state: AnimatorState, layerIndex?: number): void;
        /**
         * @en Removes an animation state.
         * @param state The animation state to remove.
         * @param layerIndex The layer index.
         * @zh 移除动画状态。
         * @param	state 动画状态。
         * @param   layerIndex 层索引。
         */
        removeState(state: AnimatorState, layerIndex?: number): void;
        /**
         * @en Adds a controller layer.
         * @param controllerLayer The animation controller layer to add.
         * @zh 添加控制器层。
         * @param controllerLayer 动画控制层。
         */
        addControllerLayer(controllerLayer: AnimatorControllerLayer): void;
        /**
         * @en Gets the controller layer.
         * @param layerIndex The layer index. Defaults to 0.
         * @returns The AnimatorControllerLayer at the specified index.
         * @zh 获取控制器层。
         * @param layerIndex 层索引。
         * @return 指定索引处的AnimatorControllerLayer。
         */
        getControllerLayer(layerIndex?: number): AnimatorControllerLayer;
        /**
         * @en Plays an animation.
         * @param name If null, plays the default animation; otherwise, plays the animation clip with the specified name.
         * @param layerIndex The layer index. Defaults to 0.
         * @param normalizedTime The normalized start time of the animation. Defaults to Number.NEGATIVE_INFINITY.
         * @zh 播放动画。
         * @param	name 如果为null则播放默认动画，否则按名字播放动画片段。
         * @param	layerIndex 层索引。
         * @param	normalizedTime 归一化的播放起始时间。
         */
        play(name?: string | null, layerIndex?: number, normalizedTime?: number): void;
        /**
         * @en Performs a crossfade transition between the current animation state and the target animation state.
         * @param name The name of the target animation state.
         * @param transitionDuration The transition duration, normalized to the current animation state's duration. Value should be between 0.0 and 1.0.
         * @param layerIndex The layer index. Defaults to 0.
         * @param normalizedTime The normalized start time of the animation. Defaults to Number.NEGATIVE_INFINITY.
         * @zh 在当前动画状态和目标动画状态之间进行融合过渡播放。
         * @param	name 目标动画状态。
         * @param	transitionDuration 过渡时间,该值为当前动画状态的归一化时间，值在0.0~1.0之间。
         * @param	layerIndex 层索引。
         * @param	normalizedTime 归一化的播放起始时间。
         */
        crossFade(name: string, transitionDuration: number, layerIndex?: number, normalizedTime?: number): void;
        /**
         * @en Enables a trigger parameter.
         * @param name The name or index of the trigger parameter.
         * @zh 启用触发条件参数。
         * @param name 触发条件的名字或者索引
         */
        setParamsTrigger(name: number): void;
        setParamsTrigger(name: string): void;
        /**
         * @en Sets the value of a number parameter.
         * @param name The name or index of the parameter.
         * @param value The value to set.
         * @zh 设置数值类型参数的值。
         * @param name 属性的名字或者索引
         * @param value 属性值
         */
        setParamsNumber(name: number, value: number): void;
        setParamsNumber(name: string, value: number): void;
        /**
         * @en Sets the value of a boolean parameter.
         * @param name The name or index of the parameter.
         * @param value The value to set.
         * @zh 设置布尔类型参数的值。
         * @param name 属性的名字或者索引
         * @param value 属性值
         */
        setParamsBool(name: number, value: boolean): void;
        setParamsBool(name: string, value: boolean): void;
        /**
         * @en Gets the value of a parameter.
         * @param name The name or index of the parameter.
         * @returns The value of the parameter.
         * @zh 获取参数的值。
         * @param	name 属性的名字或者索引
         * @return 属性值
         */
        getParamsvalue(name: number): number | boolean;
        getParamsvalue(name: string): number | boolean;
        /**
         * @deprecated 请使用animator.getControllerLayer(layerIndex).getCurrentPlayState()替换。use animator.getControllerLayer(layerIndex).getCurrentPlayState() instead
         * 获取当前的播放状态。
         * @param layerIndex 层索引。
         * @return 动画播放状态。
         */
        getCurrentAnimatorPlayState(layerIndex?: number): AnimatorPlayState;
    }
    /**
     * @en Represents an animator controller resource that manages animation states and transitions.
     * @zh 管理动画状态和转换的动画控制器资源。
     */
    class AnimatorController extends Resource {
        /**
         * @en The parsed data of the animator controller.
         * @zh 解析后的动画控制器数据。
         */
        data: TypeAnimatorControllerData;
        /**
         * @en An array of clip IDs associated with this animator controller.
         * @zh 与此动画控制器关联的剪辑ID数组。
         */
        clipsID: string[];
        /**
         * @en The constructor of AnimatorController, initialize a new AnimatorController object.
         * @param data The animator controller data.
         * @zh 构造函数，初始化一个新的 AnimatorController 对象。
         * @param data 动画控制器数据。
         */
        constructor(data: any);
        private getLayers;
        /**
         * @en Updates the given Animator with the current AnimatorController's data.
         * This method updates the controller layers and animator parameters.
         * @param a The Animator to update.
         * @zh 使用当前AnimatorController的数据更新给定的Animator。
         * 此方法更新控制器层和动画参数。
         * @param a 要更新的Animator。
         */
        updateTo(a: Animator): void;
        private createState;
        private setExitTransition;
        private setTransitions;
        private getState;
        private addConditions;
    }
    /**
     * @en The `AnimatorControllerLayer` class is used to create animation controller layers.
     * @zh `AnimatorControllerLayer` 类用于创建动画控制器层。
     */
    class AnimatorControllerLayer implements IClone {
        /**
         * @en Blending mode: Override.
         * @zh 混合模式：覆盖。
         */
        static BLENDINGMODE_OVERRIDE: number;
        /**
         * @en Blending mode: Additive.
         * @zh 混合模式：叠加。
         */
        static BLENDINGMODE_ADDTIVE: number;
        /**
         * @en The name of the layer.
         * @zh 层的名称。
         */
        name: string;
        /**
         * @en The blending mode of the layer.
         * @zh 层的混合模式。
         */
        blendingMode: number;
        /**
         * @en The default weight of the layer.
         * @zh 层的默认权重。
         */
        defaultWeight: number;
        /**
         * @en Whether to automatically play when activated.
         * @zh 激活时是否自动播放。
         */
        playOnWake: boolean;
        /**
         * @en Whether the layer is enabled.
         * @zh 层是否启用。
         */
        enable: boolean;
        /**
         * @en Default animation state machine.
         * @zh 默认动画状态机。
         */
        get defaultState(): AnimatorState;
        set defaultState(value: AnimatorState);
        /**
         * @en The avatar mask of the layer.
         * @zh 层的骨骼遮罩。
         */
        get avatarMask(): AvatarMask;
        set avatarMask(value: AvatarMask);
        private _defaultStateNameCatch;
        set defaultStateName(value: string);
        /**
         * @en The AnimatorStates in this layer.
         * @zh 此层中动画状态
         */
        get states(): ReadonlyArray<AnimatorState>;
        set states(states: ReadonlyArray<AnimatorState>);
        /**
         * @en Constructor method.
         * @param name 动画层名称
         * @zh 构造方法
         * @param name 动画层名称
         */
        constructor(name: string);
        /**
         * @en Gets the current play state of the animation.
         * @returns The current AnimatorPlayState.
         * @zh 获取当前的动画播放状态。
         * @return 动画播放状态。
         */
        getCurrentPlayState(): AnimatorPlayState;
        /**
         * @en Gets an animator state by its name.
         * @param name The name of the animator state to find.
         * @returns The AnimatorState if found, or null if not found.
         * @zh 通过名称获取动画状态。
         * @param name 要查找的动画状态的名称。
         * @returns 如果找到则返回AnimatorState，否则返回null。
         */
        getAnimatorState(name: string): AnimatorState | null;
        /**
         * @en Adds an animation state to the layer.
         * @param state The AnimatorState to add.
         * @zh 向层中添加动画状态。
         * @param state 要添加的AnimatorState。
         */
        addState(state: AnimatorState): void;
        /**
         * @en Removes an animation state from the layer.
         * @param state The AnimatorState to remove.
         * @zh 从层中移除动画状态。
         * @param state 要移除的动画状态。
         */
        removeState(state: AnimatorState): void;
        /**
         * @en Destroys the AnimatorControllerLayer and clears all references.
         * @zh 销毁AnimatorControllerLayer并清除所有引用。
         */
        destroy(): void;
        /**
         * @en Clones the properties of this AnimatorControllerLayer to another object.
         * @param destObject The target object to clone to.
         * @zh 将此AnimatorControllerLayer的属性克隆到另一个对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: AnimatorControllerLayer): void;
        /**
         * @en Creates and returns a clone of this AnimatorControllerLayer.
         * @returns A new AnimatorControllerLayer instance with properties copied from this one.
         * @zh 创建并返回此AnimatorControllerLayer的克隆副本。
         * @returns 一个新的AnimatorControllerLayer实例，其属性从当前实例复制。
         */
        clone(): any;
    }
    /**
     * @en The AnimatorPlayState class is used to create animation play state information.
     * @zh AnimatorPlayState 类用于创建动画播放状态信息。
     */
    class AnimatorPlayState {
        /**
         * @en The current AnimatorState.
         * @zh 当前的动画状态。
         */
        get currentState(): AnimatorState | null;
        set currentState(value: AnimatorState | null);
        /**
         * @en The normalized time of the play state. The integer part represents the number of loops, and the fractional part represents the time of a single play.
         * @returns The normalized time of the animation.
         * @zh 播放状态的归一化时间。整数部分表示循环次数，小数部分表示单次播放时间。
         * @returns 动画的归一化时间。
         */
        get normalizedTime(): number;
        /**
         * @en The duration of the current animation in seconds.
         * @zh 当前动画的持续时间，以秒为单位。
         */
        get duration(): number;
        /**
         * @en The current animator state.
         * @zh 当前的动画状态机。
         */
        get animatorState(): AnimatorState;
        /**
         * @en constructor
         * @zh 构造函数
         */
        constructor();
    }
    /**
     * @en Animator resource class for handling animation-related resources.
     * @zh 动画资源类，用于处理与动画相关的资源。
     */
    class AnimatorResource {
        /**
         * @en Get the animator resource component from a Sprite3D object.
         * @param sprite The Sprite3D object to get the component from.
         * @param propertyKey The key of the property to get the component for.
         * @zh 从Sprite3D对象获取动画资源组件。
         * @param sprite 要获取组件的Sprite3D对象。
         * @param propertyKey 要获取组件的属性键。
         */
        static getAnimatorResource(sprite: Sprite3D, propertyKey: string): Component;
    }
    /**
     * @en The AnimatorState class is used to create animation states.
     * @zh AnimatorState 类用于创建动画状态。
     */
    class AnimatorState extends EventDispatcher implements IClone {
        /**
         * @en Animation event called when the state is entered.
         * @zh 动画事件，在进入状态时调用。
         */
        static EVENT_OnStateEnter: string;
        /**
         * @en Animation event called when the state is updated.
         * @zh 动画事件，在更新状态时调用。
         */
        static EVENT_OnStateUpdate: string;
        /**
         * @en Animation event called when a loop is completed.
         * @zh 动画事件，在循环完成时调用。
         */
        static EVENT_OnStateLoop: string;
        /**
         * @en Animation event called when the state is exited.
         * @zh 动画事件，在离开状态时调用。
         */
        static EVENT_OnStateExit: string;
        /**
         * @en Current transition content.
         * @zh 当前过渡内容。
         */
        curTransition: AnimatorTransition;
        /**
         * @en Name of the animator state.
         * @zh 动画状态的名称。
         */
        name: string;
        /**
         * @en Animation playback speed. 1.0 is normal playback speed.
         * @zh 动画播放速度。1.0为正常播放速度。
         */
        speed: number;
        /**
         * @en Start time of animation playback.
         * @zh 动画播放的起始时间。
         */
        clipStart: number;
        /**
         * @en End time of animation playback.
         * @zh 动画播放的结束时间。
         */
        clipEnd: number;
        /**
         * @en Play on awake start offset.
         * @zh 唤醒时播放的起始偏移量。
         */
        cycleOffset: number;
        /**
         * @en The animation clip.
         * @zh 动画片段。
         */
        get clip(): AnimationClip | null;
        set clip(value: AnimationClip | null);
        /**
         * @en Whether the animation is looping.
         * @zh 动画是否循环播放。
         */
        get islooping(): boolean;
        /**
         * @en The animation transition content (used by IDE).
         * @zh 动画过渡内容（IDE使用）。
         */
        get transitions(): AnimatorTransition[];
        set transitions(value: AnimatorTransition[]);
        /**
         * @en The priority animation transition content (used by IDE).
         * @zh 优先动画过渡内容（IDE使用）。
         */
        get soloTransitions(): AnimatorTransition[];
        set soloTransitions(value: AnimatorTransition[]);
        /**
         * @en consrtuctor of AnimatorState
         * @zh 动画状态的构造方法
         */
        constructor();
        /**
         * @en Add a script to the animator state.
         * @param type The type of the script to add.
         * @returns The added script instance.
         * @zh 向动画状态添加脚本。
         * @param type 要添加的脚本类型。
         * @returns 添加的脚本实例。
         */
        addScript(type: typeof AnimatorStateScript): AnimatorStateScript;
        /**
         * @en Get a script of the specified type from the animator state.
         * @param type The type of the script to get.
         * @returns The script of the specified type, or null if not found.
         * @zh 从动画状态获取指定类型的脚本。
         * @param type 要获取的脚本类型。
         * @returns 指定类型的脚本，如果未找到则返回null。
         */
        getScript(type: typeof AnimatorStateScript): AnimatorStateScript | null;
        /**
         * @en Get all scripts of the specified type from the animator state.
         * @param type The type of the scripts to get.
         * @returns An array of scripts of the specified type, or null if none found.
         * @zh 从动画状态获取所有指定类型的脚本。
         * @param type 要获取的脚本类型。
         * @returns 指定类型的脚本数组，如果未找到则返回null。
         */
        getScripts(type: typeof AnimatorStateScript): AnimatorStateScript[] | null;
        /**
         * @en Clone the current AnimatorState to another object.
         * @param destObject The target object to clone to.
         * @zh 将当前AnimatorState克隆到另一个对象。
         * @param destObject 克隆的目标对象。
         */
        cloneTo(destObject: AnimatorState): void;
        /**
         * @en Create a clone of the current AnimatorState.
         * @returns A new AnimatorState object with the same properties as the current one.
         * @zh 创建当前AnimatorState的克隆。
         * @returns 一个新的AnimatorState对象，具有与当前对象相同的属性。
         */
        clone(): any;
    }
    /**
     * @en The AnimatorTransition class represents a transition between two AnimatorStates.
     * @zh AnimatorTransition 类表示两个 AnimatorState 之间的过渡。
     */
    class AnimatorTransition {
        /**
         * 创建一个新的Animatortransition
         */
        constructor();
        /**
         * @en The name of the transition.
         * @zh 过渡的名称。
         */
        get name(): string;
        set name(value: string);
        /**
         * @en Whether the transition is disabled.
         * @zh 过渡是否被禁用。
         */
        get mute(): boolean;
        set mute(value: boolean);
        /**
         * @en The destination state of the transition.
         * @zh 过渡的目标状态。
         */
        get destState(): AnimatorState;
        set destState(value: AnimatorState);
        /**
         * @en The conditions array for the transition. Used by IDE.
         * @zh 过渡的条件数组。由IDE使用。
         */
        get conditions(): AnimatorStateCondition[];
        set conditions(value: AnimatorStateCondition[]);
        /**
         * @en Whether the transition is triggered by time.
         * @zh 过渡是否由时间触发。
         */
        get exitByTime(): boolean;
        set exitByTime(value: boolean);
        /**
         * @en The normalized transition duration (relative to the target state).
         * @zh 过渡的归一化持续时间（相对于目标状态）。
         */
        set transduration(value: number);
        get transduration(): number;
        /**
         * @en The playback time offset of the target state (normalized time).
         * @zh 目标状态的播放时间偏移（归一化时间）。
         */
        set transstartoffset(value: number);
        get transstartoffset(): number;
        /**
         * @en The trigger time (normalized time).
         * @zh 触发时间（归一化时间）。
         */
        get exitTime(): number;
        set exitTime(value: number);
        /**
         * @en Adds a condition to the transition.
         * @zh 增加一个条件到过渡中。
         */
        addCondition(condition: AnimatorStateCondition): void;
        /**
         * @en Removes a condition from the transition.
         * @param condition The condition to remove.
         * @zh 从过渡中删除一个条件。
         * @param condition 要删除的条件。
         */
        removeCondition(condition: AnimatorStateCondition): void;
        /**
         * @en Whether to use AND operation when there are multiple conditions.
         * @zh 当有多个条件时是否使用与（AND）操作。
         */
        get isAndOperEnabled(): boolean;
        set isAndOperEnabled(vlaue: boolean);
        /**
         * @en Checks if the transition should be enabled based on the current conditions and time.
         * @param normalizeTime The normalized time of the current animation state.
         * @param paramsMap A map of condition parameters, where the key is the condition ID and the value is the condition state.
         * @returns True if the transition should be enabled, false otherwise.
         * @zh 检查是否应该根据当前条件和时间启用过渡。
         * @param normalizeTime 当前动画状态的归一化时间。
         * @param paramsMap 条件参数的映射，其中键是条件ID，值是条件状态。
         * @returns 如果应该启用过渡则返回true，否则返回false。
         */
        check(normalizeTime: number, paramsMap: {
            [key: number]: number | boolean;
        }): boolean;
    }
    /**
     * @en Describes the animation layer mask.
     * @zh 用来描述动画层遮罩。
     */
    class AvatarMask {
        /**
         * @en Constructor, initialize mask information.
         * @param data Mask information.
         * @zh 构造函数,初使化遮罩信息。
         * @param data 遮罩信息
         */
        constructor(data?: any);
        /**
         * @en Checks if the transform at the given path is active in the mask.
         * @param path The node path.
         * @returns Whether the transform is active.
         * @zh 查找节点路径遮罩。
         * @param path 节点路径
         * @returns 节点路径是否启用
         */
        getTransformActive(path: string): boolean;
        /**
         * @en Sets the mask for a specific transform path.
         * @param path The node path.
         * @param value Whether to enable the mask.
         * @zh 设置遮罩。
         * @param path 节点路径
         * @param value 是否启用遮罩
         */
        setTransformActive(path: string, value: boolean): void;
        /**
         * @en Gets all mask information.
         * @returns The mask information.
         * @zh 获得遮罩信息。
         * @returns 遮罩信息
         */
        getAllTranfromPath(): Record<string, boolean>;
        /**
         * @en Clones the AvatarMask.
         * @returns A clone of the AvatarMask.
         * @zh 克隆。
         * @returns 克隆的AvatarMask。
         */
        clone(): any;
        /**
         * @en Clones the AvatarMask to another object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 目标对象
         */
        cloneTo(destObject: AvatarMask): void;
    }
    enum KeyFrameValueType {
        None = -1,
        Float = 0,
        Position = 1,
        Rotation = 2,
        Scale = 3,
        RotationEuler = 4,
        Vector2 = 5,
        Vector3 = 6,
        Vector4 = 7,
        Color = 8
    }
    /**
     * @en HLOD (Hierarchical Level of Detail) component for optimizing rendering performance.
     * @zh HLOD（分层细节层次）组件，用于优化渲染性能。
     */
    class HLOD extends Component {
        constructor();
        /**
         * @en The bounds of the HLOD.
         * @zh HLOD 的边界。
         */
        get bounds(): Bounds;
        set bounds(value: Bounds);
        /**
         * @en The LOD resources for the HLOD.
         * @zh HLOD 的 LOD 资源。
         */
        get lodResource(): HLODResourceGroup[];
        set lodResource(value: HLODResourceGroup[]);
        /**
         * @en The LOD culling rate array. The array will be sorted in descending order.
         * @zh LOD 裁剪率数组。数组将按降序排列。
         */
        get lodCullRateArray(): number[];
        set lodCullRateArray(value: number[]);
        private _applyLODResource;
        private _releaseGroupRender;
        /**
         * @ignore
         * @en Executed every frame during the update phase.
         * @zh 每帧更新时执行。
         */
        onUpdate(): void;
        /**
         * @en Applies the specified HLOD resource.
         * @param resource The HLOD resource group to apply.
         * @zh 应用指定的 HLOD 资源。
         * @param resource 要应用的 HLOD 资源组。
         */
        applyResource(resource: HLODResourceGroup): void;
    }
    /**
     * @en a batched mesh for hierarchical level of detail (HLOD) in 3D rendering. This class optimizes rendering performance by combining multiple sub-meshes into a single rendering unit, reducing draw calls.
     * @zh 用于层次化细节级别（HLOD）的批处理网格。该类通过合并多个子网格为单一的渲染单元来优化渲染性能，减少绘制调用。
     */
    class HLODBatchMesh extends GeometryElement {
        /**
         * @en construct method of HLODBatchMesh.
         * @zh HLODBatchMesh的构造方法。
         */
        constructor();
        /**
         * @en The batched mesh.
         * @zh 合批后的网格。
         */
        get batchMesh(): Mesh;
        set batchMesh(mesh: Mesh);
        /**
         * @en The batch sub-mesh information.
         * @zh 合批子网格信息。
         */
        get batchSubMeshInfo(): HLODBatchSubMesh[];
        set batchSubMeshInfo(value: HLODBatchSubMesh[]);
        set drawSubMeshs(value: HLODBatchSubMesh[]);
        /**
         * @en Destroy the HLODBatchMesh.
         * @zh 销毁 HLODBatchMesh。
         */
        destroy(): void;
    }
    /**
     * @en Handles the rendering of a hierarchical level of detail (HLOD) element. This class is responsible for managing LODs for objects to achieve better performance by rendering simpler meshes when objects are further from the camera.
     * @zh HLOD渲染处理类，负责管理场景中对象的层级细节层次（HLOD），以提高渲染性能。通过在相机较远时渲染更简单的网格来实现。
     */
    class HLODRender extends BaseRender {
        constructor();
        /**
         * @en The current HLOD rendering state.
         * @zh 当前的 HLOD 渲染状态。
         */
        get curHLODRS(): HLODElement;
        set curHLODRS(value: HLODElement);
        /**
         * @en Set the geometry and material of the RenderElement based on the given HLODElement resource.
         * @param source The HLODElement containing mesh and material information.
         * @param out The RenderElement to be set.
         * @zh 根据给定的 HLOD 资源设置渲染节点的几何体和材质。
         * @param source 包含网格和材料信息的 HLODElement。
         * @param out 要设置的 RenderElement。
         */
        private _createRenderelementByHLODElement;
        /**
         * @en Change the current rendering mesh to a new LOD mesh.
         * @param lodMesh The new LOD mesh for rendering.
         * @zh 将当前渲染网格更改为新的 LOD 网格。
         * @param lodMesh 新的 LOD 网格，用于渲染。
         */
        private _changeMesh;
        /**
         * @en re caculate BoundBox
         * @zh 重新计算包围盒
         */
        _calculateBoundingBox(): void;
        /**
         * @en Update rendering data.
         * @zh 更新渲染数据。
         */
        _renderUpdate(context: IRenderContext3D): void;
        /**
         * @en Determine if the object needs to be rendered based on its visibility within the bounding frustum.
         * @param boundFrustum The bounding frustum used for culling.
         * @param context The rendering context.
         * @returns True if the object needs to be rendered, false otherwise.
         * @zh 根据对象在边界视锥体内的可见性确定是否需要渲染该对象。
         * @param boundFrustum 用于裁剪的边界视锥体。
         * @param context 渲染上下文。
         * @returns 如果对象需要被渲染则返回 true，否则返回 false。
         */
        _needRender(boundFrustum: BoundFrustum, context: RenderContext3D): boolean;
        /**
         * @ignore
         * @en Called when the component is being destroyed.
         * @zh 当组件被销毁时调用。
         */
        onDestroy(): void;
    }
    /**
     * @en Configuration for Hierarchical Level of Detail (HLOD) settings.
     * @zh 分层细节层次(HLOD)的配置设置。
     */
    class HLODConfig {
        releaseCallTime: number;
        releaseTime: number;
    }
    /**
     * @en Represents a sub-mesh within an HLOD batch resource, describing geometric bounds and render parameters.
     * @zh 在 HLOD 批处理资源中表示一个子网格，包括几何边界和渲染参数。
     */
    class HLODBatchSubMesh {
        bounds: Bounds;
        drawPramas: Vector2;
    }
    /**
     * @en An element representing a set of HLOD renderable resources.
     * @zh 表示一组 HLOD 可渲染资源的元素。
     */
    class HLODElement {
        /**
         * @en The batch mesh for this HLOD element.
         * @zh 此 HLOD 元素的批处理网格。
         */
        HLODMesh: HLODBatchMesh;
        /**material */
        private _material;
        /**
         * @en The material for this HLOD element.
         * @zh 此 HLOD 元素的材质。
         */
        get material(): Material;
        set material(value: Material);
        /**lightmap */
        private _lightmap;
        /**
         * @en The lightmap for this HLOD element.
         * @zh 此 HLOD 元素的光照贴图。
         */
        get lightmap(): Lightmap;
        set lightmap(value: Lightmap);
        /**
         * @en Release resources associated with this HLOD element.
         * Lightmap is directly destroyed.
         * @zh 释放与此 HLOD 元素关联的资源。
         * 光照贴图会被直接销毁。
         */
        release(): void;
    }
    /**
     * @en A resource group for managing the lifecycle of HLOD resources, handling their load and release state.
     * @zh 用于管理 HLOD 资源生命周期的资源组，处理其加载和释放状态。
     */
    class HLODResourceGroup {
        /**
         * @en The URL of the HLOD resource.
         * @zh HLOD 资源的 URL。
         */
        url: string;
        /**
         * @en Update marker for the resource group.
         * @zh 资源组的更新标记。
         */
        updateMark: number;
        /**
         * @en Array of HLOD elements in this resource group.
         * @zh 此资源组中的 HLOD 元素数组。
         */
        resources: HLODElement[];
        /**
         * @en Indicates whether the resource group is loaded.
         * @zh 资源组是否已加载。
         */
        loaded: boolean;
        /**
         * @en Load the HLOD resource group.
         * @param callFun The callback function to be called after loading.
         * @param hlod The HLOD instance.
         * @zh 加载 HLOD 资源组。
         * @param callFun 加载完成后要调用的回调函数。
         * @param hlod HLOD 实例。
         */
        load(callFun: Function, hlod: any): void;
        /**
         * @en Releases all the resources of the HLOD group, marking the group as unloaded.
         * @zh 释放 HLOD 组的所有资源，并标记组为未加载。
         */
        release(): void;
    }
    /**
     * @en The `LODInfo` class describes Level of Detail (LOD) data.
     * @zh `LODInfo` 类描述了细节层次（LOD）数据。
     */
    class LODInfo {
        /**
         * @en Constructor method of LODInfo.
         * @zh 细节层次数据的构造方法
         */
        constructor(mincullRate: number);
        /**
         * @en Minimum culling ratio for LOD.
         * @zh LOD的最小剔除率。
         */
        get mincullRate(): number;
        set mincullRate(value: number);
        /**
         * @en The node information for the LODInfo.
         * @zh LODInfo的节点信息。
         */
        get renders(): Sprite3D[];
        set renders(value: Sprite3D[]);
        /**
         * @en Adds a rendering node to the LODInfo.
         * @param node The Sprite3D node to be added as a rendering node.
         * @zh 在LODInfo中增加渲染节点。
         * @param node 要作为渲染节点添加的Sprite3D节点。
         */
        addNode(node: Sprite3D): void;
        /**
         * @en Removes a LOD node from the LODInfo.
         * @param node The Sprite3D node to be removed from the LOD.
         * @zh 从LODInfo中删除某个LOD节点。
         * @param node 要从LOD中删除的Sprite3D节点。
         */
        removeNode(node: Sprite3D): void;
        /**
         * @en Releases all render node cull flags in the LODInfo.
         * @zh 释放LODInfo中的所有渲染节点的剔除标记。
         */
        removeAllRender(): void;
    }
    /**
     * @en The `LODGroup` class is used to build LOD components.
     * @zh SpotLight 类用于构建LOD组件
     */
    class LODGroup extends Component {
        /**
       * @en Indicates whether the LOD bounds radius and bounds need to be recalculated. Recalculation is needed when there is a relative change in the LOD values.
       * @zh 是否需要重新计算 _lodBoundsRadius 和 _bounds。当 LOD 值的位置有相对改动时，需要重新计算。
       */
        private _needcaculateBounds;
        /**
         * @en The bounds calculation for all rendering nodes in the LOD group.
         * @zh lodGroup 所有的渲染节点的包围盒计算
         */
        private _bounds;
        /**
         * @en The size of the LOD group.
         * @zh LOD组大小
         */
        private _size;
        /**
         * @en The center position of the bounding box.
         * @zh 包围盒中心位置
         */
        private _lodPosition;
        /**
         * @en The number of LOD levels.
         * @zh LOD 等级数量
         */
        private _lodCount;
        /**
         * @en The information of LOD levels.
         * @zh LOD 等级信息
         */
        private _lods;
        /**
         * @en The index of the visible node.
         * @zh 显示节点
         */
        private _visialIndex;
        /**
         * @en The ratio of the LOD node.
         * @zh LOD节点比例
         */
        private _nowRate;
        /**
         * @en Constructor method of LODGroup.
         * @zh LOD组的构造方法
         */
        constructor();
        /**
         * @en Shadow culling pass
         * @zh 阴影裁剪pass
         */
        shadowCullPass(): boolean;
        /**
         * @en Currently displayed LOD node index
         * @zh 当前显示的LOD节点下标
         */
        get visialIndex(): number;
        /**
         * @en The array of LODInfo objects
         * @zh LODInfo数组
         */
        get lods(): LODInfo[];
        set lods(data: LODInfo[]);
        /**
         * @en Proportion of lod nodes
         * @zh lod节点比例
         */
        get nowRate(): number;
        /**
         * @en LOD bounds
         * @zh LOD包围盒
         */
        get bounds(): Bounds;
        /**
         * 设置显示隐藏组
         * @param rate
         * @returns
         */
        private _applyVisibleRate;
        /**
         * 设置某一级LOD显示
         * @param index
         */
        private _setLODvisible;
        /**
         * 设置某一级LOD不显示
         * @param index
         */
        private _setLODinvisible;
    }
    /**
     * @en The `PostProcess` class is used to create post-processing components.
     * @zh `PostProcess` 类用于创建后期处理组件。
     */
    class PostProcess {
        /**
         * 重新计算CameraFlag
         */
        private recaculateCameraFlag;
        /**
         * @en Add a post-process effect.
         * @zh 构造方法，添加后期处理效果。
         */
        constructor();
        /**
         * @en The enable property of the post-process.
         * @zh 启用后期处理。
         */
        get enable(): boolean;
        set enable(value: boolean);
        /**
         * @en Set the array of post-process effects.IDE main
         * @zh 设置后期处理效果数组。
         */
        get effects(): PostProcessEffect[];
        set effects(value: PostProcessEffect[]);
        /**
         * @en The camera depth texture mode required for post-processing.
         * @zh 后期处理所需的相机深度纹理模式。
         */
        get cameraDepthTextureMode(): DepthTextureMode;
        /**
         * @en Add a post-processing effect.
         * @param effect The post-processing effect to add.
         * @zh 添加后期处理效果。
         * @param effect 后期处理效果
         */
        addEffect(effect: PostProcessEffect): void;
        /**
         * @en Get a post-processing instance based on its type.
         * @param classReg The registered post-processing class type.
         * @returns The post-processing effect instance, or null if not found.
         * @zh 根据类型获取后期处理实例。
         * @param classReg 注册的后期处理类型
         * @returns 后期处理效果实例，如果没有找到则返回null
         */
        getEffect(classReg: any): any;
        /**
         * @en Remove a post-processing effect.
         * @param effect The post-processing effect to remove.
         * @zh 移除后期处理效果。
         * @param effect 后期处理效果
         */
        removeEffect(effect: PostProcessEffect): void;
        /**
         * @en Clear all post-processing effects.
         * @zh 清理所有后期处理效果。
         */
        clearEffect(): void;
    }
    /**
     * @en Maintain compatibility with 2.0. The new script supports the use of scripts.
     * @zh 保持对2.0的兼容。新脚本支持使用Script即可。
     */
    var Script3D: typeof Script;
    type Script3D = Script;
    /**
     * @en Represents a static batch mesh for efficient rendering of multiple static meshes.
     * @zh 用于高效渲染多个静态网格的静态批处理网格。
     */
    class StaticBatchMesh {
        /**
         * @en Creates a new StaticBatchMesh instance based on the provided merge information.
         * @param info The static mesh merge information.
         * @returns A new StaticBatchMesh instance.
         * @zh 根据提供的合并信息创建一个新的静态合批实例。
         * @param info 静态网格合并信息。
         * @returns 一个新的静态合批实例。
         */
        static create(info: StaticMeshMergeInfo): StaticBatchMesh;
        /**
         * @en The bounding volume of the static batch mesh.
         * @zh 静态批处理网格的边界体积。
         */
        bounds: Bounds;
        /**
         * @en Constructs, initializes a new static batch mesh.
         * @zh 构造方法，初始化静态网格合批。
         */
        constructor();
        /**
         * @en Sets the vertex and index buffers for this static batch mesh.
         * @param vertex The vertex buffer to set.
         * @param index The index buffer to set.
         * @zh 为此静态批处理网格设置顶点和索引缓冲区。
         * @param vertex 要设置的顶点缓冲区。
         * @param index 要设置的索引缓冲区。
         */
        setBuffer(vertex: VertexBuffer3D, index: IndexBuffer3D): void;
        /**
         * @en Destroys this static batch mesh and releases all associated resources.
         * @zh 销毁此静态批处理网格并释放所有相关资源。
         */
        destroy(): void;
    }
    /**
     * @en StaticBatchMeshRender class, extends BaseRender for static batch mesh rendering.
     * @zh StaticBatchMeshRender 类，继承自 BaseRender，用于静态批处理网格渲染。
     */
    class StaticBatchMeshRender extends BaseRender {
        /**
         * @en Creates a new StaticBatchMeshRender instance.
         * @param info The static mesh merge information.
         * @returns A new StaticBatchMeshRender instance.
         * @zh 创建一个新的 StaticBatchMeshRender 实例。
         * @param info 静态网格合并信息。
         * @returns 新的 StaticBatchMeshRender 实例。
         */
        static create(info: StaticMeshMergeInfo): StaticBatchMeshRender;
        private _staticMesh;
        /**
         * @en The static batch mesh.
         * @zh 静态批处理网格。
         */
        get staticMesh(): StaticBatchMesh;
        private _mergeInfo;
        /**
         * @en The static mesh merge information.
         * @zh 静态网格合并信息。
         */
        get mergeInfo(): StaticMeshMergeInfo;
        set mergeInfo(value: StaticMeshMergeInfo);
        _singleton: boolean;
        private constructor();
        _calculateBoundingBox(): void;
        _renderUpdate(context: IRenderContext3D): void;
        /**
         * @en Gets mesh defines based on vertex elements.
         * @param mesh The static batch mesh.
         * @param out Array to store the resulting shader defines.
         * @zh 根据顶点元素获取网格定义。
         * @param mesh 静态批处理网格。
         * @param out 用于存储结果着色器定义的数组。
         */
        _getMeshDefine(mesh: StaticBatchMesh, out: Array<ShaderDefine>): void;
        /**
         * @en Determines if the mesh needs to be rendered based on frustum culling.
         * @param boundFrustum The bounding frustum for culling.
         * @param context The 3D render context.(Not used)
         * @returns True if the mesh needs to be rendered, false otherwise.
         * @zh 根据视锥体剔除确定是否需要渲染网格。
         * @param boundFrustum 用于剔除的边界视锥体。
         * @param context 3D渲染上下文。(未使用)
         * @returns 如果需要渲染网格则返回true，否则返回false。
         */
        _needRender(boundFrustum: BoundFrustum, context: RenderContext3D): boolean;
        /**
         * @ignore
         * @en Called when the component is enabled.
         * Sets the batch render flag for all renders in the merge info.
         * @zh 当组件启用时调用。
         * 为合并信息中的所有渲染器设置批处理渲染标志。
         */
        onEnable(): void;
        /**
         * @ignore
         * @en Called when the component is disabled.
         * Unsets the batch render flag for all renders in the merge info.
         * @zh 当组件禁用时调用。
         * 为合并信息中的所有渲染器取消设置批处理渲染标志。
         */
        onDisable(): void;
        /**
         * @ignore
         * @en Called when the component is being destroyed.
         * Cleans up resources including render elements and static mesh.
         * @zh 当组件被销毁时调用。
         * 清理资源，包括渲染元素和静态网格。
         */
        onDestroy(): void;
        /**
         * @en Clones the current StaticBatchMeshRender to another instance.
         * @param dest The destination StaticBatchMeshRender instance.
         * @zh 将当前 StaticBatchMeshRender 克隆到另一个实例。
         * @param dest 目标 StaticBatchMeshRender 实例。
         */
        _cloneTo(dest: StaticBatchMeshRender): void;
    }
    /**
     * @en represents information for a sub-batch in static batch rendering.
     * @zh 静态批处理渲染中子批次的信息。
     */
    class StaticBatchSubInfo {
        /**
         * @en The starting index of the sub-batch in the index buffer.
         * @zh 子批次在索引缓冲区中的起始索引。
         */
        indexStart: number;
        /**
         * @en The number of indices in the sub-batch.
         * @zh 子批次中的索引数量。
         */
        indexCount: number;
        /**
         * @en The bounding volume of the sub-batch mesh.
         * @zh 子批次网格的边界体积。
         */
        meshBounds: Bounds;
        /**
         * @en Indicates whether this sub-batch needs to be rendered.
         * @zh 指示是否需要渲染此子批次。
         */
        needRender: boolean;
        /**
         * @en Constructor method, initializes data.
         * @zh 构造方法，初始化数据
         */
        constructor();
    }
    /**
     * @en static batch sub-mesh rendering.
     * @zh 用于静态批处理子网格渲染。
     */
    class StaticBatchSubMesh extends GeometryElement {
        /**
         * @en Array of StaticBatchSubInfo objects representing sub-mesh information.
         * @zh StaticBatchSubInfo 对象数组，表示子网格信息。
         */
        subInfos: StaticBatchSubInfo[];
        /**
         * @en The byte count of indices in the sub-mesh.
         * @zh 子网格中索引的字节数。
         */
        indexByteCount: number;
        constructor();
        /**
         * @en Adds a sub-mesh to the StaticBatchSubMesh.
         * @param indexCount The number of indices in the sub-mesh.
         * @param indexStart The starting index of the sub-mesh.
         * @param bounds The bounding volume of the sub-mesh.
         * @zh 向 StaticBatchSubMesh 添加一个子网格。
         * @param indexCount 子网格中的索引数量。
         * @param indexStart 子网格的起始索引。
         * @param bounds 子网格的边界体积。
         */
        addSubMesh(indexCount: number, indexStart: number, bounds: Bounds): void;
        /**
         * @en Gets the type of the StaticBatchSubMesh.
         * @zh 获取 StaticBatchSubMesh 的类型。
         */
        _getType(): number;
        /**
         * @en Updates render parameters based on the current render context.
         * @param state The current render context.
         * @zh 根据当前渲染上下文更新渲染参数。
         * @param state 当前渲染上下文。
         */
        _updateRenderParams(state: RenderContext3D): void;
        /**
         * @en Prepares the sub-mesh for rendering.
         * @param state The current render context.(Not used)
         * @returns True if any sub-info needs rendering, false otherwise.
         * @zh 准备子网格进行渲染。
         * @param state 当前渲染上下文。（未使用）
         * @returns 如果有任何子信息需要渲染则返回 true，否则返回 false。
         */
        _prepareRender(state: RenderContext3D): boolean;
        /**
         * @en Destroys the StaticBatchSubMesh and its resources.
         * @zh 销毁 StaticBatchSubMesh 及其资源。
         */
        destroy(): void;
    }
    /**
     * @en StaticMeshMergeInfo class represents information for merging static meshes.
     * @zh StaticMeshMergeInfo 类表示用于合并静态网格的信息。
     */
    class StaticMeshMergeInfo {
        /**
         * @en Creates a new StaticMeshMergeInfo instance from a MeshRenderer.
         * @param render The MeshRenderer to create the merge info from.
         * @returns A new StaticMeshMergeInfo instance.
         * @zh 从 MeshRenderer 创建新的 StaticMeshMergeInfo 实例。
         * @param render 用于创建合并信息的 MeshRenderer。
         * @returns 新的 StaticMeshMergeInfo 实例。
         */
        static create(render: MeshRenderer): StaticMeshMergeInfo;
        /**
         * @en Indicates whether the object receives shadows.
         * @zh 表示对象是否接收阴影。
         */
        receiveShadow: boolean;
        /**
         * @en The index of the lightmap used by this object.
         * @zh 此对象使用的光照贴图索引。
         */
        lightmapIndex: number;
        /**
         * @en The vertex declaration describing the structure of vertex data.
         * @zh 描述顶点数据结构的顶点声明。
         */
        vertexDec: VertexDeclaration;
        private _renders;
        /**
         * @en The array of MeshRenderer components attached to this object.
         * @zh 附加到此对象的 MeshRenderer 组件数组。
         */
        get renders(): MeshRenderer[];
        /**
         * @en The total number of vertices in this batch.
         * @zh 此批次中的顶点总数。
         */
        vertexCount: number;
        /**
         * @en The total number of indices in this batch.
         * @zh 此批次中的索引总数。
         */
        indexCount: number;
        private constructor();
        /**
         * @en Checks if a MeshRenderer matches the criteria for this batch.
         * @param render The MeshRenderer to check.
         * @returns True if the renderer matches, false otherwise.
         * @zh 检查 MeshRenderer 是否符合此批次的条件。
         * @param render 要检查的 MeshRenderer。
         * @returns 如果渲染器匹配则返回 true，否则返回 false。
         */
        match(render: MeshRenderer): boolean;
        /**
         * @en Adds a MeshRenderer to this batch.
         * @param render The MeshRenderer to add.
         * @zh 将 MeshRenderer 添加到此批次。
         * @param render 要添加的 MeshRenderer。
         */
        addElement(render: MeshRenderer): void;
        /**
         * @en Destroys this batch and releases its resources.
         * @zh 销毁此批次并释放其资源。
         */
        destroy(): void;
    }
    /**
     * @en Class used to describe batched rendering nodes.
     * @zh 类用来描述合批的渲染节点。
     */
    class BatchRender extends BaseRender {
        /**
         * @en constructor, initialize the batch rendering node.
         * @zh 构造方法, 初始化合批渲染节点。
         */
        constructor();
        /**
         * @en Whether to batch based on LOD (Level of Detail).
         * @zh 是否根据 LOD（细节层次）来进行合批。
         */
        get checkLOD(): boolean;
        set checkLOD(value: boolean);
        /**
         * @en Sets the LOD culling rate array for filtering.
         * @zh 设置 LOD 裁剪率数组用于过滤。
         */
        get lodCullRateArray(): number[];
        set lodCullRateArray(value: number[]);
        /**
         * @en Called before rendering. Handles LOD (Level of Detail) calculations and changes.
         * @zh 渲染前调用。处理 LOD（细节级别）计算和变更。
         */
        onPreRender(): void;
        /**
         * @en Adds a list of render nodes to the batch queue.
         * @param renderNode An array of BaseRender objects to be added to the batch.
         * @zh 将渲染节点队列添加到合批队列中。
         * @param renderNode 要添加到合批的 BaseRender 对象数组。
         */
        addList(renderNode: BaseRender[]): void;
        /**
         * @en Performs batching based on the _batchList.
         * This method iterates through the _batchList and batches each render node.
         * @zh 根据 _batchList 执行合批操作。
         * 此方法遍历 _batchList 并对每个渲染节点进行合批。
         */
        reBatch(): void;
    }
    /**
     * @en Class used to describe the volume of a mergeable render node.
     * @zh 用来描述一个可合并渲染节点的体积。
     */
    class StaticBatchVolume extends Volume {
        /**
         * @en Whether LOD (Level of Detail) is considered in batching.
         * @zh 合批是否考虑 LOD（细节层次）。
         */
        get checkLOD(): boolean;
        set checkLOD(value: boolean);
        /**
         * @en Whether static instance batching is enabled.
         * @zh 是否启用静态实例合批渲染。
         */
        get enableStaticInstanceBatchRender(): boolean;
        set enableStaticInstanceBatchRender(value: boolean);
        /**
         * @en Whether static vertex merge batching is enabled.
         * @zh 是否启用静态顶点合并合批。
         */
        get enableMergeBatchRender(): boolean;
        set enableMergeBatchRender(value: boolean);
        /**
         * @en Whether custom batching is enabled.
         * @zh 是否启用自定义合批。
         */
        get enableCustomBatchRender(): boolean;
        set enableCustomBatchRender(value: boolean);
        /**
         * @en The custom batch renderers.
         * @zh 自定义的合批渲染器。
         */
        get customBatchRenders(): BatchRender[];
        set customBatchRenders(value: BatchRender[]);
        /**
         * @en Constructor method，initialize rendering related settings.
         * @zh 构造方法，初始化渲染相关的设置。
         */
        constructor();
        /**
         * Restoring the Batch Render State
         */
        private _restorRenderNode;
        /**
         * add one RenderNode
         * @param renderNode
         * @returns
         */
        private __addRenderNodeToBatch;
        /**
         * remove one RenderNode
         * @param renderNode
         */
        private __removeRenderNodeFromBatch;
        /**
         * @en Rebatches the render nodes, clearing previous states.
         * This method should be called manually when necessary. Performs batching based on the values in the Volume.
         * @zh 重新合批渲染节点，清理先前的状态。
         * 必要时需要手动调用此方法。根据 Volume 中的值执行合批。
         */
        reBatch(): void;
    }
    /**
     * @en used to create static instance batch rendering.
     * @zh 用于创建静态实例批处理渲染。
     */
    class StaticInstanceBatchRender extends BatchRender {
        /**
         * @en constructor, initialize static instance batch rendering.
         * @zh 构造方法, 初始化静态实例批处理渲染。
         */
        constructor();
        /**
         * @en Determines whether this render supports instance batching.
         * @param render The render object to be checked.
         * @returns A boolean value indicating whether instance batching is supported.
         * @zh 判断这个 Render 是否支持 InstanceBatch。
         * @param render 要检查的渲染对象。
         * @returns 一个布尔值，指示是否支持实例批处理。
         */
        private _isRenderNodeAllCanInstanceBatch;
        /**
         * @en Calculates the number of instances to be batched.
         * @param render The render object containing the elements to be batched.
         * @zh 计算实例合并的数量。
         * @param render 包含要合并元素的渲染对象。
         */
        private _sumInstanceBatch;
        /**
         * batch one element
         * @param element
         * @param render
         * @returns
         */
        private _batchOneElement;
        /**
         * remove one element
         * @param element
         * @param render
         * @returns
         */
        private _removeOneElement;
        /**
         * update one element
         * @param element
         * @param render
         * @returns
         */
        private _updateOneElement;
        /**
         * create instanceElement
         * @param element
         * @param render
         * @param batchMark
         * @returns
         */
        private _createInstanceElement;
        /**
         * @en Add a list of renders to the batch queue
         * @param renderNodes  The render queue to be added
         * @zh 将渲染队列添加到批处理队列
         * @param renderNodes  要添加的渲染队列
         */
        addList(renderNodes: BaseRender[]): void;
        /**
         * @en Rebatch based on the _batchList
         * @zh 根据_batchList重新进行批处理
         */
        reBatch(): void;
    }
    /**
     * @en The batch rendering of the static vertex merge.
     * @zh 静态顶点合并的批量渲染。
     */
    class StatiVertexMergeBatchRender extends BatchRender {
        _addList(renderNodes: BaseRender[]): void;
    }
    /**
     * @en The `VolumeManager` class is used to manage volume components.
     * @zh `VolumeManager` 类用于管理体积组件。
     */
    interface IVolumeManager {
    }
    /**
     * @en Reflective probe mode
     * @zh 反射探针模式
     */
    enum ReflectionProbeMode {
        /**
         * @en Baking mode. Currently, only Back baking is supported.
         * @zh 烘培模式。现在仅仅支持Back烘培
         */
        off = 0,
        /**
         * @en Real time simple sampling mode, not supported yet.
         * @zh 实时简单采样模式 还未支持*/
        simple = 1
    }
    /**
     * @en used to implement reflection probe components
     * @zh 用于实现反射探针组件
     */
    class ReflectionProbe extends Volume {
        /**
         * @en Number of reflection probes
         * @zh 反射探针数量
         */
        static reflectionCount: number;
        /**
         * @en Get a globally unique ID
         * @zh 获取一个全局唯一ID
         */
        static getID(): number;
        /**
         * @en Default HDR decode values
         * @zh 默认的 HDR 解码数据
         */
        static defaultTextureHDRDecodeValues: Vector4;
        /**漫反射顔色 */
        private _ambientColor;
        /**漫反射SH */
        private _ambientSH;
        constructor();
        /**
         * @en Whether to enable orthogonal reflection
         * @zh 是否开启正交反射
         */
        get boxProjection(): boolean;
        set boxProjection(value: boolean);
        /**
         * @en The importance of the reflection probe
         * @zh 反射探针的重要度
         */
        get importance(): number;
        set importance(value: number);
        /**
         * @en The intensity of ambient diffuse reflection
         * @zh 环境漫反射的强度
         */
        get ambientIntensity(): number;
        set ambientIntensity(value: number);
        /**
         * @en The intensity of the reflection probe
         * @zh 反射探针的强度
         */
        get reflectionIntensity(): number;
        set reflectionIntensity(value: number);
        _reCaculateBoundBox(): void;
        /**
         * @en The bounding box of the reflection probe
         * @zh 反射探针的包围盒
         */
        get bounds(): Bounds;
        /**
         * @en The maximum point of the bounding box
         * @zh 包围盒的最大点
         */
        get boundsMax(): Vector3;
        set boundsMax(value: Vector3);
        /**
         * @en The minimum point of the bounding box
         * @zh 包围盒的最小点
         */
        get boundsMin(): Vector3;
        set boundsMin(value: Vector3);
        /**
         * @en The position of the probe
         * @zh 探针的位置
         */
        get probePosition(): Vector3;
        /**
         * @en The ambient diffuse color
         * @zh 环境漫反射颜色
         */
        get ambientColor(): Color;
        set ambientColor(value: Color);
        /**
         * @en The spherical harmonics coefficients for ambient color
         * @zh 环境颜色的球谐系数
         */
        get ambientSH(): Float32Array;
        set ambientSH(value: Float32Array);
        /**
         * @en Get or set the ambient light mode
         * If the value is AmbientMode.SolidColor, ambientColor is generally used as the ambient light source
         * If the value is AmbientMode.SphericalHarmonics, ambientSphericalHarmonics is generally used as the ambient light source
         * @zh 获取或设置环境光模式
         * 如果值为AmbientMode.SolidColor，一般使用ambientColor作为环境光源
         * 如果值为AmbientMode.SphericalHarmonics，一般使用ambientSphericalHarmonics作为环境光源
         */
        get ambientMode(): AmbientMode;
        set ambientMode(value: AmbientMode);
        private _iblTex;
        /**
         * @en The Image-Based Lighting (IBL) texture
         * @zh 基于图像的照明(IBL)纹理
         */
        get iblTex(): TextureCube;
        set iblTex(value: TextureCube);
        /**
         * @en Whether the Image-Based Lighting texture is compressed using RGBD format
         * @zh 基于图像的照明纹理是否使用RGBD格式压缩
         */
        get iblTexRGBD(): boolean;
        set iblTexRGBD(value: boolean);
    }
    /**
     * @en The `ReflectionProbeManager` class is used for managing reflection probes.
     * @zh `ReflectionProbeManager` 类用于管理反射探针。
     */
    class ReflectionProbeManager implements IVolumeManager {
        /**
         * @en The constructor of the `ReflectionProbeManager` class.
         * @zh `ReflectionProbeManager` 类构造函数。
         */
        constructor();
        /**
         * @en The scene reflection probe
         * @zh 场景反射探针
         */
        get sceneReflectionProbe(): ReflectionProbe;
        set sceneReflectionProbe(value: ReflectionProbe);
        /**
         * @en Update the reflection probe for the base render.
         * @param baseRender The base render object to update.
         * @zh 更新基础渲染对象的反射探针。
         * @param baseRender 要更新的基础渲染对象。
         */
        _updateRenderObject(baseRender: BaseRender): void;
    }
    /**
     * @en Enum representing the types of intersection between volumes.
     * @zh 表示体积之间相交类型的枚举。
     */
    enum volumeIntersectType {
        /**
         * @en One volume contains the other.
         * @zh 一个体积包含另一个体积。
         */
        contain = 0,
        /**
         * @en Volumes intersect but do not fully contain each other.
         * @zh 体积相交但不完全包含彼此。
         */
        intersect = 1,
        /**
         * @en Volumes are disjoint (do not intersect).
         * @zh 体积不相交（互不相交）。
         */
        Disjoint = 2
    }
    /**
     * @en Represents the intersection properties between volume.
     * @zh 表示物体的相交属性。
     */
    class volumeIntersectInfo {
        /**
         * @en Intersection Type
         * @zh 相交类型
         */
        type: volumeIntersectType;
        /**
         * @en Intersection ratio
         * @zh 相交比例
         */
        intersectRate: number;
    }
    /**
     * @en Represents a volume component in the scene.
     * @zh 表示场景中的体积组件。
     */
    class Volume extends Component {
        /**
         * @en constractor of Volume
         * @zh 体积组件的构造函数。
         */
        constructor();
        /**
         * @en The volume type.
         * @zh 体积类型。
         */
        get type(): number;
        /**
         * @en The maximum point of the volume component's own bounding box.
         * @zh 体积组件自身包围盒的最大点。
         */
        get boundsMax(): Vector3;
        set boundsMax(value: Vector3);
        /**
         * @en The minimum point of the volume component's own bounding box.
         * @zh 体积组件自身包围盒的最小点。
         */
        get boundsMin(): Vector3;
        set boundsMin(value: Vector3);
        /**
         * @en The probe position of the volume.
         * @zh 体积的探针位置。
         */
        get probePosition(): Vector3;
        /**
         * @en The importance value of the volume probe.
         * @zh 体积探针的重要度。
         */
        get importance(): number;
        set importance(value: number);
    }
    /**
     * @en The `VolumeManager` class is used to manage volume components in a scene.
     * @zh `VolumeManager` 类用于管理场景中的体积组件。
     */
    class VolumeManager implements IVolumeManager {
        /**
         * @en Type identifier for Reflection Probe Volume.
         * @zh 反射探针体积的类型标识符。
         */
        static ReflectionProbeVolumeType: number;
        /**
         * @en Type identifier for Volumetric Global Illumination.
         * @zh 体积全局光照的类型标识符。
         */
        static VolumetricGIType: number;
        /**
         * @en Dictionary of specialized volume managers for different volume types.
         * @zh 不同体积类型的专门体积管理器字典。
         */
        _regVolumeManager: {
            [key: number]: IVolumeManager;
        };
        /**
         * @en Volumetric Global Illumination manager.
         * @zh 体积全局光照管理器。
         */
        _volumetricGIManager: VolumetricGIManager;
        constructor();
        /**
         * @en The reflection probe manager.
         * @zh 反射探针管理器。
         */
        get reflectionProbeManager(): ReflectionProbeManager;
        /**
         * @en The volumetric global illumination manager.
         * @zh 体积全局光照管理器。
         */
        get volumetricGIManager(): VolumetricGIManager;
        /**
         * @en Add a volume component to the manager.
         * @zh 向管理器添加一个体积组件。
         */
        add(volume: Volume): void;
        /**
         * @en Remove a volume component from the manager.
         * @zh 从管理器中移除一个体积组件。
         */
        remove(volume: Volume): void;
        /**
         * @en Add a motion object to the handle list.
         * @zh 将运动对象添加到处理列表中。
         */
        addMotionObject(renderObj: BaseRender): void;
        /**
         * @en Remove a motion object from the handle list.
         * @zh 从处理列表中移除运动对象。
         */
        removeMotionObject(renderObj: BaseRender): void;
        /**
         * @en Update one RenderNode Volume info
         * @param baseRender The BaseRender object to update
         * @zh 更新一个RenderNode的Volume信息
         * @param baseRender 要更新的BaseRender对象
         */
        _updateRenderObject(baseRender: BaseRender): void;
        /**
         * @en Recalculate and update all Volume information for render objects
         * @zh 重新计算并更新所有渲染对象的Volume信息
         */
        reCaculateAllRenderObjects(baseRenders: SingletonList<BaseRender>): void;
        /**
         * @en Check if all render objects need to be recalculated
         * @zh 检查是否需要重新计算所有渲染对象
         */
        needreCaculateAllRenderObjects(): boolean;
    }
    /**
     * @en The VolumetricGI class represents volumetric global illumination in the scene.
     * @zh VolumetricGI 类表示场景中的体积全局光照。
     */
    class VolumetricGI extends Volume {
        /**
         * @en The count of volumetric global illumination probes.
         * @zh 体积全局光照探针的数量。
         */
        static volumetricCount: number;
        /**
         * @en Get a globally unique ID.
         * @zh 获取一个全局唯一的ID。
         */
        static getID(): number;
        /**
         * @en construct method, initialize VolumetricGI object.
         * @zh 构造方法，初始化VolumetricGI对象。
         */
        constructor();
        private _irradiance;
        /**
         * @en Light probe irradiance texture.
         * @zh 光照探针辐照度纹理。
         */
        get irradiance(): Texture2D;
        set irradiance(value: Texture2D);
        private _distance;
        /**
         * @en Distance texture for light probe.
         * @zh 光照探针的距离纹理。
         */
        get distance(): Texture2D;
        set distance(value: Texture2D);
        /**
         * @en Normal bias for volumetric global illumination.
         * @zh 体积全局光照的法线偏移。
         */
        get normalBias(): number;
        set normalBias(value: number);
        /**
         * @en View bias for volumetric global illumination.
         * @zh 体积全局光照的视图偏移。
         */
        get viewBias(): number;
        set viewBias(value: number);
        /**
         * @en Number of texels per probe in the irradiance texture.
         * @zh 辐照度纹理中每个探针的纹素数量。
         */
        get irradianceTexel(): number;
        /**
         * @en Number of texels per probe in the distance texture.
         * @zh 距离纹理中每个探针的纹素数量。
         */
        get distanceTexel(): number;
        /**
         * @en The intensity of the reflection probe.
         * @zh 反射探针的强度。
         */
        get intensity(): number;
        set intensity(value: number);
        /**
         * @en The number of probes for volumetric global illumination.
         * @zh 体积全局光照的探针数量。
         */
        get probeCounts(): Vector3;
        set probeCounts(value: Vector3);
        /**
         * @en The step size between probes for volumetric global illumination.
         * @zh 体积全局光照探针之间的间隔。
         */
        get probeStep(): Vector3;
        set probeStep(value: Vector3);
        _reCaculateBoundBox(): void;
    }
    /**
     * @en The `BaseCamera` class is used to create the parent class of cameras.
     * @zh `BaseCamera` 类用于创建摄像机的父类。
     */
    class BaseCamera extends Sprite3D {
        /**渲染模式,延迟光照渲染，暂未开放。*/
        static RENDERINGTYPE_DEFERREDLIGHTING: string;
        /**
         * @en Rendering mode: Forward rendering.
         * @zh 渲染模式：前向渲染。
         */
        static RENDERINGTYPE_FORWARDRENDERING: string;
        /**
         * @en Initialize the Camera
         * @zh 初始化相机
         */
        static __init__(): void;
        /**
         * @en Near clipping plane.
         * @zh 近裁剪面。
         */
        protected _nearPlane: number;
        /**
         * @en Far clipping plane.
         * @zh 远裁剪面。
         */
        protected _farPlane: number;
        /**
         * @en Render engine.
         * @zh 渲染引擎。
         */
        protected _renderEngine: IRenderEngine;
        /**
         * @en Field of view.
         * @zh 视野。
         */
        protected _fieldOfView: number;
        /**
         * @en Vertical size of orthographic projection.
         * @zh 正交投影的垂直尺寸。
         */
        private _orthographicVerticalSize;
        private _skyRenderElement;
        /**
         * @en Forward vector.
         * @zh 前向量。
         */
        _forward: Vector3;
        /**
         * @en Up vector.
         * @zh 上向量。
         */
        _up: Vector3;
        /**
         * @en Whether the camera uses orthographic projection.
         * @zh 是否使用正交投影。
         */
        protected _orthographic: boolean;
        /**
         * @en The clear color of the camera. The default color is CornflowerBlue.
         * @zh 摄像机的清除颜色。默认颜色为CornflowerBlue。
         */
        private _clearColor;
        get clearColor(): Color;
        set clearColor(value: Color);
        /**
         * @en The culling mask value for visible layers, supporting mixed values. For example, cullingMask = Math.pow(2,0) | Math.pow(2,1) means layers 0 and 1 are visible.
         * @zh 可视层位标记遮罩值,支持混合 例:cullingMask=Math.pow(2,0)|Math.pow(2,1)为第0层和第1层可见。
         */
        private _cullingMask;
        /**
         * @en Whether to use occlusion culling during rendering.
         * @zh 渲染时是否使用遮挡剔除。
         */
        useOcclusionCulling: boolean;
        /**
         * @en Sky renderer element.
         * @zh 天空渲染器。
         */
        get skyRenderElement(): SkyRenderElement;
        /**
         * @en Field of view.
         * @zh 视野。
         */
        get fieldOfView(): number;
        set fieldOfView(value: number);
        /**
         * @en Maximum local distance.
         * @zh 最大本地距离。
         */
        get maxlocalYDistance(): number;
        /**
         * @en Near clipping plane.
         * @zh 近裁剪面。
         */
        get nearPlane(): number;
        set nearPlane(value: number);
        /**
         * @en Far clipping plane.
         * @zh 远裁剪面。
         */
        get farPlane(): number;
        set farPlane(vaule: number);
        /**
         * @en Whether to use orthographic projection matrix.
         * @zh 是否使用正交投影矩阵。
         */
        get orthographic(): boolean;
        set orthographic(vaule: boolean);
        /**
         * @en Vertical size of the orthographic projection.
         * @zh 正交投影的垂直尺寸。
         */
        get orthographicVerticalSize(): number;
        set orthographicVerticalSize(vaule: number);
        /**
         * @en Culling mask.
         * @zh 剔除遮罩。
         */
        get cullingMask(): number;
        set cullingMask(value: number);
        /**
         * @en Rendering order.
         * @zh 渲染顺序。
         */
        get renderingOrder(): number;
        set renderingOrder(value: number);
        /**
         * @en Constructor function.
         * @param nearPlane The near clipping plane. Default value is 0.3.
         * @param farPlane The far clipping plane. Default value is 1000.
         * @zh 构造函数。
         * @param nearPlane 近裁剪面。默认值为 0.3。
         * @param farPlane 远裁剪面。默认值为 1000。
         */
        constructor(nearPlane?: number, farPlane?: number);
        private _caculateMaxLocalYRange;
        /**
         * @en Add a visible layer, layer value ranges from 0 to 31.
         * @param layer The layer to add.
         * @zh 增加可视图层，layer值为0到31层。
         * @param layer 要添加的图层。
         */
        addLayer(layer: number): void;
        /**
         * @en Remove a visible layer, layer value ranges from 0 to 31.
         * @param layer The layer to remove.
         * @zh 移除可视图层，layer值为0到31层。
         * @param layer 要移除的图层。
         */
        removeLayer(layer: number): void;
        /**
         * @en Add all layers.
         * @zh 增加所有图层。
         */
        addAllLayers(): void;
        /**
         * @en Remove all layers.
         * @zh 移除所有图层。
         */
        removeAllLayers(): void;
        /**
         * @en Recalculate the projection matrix.
         * @zh 重新计算投影矩阵。
         */
        resetProjectionMatrix(): void;
        /**
         * @inheritDoc
         * @override
         */
        protected _onActive(): void;
        /**
         * @inheritDoc
         * @override
         */
        protected _onInActive(): void;
        /**
         * @inheritDoc
         * @override
         * @en Destroy the camera.
         * @param destroyChild Whether to destroy child nodes.
         * @zh 销毁相机。
         * @param destroyChild 是否销毁子节点。
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * @en Camera clear flags.
     * @zh 相机清除标记。
     */
    enum CameraClearFlags {
        /**
         * @en Solid color.
         * @zh 固定颜色。
         */
        SolidColor = 0,
        /**
         * @en Sky.
         * @zh 天空。
         */
        Sky = 1,
        /**
         * @en Depth only.
         * @zh 仅深度。
         */
        DepthOnly = 2,
        /**
         * @en Do not clear.
         * @zh 不清除。
         */
        Nothing = 3,
        /**
         * @en Clear color only.
         * @zh 只清理颜色。
         */
        ColorOnly = 4
    }
    /**
     * @en Camera event flags.
     * @zh 相机事件标记。
     */
    enum CameraEventFlags {
        /**
         * @en Before rendering opaque objects.
         * @zh 在渲染非透明物体之前。
         */
        BeforeForwardOpaque = 0,
        /**
         * @en Before rendering the skybox.
         * @zh 在渲染天空盒之前。
         */
        BeforeSkyBox = 2,
        /**
         * @en Before rendering transparent objects.
         * @zh 在渲染透明物体之前。
         */
        BeforeTransparent = 4,
        /**
         * @en Before applying image effects.
         * @zh 在后期处理之前。
         */
        BeforeImageEffect = 6,
        /**
         * @en After all rendering is complete.
         * @zh 所有渲染之后。
         */
        AfterEveryThing = 8
    }
    /**
     * @en The Camera class is used to create cameras.
     * @zh Camera 类用于创建摄像机。
     */
    class Camera extends BaseCamera {
        static set _updateMark(value: number);
        /**
         * @en Get the rendering result of a certain position in the scene based on camera and scene information.
         * @param camera The camera
         * @param scene The scene to be rendered
         * @param renderTexture The render texture to draw to
         * @returns The rendered texture
         * @zh 根据相机、场景信息获得场景中某一位置的渲染结果。
         * @param camera 相机
         * @param scene 需要渲染的场景
         * @param renderTexture 要绘制到的渲染纹理
         * @returns 渲染后的纹理
         */
        static drawRenderTextureByScene(camera: Camera, scene: Scene3D, renderTexture: RenderTexture): RenderTexture;
        /**
         * @deprecated 请使用getTexturePixelAsync函数代替
         * get PixelTexture
         * 获得纹理的像素
         * @param texture 纹理
         * @returns
         */
        static getTexturePixel(texture: Texture2D): ArrayBufferView;
        /**
         * @en Get the pixels of a texture asynchronously
         * @param texture The texture
         * @returns A promise that resolves with the pixel data
         * @zh 获得纹理的像素
         * @param texture 纹理
         * @returns 解析为像素数据的 Promise
         */
        static getTexturePixelAsync(texture: Texture2D): Promise<ArrayBufferView>;
        /**
         * @en Draw scene content based on the camera's position in the scene and return it
         * @param camera The camera
         * @param scene The scene
         * @param renderCubeSize The pixel size of the cube texture
         * @param format The color format
         * @param cullingMask The culling mask
         * @returns Output texture pixels in order: back, front, left, right, up, down
         * @zh 根据场景中相机的位置绘制场景内容并返回
         * @param camera 相机
         * @param scene 场景
         * @param renderCubeSize 立方体纹理像素大小
         * @param format 颜色格式
         * @param cullingMask 剔除遮罩
         * @returns 输出纹理像素顺序：后、前、左、右、上、下
         */
        static drawTextureCubePixelByScene(camera: Camera, scene: Scene3D, renderCubeSize: number, format: TextureFormat, cullingMask: number): ArrayBufferView[];
        /**
         * @en Draw the content of a specified scene to a cube map texture.
         * @param camera The camera used for rendering.
         * @param position The position of the camera.
         * @param scene The specified scene to render.
         * @param renderCubeSize The size of the cube map texture.
         * @param format The format of the cube map texture.
         * @param cullingMask The culling mask for the camera. Default is 0.
         * @returns The created cube map texture.
         * @zh 绘制指定场景的内容到立方体贴图。
         * @param camera 用于渲染的相机。
         * @param position 相机的位置。
         * @param scene 要渲染的指定场景。
         * @param renderCubeSize 立方体贴图的大小。
         * @param format 立方体贴图的格式。
         * @param cullingMask 相机的剔除遮罩。默认值为0。
         * @returns 创建的立方体贴图。
         */
        static drawTextureCubeByScene(camera: Camera, position: Vector3, scene: Scene3D, renderCubeSize: number, format: TextureFormat, cullingMask?: number): TextureCube;
        /**
         * @en Depth texture
         * @zh 深度贴图
         */
        private _depthTexture;
        /**
         * @en Depth normals texture
         * @zh 深度法线贴图
         */
        private _depthNormalsTexture;
        /**
         * @en Whether to enable the opaque objects pass
         * @zh 是否开启非透明物体通道
         */
        private _opaquePass;
        /**
         * @en Whether rendering is allowed.
         * @zh 是否允许渲染。
         */
        enableRender: boolean;
        /**
         * @en Clear flag.
         * @zh 清除标记。
         */
        clearFlag: CameraClearFlags;
        _renderDataModule: ICameraNodeData;
        private _Render3DProcess;
        /**
         * @en The near clipping plane of the camera.
         * @param value The distance to the near clipping plane.
         * @zh 相机的近裁剪平面。
         * @param value 近裁剪平面的距离。
         */
        set nearPlane(value: number);
        get nearPlane(): number;
        /**
         * @en The far clipping plane of the camera.
         * @param value The distance to the far clipping plane.
         * @zh 相机的远裁剪平面。
         * @param value 远裁剪平面的距离。
         */
        set farPlane(value: number);
        get farPlane(): number;
        /**
         * @en Set the field of view of the camera.
         * @param value The field of view in degrees.
         * @zh 设置相机的视野。
         * @param value 单位为度。
         */
        set fieldOfView(value: number);
        get fieldOfView(): number;
        /**
         * @en The aspect ratio of the camera.
         * @zh 相机的横纵比。
         */
        get aspectRatio(): number;
        set aspectRatio(value: number);
        /**
         * @en The viewport in screen pixel coordinates.
         * @zh 屏幕像素坐标的视口。
         */
        get viewport(): Viewport;
        set viewport(value: Viewport);
        /**
         * @en The display width of the camera.
         * @zh 相机显示宽度。
         */
        get clientWidth(): number;
        /**
         * @en The display height of the camera.
         * @zh 相机显示高度。
         */
        get clientHeight(): number;
        /**
         * @en Multi-sample anti-aliasing.
         * @zh 多重采样抗锯齿。
         */
        set msaa(value: boolean);
        get msaa(): boolean;
        /**
         * @en Space anti-aliasing.
         * @zh 空间抗锯齿
         */
        set fxaa(value: boolean);
        get fxaa(): boolean;
        /**
         * @en The viewport in clip space.
         * @zh 裁剪空间的视口。
         */
        get normalizedViewport(): Viewport;
        set normalizedViewport(value: Viewport);
        /**
         * @en Get the view matrix.
         * @zh 视图矩阵。
         */
        get viewMatrix(): Matrix4x4;
        /**
         * @en The projection matrix.
         * @zh 投影矩阵。
         */
        get projectionMatrix(): Matrix4x4;
        set projectionMatrix(value: Matrix4x4);
        /**
         * @en The projection view matrix.
         * @zh 视图投影矩阵。
         */
        get projectionViewMatrix(): Matrix4x4;
        /**
         * @en The bound frustum of the camera.
         * @zh 摄像机视锥。
         */
        get boundFrustum(): BoundFrustum;
        /**
         * @en Customize the rendering target for the scene.
         * @zh 自定义渲染场景的渲染目标。
         */
        get renderTarget(): RenderTexture;
        set renderTarget(value: RenderTexture);
        /**
         * @en Post processing.
         * @zh 后期处理。
         */
        get postProcess(): PostProcess;
        set postProcess(value: PostProcess);
        /**
         * @en Whether to enable HDR. Enabling it has a certain impact on performance.
         * @zh 是否开启HDR。开启后对性能有一定影响。
         */
        get enableHDR(): boolean;
        set enableHDR(value: boolean);
        /**
         * @en Whether to use the RenderTexture being rendered for CommandBuffer service. Set to true when used with CommandBuffer.
         * @zh 是否使用正在渲染的 RenderTexture 为 CommandBuffer 服务。通常与 CommandBuffer 一起使用时设置为 true。
         */
        get enableBuiltInRenderTexture(): boolean;
        set enableBuiltInRenderTexture(value: boolean);
        /**
         * @en The depth texture mode for the camera.
         * @zh 相机的深度纹理模式。
         */
        get depthTextureMode(): DepthTextureMode;
        set depthTextureMode(value: DepthTextureMode);
        /**
         * @en Set the Opaque Pass mode for the camera.
         * @zh 相机的不透明通道模式。
         */
        set opaquePass(value: boolean);
        get opaquePass(): boolean;
        opaqueTextureSize: number;
        /**
         * @en The format of the depth texture.
         * @zh 深度纹理的格式。
         */
        get depthTextureFormat(): RenderTargetFormat;
        set depthTextureFormat(value: RenderTargetFormat);
        /**
         * @en Enable or disable the use of built-in depth texture (TODO: If enabled, the depth texture can only be used in post-processing, not in the rendering process).
         * @zh 设置是否使用内置的深度纹理（TODO:如果开启，深度纹理只能在后期处理中使用，不能在渲染流程中使用）。
         */
        set enableBlitDepth(value: boolean);
        get enableBlitDepth(): boolean;
        /**
         * @en Whether the camera can blit (draw) the depth texture.
         * @zh 相机是否可以绘制深度纹理。
         */
        get canblitDepth(): boolean;
        /**
         * @en Creates an instance of the Camera.
         * @param aspectRatio The aspect ratio of the camera view.
         * @param nearPlane The near clipping plane distance.
         * @param farPlane The far clipping plane distance.
         * @zh 创建一个Camera实例。
         * @param	aspectRatio 横纵比。
         * @param	nearPlane 近裁面。
         * @param	farPlane 远裁面。
         */
        constructor(aspectRatio?: number, nearPlane?: number, farPlane?: number);
        /**
         * @en Clone the camera.
         * @zh 克隆相机。
         */
        clone(): Camera;
        set depthTexture(value: BaseTexture);
        set depthNormalTexture(value: RenderTexture);
        /**
         * @override
         * @en Render the scene.
         * @param scene The scene to render.
         * @zh 渲染场景。
         * @param scene 要渲染的场景。
         */
        render(scene: Scene3D): void;
        /**
         * @en Calculate a ray from screen space.
         * @param point The position in screen space.
         * @param out The output ray.
         * @zh 计算从屏幕空间生成的射线。
         * @param point 屏幕空间的位置位置。
         * @param out  输出射线。
         */
        viewportPointToRay(point: Vector2, out: Ray): void;
        /**
         * @en Calculate a ray from normalized viewport space.
         * @param point The position in normalized viewport space.
         * @param out The output ray.
         * @zh 计算从归一化视口空间生成的射线。
         * @param point 裁切空间的位置。
         * @param out  输出射线。
         */
        normalizedViewportPointToRay(point: Vector2, out: Ray): void;
        /**
         * @en Transform a point from world space to viewport space.
         * @param position The coordinate in world space.
         * @param out x, y, z are viewport space coordinates, w is the z-axis coordinate relative to the camera.
         * @zh 将一个点从世界空间转换到视口空间。
         * @param position 世界空间的坐标。
         * @param out  x、y、z为视口空间坐标,w为相对于摄像机的z轴坐标。
         */
        worldToViewportPoint(position: Vector3, out: Vector4): void;
        /**
         * @en Transform a point from world space to normalized viewport space.
         * @param position The coordinate in world space.
         * @param out x, y, z are normalized viewport space coordinates, w is the z-axis coordinate relative to the camera.
         * @zh 将一个点从世界空间转换到归一化视口空间。
         * @param position 世界空间的坐标。
         * @param out  x、y、z为归一化视口空间坐标,w为相对于摄像机的z轴坐标。
         */
        worldToNormalizedViewportPoint(position: Vector3, out: Vector4): void;
        /**
         * @en Convert 2D screen coordinate system to 3D orthographic projection coordinate system. Note: Only valid under orthographic model.
         * @param source The source coordinate.
         * @param out The output coordinate.
         * @returns Whether the conversion was successful.
         * @zh 转换2D屏幕坐标系统到3D正交投影下的坐标系统，注：只有正交模型下有效。
         * @param   source 源坐标。
         * @param   out 输出坐标。
         * @return 是否转换成功。
         */
        convertScreenCoordToOrthographicCoord(source: Vector3, out: Vector3): boolean;
        /**
         * @override
         * @inheritDoc
         * @en Destroy the Camera node.
         * @param destroyChild Whether to destroy child nodes.
         * @zh 删除Camera节点。
         * @param destroyChild 是否删除子节点
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @en Add a command buffer to the camera's rendering pipeline.
         * @param event The camera event flag.
         * @param commandBuffer The rendering command buffer.
         * @zh 增加camera渲染节点渲染缓存。
         * @param event 相机事件标志
         * @param commandBuffer 渲染命令流
         */
        addCommandBuffer(event: CameraEventFlags, commandBuffer: CommandBuffer): void;
        /**
         * @en Remove a command buffer from the camera's rendering pipeline.
         * @param event The camera event flag.
         * @param commandBuffer The rendering command buffer to remove.
         * @zh 移除camera渲染节点渲染缓存。
         * @param event 相机事件标志
         * @param commandBuffer 渲染命令流
         */
        removeCommandBuffer(event: CameraEventFlags, commandBuffer: CommandBuffer): void;
        /**
         * @en Remove all command buffers for a specific camera event.
         * @param event The camera event flag.
         * @zh 移除camera相机节点的所有渲染缓存。
         * @param event 相机事件标志
         */
        removeCommandBuffers(event: CameraEventFlags): void;
    }
    /**
     * @en The `FloatKeyframe` class is used to create floating-point keyframe instances.
     * @zh `FloatKeyframe` 类用于创建浮点关键帧实例。
     */
    class FloatKeyframe extends Keyframe {
        /**
         * @en The in-tangent of the keyframe.
         * @zh 关键帧的内切线。
         */
        inTangent: number;
        /**
         * @en The out-tangent of the keyframe.
         * @zh 关键帧的外切线。
         */
        outTangent: number;
        /**
         * @en The value of the keyframe.
         * @zh 关键帧的值。
         */
        value: number;
        /**
         * @en The in-weight of the keyframe. Default is Keyframe.defaultWeight.
         * @zh 关键帧的内权重。默认值为 Keyframe.defaultWeight。
         */
        inWeight: number;
        /**
         * @en The out-weight of the keyframe. Default is Keyframe.defaultWeight.
         * @zh 关键帧的外权重。默认值为 Keyframe.defaultWeight。
         */
        outWeight: number;
        /**
         * @en The weighted mode of the keyframe. Default is WeightedMode.None.
         * @zh 关键帧的权重模式。默认值为 WeightedMode.None。
         */
        weightedMode: number;
        /**
         * @ignore
         * @en Creates an instance of `FloatKeyframe`.
         * @zh 创建一个 `FloatKeyframe` 的实例。
         */
        constructor();
        /**
        * @en Clones the data to another object.
        * @param destObject The target object to clone to.
        * @zh 克隆数据到目标对象。
        * @param destObject 拷贝数据结构
        */
        cloneTo(destObject: FloatKeyframe): void;
        /**
         * @en Clones.
         * @zh 克隆
         */
        clone(): FloatKeyframe;
    }
    /**
     * @en The `GeometryElement` class is used to implement geometric elements. This class is abstract.
     * @zh `GeometryElement` 类用于实现几何体元素，该类为抽象类。
     */
    class GeometryElement {
        protected _owner: any;
        static _typeCounter: number;
        _geometryElementOBj: IRenderGeometryElement;
        protected _bufferState: BufferState;
        /**
         * @en VAO (Vertex Array Object) instance
         * @zh VAO (顶点数组对象) 实例
         */
        set bufferState(value: BufferState);
        get bufferState(): BufferState;
        /**
         * @en Mesh topology type
         * @zh 网格拓扑类型
         */
        set mode(value: MeshTopology);
        get mode(): MeshTopology;
        /**
         * @en Draw type
         * @zh 绘制类型
         */
        set drawType(value: number);
        get drawType(): number;
        /**
         * @en Set parameters for drawing arrays
         * @param first The starting index in the array
         * @param count The number of indices to be rendered
         * @zh 设置绘制数组的参数。
         * @param first 数组起始索引。
         * @param count 要渲染的索引数量。
         */
        setDrawArrayParams(first: number, count: number): void;
        /**
         * @en Set parameters for drawing elements
         * @param count The number of elements to be rendered
         * @param offset The starting offset in the element array
         * @zh 设置绘制元素的参数。
         * @param count 要渲染的元素数量。
         * @param offset 元素数组的起始偏移。
         */
        setDrawElemenParams(count: number, offset: number): void;
        /**
         * @en Number of instances to draw
         * @zh 要绘制的实例数量
         */
        set instanceCount(value: number);
        get instanceCount(): number;
        /**
         * @en Index buffer format
         * @zh 索引缓冲区格式
         */
        set indexFormat(value: IndexFormat);
        get indexFormat(): IndexFormat;
        /**
         * @en Get whether the object is destroyed
         * @zh 获取是否已销毁
         */
        get destroyed(): boolean;
        /**
         * @ignore
         * @en Creates an instance of GeometryElement.
         * @param mode The topology used by the mesh.
         * @param drawType The draw type used for rendering.
         * @zh 创建一个 GeometryElement 的实例。
         * @param mode 网格使用的拓扑结构。
         * @param drawType 用于渲染的绘制类型。
         */
        constructor(mode: MeshTopology, drawType: DrawType);
        /**
         * @en Get the geometry type
         * @zh 获取几何体类型
         */
        _getType(): number;
        /**
         * @en Destroy the object
         * @zh 销毁对象
         */
        destroy(): void;
        /**
         * @en Clear render parameters
         * @zh 清除渲染参数
         */
        clearRenderParams(): void;
    }
    /**
     * @en The `Gradient` class is used to create color gradients.
     * @zh `Gradient` 类用于创建颜色渐变。
     */
    class Gradient implements IClone {
        private _mode;
        private _maxColorRGBKeysCount;
        get maxColorRGBKeysCount(): number;
        private _colorRGBKeysCount;
        /**
         * @en Get the count of color RGB keys.
         * @returns The count of color RGB keys.
         * @zh 获取颜色 RGB 数量。
         * @returns 颜色 RGB 数量。
         */
        get colorRGBKeysCount(): number;
        private _maxColorAlphaKeysCount;
        get maxColorAlphaKeysCount(): number;
        private _colorAlphaKeysCount;
        /**
         * 获取颜色Alpha数量。
         * @return 颜色Alpha数量。
         */
        get colorAlphaKeysCount(): number;
        get maxColorKeysCount(): number;
        /**
         * @en Get the gradient mode.
         * @returns The gradient mode.
         * @zh 获取梯度模式。
         * @returns 梯度模式。
         */
        get mode(): number;
        /**
         * @en Set the gradient mode.
         * @param value The gradient mode.
         * @zh 设置梯度模式。
         * @param value 梯度模式。
         */
        set mode(value: number);
        /**
         * @ignore
         */
        constructor();
        /**
         * @en Add a color RGB key.
         * @param key The lifetime, ranging from 0 to 1.
         * @param value The RGB value.
         * @zh 增加颜色 RGB 帧。
         * @param key 生命周期，范围为 0 到 1。
         * @param value RGB 值。
         */
        addColorRGB(key: number, value: Color): void;
        /**
         * @en Add a color Alpha key.
         * @param key The lifetime, ranging from 0 to 1.
         * @param value The Alpha value.
         * @zh 增加颜色 Alpha 帧。
         * @param key 生命周期，范围为 0 到 1。
         * @param value Alpha 值。
         */
        addColorAlpha(key: number, value: number): void;
        /**
         * @en Update a color RGB key.
         * @param index The index.
         * @param key The lifetime, ranging from 0 to 1.
         * @param value The RGB value.
         * @zh 更新颜色 RGB 帧。
         * @param index 索引。
         * @param key 生命周期，范围为 0 到 1。
         * @param value RGB 值。
         */
        updateColorRGB(index: number, key: number, value: Color): void;
        /**
         * @en Update a color Alpha key.
         * @param index The index.
         * @param key The lifetime, ranging from 0 to 1.
         * @param value The Alpha value.
         * @zh 更新颜色 Alpha 帧。
         * @param index 索引。
         * @param key 生命周期，范围为 0 到 1。
         * @param value Alpha 值。
         */
        updateColorAlpha(index: number, key: number, value: number): void;
        /**
         * @en Get RGB color through interpolation.
         * @param lerpFactor Interpolation factor, clamped between 0 and 1.
         * @param out The resulting color.
         * @param startSearchIndex The starting search index. Default is 0.
         * @param reverseSearch Whether to perform reverse interpolation. Default is false.
         * @returns The current index after interpolation.
         * @zh 通过插值获取RGB颜色。
         * @param lerpFactor 插值因子，取值范围在0到1之间。
         * @param out 颜色结果。
         * @param startSearchIndex 开始查找索引。默认为0。
         * @param reverseSearch 是否进行反向插值。默认为false。
         * @returns 插值后的当前索引。
         */
        evaluateColorRGB(lerpFactor: number, out: Color, startSearchIndex?: number, reverseSearch?: boolean): number;
        /**
         * @en Get the alpha value through interpolation.
         * @param lerpFactor The interpolation factor.
         * @param outColor The resulting color.
         * @param startSearchIndex The starting search index. Default is 0.
         * @param reverseSearch Whether to perform reverse interpolation. Default is false.
         * @returns The resulting index.
         * @zh 通过插值获取透明值。
         * @param lerpFactor 插值因子。
         * @param outColor 颜色结果。
         * @param startSearchIndex 开始查找索引。默认为0。
         * @param reverseSearch 是否反向插值。默认为false。
         * @returns 结果索引。
         */
        evaluateColorAlpha(lerpFactor: number, outColor: Color, startSearchIndex?: number, reverseSearch?: boolean): number;
        /**
         * 更新 GPU data array
         * @param data GPU data array
         * @param elements 原始数据
         */
        private _updateGpuData;
        private _fixGPUAlphaData;
        private _fixGPURGBData;
        private _gpuRGBData4;
        private _gpuRGBData8;
        private _gpuAlphaData4;
        private _gpuAlphaData8;
        /**
         * @en Clone.
         * @param destObject The destination object to clone to.
         * @zh 克隆。
         * @param destObject 克隆的目标对象。
         */
        cloneTo(destObject: Gradient): void;
        /**
         * @en Clone the gradient.
         * @returns A clone of the gradient.
         * @zh 克隆渐变。
         * @returns 克隆的副本。
         */
        clone(): any;
    }
    /**
     * @en The gradient mode.
     * @zh  渐变模式
     */
    class GradientMode {
        /**
         * @en Finds the two keys adjacent to the requested evaluation time and linearly interpolates between them to obtain a blended color.
         * @zh 找到与请求的评估时间相邻的两个键,并线性插值在他们之间,以获得一种混合的颜色。
         */
        static Blend: number;
        /**
         * @en Returns a fixed color by finding the first key with a time value greater than the requested evaluation time.
         * @zh 返回一个固定的颜色，通过查找第一个键的时间值大于所请求的评估时间。
         */
        static Fixed: number;
    }
    /**
     * @en Animation weight mode
     * @zh 动画权重模式
     */
    enum WeightedMode {
        None = 0,
        In = 1,
        Out = 2,
        Both = 3
    }
    /**
     * @en The `Keyframe` class is used to create keyframe instances.
     * @zh `Keyframe` 类用于创建关键帧实例。
     */
    class Keyframe implements IClone {
        /**
         * @en The default weight value for keyframes.
         * @zh 关键帧的默认权重值。
         */
        static defaultWeight: number;
        /**
         * @en The time of the keyframe.
         * @zh 关键帧的时间。
         */
        time: number;
        /** @ignore */
        constructor();
        /**
         * @en Source of the keyframe.
         * @param destObject The target object to clone to.
         * @zh 克隆到另一个对象。
         * @param destObject 克隆源。
         */
        cloneTo(destObject: Keyframe): void;
        /**
         * @en Creates a clone of the current keyframe.
         * @returns A clone of the current keyframe.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    enum AreaShape {
        rectangle = 0,
        ellipse = 1
    }
    /**
     * @en The AreaLightCom class is used to create area lights.
     * @zh AreaLightCom 类用于创建区域光。
     */
    class AreaLightCom extends Light {
        /**
         * @ignore
         * @en Creates an instance of AreaLightCom.
         * @zh 创建一个 AreaLightCom 的实例。
         */
        constructor();
        protected _creatModuleData(): void;
        /**
         * @en The lightmap baked type.
         * @zh 灯光烘焙类型。
         */
        get lightmapBakedType(): LightMode;
        set lightmapBakedType(value: LightMode);
        /**
         * @en The area light shape.
         * @zh 区域光的形状。
         */
        get shape(): AreaShape;
        set shape(value: AreaShape);
        /**
         * @en The light intensity.
         * @zh 光照强度。
         */
        get power(): number;
        set power(value: number);
        /**
         * @en The size of the area light.
         * @zh 区域光大小。
         */
        get size(): Vector2;
        set size(value: Vector2);
        /**
         * @en The spread angle of the area light.
         * @zh 区域光的辐射角度。
         */
        get spread(): number;
        set spread(value: number);
        /**
         * @en The maximum number of light bounces.
         * @zh 区域光的最大反弹次数。
         */
        get maxBounces(): number;
        set maxBounces(value: number);
    }
    /**
     * @en DirectionLight used to create parallel light.
     * @zh DirectionLight 类用于创建方向光。
     */
    class DirectionLightCom extends Light {
        /**
         * @en The direction of the directional light.
         * @zh 方向光的方向。
         */
        get direction(): Vector3;
        set direction(value: Vector3);
        /**
         * @en The number of shadow cascades.
         * @zh 阴影级联数量。
         */
        get shadowCascadesMode(): ShadowCascadesMode;
        set shadowCascadesMode(value: ShadowCascadesMode);
        /**
         * @en The split ratio for two cascade shadows.
         * @zh 二级级联阴影分割比例。
         */
        get shadowTwoCascadeSplits(): number;
        set shadowTwoCascadeSplits(value: number);
        /**
         * @en The split ratios for four cascade shadows. X, Y, Z represent the split ratios in order. Z must be greater than Y, and Y must be greater than X.
         * @zh 四级级联阴影分割比例。X、Y、Z依次为其分割比例，Z必须大于Y，Y必须大于X。
         */
        get shadowFourCascadeSplits(): Vector3;
        set shadowFourCascadeSplits(value: Vector3);
        /**
         * @ignore
         * @en Creates an instance of DirectionLight.
         * @zh 创建一个 DirectionLight 的实例。
         */
        constructor();
        protected _creatModuleData(): void;
    }
    /**
     * @en Light type.
     * @zh 灯光类型。
     */
    enum LightType {
        Directional = 0,
        Spot = 1,
        Point = 2,
        Area = 3
    }
    /**
     * @en Light mode.
     * @zh 灯光模式。
     */
    enum LightMode {
        mix = 0,
        realTime = 1,
        bakeOnly = 2
    }
    /**
     * @en LightSprite is the base class for creating light sources.
     * @zh LightSprite 类用于创建灯光的父类。
     */
    class Light extends Component {
        /**
         * @en The light color.
         * @zh 灯光颜色。
         */
        color: Color;
        /**
         * @en The light intensity.
         * @zh 灯光强度。
         */
        get intensity(): number;
        set intensity(value: number);
        /**
         * @en Shadow mode.
         * @zh 阴影模式。
         */
        get shadowMode(): ShadowMode;
        set shadowMode(value: ShadowMode);
        /**
         * @en The maximum shadow distance.
         * @zh 最大阴影距离。
         */
        get shadowDistance(): number;
        set shadowDistance(value: number);
        /**
         * @en The shadow map resolution.
         * @zh 阴影贴图分辨率。
         */
        get shadowResolution(): number;
        set shadowResolution(value: number);
        /**
         * @en The shadow depth bias.
         * @zh 阴影深度偏差。
         */
        get shadowDepthBias(): number;
        set shadowDepthBias(value: number);
        /**
         * @en The shadow normal bias.
         * @zh 阴影法线偏差。
         */
        get shadowNormalBias(): number;
        set shadowNormalBias(value: number);
        /**
         * @en The shadow strength.
         * @zh 阴影强度。
         */
        get shadowStrength(): number;
        set shadowStrength(value: number);
        /**
         * @en The near cut surface of the shadow cone.
         * @zh 阴影视锥的近裁面。
         */
        get shadowNearPlane(): number;
        set shadowNearPlane(value: number);
        /**
         * @en Light baking type
         * @zh 灯光烘培类型。
         */
        get lightmapBakedType(): LightMode;
        set lightmapBakedType(value: LightMode);
        /**
         * @en The light world matrix.
         * @zh 灯光世界矩阵
         */
        get lightWorldMatrix(): Matrix4x4;
        /**
         * @en The light type.
         * @zh 灯光类型
         */
        get lightType(): LightType;
        /**
         * @ignore
         * @en Creates an instance of Light.
         * @zh 创建一个 Light 的实例。
         */
        constructor();
        protected _creatModuleData(): void;
    }
    /**
     * @ignore
     * @deprecated
     * <code>LightSprite</code> 类用于创建灯光的父类。
     */
    class LightSprite extends Sprite3D {
        /**
         * 灯光颜色。
         */
        get color(): Color;
        set color(value: Color);
        /**
         * 灯光烘焙模式
         */
        get mode(): LightMode;
        set mode(value: LightMode);
        /**
         * 灯光强度。
         */
        get intensity(): number;
        set intensity(value: number);
        /**
         * 阴影模式。
         */
        get shadowMode(): ShadowMode;
        set shadowMode(value: ShadowMode);
        /**
         * 最大阴影距离。
         */
        get shadowDistance(): number;
        set shadowDistance(value: number);
        /**
         * 阴影贴图分辨率。
         */
        get shadowResolution(): number;
        set shadowResolution(value: number);
        /**
         * 阴影深度偏差。
         */
        get shadowDepthBias(): number;
        set shadowDepthBias(value: number);
        /**
         * 阴影法线偏差。
         */
        get shadowNormalBias(): number;
        set shadowNormalBias(value: number);
        /**
         * 阴影强度。
         */
        get shadowStrength(): number;
        set shadowStrength(value: number);
        /**
         * 阴影视锥的近裁面。
         */
        get shadowNearPlane(): number;
        set shadowNearPlane(value: number);
        /**
         * 灯光烘培类型。
         */
        get lightmapBakedType(): number;
        set lightmapBakedType(value: number);
        /**
         * 获取灯光世界矩阵
         */
        get lightWorldMatrix(): Matrix4x4;
        /**
         * 创建一个 <code>LightSprite</code> 实例。
         */
        constructor();
    }
    /**
     * @en The `PointLightCom` class represents a point light source in the scene.
     * @zh `PointLightCom` 类表示场景中的点光源。
     */
    class PointLightCom extends Light {
        /**
         * @en Declares the data module for point light.
         * @zh 声明点光源的数据模块。
         */
        _dataModule: IPointLightData;
        /**
         * @en The range of the point light.
         * @zh 点光的范围。
         */
        get range(): number;
        set range(value: number);
        /**
         * @ignore
         * @en Creates an instance of PointLightCom.
         * @zh 创建一个 PointLightCom 的实例。
         */
        constructor();
        protected _creatModuleData(): void;
    }
    /**
     * @en Shadow cascade mode.
     * @zh 阴影的级联模式。
     */
    enum ShadowCascadesMode {
        /**
         * @en No cascades.
         * @zh 无级联。
         */
        NoCascades = 0,
        /**
         * @en Two-level cascades.
         * @zh 二级级联。
         */
        TwoCascades = 1,
        /**
         * @en Four-level cascades.
         * @zh 四级级联。
         */
        FourCascades = 2
    }
    /**
     * @en The shadow mode.
     * @zh 阴影模式。
     */
    enum ShadowMode {
        /**
         * @en No shadows are produced.
         * @zh 不产生阴影。
         */
        None = 0,
        /**
         * @en Hard shadows with lower performance requirements.
         * @zh 硬阴影，对性能要求较低。
         */
        Hard = 1,
        /**
         * @en Soft shadows with low intensity, moderate performance requirements.
         * @zh 低强度软阴影，对性能要求一般。
         */
        SoftLow = 2,
        /**
         * @en Soft shadows with high intensity, higher performance requirements.
         * @zh 高强度软阴影，对性能要求较高。
         */
        SoftHigh = 3
    }
    /**
     * @en Enum representing the format of the shadow map.
     * @zh 表示阴影贴图格式的枚举。
     */
    enum ShadowMapFormat {
        bit16 = 0,
        bit24_8 = 1,
        bit32 = 2
    }
    /**
     * @en The `SpotLightCom` class is used to create a spotlight.
     * @zh `SpotLightCom` 类用于创建聚光。
     */
    class SpotLightCom extends Light {
        /**
         * @en Declares the data module for the spotlight.
         * @zh 声明聚光灯的数据模块。
         */
        _dataModule: ISpotLightData;
        /**
         * @en The direction of the spotlight.
         * @zh 聚光的方向。
         */
        get direction(): Vector3;
        set direction(value: Vector3);
        /**
         * @en The cone angle of the spotlight.
         * @zh 聚光灯的锥形角度。
         */
        get spotAngle(): number;
        set spotAngle(value: number);
        /**
         * @en The range of the spotlight.
         * @zh 聚光灯的范围。
         */
        get range(): number;
        set range(value: number);
        /**
         * @ignore
         * @en Creats an instance of SpotLightCom.
         * @zh 创建一个 SpotLightCom 的实例。
         */
        constructor();
        protected _creatModuleData(): void;
    }
    /**
     * @en The BlinnPhongMaterial class is used to implement Blinn-Phong materials.
     * @zh BlinnPhongMaterial 类用于实现Blinn-Phong材质。
     */
    class BlinnPhongMaterial extends Material {
        /**
         * @en Specular intensity data source: Alpha channel of the diffuse map.
         * @zh 高光强度数据源：漫反射贴图的 Alpha 通道。
         */
        static SPECULARSOURCE_DIFFUSEMAPALPHA: number;
        /**
         * @en Specular intensity data source: RGB channels of the specular map.
         * @zh 高光强度数据源：高光贴图的 RGB 通道。
         */
        static SPECULARSOURCE_SPECULARMAP: number;
        /**
         * @en Render mode: Opaque.
         * @zh 渲染状态：不透明。
         */
        static RENDERMODE_OPAQUE: number;
        /**
         * @en Render mode: Alpha test.
         * @zh 渲染状态：Alpha 测试。
         */
        static RENDERMODE_CUTOUT: number;
        /**
         * @en Render mode: Transparent blend.
         * @zh 渲染状态：透明混合。
         */
        static RENDERMODE_TRANSPARENT: number;
        /**
         * @en The default material, prohibit modification.
         * @zh 默认材质，禁止修改。
         */
        static defaultMaterial: BlinnPhongMaterial;
        /**
         * @en The render mode.
         * @zh 渲染模式。
         */
        set renderMode(value: number);
        /**
         * @en Whether to support vertex color.
         * @zh 是否支持顶点色。
         */
        get enableVertexColor(): boolean;
        set enableVertexColor(value: boolean);
        /**
         * @en Texture tiling and offsetting.
         * @zh 纹理平铺和偏移。
         */
        get tilingOffset(): Vector4;
        set tilingOffset(value: Vector4);
        /**
         * @en Albedo color.
         * @zh 漫反射颜色。
         */
        get albedoColor(): Color;
        set albedoColor(value: Color);
        /**
         * @en Albedo intensity
         * @zh 漫反射强度。
         */
        get albedoIntensity(): number;
        set albedoIntensity(value: number);
        /**
         * @en Specular color.
         * @zh 高光颜色。
         */
        get specularColor(): Color;
        set specularColor(value: Color);
        /**
         * @en Specular intensity, ranging from 0 to 1.
         * @zh 高光强度,范围为0到1。
         */
        get shininess(): number;
        set shininess(value: number);
        /**
         * @en Albedo texture.
         * @zh 漫反射贴图。
         */
        get albedoTexture(): BaseTexture;
        set albedoTexture(value: BaseTexture);
        /**
         * @en Normal texture.
         * @zh 法线贴图。
         */
        get normalTexture(): BaseTexture;
        set normalTexture(value: BaseTexture);
        /**
         * @en Specular texture.
         * @zh 高光贴图。
         */
        get specularTexture(): BaseTexture;
        set specularTexture(value: BaseTexture);
        /**
         * @en Does it support transparency.
         * @zh 是否支持透光。
         */
        get enableTransmission(): boolean;
        set enableTransmission(value: boolean);
        /**
         * @en Transmittance, which affects diffuse reflection and transmittance intensity
         * @zh 透光率，会影响漫反射以及透光强度
         */
        get transmissionRata(): number;
        set transmissionRata(value: number);
        /**
         * @en Transmission influence range index
         * @zh 透射影响范围指数
         */
        get backDiffuse(): number;
        set backDiffuse(value: number);
        /**
         * @en Transmitted light intensity
         * @zh 透射光强度
         */
        get backScale(): number;
        set backScale(value: number);
        /**
         * @en Thickness texture, which affects the perspective light. The thicker the material, the weaker the transmitted light.
         * @zh 厚度贴图，会影响透射光。材质越厚，透射光越弱。
         */
        get thinknessTexture(): BaseTexture;
        set thinknessTexture(value: BaseTexture);
        /**
         * @en Transmission color. Simulates the internal color absorption rate of translucent materials.
         * @zh 透光颜色。模拟透光物质内部颜色吸收率。
         */
        get transmissionColor(): Color;
        set transmissionColor(value: Color);
        /**
         * 请使用transmissionRata
         * @deprecated
         */
        get transmissionRate(): number;
        /**
         * @ignore
         * @en Creates an instance of BlinnPhongMaterial.
         * @zh 创建一个 BlinnPhongMaterial 的实例。
         */
        constructor();
        /**
         * @override
         * @en Clone.
         * @returns Clone Copy.
         * @zh 克隆。
         * @returns 克隆的副本。
         */
        clone(): any;
        /**
         * @override
         * @inheritDoc
         * @en Clone the properties of this material to another material.
         * @param destObject The target material to clone to.
         * @zh 将此材质的属性克隆到另一个材质。
         * @param destObject 要克隆到的目标材质。
         */
        cloneTo(destObject: BlinnPhongMaterial): void;
    }
    /**
     * @en The AffectMaterial class is used to implement Mesh effect materials.
     * @zh EffectMaterial 类用于实现Mesh特效材质。
     */
    class EffectMaterial extends Material {
        /**
         * @en Default material, no modification allowed
         * @zh 默认材质，禁止修改
         */
        static defaultMaterial: EffectMaterial;
        /**
         * @en The color of the material.
         * @zh 材质的颜色。
         */
        get color(): Color;
        set color(value: Color);
        /**
         * @en The texture of the material.
         * @zh 材质的贴图。
         */
        get texture(): BaseTexture;
        set texture(value: BaseTexture);
        /**
         * @en The tiling and offset values for the material's textures.
         * @zh 材质纹理的平铺和偏移值。
         */
        get tilingOffset(): Vector4;
        set tilingOffset(value: Vector4);
        /**
         * @ignore
         * @en Creates an instance of EffectMaterial.
         * @zh 创建EffectMaterial实例。
         */
        constructor();
        /**
         * @override
         * @en Clone the material.
         * @returns A clone of the material.
         * @zh 克隆材质。
         * @returns 克隆的材质副本。
         */
        clone(): any;
        /**
         * @deprecated
         * 渲染状态_加色法混合。
         */
        static RENDERMODE_ADDTIVE: number;
        /**
         * @deprecated
         * 渲染状态_透明混合。*/
        static RENDERMODE_ALPHABLENDED: number;
        /**
         * @deprecated
         * 设置渲染模式。
         * 可以使用新的渲染状态
         */
        set renderMode(value: number);
    }
    /**
     * @en Enum representing the different render modes used in PBR (Physically Based Rendering) materials.
     * @zh 表示 PBR（基于物理的渲染）材质中使用的不同渲染模式的枚举。
     */
    enum PBRRenderMode {
        /**
         * @en Opaque render mode.
         * @zh 不透明渲染模式。
         */
        Opaque = 0,
        /**
         * @en Cutout render mode.
         * @zh 裁剪透明渲染模式。
         */
        Cutout = 1,
        /**
         * @en Transparent Mixing: Transparent commonly used in games
         * @zh 透明混合_游戏中经常使用的透明。
         */
        Fade = 2,
        /**
         * @en Transparent Mixing: Physically Seemingly Reasonable Transparency
         * @zh 透明混合_物理上看似合理的透明。
         */
        Transparent = 3
    }
    /**
     * @en The parent class of PBR material, which is an abstract class.
     * @zh PBR材质的父类,该类为抽象类。
     */
    class PBRMaterial extends Material {
        /**
         * @en render quality
         * @zh 渲染质量。
         * */
        static renderQuality: PBRRenderQuality;
        /**
         * @private
         */
        static __init__(): void;
        /**
         * @en Albedo color
         * @zh 漫反射颜色。
         */
        get albedoColor(): Color;
        set albedoColor(value: Color);
        /**
         * @en Albedo texture
         * @zh 漫反射贴图。
         */
        get albedoTexture(): BaseTexture;
        set albedoTexture(value: BaseTexture);
        /**
         * @en Normal texture
         * @zh 法线贴图。
         */
        get normalTexture(): BaseTexture;
        set normalTexture(value: BaseTexture);
        /**
         * @en Normal texture scaling factor.
         * @zh 法线贴图缩放系数。
         */
        get normalTextureScale(): number;
        set normalTextureScale(value: number);
        /**
         * @en Parallax texture
         * @zh 视差贴图。
         */
        get parallaxTexture(): BaseTexture;
        set parallaxTexture(value: BaseTexture);
        /**
         * @en Parallax texture scaling factor.
         * @zh 视差贴图缩放系数。
         */
        get parallaxTextureScale(): number;
        set parallaxTextureScale(value: number);
        /**
         * @en Occlusion texture
         * @zh 遮挡贴图。
         */
        get occlusionTexture(): BaseTexture;
        set occlusionTexture(value: BaseTexture);
        /**
         * @en Occlusion texture strength, the range is from 0 to 1.
         * @zh 遮挡贴图强度，范围为0到1。
         */
        get occlusionTextureStrength(): number;
        set occlusionTextureStrength(value: number);
        /**
         * @en The smoothness of the material, the range is from 0 to 1.
         * @zh 材质的光滑度，范围为0到1。
         */
        get smoothness(): number;
        set smoothness(value: number);
        /**
         * @en Whether to support vertex color.
         * @zh 是否支持顶点色。
         */
        get enableVertexColor(): boolean;
        set enableVertexColor(value: boolean);
        /**
         * @en Whether to enable emission.
         * @zh 是否开启自发光。
         */
        get enableEmission(): boolean;
        set enableEmission(value: boolean);
        /**
         * @en Emission color.
         * @zh 自发光颜色。
         */
        get emissionColor(): Color;
        set emissionColor(value: Color);
        /**
         * @en Emission intensity
         * @zh 自发光强度
         */
        get emissionIntensity(): number;
        set emissionIntensity(value: number);
        /**
         * @en Emission texture.
         * @zh 自发光贴图。
         */
        get emissionTexture(): BaseTexture;
        set emissionTexture(value: BaseTexture);
        /**
         * @en Texture tiling and offsetting.
         * @zh 纹理平铺和偏移。
         */
        get tilingOffset(): Vector4;
        set tilingOffset(value: Vector4);
        /**
         * @en Detail texture.
         * @zh 细节贴图。
         */
        get detailAlbedoTexture(): BaseTexture;
        set detailAlbedoTexture(value: BaseTexture);
        /**
         * @en Detail normal texture.
         * @zh 细节法线贴图。
         */
        get detailNormalTexture(): BaseTexture;
        set detailNormalTexture(value: BaseTexture);
        /**
         * @en The tiling and offset values for the detail textures.
         * @zh 细节图纹理平铺和偏移。
         */
        get detailTilingOffset(): Vector4;
        set detailTilingOffset(value: Vector4);
        /**
         * @en The scale factor for the detail normal textures.
         * @zh 细节法线贴图缩放系数。
         */
        get detailNormalScale(): number;
        set detailNormalScale(value: number);
        /**
         * @en Render mode.
         * @zh 渲染模式。
         */
        set renderMode(value: number);
        /**
         * @en Whether to enable anisotropy
         * @zh 是否开启各向异性
         */
        get anisotropyEnable(): boolean;
        set anisotropyEnable(value: boolean);
        /**
         * @en The strength of the anisotropy effect.
         * @zh 各向异性强度
         */
        get anisotropy(): number;
        set anisotropy(value: number);
        /**
         * @en Anisotropy strength texture.
         * @zh 各向异性强度贴图。
         */
        get anisotropyTexture(): Texture2D;
        set anisotropyTexture(value: Texture2D);
        /**
         * @en Anisotropy rotation in tangent space.
         * @zh 各向异性在切线空间中的旋转。
         */
        get anisotropyRotation(): number;
        set anisotropyRotation(value: number);
        /**
         * @en Whether to enable clear coat
         * @zh 是否开启透明涂层
         */
        get clearCoatEnable(): boolean;
        set clearCoatEnable(value: boolean);
        /**
         * @en The strength of the clear coat effect.
         * @zh 透明涂层强度
         */
        get clearCoat(): number;
        set clearCoat(value: number);
        /**
         * @en Clear coat strength texture.
         * @zh 透明涂层强度贴图
         */
        get clearCoatTexture(): BaseTexture;
        set clearCoatTexture(value: BaseTexture);
        /**
         * @en Clear coat roughness.
         * @zh 透明涂层粗糙度。
         */
        get clearCoatRoughness(): number;
        set clearCoatRoughness(value: number);
        /**
         * @en Clear coat roughness texture.
         * @zh 透明涂层粗糙度贴图。
         */
        get clearCoatRoughnessTexture(): BaseTexture;
        set clearCoatRoughnessTexture(value: BaseTexture);
        /**
         * @en Clear coat normal texture.
         * @zh 透明涂层法线贴图。
         */
        get clearCoatNormalTexture(): BaseTexture;
        set clearCoatNormalTexture(value: BaseTexture);
        constructor();
        /**
         * @deprecated
         * 光滑度缩放系数,范围为0到1。
         */
        get smoothnessTextureScale(): number;
        set smoothnessTextureScale(value: number);
    }
    /**
     * @en PBR material rendering quality.
     * @zh PBR材质渲染质量。
     */
    enum PBRRenderQuality {
        /**
         * @en High quality.
         * @zh 高质量。
         */
        High = 0,
        /**
         * @en Low quality.
         * @zh 低质量
         */
        Low = 1
    }
    /**
     * @en Metallic PBR material smoothness data source.
     * @zh 金属度PBR材质光滑度数据源。
     */
    enum PBRMetallicSmoothnessSource {
        /**
         * @en Alpha channel for metallicity mapping.
         * @zh 金属度贴图的Alpha通道。
         */
        MetallicGlossTextureAlpha = 0,
        /**
         * @en Alpha channel of albedo texture.
         * @zh 漫反射贴图的Alpha通道。
         */
        AlbedoTextureAlpha = 1
    }
    /**
     * @en The PBRStandardMaterial class is used to implement PBR materials.
     * @zh PBRStandardMaterial 类用于实现PBR材质。
     */
    class PBRStandardMaterial extends PBRMaterial {
        /**
         * @en Default material, no modification allowed
         * @zh 默认材质，禁止修改
         */
        static defaultMaterial: PBRStandardMaterial;
        /**
         * @en Metallic gloss texture.
         * @zh 金属光滑度贴图。
         */
        get metallicGlossTexture(): BaseTexture;
        set metallicGlossTexture(value: BaseTexture);
        /**
         * @en The metallic value, ranging from 0 to 1.
         * @zh 金属度，范围为0到1。
         */
        get metallic(): number;
        set metallic(value: number);
        /**
         * @en The smoothness data source, 0 or 1.
         * @zh 光滑度数据源，0或1。
         */
        get smoothnessSource(): PBRMetallicSmoothnessSource;
        set smoothnessSource(value: PBRMetallicSmoothnessSource);
        /**
         * @ignore
         * @en Creates an instance of PBRStandardMaterial.
         * @zh 创建一个 PBRStandardMaterial 的实例。
         */
        constructor();
        /**
         * @override
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en The SkyBoxMaterial class is used to implement the SkyBoxMaterial material.
     * @zh SkyBoxMaterial 类用于实现天空盒材质。
     */
    class SkyBoxMaterial extends Material {
        static TINTCOLOR: number;
        static EXPOSURE: number;
        static ROTATION: number;
        static TEXTURECUBE: number;
        /**
         * @en Default material, no modification allowed
         * @zh 默认材质，禁止修改
         */
        static defaultMaterial: SkyBoxMaterial;
        /**
         * @en Tint color of the skybox.
         * @zh 天空盒的颜色。
         */
        get tintColor(): Color;
        set tintColor(value: Color);
        /**
         * @en Exposure intensity of the skybox.
         * @zh 天空盒的曝光强度。
         */
        get exposure(): number;
        set exposure(value: number);
        /**
         * @en Rotation angle of the skybox.
         * @zh 天空盒的旋转角度。
         */
        get rotation(): number;
        set rotation(value: number);
        /**
         * @en Texture of the skybox.
         * @zh 天空盒的纹理。
         */
        get textureCube(): TextureCube;
        set textureCube(value: TextureCube);
        /**
         * @override
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
        /**
         * @ignore
         * @en Creates an instance of SkyBoxMaterial.
         * @zh 创建一个 SkyBoxMaterial 实例。
         */
        constructor();
    }
    /**
     * @en The SkyPanoramicMaterial class is used to implement SkyPanoramicMaterial material.
     * @zh SkyPanoramicMaterial 类用于实现全景天空材质。
     */
    class SkyPanoramicMaterial extends Material {
        static TINTCOLOR: number;
        static EXPOSURE: number;
        static ROTATION: number;
        static TEXTURE: number;
        static TEXTURE_HDR_PARAMS: number;
        /**
         * @en Tint color of the panoramic sky.
         * @zh 全景天空的颜色。
         */
        get tintColor(): Color;
        set tintColor(value: Color);
        /**
         * @en Exposure intensity of the panoramic sky.
         * @zh 全景天空的曝光强度。
         */
        get exposure(): number;
        set exposure(value: number);
        /**
         * @en Rotation angle of the panoramic sky.
         * @zh 全景天空的旋转角度。
         */
        get rotation(): number;
        set rotation(value: number);
        /**
         * @en Panoramic sky texture.
         * @zh 全景天空纹理。
         */
        get panoramicTexture(): Texture2D;
        set panoramicTexture(value: Texture2D);
        /**
         * @ignore
         * @en Creates an instance of SkyPanoramicMaterial.
         * @zh 创建一个 SkyPanoramicMaterial 的实例。
         */
        constructor();
    }
    /**
     * @en The SkyProceduralMaterial class is used to implement the SkyProceduralMaterial material.
     * @zh SkyProceduralMaterial 类用于实现程序化天空材质。
     */
    class SkyProceduralMaterial extends Material {
        /**
         * @en Sun: None
         * @zh 太阳：无
         */
        static SUN_NODE: number;
        /**
         * @en Sun: Simple
         * @zh 太阳：简单
         */
        static SUN_SIMPLE: number;
        /**
         * @en Sun: High quality
         * @zh 太阳：高质量
         */
        static SUN_HIGH_QUALITY: number;
        /** 默认材质，禁止修改*/
        static defaultMaterial: SkyProceduralMaterial;
        /**
         * @en Sun state.
         * @zh 太阳状态。
         */
        get sunDisk(): number;
        set sunDisk(value: number);
        /**
         * @en Sun size, range is 0 to 1.
         * @zh 太阳尺寸，范围是0到1。
         */
        get sunSize(): number;
        set sunSize(value: number);
        /**
         * @en Sun size convergence, range is 0 to 20.
         * @zh 太阳尺寸收缩，范围是0到20。
         */
        get sunSizeConvergence(): number;
        set sunSizeConvergence(value: number);
        /**
         * @en Atmosphere thickness, range is 0 to 5.
         * @zh 大气厚度，范围是0到5。
         */
        get atmosphereThickness(): number;
        set atmosphereThickness(value: number);
        /**
         * @en Sky color.
         * @zh 天空颜色。
         */
        get skyTint(): Color;
        set skyTint(value: Color);
        /**
         * @en Ground color.
         * @zh 地面颜色。
         */
        get groundTint(): Color;
        set groundTint(value: Color);
        /**
         * @en Exposure intensity, range is 0 to 8.
         * @zh 曝光强度，范围是0到8。
         */
        get exposure(): number;
        set exposure(value: number);
        /**
         * @ignore
         * @en Creates an instance of SkyProceduralMaterial.
         * @zh 创建一个 SkyProceduralMaterial 的实例。
         */
        constructor();
        /**
         * @override
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en The UnlitMaterial class is used to implement materials that are not affected by lighting.
     * @zh UnlitMaterial 类用于实现不受光照影响的材质。
     */
    class UnlitMaterial extends Material {
        static SHADERDEFINE_ALBEDOTEXTURE: ShaderDefine;
        static SHADERDEFINE_ENABLEVERTEXCOLOR: ShaderDefine;
        static ALBEDOTEXTURE: number;
        static ALBEDOCOLOR: number;
        static TILINGOFFSET: number;
        static defaultMaterial: UnlitMaterial;
        private _albedoIntensity;
        /**
         * @en Albedo color
         * @zh 漫反射颜色。
         */
        get albedoColor(): Color;
        set albedoColor(value: Color);
        /**
         * @en Albedo intensity
         * @zh 漫反射强度。
         */
        get albedoIntensity(): number;
        set albedoIntensity(value: number);
        /**
         * @en Albedo texture
         * @zh 漫反射贴图。
         */
        get albedoTexture(): BaseTexture;
        set albedoTexture(value: BaseTexture);
        /**
         * @en Texture tiling and offsetting.
         * @zh 纹理平铺和偏移。
         */
        get tilingOffset(): Vector4;
        set tilingOffset(value: Vector4);
        /**
         * @en Whether to support vertex color.
         * @zh 是否支持顶点色。
         */
        get enableVertexColor(): boolean;
        set enableVertexColor(value: boolean);
        /**
         * @ignore
         * @en Creates an instance of UnlitMaterial.
         * @zh 创建一个 UnlitMaterial 的实例。
         */
        constructor();
        /**
         * @override
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
        /**
         * @deprecated
         * 渲染状态_不透明。
         */
        static RENDERMODE_OPAQUE: number;
        /**
         * @deprecated
         * 渲染状态_阿尔法测试。
        */
        static RENDERMODE_CUTOUT: number;
        /**
         * @deprecated
         * 渲染状态__透明混合。
         */
        static RENDERMODE_TRANSPARENT: number;
        /**
         * @deprecated
         * 渲染状态__加色法混合。
         */
        static RENDERMODE_ADDTIVE: number;
        /**
         * @deprecated
         * 渲染模式。
         */
        set renderMode(value: number);
    }
    /**
     * @en The `MeshFilter` class is used to create mesh filters.
     * @zh `MeshFilter` 类用于创建网格过滤器。
     */
    class MeshFilter extends Component {
        constructor();
        /**
         * @en The shared mesh of the MeshFilter.
         * @zh 共享网格。
         */
        get sharedMesh(): Mesh;
        set sharedMesh(value: Mesh);
    }
    /**
     * @en The `MeshRenderer` class is used for mesh rendering.
     * @zh `MeshRenderer` 类用于网格渲染器。
     */
    class MeshRenderer extends BaseRender {
        private morphTargetActiveCount;
        private morphTargetActiveData;
        private morphtargetChannels;
        private _morphWeightChange;
        private _moduleData;
        /**
         * @ignore
         * @en Creates an instance of MeshRenderer.
         * @zh 创建一个 MeshRenderer 的实例。
         */
        constructor();
        /**
         * override it
         * @returns
         */
        protected _createBaseRenderNode(): IMeshRenderNode;
        private _morphTargetValues;
        /**
         * @en Set the weight of a morph target channel.
         * @param channelName The name of the morph target channel.
         * @param weight The weight value to set for the channel.
         * @zh 设置变形目标通道的权重。
         * @param channelName 变形目标通道的名称。
         * @param weight 要设置的通道权重值。
         */
        setMorphChannelWeight(channelName: string, weight: number): void;
        _setBelongScene(scene: any): void;
        protected _statAdd(): void;
        protected _statRemove(): void;
        protected _meshChange: boolean;
        /**
         * @en Update the rendering state of the mesh renderer.
         * @param context The 3D render context.
         * @zh 更新网格渲染器的渲染状态。
         * @param context 3D渲染上下文。
         */
        renderUpdate(context: RenderContext3D): void;
    }
    /**
     * @deprecated
     * <code>MeshSprite3D</code> 类用于创建网格。
     */
    class MeshSprite3D extends RenderableSprite3D {
        private _meshFilter;
        /**
         * 网格过滤器。
         */
        get meshFilter(): MeshFilter;
        /**
         * 网格渲染器。
         */
        get meshRenderer(): MeshRenderer;
        /**
         * 创建一个 <code>MeshSprite3D</code> 实例。
         * @param mesh 网格,同时会加载网格所用默认材质。
         * @param name 名字。
         */
        constructor(mesh?: Mesh, name?: string);
    }
    /**
     * @en Class used to record sprite data macros
     * @zh 类用来记录精灵数据宏
     */
    class MeshSprite3DShaderDeclaration {
        /**
         * @en Shader define for UV0 channel vertex data
         * @zh UV0通道顶点数据宏
         */
        static SHADERDEFINE_UV0: ShaderDefine;
        /**
         * @en Shader define for vertex color data
         * @zh 顶点色顶点数据宏
         */
        static SHADERDEFINE_COLOR: ShaderDefine;
        /**
         * @en Shader define for UV1 channel vertex data
         * @zh UV1通道顶点数据宏
         */
        static SHADERDEFINE_UV1: ShaderDefine;
        /**
         * @en Shader define for Tangent channel vertex data
         * @zh Tangent 通道顶点数据宏
         */
        static SHADERDEFINE_TANGENT: ShaderDefine;
        /**
         * @en Using instance
         * @zh instance调用宏
         */
        static SHADERDEFINE_GPU_INSTANCE: ShaderDefine;
    }
    /**
     * @en The Burst class is used to describe the burst of particles.
     * @zh Burst 类用于粒子的爆发描述。
     */
    class Burst implements IClone {
        /** 爆发时间,单位为秒。*/
        private _time;
        /** 爆发的最小数量。*/
        private _minCount;
        /** 爆发的最大数量。*/
        private _maxCount;
        /**
         * @en The burst time in seconds.
         * @zh 爆发时间，单位为秒。
         */
        get time(): number;
        /**
         * @en The minimum count of particles in a burst.
         * @zh 爆发的最小粒子数量。
         */
        get minCount(): number;
        /**
         * @en The maximum count of particles in a burst.
         * @zh 爆发的最大粒子数量。
         */
        get maxCount(): number;
        /**
         * @en Creates an instance of the Burst class.
         * @param time Burst time in seconds. Default is 0.
         * @param minCount Minimum count of particles in a burst. Default is 0.
         * @param maxCount Maximum count of particles in a burst. Default is 0.
         * @zh 创建Burst类的实例。
         * @param time 爆发时间,单位为秒。
         * @param minCount 爆发的最小数量。
         * @param time 爆发的最大数量。
         */
        constructor(time?: number, minCount?: number, maxCount?: number);
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: Burst): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en The ColorOverLifetime class is used for the lifecycle color of particles.
     * @zh ColorOverLifetime 类用于粒子的生命周期颜色。
     */
    class ColorOverLifetime {
        private _color;
        /**
         * @en Whether to enable.
         * @zh 是否启用。
         */
        enable: boolean;
        /**
         * @en The color.
         * @zh 颜色。
         */
        get color(): GradientColor;
        /**
         * @ignore
         * @en creates an instance of the ColorOverLifetime class.
         * @param color gradient color.
         * @zh 创建ColorOverLifetime类的实例。
         * @param color 渐变颜色。
         */
        constructor(color: GradientColor);
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: ColorOverLifetime): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en The Emission class is used for particle emitters.
     * @zh Emission 类用于粒子发射器。
     */
    class Emission implements IClone {
        private _emissionRateOverDistance;
        /**
         * @en Whether the emission is enabled.
         * @zh 是否启用。
         */
        enable: boolean;
        /**
         * @en The particle emission rate.
         * @zh 粒子发射速率。
         */
        get emissionRate(): number;
        set emissionRate(value: number);
        /**
         * @en Particle emission rate based on distance (particles/meter).
         * @zh 粒子基于距离的发射速率（个/米）。
         */
        get emissionRateOverDistance(): number;
        set emissionRateOverDistance(value: number);
        /**
         * @en Whether the object has been destroyed.
         * @zh 是否已销毁。
         */
        get destroyed(): boolean;
        /**
         * @ignore
         * @en Creates an instance of the Emission class.
         * @zh 创建Emission类的实例。
         */
        constructor();
        /**
         * @private
         * @en Destroy the object.
         * @zh 销毁对象。
         */
        destroy(): void;
        /**
         * @en Get the number of particle bursts.
         * @zh 获取粒子爆发个数。
         */
        getBurstsCount(): number;
        /**
         * @en Get a particle burst by index.
         * @param index The burst index.
         * @returns The particle burst.
         * @zh 通过索引获取粒子爆发。
         * @param index 粒子爆发索引。
         * @return 粒子爆发。
         */
        getBurstByIndex(index: number): Burst;
        /**
         * @en Add a particle burst.
         * @param burst The burst to add.
         * @zh 增加粒子爆发。
         * @param burst 要添加的爆发。
         */
        addBurst(burst: Burst): void;
        /**
         * @en Remove a particle burst.
         * @param burst The burst to remove.
         * @zh 移除粒子爆发。
         * @param burst 要移除的爆发。
         */
        removeBurst(burst: Burst): void;
        /**
         * @en Remove a particle burst by index.
         * @param index The burst index to remove.
         * @zh 通过索引移除粒子爆发。
         * @param index 爆发索引。
         */
        removeBurstByIndex(index: number): void;
        /**
         * @en Clear all particle bursts.
         * @zh 清空粒子爆发。
         */
        clearBurst(): void;
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: Emission): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en The FrameOverTime class is used to create time frames.
     * @zh FrameOverTime 类用于创建时间帧。
     */
    class FrameOverTime implements IClone {
        /**
         * @en Create a FrameOverTime instance with a constant frame.
         * @param constant The constant frame.
         * @returns The time frame.
         * @zh 通过固定帧创建一个 FrameOverTime 实例。
         * @param constant 固定帧。
         * @return 时间帧。
         */
        static createByConstant(constant?: number): FrameOverTime;
        /**
         * @en Create a FrameOverTime instance with a time frame.
         * @param overTime The time frame.
         * @returns The time frame.
         * @zh 通过时间帧创建一个 FrameOverTime 实例。
         * @param	overTime 时间帧。
         * @return 时间帧。
         */
        static createByOverTime(overTime: GradientDataInt): FrameOverTime;
        /**
         * @en Create a FrameOverTime instance with random two constant frames.
         * @param constantMin The minimum constant frame.
         * @param constantMax The maximum constant frame.
         * @returns The time frame.
         * @zh 通过随机双固定帧创建一个 FrameOverTime 实例。
         * @param	constantMin 最小固定帧。
         * @param	constantMax 最大固定帧。
         * @return 时间帧。
         */
        static createByRandomTwoConstant(constantMin?: number, constantMax?: number): FrameOverTime;
        /**
         * @en Create a FrameOverTime instance with random two time frames.
         * @param gradientFrameMin The minimum time frame.
         * @param gradientFrameMax The maximum time frame.
         * @returns The time frame.
         * @zh 通过随机双时间帧创建一个 FrameOverTime 实例。
         * @param	gradientFrameMin 最小时间帧。
         * @param	gradientFrameMax 最大时间帧。
         * @return 时间帧。
         */
        static createByRandomTwoOverTime(gradientFrameMin: GradientDataInt, gradientFrameMax: GradientDataInt): FrameOverTime;
        private _type;
        private _constant;
        private _overTime;
        private _constantMin;
        private _constantMax;
        private _overTimeMin;
        private _overTimeMax;
        /**
         * @en Lifecycle rotation type, 0: constant mode, 1: curve mode, 2: random double constant mode, 3: random double curve mode.
         * @zh 生命周期旋转类型，0：常量模式，1：曲线模式，2：随机双常量模式，3：随机双曲线模式。
         */
        get type(): number;
        /**
         * @en Constant frame.
         * @zh 固定帧。
         */
        get constant(): number;
        /**
         * @en Time frame.
         * @zh 时间帧。
         */
        get frameOverTimeData(): GradientDataInt;
        /**
         * @en Minimum constant frame.
         * @zh 最小固定帧。
         */
        get constantMin(): number;
        /**
         * @en Maximum constant frame.
         * @zh 最大固定帧。
         */
        get constantMax(): number;
        /**
         * @en Minimum time frame.
         * @zh 最小时间帧。
         */
        get frameOverTimeDataMin(): GradientDataInt;
        /**
         * @en Maximum time frame.
         * @zh 最大时间帧。
         */
        get frameOverTimeDataMax(): GradientDataInt;
        /**
         * @ignore
         * @en Creation via `new` is not allowed; please use the static creation function.
         * @zh 不允许new，请使用静态创建函数。
         */
        constructor();
        /**
         * @en Clones to a target object.
         * @param destFrameOverTime The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destFrameOverTime 要克隆到的目标对象。
         */
        cloneTo(destFrameOverTime: FrameOverTime): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en The GradientAngularVelocity class is used to create gradient angular velocities.
     * @zh GradientAngularVelocity 类用于创建渐变角速度。
     */
    class GradientAngularVelocity implements IClone {
        /**
         * @en Create a `GradientAngularVelocity` instance with a constant angular velocity.
         * @param constant The constant angular velocity.
         * @return The gradient angular velocity.
         * @zh 通过固定角速度创建一个 `GradientAngularVelocity` 实例。
         * @param	constant 固定角速度。
         * @return 渐变角速度。
         */
        static createByConstant(constant: number): GradientAngularVelocity;
        /**
         * @en Create a `GradientAngularVelocity` instance with separate constant angular velocities for each axis.
         * @param separateConstant The separate constant angular velocities for each axis.
         * @return The gradient angular velocity instance.
         * @zh 通过分轴固定角速度创建一个 `GradientAngularVelocity` 实例。
         * @param separateConstant  分轴固定角速度。
         * @return 渐变角速度实例。
         */
        static createByConstantSeparate(separateConstant: Vector3): GradientAngularVelocity;
        /**
         * @en Create a `GradientAngularVelocity` instance with a gradient angular velocity.
         * @param gradient The gradient angular velocity.
         * @return The gradient angular velocity instance.
         * @zh 通过渐变角速度创建一个 `GradientAngularVelocity` 实例。
         * @param gradient 渐变角速度。
         * @return 渐变角速度实例。
         */
        static createByGradient(gradient: GradientDataNumber): GradientAngularVelocity;
        /**
         * @en Create a `GradientAngularVelocity` instance with separate gradient angular velocities for each axis.
         * @param gradientX The gradient angular velocity for the X-axis.
         * @param gradientY The gradient angular velocity for the Y-axis.
         * @param gradientZ The gradient angular velocity for the Z-axis.
         * @returns The gradient angular velocity instance.
         * @zh 通过分轴渐变角速度创建一个 `GradientAngularVelocity` 实例。
         * @param gradientX X轴渐变角速度。
         * @param gradientY Y轴渐变角速度。
         * @param gradientZ Z轴渐变角速度。
         * @returns 渐变角速度实例。
         */
        static createByGradientSeparate(gradientX: GradientDataNumber, gradientY: GradientDataNumber, gradientZ: GradientDataNumber): GradientAngularVelocity;
        /**
         * @en Create a `GradientAngularVelocity` instance with random constant angular velocities between two values.
         * @param constantMin The minimum constant angular velocity.
         * @param constantMax The maximum constant angular velocity.
         * @returns The gradient angular velocity instance.
         * @zh 通过随机双固定角速度创建一个 `GradientAngularVelocity` 实例。
         * @param constantMin 最小固定角速度。
         * @param constantMax 最大固定角速度。
         * @returns 渐变角速度实例。
         */
        static createByRandomTwoConstant(constantMin: number, constantMax: number): GradientAngularVelocity;
        /**
         * @en Create a `GradientAngularVelocity` instance with random separate constant angular velocities between two values for each axis.
         * @param separateConstantMin The minimum separate constant angular velocities for each axis.
         * @param separateConstantMax The maximum separate constant angular velocities for each axis.
         * @returns The gradient angular velocity instance.
         * @zh 通过随机分轴双固定角速度创建一个 `GradientAngularVelocity` 实例。
         * @param separateConstantMin 最小分轴固定角速度。
         * @param separateConstantMax 最大分轴固定角速度。
         * @returns 渐变角速度实例。
         */
        static createByRandomTwoConstantSeparate(separateConstantMin: Vector3, separateConstantMax: Vector3): GradientAngularVelocity;
        /**
         * @en Create a `GradientAngularVelocity` instance with random gradient angular velocities between two gradients.
         * @param gradientMin The minimum gradient angular velocity.
         * @param gradientMax The maximum gradient angular velocity.
         * @returns The gradient angular velocity instance.
         * @zh 通过随机双渐变角速度创建一个 `GradientAngularVelocity` 实例。
         * @param gradientMin 最小渐变角速度。
         * @param gradientMax 最大渐变角速度。
         * @returns 渐变角速度实例。
         */
        static createByRandomTwoGradient(gradientMin: GradientDataNumber, gradientMax: GradientDataNumber): GradientAngularVelocity;
        /**
         * @en Create a `GradientAngularVelocity` instance with random separate gradient angular velocities between two gradients for each axis.
         * @param gradientXMin The minimum gradient angular velocity for the X-axis.
         * @param gradientXMax The maximum gradient angular velocity for the X-axis.
         * @param gradientYMin The minimum gradient angular velocity for the Y-axis.
         * @param gradientYMax The maximum gradient angular velocity for the Y-axis.
         * @param gradientZMin The minimum gradient angular velocity for the Z-axis.
         * @param gradientZMax The maximum gradient angular velocity for the Z-axis.
         * @param gradientWMin Reserved data.
         * @param gradientWMax Reserved data.
         * @returns The gradient angular velocity instance.
         * @zh 通过分轴随机双渐变角速度创建一个 `GradientAngularVelocity` 实例。
         * @param gradientXMin 最小X轴渐变角速度。
         * @param gradientXMax 最大X轴渐变角速度。
         * @param gradientYMin 最小Y轴渐变角速度。
         * @param gradientYMax 最大Y轴渐变角速度。
         * @param gradientZMin 最小Z轴渐变角速度。
         * @param gradientZMax 最大Z轴渐变角速度。
         * @param gradientWMin 预留数据。
         * @param gradientWMax 预留数据。
         * @returns 渐变角速度实例。
         */
        static createByRandomTwoGradientSeparate(gradientXMin: GradientDataNumber, gradientXMax: GradientDataNumber, gradientYMin: GradientDataNumber, gradientYMax: GradientDataNumber, gradientZMin: GradientDataNumber, gradientZMax: GradientDataNumber, gradientWMin: GradientDataNumber, gradientWMax: GradientDataNumber): GradientAngularVelocity;
        private _type;
        private _separateAxes;
        private __constantSeparate;
        /**
         * @en The separate constant angular velocities for each axis.
         * @zh 分轴固定角速度。
         */
        get _constantSeparate(): Vector3;
        set _constantSeparate(value: Vector3);
        private _gradient;
        private _gradientX;
        private _gradientY;
        private _gradientZ;
        private _gradientW;
        private __constant;
        private __constantMin;
        private __constantMax;
        private __constantMinSeparate;
        private __constantMaxSeparate;
        /**
         * @en The minimum constant separate vector.
         * @zh 最小常量分离向量。
         */
        get _constantMinSeparate(): Vector3;
        set _constantMinSeparate(value: Vector3);
        /**
         * @en The maximum constant separate vector.
         * @zh 最大常量分离向量。
         */
        get _constantMaxSeparate(): Vector3;
        set _constantMaxSeparate(value: Vector3);
        private _gradientMin;
        private _gradientMax;
        private _gradientXMin;
        private _gradientXMax;
        private _gradientYMin;
        private _gradientYMax;
        private _gradientZMin;
        private _gradientZMax;
        private _gradientWMin;
        private _gradientWMax;
        /**
         * @en The type of lifetime angular velocity. 0: Constant mode, 1: Curve mode, 2: Random between two constants mode, 3: Random between two curves mode.
         * @zh 生命周期角速度类型。0：常量模式，1：曲线模式，2：随机双常量模式，3：随机双曲线模式。
         */
        get type(): number;
        /**
         * @en Whether the axes are separated.
         * @zh 是否分轴。
         */
        get separateAxes(): boolean;
        /**
         * @en The constant angular velocity.
         * @zh 固定角速度。
         */
        get constant(): number;
        /**
         * @en The constant angular velocity for separate axes.
         * @zh 分轴固定角速度。
         */
        get constantSeparate(): Vector3;
        /**
         * @en The gradient angular velocity.
         * @zh 渐变角速度。
         */
        get gradient(): GradientDataNumber;
        /**
         * @en The gradient angular velocity for X axis.
         * @zh X轴渐变角速度。
         */
        get gradientX(): GradientDataNumber;
        /**
         * @en The gradient angular velocity for Y axis.
         * @zh Y轴渐变角速度。
         */
        get gradientY(): GradientDataNumber;
        /**
         * @en The gradient angular velocity for Z axis.
         * @zh Z轴渐变角速度。
         */
        get gradientZ(): GradientDataNumber;
        /**
         * @en The gradient angular velocity for W component.
         * @zh W分量渐变角速度。
         */
        get gradientW(): GradientDataNumber;
        /**
         * @en The minimum constant angular velocity for random between two constants mode.
         * @zh 随机双固定角速度的最小值。
         */
        get constantMin(): number;
        /**
         * @en The maximum constant angular velocity for random between two constants mode.
         * @zh 随机双固定角速度的最大值。
         */
        get constantMax(): number;
        /**
         * @en The minimum constant angular velocity for separate axes in random between two constants mode.
         * @zh 分轴随机双固定角速度的最小值。
         */
        get constantMinSeparate(): Vector3;
        /**
         * @en The maximum constant angular velocity for separate axes in random between two constants mode.
         * @zh 分轴随机双固定角速度的最大值。
         */
        get constantMaxSeparate(): Vector3;
        /**
         * @en The minimum gradient angular velocity.
         * @zh 最小渐变角速度。
         */
        get gradientMin(): GradientDataNumber;
        /**
         * @en The maximum gradient angular velocity.
         * @zh 最大渐变角速度。
         */
        get gradientMax(): GradientDataNumber;
        /**
         * @en The minimum gradient angular velocity for X axis.
         * @zh X轴最小渐变角速度。
         */
        get gradientXMin(): GradientDataNumber;
        /**
         * @en The maximum gradient angular velocity for X axis.
         * @zh X轴最大渐变角速度。
         */
        get gradientXMax(): GradientDataNumber;
        /**
         * @en The minimum gradient angular velocity for Y axis.
         * @zh Y轴最小渐变角速度。
         */
        get gradientYMin(): GradientDataNumber;
        /**
         * @en The maximum gradient angular velocity for Y axis.
         * @zh Y轴最大渐变角速度。
         */
        get gradientYMax(): GradientDataNumber;
        /**
         * @en The minimum gradient angular velocity for Z axis.
         * @zh Z轴最小渐变角速度。
         */
        get gradientZMin(): GradientDataNumber;
        /**
         * @en The maximum gradient angular velocity for Z axis.
         * @zh Z轴最大渐变角速度。
         */
        get gradientZMax(): GradientDataNumber;
        /**
         * @en The minimum gradient angular velocity for W axis.
         * @zh W轴最小渐变角速度。
         */
        get gradientWMin(): GradientDataNumber;
        /**
         * @en The maximum gradient angular velocity for W axis.
         * @zh W轴最大渐变角速度。
         */
        get gradientWMax(): GradientDataNumber;
        /**
         * @ignore
         * @en Creating an instance via `new` is not allowed; please use the static creation function.
         * @zh 不允许new，请使用静态创建函数。
         */
        constructor();
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: GradientAngularVelocity): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en The GradientColor class is used to create gradient colors.
     * @zh GradientColor 类用于创建渐变颜色。
     */
    class GradientColor implements IClone {
        /**
         * @en Create a GradientColor instance with a constant color.
         * @param constant The constant color.
         * @returns A new GradientColor instance.
         * @zh 通过固定颜色创建一个 GradientColor 实例。
         * @param constant 固定颜色。
         * @returns 一个新的 GradientColor 实例。
         */
        static createByConstant(constant: Vector4): GradientColor;
        /**
         * @en Create a GradientColor instance with a gradient color.
         * @param gradient The gradient color.
         * @returns A new GradientColor instance.
         * @zh 通过渐变颜色创建一个 GradientColor 实例。
         * @param gradient 渐变色。
         * @returns 一个新的 GradientColor 实例。
         */
        static createByGradient(gradient: Gradient): GradientColor;
        /**
         * @en Create a GradientColor instance with two random constant colors.
         * @param minConstant The minimum constant color.
         * @param maxConstant The maximum constant color.
         * @returns A new GradientColor instance.
         * @zh 通过随机双固定颜色创建一个 GradientColor 实例。
         * @param minConstant 最小固定颜色。
         * @param maxConstant 最大固定颜色。
         * @returns 一个新的 GradientColor 实例。
         */
        static createByRandomTwoConstant(minConstant: Vector4, maxConstant: Vector4): GradientColor;
        /**
         * @en Create a GradientColor instance with two random gradient colors.
         * @param minGradient The minimum gradient color.
         * @param maxGradient The maximum gradient color.
         * @returns A new GradientColor instance.
         * @zh 通过随机双渐变颜色创建一个 GradientColor 实例。
         * @param minGradient 最小渐变颜色。
         * @param maxGradient 最大渐变颜色。
         * @returns 一个新的 GradientColor 实例。
         */
        static createByRandomTwoGradient(minGradient: Gradient, maxGradient: Gradient): GradientColor;
        private _type;
        private _constant;
        private _constantMin;
        private _constantMax;
        private _gradient;
        private _gradientMin;
        private _gradientMax;
        /**
         * @en The type of lifetime color. 0 for constant color mode, 1 for gradient mode, 2 for random two constant colors mode, 3 for random two gradients mode.
         * @zh 生命周期颜色类型。0为固定颜色模式，1为渐变模式，2为随机双固定颜色模式，3为随机双渐变模式。
         */
        get type(): number;
        /**
         * @en The constant color.
         * @zh 固定颜色。
         */
        get constant(): Vector4;
        /**
         * @en The minimum constant color.
         * @zh 最小固定颜色。
         */
        get constantMin(): Vector4;
        /**
         * @en The maximum constant color.
         * @zh 最大固定颜色。
         */
        get constantMax(): Vector4;
        /**
         * @en The gradient color.
         * @zh 渐变颜色。
         */
        get gradient(): Gradient;
        /**
         * @en The minimum gradient color.
         * @zh 最小渐变颜色。
         */
        get gradientMin(): Gradient;
        /**
         * @en The maximum gradient color.
         * @zh 最大渐变颜色。
         */
        get gradientMax(): Gradient;
        /**
         * @ignore
         * @en Creating an instance via `new` is not allowed; please use the static creation function.
         * @zh 不允许new，请使用静态创建函数。
         */
        constructor();
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: GradientColor): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en The GradientDataInt class is used to create integer gradients.
     * @zh GradientDataInt 类用于创建整形渐变。
     */
    class GradientDataInt implements IClone {
        private _currentLength;
        /**
         * @en The number of integer gradients.
         * @zh 整形渐变数量。
         */
        get gradientCount(): number;
        /**
         * @ignore
         * @en creates an instance of the GradientDataInt class.
         * @zh 创建一个 GradientDataInt 类的实例。
         */
        constructor();
        /**
         * @en Add an integer gradient.
         * @param key - The lifecycle key, ranging from 0 to 1.
         * @param value - The integer value.
         * @zh 增加整形渐变。
         * @param key - 生命周期，范围为0到1。
         * @param value - 整形值。
         */
        add(key: number, value: number): void;
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: GradientDataInt): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en The `GradientDataNumber` class is used to create floating-point gradients.
     * @zh `GradientDataNumber` 类用于创建浮点渐变。
     */
    class GradientDataNumber implements IClone {
        private _currentLength;
        /**
         * @en The number of gradient floats.
         * @zh 渐变浮点数量。
         */
        get gradientCount(): number;
        /**
         * @ignore
         * @en creates an instance of the GradientDataNumber class.
         * @zh 创建一个 GradientDataNumber 类的实例。
         */
        constructor();
        /**
         * @en Add a floating-point gradient.
         * @param key Lifecycle, ranging from 0 to 1.
         * @param value The float value.
         * @zh 增加浮点渐变。
         * @param key 生命周期，范围为 0 到 1。
         * @param value 浮点值。
         */
        add(key: number, value: number): void;
        /**
         * @en Get the key by index.
         * @param index The index.
         * @returns The key.
         * @zh 通过索引获取键。
         * @param index 索引。
         * @returns 键。
         */
        getKeyByIndex(index: number): number;
        /**
         * @en Get the value by index.
         * @param index The index.
         * @returns The value.
         * @zh 通过索引获取值。
         * @param index 索引。
         * @returns 值。
         */
        getValueByIndex(index: number): number;
        /**
         * @en Get the average value.
         * @returns The average value of the gradient.
         * @zh 获取平均值。
         * @returns 渐变的平均值。
         */
        getAverageValue(): number;
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: GradientDataNumber): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en The `GradientDataVector2` class is used to create two-dimensional vector gradients.
     * @zh `GradientDataVector2` 类用于创建二维向量渐变。
     */
    class GradientDataVector2 implements IClone {
        private _currentLength;
        /**
         * @en The number of two-dimensional vector gradients.
         * @zh 二维向量渐变数量。
         */
        get gradientCount(): number;
        /**
         * @ignore
         * @en creates an instance of the `GradientDataVector2` class.
         * @zh 创建一个 `GradientDataVector2` 实例。
         */
        constructor();
        /**
         * @en Add a two-dimensional vector gradient.
         * @param key Lifecycle, ranging from 0 to 1.
         * @param value The two-dimensional vector value.
         * @zh 增加二维向量渐变。
         * @param key 生命周期，范围为 0 到 1。
         * @param value 二维向量值。
         */
        add(key: number, value: Vector2): void;
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: GradientDataVector2): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en The `GradientSize` class is used to create gradient sizes.
     * @zh `GradientSize` 类用于创建渐变尺寸。
     */
    class GradientSize implements IClone {
        /**
         * @en Create a `GradientSize` instance by gradient size.
         * @param gradient  The gradient size.
         * @returns The gradient size instance.
         * @zh 通过渐变尺寸创建一个 `GradientSize` 实例。
         * @param gradient 渐变尺寸。
         * @returns 渐变尺寸实例。
         */
        static createByGradient(gradient: GradientDataNumber): GradientSize;
        /**
         * @en Create a `GradientSize` instance by separate axis gradient sizes.
         * @param gradientX The gradient size for X axis.
         * @param gradientY The gradient size for Y axis.
         * @param gradientZ The gradient size for Z axis.
         * @returns The gradient size instance.
         * @zh 通过分轴渐变尺寸创建一个 `GradientSize` 实例。
         * @param gradientX 渐变尺寸X。
         * @param gradientY 渐变尺寸Y。
         * @param gradientZ 渐变尺寸Z。
         * @returns 渐变尺寸实例。
         */
        static createByGradientSeparate(gradientX: GradientDataNumber, gradientY: GradientDataNumber, gradientZ: GradientDataNumber): GradientSize;
        /**
         * @en Create a `GradientSize` instance by random two constant sizes.
         * @param constantMin The minimum constant size.
         * @param constantMax The maximum constant size.
         * @returns The gradient size instance.
         * @zh 通过随机双固定尺寸创建一个 `GradientSize` 实例。
         * @param constantMin 最小固定尺寸。
         * @param constantMax 最大固定尺寸。
         * @returns 渐变尺寸实例。
         */
        static createByRandomTwoConstant(constantMin: number, constantMax: number): GradientSize;
        /**
         * @en Create a `GradientSize` instance by separate axis random two constant sizes.
         * @param constantMinSeparate The minimum constant size for separate axes.
         * @param constantMaxSeparate The maximum constant size for separate axes.
         * @returns The gradient size instance.
         * @zh 通过分轴随机双固定尺寸创建一个 `GradientSize` 实例。
         * @param constantMinSeparate 分轴最小固定尺寸。
         * @param constantMaxSeparate 分轴最大固定尺寸。
         * @returns 渐变尺寸实例。
         */
        static createByRandomTwoConstantSeparate(constantMinSeparate: Vector3, constantMaxSeparate: Vector3): GradientSize;
        /**
         * @en Create a `GradientSize` instance by random two gradient sizes.
         * @param gradientMin The minimum gradient size.
         * @param gradientMax The maximum gradient size.
         * @returns The gradient size instance.
         * @zh 通过随机双渐变尺寸创建一个 `GradientSize` 实例。
         * @param gradientMin 最小渐变尺寸。
         * @param gradientMax 最大渐变尺寸。
         * @returns 渐变尺寸实例。
         */
        static createByRandomTwoGradient(gradientMin: GradientDataNumber, gradientMax: GradientDataNumber): GradientSize;
        /**
         * @en Create a `GradientSize` instance by separate axis random two gradient sizes.
         * @param gradientXMin The minimum gradient size for X axis.
         * @param gradientXMax The maximum gradient size for X axis.
         * @param gradientYMin The minimum gradient size for Y axis.
         * @param gradientYMax The maximum gradient size for Y axis.
         * @param gradientZMin The minimum gradient size for Z axis.
         * @param gradientZMax The maximum gradient size for Z axis.
         * @returns The gradient size instance.
         * @zh 通过分轴随机双渐变尺寸创建一个 `GradientSize` 实例。
         * @param gradientXMin X轴最小渐变尺寸。
         * @param gradientXMax X轴最大渐变尺寸。
         * @param gradientYMin Y轴最小渐变尺寸。
         * @param gradientYMax Y轴最大渐变尺寸。
         * @param gradientZMin Z轴最小渐变尺寸。
         * @param gradientZMax Z轴最大渐变尺寸。
         * @returns 渐变尺寸实例。
         */
        static createByRandomTwoGradientSeparate(gradientXMin: GradientDataNumber, gradientXMax: GradientDataNumber, gradientYMin: GradientDataNumber, gradientYMax: GradientDataNumber, gradientZMin: GradientDataNumber, gradientZMax: GradientDataNumber): GradientSize;
        private _type;
        private _separateAxes;
        private _gradient;
        private _gradientX;
        private _gradientY;
        private _gradientZ;
        private _constantMin;
        private _constantMax;
        private _constantMinSeparate;
        private _constantMaxSeparate;
        private _gradientMin;
        private _gradientMax;
        private _gradientXMin;
        private _gradientXMax;
        private _gradientYMin;
        private _gradientYMax;
        private _gradientZMin;
        private _gradientZMax;
        /**
         * @en The type of lifecycle size. 0: Curve mode, 1: Random double constant mode, 2: Random double curve mode.
         * @zh 生命周期尺寸类型，0：曲线模式，1：随机双常量模式，2：随机双曲线模式。
         */
        get type(): number;
        /**
         * @en Whether to separate axes.
         * @zh 是否分轴。
         */
        get separateAxes(): boolean;
        /**
         * @en The gradient size.
         * @zh 渐变尺寸。
         */
        get gradient(): GradientDataNumber;
        /**
         * @en The gradient size for X axis.
         * @zh 渐变尺寸X。
         */
        get gradientX(): GradientDataNumber;
        /**
         * @en The gradient size for Y axis.
         * @zh 渐变尺寸Y。
         */
        get gradientY(): GradientDataNumber;
        /**
         * @en The gradient size for Z axis.
         * @zh 渐变尺寸Z。
         */
        get gradientZ(): GradientDataNumber;
        /**
         * @en The minimum random double constant size.
         * @zh 最小随机双固定尺寸。
         */
        get constantMin(): number;
        /**
         * @en The maximum random double constant size.
         * @zh 最大随机双固定尺寸。
         */
        get constantMax(): number;
        /**
         * @en The minimum separate axis random double constant size.
         * @zh 最小分轴随机双固定尺寸。
         */
        get constantMinSeparate(): Vector3;
        /**
         * @en The maximum separate axis random double constant size.
         * @zh 最大分轴随机双固定尺寸。
         */
        get constantMaxSeparate(): Vector3;
        /**
         * @en The minimum gradient size.
         * @zh 渐变最小尺寸。
         */
        get gradientMin(): GradientDataNumber;
        /**
         * @en The maximum gradient size.
         * @zh 渐变最大尺寸。
         */
        get gradientMax(): GradientDataNumber;
        /**
         * @en The minimum gradient size for X axis.
         * @zh 渐变最小尺寸X。
         */
        get gradientXMin(): GradientDataNumber;
        /**
         * @en The maximum gradient size for X axis.
         * @zh 渐变最大尺寸X。
         */
        get gradientXMax(): GradientDataNumber;
        /**
         * @en The minimum gradient size for Y axis.
         * @zh 渐变最小尺寸Y。
         */
        get gradientYMin(): GradientDataNumber;
        /**
         * @en The maximum gradient size for Y axis.
         * @zh 渐变最大尺寸Y。
         */
        get gradientYMax(): GradientDataNumber;
        /**
         * @en The minimum gradient size for Z axis.
         * @zh 渐变最小尺寸Z。
         */
        get gradientZMin(): GradientDataNumber;
        /**
         * @en The maximum gradient size for Z axis.
         * @zh 渐变最大尺寸Z。
         */
        get gradientZMax(): GradientDataNumber;
        /**
         * @ignore
         * @en Constructor, not allowed to use "new", please use the static creation function.
         * @zh 构造方法。不允许new，请使用静态创建函数。
         */
        constructor();
        /**
         * @en Retrieves the maximum size within a gradient, based on the specified parameters and mode.
         * @param meshMode Indicates whether the calculation is for mesh mode.
         * @returns The maximum size found in the gradient.
         * @zh 获取渐变中的最大尺寸。
         * @param	meshMode 是否是网格模式
         * @returns 返回渐变中找到的最大尺寸。
         */
        getMaxSizeInGradient(meshMode?: boolean): number;
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: GradientSize): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en The `GradientVelocity` class is used to create gradient velocities.
     * @zh `GradientVelocity` 类用于创建渐变速度。
     */
    class GradientVelocity implements IClone {
        /**
         * @en Create a `GradientVelocity` instance with constant velocity.
         * @param constant The constant velocity.
         * @returns The gradient velocity instance.
         * @zh 通过固定速度创建一个 `GradientVelocity` 实例。
         * @param constant 固定速度。
         * @returns 渐变速度实例。
         */
        static createByConstant(constant: Vector3): GradientVelocity;
        /**
         * @en Create a `GradientVelocity` instance with gradient velocities.
         * @param gradientX Gradient velocity for X axis.
         * @param gradientY Gradient velocity for Y axis.
         * @param gradientZ Gradient velocity for Z axis.
         * @returns The gradient velocity instance.
         * @zh 通过渐变速度创建一个 `GradientVelocity` 实例。
         * @param gradientX 渐变速度X。
         * @param gradientY 渐变速度Y。
         * @param gradientZ 渐变速度Z。
         * @returns 渐变速度实例。
         */
        static createByGradient(gradientX: GradientDataNumber, gradientY: GradientDataNumber, gradientZ: GradientDataNumber): GradientVelocity;
        /**
         * @en Create a `GradientVelocity` instance with random two constant velocities.
         * @param constantMin The minimum constant velocity.
         * @param constantMax The maximum constant velocity.
         * @returns The gradient velocity instance.
         * @zh 通过随机双固定速度创建一个 `GradientVelocity` 实例。
         * @param constantMin 最小固定速度。
         * @param constantMax 最大固定速度。
         * @returns 渐变速度实例。
         */
        static createByRandomTwoConstant(constantMin: Vector3, constantMax: Vector3): GradientVelocity;
        /**
         * @en Create a `GradientVelocity` instance with random two gradient velocities.
         * @param gradientXMin Minimum gradient velocity for X axis.
         * @param gradientXMax Maximum gradient velocity for X axis.
         * @param gradientYMin Minimum gradient velocity for Y axis.
         * @param gradientYMax Maximum gradient velocity for Y axis.
         * @param gradientZMin Minimum gradient velocity for Z axis.
         * @param gradientZMax Maximum gradient velocity for Z axis.
         * @returns The gradient velocity instance.
         * @zh 通过随机双渐变速度创建一个 `GradientVelocity` 实例。
         * @param gradientXMin X轴最小渐变速度。
         * @param gradientXMax X轴最大渐变速度。
         * @param gradientYMin Y轴最小渐变速度。
         * @param gradientYMax Y轴最大渐变速度。
         * @param gradientZMin Z轴最小渐变速度。
         * @param gradientZMax Z轴最大渐变速度。
         * @returns 渐变速度实例。
         */
        static createByRandomTwoGradient(gradientXMin: GradientDataNumber, gradientXMax: GradientDataNumber, gradientYMin: GradientDataNumber, gradientYMax: GradientDataNumber, gradientZMin: GradientDataNumber, gradientZMax: GradientDataNumber): GradientVelocity;
        private _type;
        private __constant;
        /**
         * @en The constant velocity.
         * @zh 固定速度。
         */
        get _constant(): Vector3;
        set _constant(value: Vector3);
        private __constantMin;
        /**
         * @en The minimum constant velocity.
         * @zh 最小固定速度。
         */
        get _constantMin(): Vector3;
        set _constantMin(value: Vector3);
        private __constantMax;
        /**
         * @en The maximum constant velocity.
         * @zh 最大固定速度。
         */
        get _constantMax(): Vector3;
        set _constantMax(value: Vector3);
        private _gradientConstantX;
        private _gradientConstantY;
        private _gradientConstantZ;
        private _gradientConstantXMin;
        private _gradientConstantXMax;
        private _gradientConstantYMin;
        private _gradientConstantYMax;
        private _gradientConstantZMin;
        private _gradientConstantZMax;
        private _gradientX;
        private _gradientY;
        private _gradientZ;
        private _gradientXMin;
        private _gradientXMax;
        private _gradientYMin;
        private _gradientYMax;
        private _gradientZMin;
        private _gradientZMax;
        /**
         * @en The lifecycle velocity type. 0: constant mode, 1: curve mode, 2: random double constant mode, 3: random double curve mode.
         * @zh 生命周期速度类型。0：常量模式，1：曲线模式，2：随机双常量模式，3：随机双曲线模式。
         */
        get type(): number;
        /**
         * @en The constant velocity.
         * @zh 固定速度。
         */
        get constant(): Vector3;
        /**
         * @en The gradient velocity for X axis.
         * @zh X轴渐变速度。
         */
        get gradientX(): GradientDataNumber;
        /**
         * @en The gradient velocity for Y axis.
         * @zh Y轴渐变速度。
         */
        get gradientY(): GradientDataNumber;
        /**
         * @en The gradient velocity for Z axis.
         * @zh Z轴渐变速度。
         */
        get gradientZ(): GradientDataNumber;
        /**
         * @en The minimum constant velocity.
         * @zh 最小固定速度。
         */
        get constantMin(): Vector3;
        /**
         * @en The maximum constant velocity.
         * @zh 最大固定速度。
         */
        get constantMax(): Vector3;
        /**
         * @en The minimum gradient velocity for X axis.
         * @zh X轴最小渐变速度。
         */
        get gradientXMin(): GradientDataNumber;
        /**
         * @en The maximum gradient velocity for X axis.
         * @zh X轴最大渐变速度。
         */
        get gradientXMax(): GradientDataNumber;
        /**
         * @en The minimum gradient velocity for Y axis.
         * @zh Y轴最小渐变速度。
         */
        get gradientYMin(): GradientDataNumber;
        /**
         * @en The maximum gradient velocity for Y axis.
         * @zh Y轴最大渐变速度。
         */
        get gradientYMax(): GradientDataNumber;
        /**
         * @en The minimum gradient velocity for Z axis.
         * @zh Z轴最小渐变速度。
         */
        get gradientZMin(): GradientDataNumber;
        /**
         * @en The maximum gradient velocity for Z axis.
         * @zh Z轴最大渐变速度。
         */
        get gradientZMax(): GradientDataNumber;
        /**
         * @ignore
         * @en Constructor, not allowed to use "new", please use the static creation function.
         * @zh 构造方法。不允许new，请使用静态创建函数。
         */
        constructor();
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: GradientVelocity): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en The `RotationOverLifetime` class is used for particle rotation over its lifecycle.
     * @zh `RotationOverLifetime` 类用于控制粒子在其生命周期内的旋转。
     */
    class RotationOverLifetime implements IClone {
        private _angularVelocity;
        /**
         * @en Indicates whether the rotation over lifetime is enabled.
         * @zh 是否启用生命周期旋转。
         */
        enable: boolean;
        /**
         * @en The angular velocity of the particle.
         * @zh 粒子的角速度。
         */
        get angularVelocity(): GradientAngularVelocity;
        /**
         * @ignore
         * @en Constructor, not allowed to use "new", please use the static creation function.
         * @zh 构造方法。不允许new，请使用静态创建函数。
         */
        constructor(angularVelocity: GradientAngularVelocity);
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: RotationOverLifetime): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en Enumeration of particle system shape types.
     * @zh 粒子系统形状类型枚举。
     */
    enum ParticleSystemShapeType {
        /**
         * @en Box shape.
         * @zh 盒子形状。
         */
        Box = 0,
        /**
         * @en Circle shape.
         * @zh 环形形状。
         */
        Circle = 1,
        /**
         * @en Cone shape.
         * @zh 锥体形状。
         */
        Cone = 2,
        /**
         * @en Hemisphere shape.
         * @zh 半球体形状。
         */
        Hemisphere = 3,
        /**
         * @en Sphere shape.
         * @zh 球体形状。
         */
        Sphere = 4
    }
    /**
     * @en BaseShape class for particle shapes.
     * @zh BaseShape类用于粒子形状。
     */
    class BaseShape implements IClone {
        /**
         * @en Whether the shape is enabled.
         * @zh 是否启用。
         */
        enable: boolean;
        /**
         * @en Random direction.
         * @zh 随机方向，默认0为不随机。
         */
        randomDirection: number;
        /**
         * @en Particle shape type.
         * @zh 粒子形状类型。
         */
        shapeType: ParticleSystemShapeType;
        /**
         * @ignore
         * @en Creates an instance of the BaseShape class.
         * @zh 创建一个BaseShape实例。
         */
        constructor();
        /**
         * @en Generates initial position and direction for particles.
         * @param position The particle position.
         * @param direction The particle direction.
         * @param rand Random number.
         * @param randomSeeds Random seeds.
         * @zh 用于生成粒子初始位置和方向。
         * @param position 粒子位置。
         * @param direction 粒子方向。
         * @param rand 随机数。
         * @param randomSeeds 随机种子。
         */
        generatePositionAndDirection(position: Vector3, direction: Vector3, rand?: Rand, randomSeeds?: Uint32Array): void;
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: BaseShape): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en BoxShape class for creating box-shaped particle emitters.
     * @zh BoxShape 类用于创建盒形粒子发射器。
     */
    class BoxShape extends BaseShape {
        /**
         * @en Length of the emitter along the X-axis.
         * @zh 发射器X轴长度。
         */
        x: number;
        /**
         * @en Length of the emitter along the Y-axis.
         * @zh 发射器Y轴长度。
         */
        y: number;
        /**
         * @en Length of the emitter along the Z-axis.
         * @zh 发射器Z轴长度。
         */
        z: number;
        /**
         * @ignore
         * @en Creates an instance of the BoxShape class.
         * @zh 创建一个BoxShape实例。
         */
        constructor();
        /**
         * @en Generates initial position and direction for particles.
         * @param position The particle position.
         * @param direction The particle direction.
         * @param rand Random number.
         * @param randomSeeds Array of random seeds.
         * @zh 用于生成粒子初始位置和方向。
         * @param position 粒子位置。
         * @param direction 粒子方向。
         * @param rand 随机数。
         * @param randomSeeds 随机种子数组。
         */
        generatePositionAndDirection(position: Vector3, direction: Vector3, rand?: Rand, randomSeeds?: Uint32Array): void;
        /**
         * @override
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: BoxShape): void;
        /**
         * @override
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en CircleShape class for creating circular particle emitters.
     * @zh CircleShape 类用于创建环形粒子发射器。
     */
    class CircleShape extends BaseShape {
        /**
         * @en Emitter radius.
         * @zh 发射器半径。
         */
        radius: number;
        /**
         * @en Arc angle.
         * @zh 环形弧度。
         */
        arc: number;
        /**
         * @en Whether to emit from the edge.
         * @zh 是否从边缘发射。
         */
        emitFromEdge: boolean;
        /**
         * @ignore
         * @en Creates an instance of the CircleShape class.
         * @zh 创建一个CircleShape实例。
         */
        constructor();
        /**
         * @en Emission angle 0-360
         * @zh 发射角度 0-360
         */
        get arcDEG(): number;
        set arcDEG(deg: number);
        /**
         * @en Generates initial position and direction for particles.
         * @param position The particle position.
         * @param direction The particle direction.
         * @param rand Random number.
         * @param randomSeeds Array of random seeds.
         * @zh 用于生成粒子初始位置和方向。
         * @param position 粒子位置。
         * @param direction 粒子方向。
         * @param rand 随机数。
         * @param randomSeeds 随机种子数组。
         */
        generatePositionAndDirection(position: Vector3, direction: Vector3, rand?: Rand, randomSeeds?: Uint32Array): void;
        /**
         * @override
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: CircleShape): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en ConeShape class is used to create cone-shaped particle emitters.
     * @zh ConeShape类用于创建锥形粒子发射器。
     */
    class ConeShape extends BaseShape {
        /**
         * @en The emission angle in radians.
         * @zh 发射角度，单位为弧度。
         */
        angle: number;
        /**
         * @en The radius of the emitter.
         * @zh 发射器的半径。
         */
        radius: number;
        /**
         * @en The length of the cone.
         * @zh 锥体的长度。
         */
        length: number;
        /**
         * @en The emission type. 0 for Base, 1 for BaseShell, 2 for Volume, 3 for VolumeShell.
         * @zh 发射类型：0 表示基础发射，1 表示基础外壳发射，2 表示体积发射，3 表示体积外壳发射。
         */
        emitType: number;
        /**
         * @ignore
         * @en Creates an instance of the ConeShape class.
         * @zh 创建一个ConeShape实例。
         */
        constructor();
        /**
         * @en Emission angle 0-360
         * @zh 发射角度0-360
         */
        get angleDEG(): number;
        set angleDEG(deg: number);
        /**
         * @en Generates initial position and direction for particles.
         * @param position The particle position.
         * @param direction The particle direction.
         * @param rand Random number.
         * @param randomSeeds Array of random seeds.
         * @zh 用于生成粒子初始位置和方向。
         * @param position 粒子位置。
         * @param direction 粒子方向。
         * @param rand 随机数。
         * @param randomSeeds 随机种子数组。
         */
        generatePositionAndDirection(position: Vector3, direction: Vector3, rand?: Rand, randomSeeds?: Uint32Array): void;
        /**
         * @override
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: ConeShape): void;
        /**
         * @override
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en The HemisphereShape class is used to create hemispherical particle shapes emitters.
     * @zh HemisphereShape 类用于创建半球形粒子形状发射器。
     */
    class HemisphereShape extends BaseShape {
        /**
         * @en The radius of the hemisphere.
         * @zh 发射器半径。
         */
        radius: number;
        /**
         * @en Whether to emit from the shell.
         * @zh 是否从外壳发射。
         */
        emitFromShell: boolean;
        /**
         * @ignore
         * @en Creats an instance of the HemisphereShape class.
         * @zh 创建一个HemisphereShape实例。
         */
        constructor();
        /**
         * @override
         * @en Generates initial position and direction for particles.
         * @param position The particle position.
         * @param direction The particle direction.
         * @param rand Random number.
         * @param randomSeeds Array of random seeds.
         * @zh 用于生成粒子初始位置和方向。
         * @param position 粒子位置。
         * @param direction 粒子方向。
         * @param rand 随机数。
         * @param randomSeeds 随机种子数组。
         */
        generatePositionAndDirection(position: Vector3, direction: Vector3, rand?: Rand, randomSeeds?: Uint32Array): void;
        /**
         * @override
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: HemisphereShape): void;
        /**
         * @override
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en SphereShape class is used to create spherical particle shapes.
     * @zh SphereShape 类用于创建球形粒子发射器。
     */
    class SphereShape extends BaseShape {
        /**
         * @en Emitter radius.
         * @zh 发射器半径。
         */
        radius: number;
        /**
         * @en Whether to emit from the shell.
         * @zh 是否从外壳发射。
         */
        emitFromShell: boolean;
        /**
         * @ignore
         * @en Creates an instance of the SphereShape class.
         * @zh 创建一个 SphereShape 实例。
         */
        constructor();
        /**
         * @en Generates initial position and direction for particles.
         * @param position The particle position.
         * @param direction The particle direction.
         * @param rand Random number.
         * @param randomSeeds Array of random seeds.
         * @zh 用于生成粒子初始位置和方向。
         * @param position 粒子位置。
         * @param direction 粒子方向。
         * @param rand 随机数。
         * @param randomSeeds 随机种子数组。
         */
        generatePositionAndDirection(position: Vector3, direction: Vector3, rand?: Rand, randomSeeds?: Uint32Array): void;
        /**
         * @override
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: SphereShape): void;
        /**
         * @override
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en The `SizeOverLifetime` class is used to control the size of particles over their lifetime.
     * @zh `SizeOverLifetime` 类用于控制粒子在其生命周期内的尺寸变化。
     */
    class SizeOverLifetime implements IClone {
        private _size;
        /**
         * @en Whether to enable.
         * @zh 是否启用
         */
        enable: boolean;
        /**
         * @en The size.
         * @zh 尺寸。
         */
        get size(): GradientSize;
        /**
         * @ignore
         * @en Creates an instance of the `SizeOverLifetime` class.
         * @param size gradient size.
         * @zh 创建一个 `SizeOverLifetime` 实例。
         * @param size 渐变尺寸
         */
        constructor(size: GradientSize);
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: SizeOverLifetime): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en The `StartFrame` class is used to create start frames.
     * @zh `StartFrame` 类用于创建起始帧。
     */
    class StartFrame implements IClone {
        /**
         * @en Create a `StartFrame` instance with a constant frame value.
         * @param constant The fixed frame value. Default is 0.
         * @returns A new StartFrame instance.
         * @zh 通过固定帧值创建一个 `StartFrame` 实例。
         * @param constant 固定帧值。默认为0。
         * @returns 新的 StartFrame 实例。
         */
        static createByConstant(constant?: number): StartFrame;
        /**
         * @en Create a `StartFrame` instance with a random range between two constant frame values.
         * @param constantMin The minimum fixed frame value. Default is 0.
         * @param constantMax The maximum fixed frame value. Default is 0.
         * @returns A new StartFrame instance.
         * @zh 通过随机范围在两个固定帧值之间创建一个 `StartFrame` 实例。
         * @param constantMin 最小固定帧值。默认为0。
         * @param constantMax 最大固定帧值。默认为0。
         * @returns 新的 StartFrame 实例。
         */
        static createByRandomTwoConstant(constantMin?: number, constantMax?: number): StartFrame;
        private _type;
        private _constant;
        private _constantMin;
        private _constantMax;
        /**
         * @en The start frame type. 0 for constant mode, 1 for random between two constants mode.
         * @zh 起始帧类型。0表示常量模式，1表示随机双常量模式。
         */
        get type(): number;
        /**
         * @en The constant frame value.
         * @zh 固定帧值。
         */
        get constant(): number;
        /**
         * @en The minimum constant frame value.
         * @zh 最小固定帧值。
         */
        get constantMin(): number;
        /**
         * @en The maximum constant frame value.
         * @zh 最大固定帧值。
         */
        get constantMax(): number;
        /**
         * @ignore
         * @en Constructor, not allowed to use "new", please use the static creation function.
         * @zh 构造方法。不允许new，请使用静态创建函数。
         */
        constructor();
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: StartFrame): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en The `TextureSheetAnimation` class is used to create particle frame animations.
     * @zh `TextureSheetAnimation` 类用于创建粒子帧动画。
     */
    class TextureSheetAnimation implements IClone {
        /**
         * @en Texture tiling.
         * @zh 纹理平铺。
         */
        tiles: Vector2;
        /**
         * @en Type, 0 for whole sheet, 1 for single row.
         * @zh 类型，0 表示整个纹理表，1 表示纹理表中的某一行。
         */
        type: number;
        /**
         * @en Whether to use random row, effective when type is 1.
         * @zh 是否随机行，type属性 为 1 时，该属性才会生效。
         */
        randomRow: boolean;
        /**
         * @en Row index, effective when type is 1.
         * @zh 行索引，type属性 为 1 时，该属性才会生效。
         */
        rowIndex: number;
        /**
         * @en Number of cycles.
         * @zh 循环次数。
         */
        cycles: number;
        /**
         * @en UV channel type, 0 for Nothing, 1 for Everything.
         * @zh UV 通道类型，0 表示 Nothing，1 表示 Everything。
         */
        enableUVChannels: number;
        /**
         * @en Whether enabled.
         * @zh 是否启用。
         */
        enable: boolean;
        /**
         * @en The time frame rate.
         * @zh 时间帧率。
         */
        get frame(): FrameOverTime;
        /**
         * @en The start frame rate.
         * @zh 开始帧率。
         */
        get startFrame(): StartFrame;
        /**
         * @en Creates an instance of the `TextureSheetAnimation` class.
         * @param frame Animation frames.
         * @param  startFrame Start frame.
         * @zh 创建一个 `TextureSheetAnimation` 类的实例。
         * @param frame 动画帧。
         * @param  startFrame 开始帧。
         */
        constructor(frame: FrameOverTime, startFrame: StartFrame);
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: TextureSheetAnimation): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en The `VelocityOverLifetime` class is used for particle velocity over its lifetime.
     * @zh `VelocityOverLifetime` 类用于控制粒子在生命周期内的速度变化。
     */
    class VelocityOverLifetime implements IClone {
        /**
         * @en Whether to enable.
         * @zh 是否启用*/
        enable: boolean;
        /**
         * @en Velocity space, 0 for local, 1 for world.
         * @zh 速度空间，0 表示局部空间，1 表示世界空间。
         */
        space: number;
        /**
         * @en The gradient velocity.
         * @zh 渐变速度。
         */
        get velocity(): GradientVelocity;
        /**
         * @ignore
         * @en Creates an instance of `VelocityOverLifetime` class.
         * @param velocity gradient velocity.
         * @zh 创建一个 `VelocityOverLifetime` 类的实例。
         * @param velocity 渐变速度。
         */
        constructor(velocity: GradientVelocity);
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: VelocityOverLifetime): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en ShuriKenParticle3D is a class of 3D particle system.
     * @zh ShuriKenParticle3D 是3D粒子系统的类。
     */
    class ShuriKenParticle3D extends RenderableSprite3D {
        /**
         * @en The particle system.
         * @zh 粒子系统。
         */
        get particleSystem(): ShurikenParticleSystem;
        /**
         * @en The particle renderer.
         * @zh 粒子渲染器。
         */
        get particleRenderer(): ShurikenParticleRenderer;
        /**
         * @ignore
         * @en creates an instance of the ShuriKenParticle3D class.
         * @zh 创建Particle3D类的实例。
         */
        constructor();
        /**
         * @override
         * @en Destroy this object.
         * @param	destroyChild Whether to destroy the child node. If true, the child node will be destroyed, otherwise it will not be destroyed.
         * @zh 销毁此对象。
         * @param	destroyChild 是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * @en ShurikenParticleInstanceSystem class is used to implement instanced particle rendering.
     * @zh ShurikenParticleInstanceSystem 类用于实现实例化粒子渲染。
     */
    class ShurikenParticleInstanceSystem extends ShurikenParticleSystem {
        private _instanceParticleVertexBuffer;
        private _instanceVertex;
        private _meshIndexCount;
        private _meshFloatCountPreVertex;
        /**
         * 每个粒子数据 float 个数
         */
        private _floatCountPerParticleData;
        /**
         * @ignore
         * @en creates an instance of ShurikenParticleInstanceSystem class.
         * @param render The ShurikenParticleRenderer associated with this particle system.
         * @zh 创建 ShurikenParticleInstanceSystem 类的实例。
         * @param render 与该粒子系统关联的 ShurikenParticleRenderer。
         */
        constructor(render: ShurikenParticleRenderer);
        /***
         * 重排 mesh vb
         */
        private _initMeshVertex;
        /**
         * @en Initialize buffer
         * @zh 初始化 buffer
         */
        _initBufferDatas(): void;
        protected _retireActiveParticles(): void;
        protected _freeRetiredParticles(): void;
        /**
         * @en Add a new particle to the particle system.
         * @param position The initial position of the particle.
         * @param direction The initial direction of the particle.
         * @param time The current simulation time.
         * @returns Whether the particle was successfully added.
         * @zh 向粒子系统添加一个新粒子。
         * @param position 粒子的初始位置。
         * @param direction 粒子的初始方向。
         * @param time 当前的模拟时间。
         * @returns 粒子是否成功添加。
         */
        addParticle(position: Vector3, direction: Vector3, time: number, elapsedTime: number): boolean;
        /**
         * @en Update the render parameters for the particle system.
         * @param stage The current render context.
         * @zh 更新粒子系统的渲染参数。
         * @param stage 当前渲染上下文。
         */
        _updateRenderParams(stage: RenderContext3D): void;
        /**
         * @en Destroy the particle system and release resources.
         * @zh 销毁粒子系统并释放资源。
         */
        destroy(): void;
    }
    /**
     * @en ShurikenParticleMaterial class is used to implement particle materials.
     * @zh ShurikenParticleMaterial 类用于实现粒子材质。
     */
    class ShurikenParticleMaterial extends Material {
        /**
         * @en Render mode for transparent blending.
         * @zh 渲染状态_透明混合。
         */
        static RENDERMODE_ALPHABLENDED: number;
        /**
         * @en Render mode for additive blending.
         * @zh 渲染状态_加色法混合。
         */
        static RENDERMODE_ADDTIVE: number;
        /**
         * @en Default material, modification prohibited.
         * @zh 默认材质，禁止修改。
         */
        static defaultMaterial: ShurikenParticleMaterial;
        /**
         * @en Color of the particle material.
         * @zh 粒子材质的颜色。
         */
        get color(): Color;
        set color(value: Color);
        /**
         * @en Texture tiling and offset.
         * @zh 纹理平铺和偏移。
         */
        get tilingOffset(): Vector4;
        set tilingOffset(value: Vector4);
        /**
         * @en Diffuse texture.
         * @zh 漫反射贴图。
         */
        get texture(): BaseTexture;
        set texture(value: BaseTexture);
        /**
         * @ignore
         * @en creates a new instance of the ShurikenParticleMaterial class.
         * @zh 创建ShurikenParticleMaterial类的新实例。
         */
        constructor();
        /**
         * @override
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
        /**
         * @deprecated
         * 渲染模式。
         */
        set renderMode(value: number);
        /**
         * @deprecated
         * 纹理平铺和偏移X分量。
         */
        get tilingOffsetX(): number;
        set tilingOffsetX(x: number);
        /**
         * @deprecated
         * 纹理平铺和偏移Y分量。
         */
        get tilingOffsetY(): number;
        set tilingOffsetY(y: number);
        /**
         * @deprecated
         * 纹理平铺和偏移Z分量。
         */
        get tilingOffsetZ(): number;
        set tilingOffsetZ(z: number);
        /**
         * @deprecated
         * 纹理平铺和偏移W分量。
         */
        get tilingOffsetW(): number;
        set tilingOffsetW(w: number);
        /**
         * @deprecated
         * 颜色R分量。
         */
        get colorR(): number;
        set colorR(value: number);
        /**
         * @deprecated
         * 颜色G分量。
         */
        get colorG(): number;
        set colorG(value: number);
        /**
         * @deprecated
         * 颜色B分量。
         */
        get colorB(): number;
        set colorB(value: number);
        /**
         * @deprecated
         * 颜色Z分量。
         */
        get colorA(): number;
        set colorA(value: number);
    }
    /**
     * @en The `ShurikenParticleRenderer` class is used to create 3D particle renderers.
     * @zh `ShurikenParticleRenderer` 类用于创建3D粒子渲染器。
     */
    class ShurikenParticleRenderer extends BaseRender {
        /**
         * @en Gravity value.
         * @zh 重力值。
         */
        static gravity: Vector3;
        private _dragConstant;
        /**
         * @en Scale of camera speed in stretched billboard mode (currently not supported).
         * @zh 拉伸广告牌模式摄像机速度缩放（暂不支持）。
         */
        stretchedBillboardCameraSpeedScale: number;
        /**
         * @en Speed scale in stretched billboard mode.
         * @zh 拉伸广告牌模式速度缩放。
         */
        stretchedBillboardSpeedScale: number;
        /**
         * @en Length scale in stretched billboard mode.
         * @zh 拉伸广告牌模式长度缩放。
         */
        stretchedBillboardLengthScale: number;
        /**
         * @en The particle management system.
         * @zh 粒子管理系统。
         */
        get particleSystem(): ShurikenParticleSystem;
        /**
         * @en The render mode. 0: BILLBOARD, 1: STRETCHEDBILLBOARD, 2: HORIZONTALBILLBOARD, 3: VERTICALBILLBOARD, 4: MESH.
         * @zh 渲染模式。0：粒子始终面向摄像机。、1：粒子面向摄像机，但会应用各种缩放、2：粒子平面与 XZ“地板”平面平行、3：粒子在世界 Y 轴上直立，但转向面向摄像机、4：从 3D 网格而非从纹理渲染粒子。。
         */
        get renderMode(): number;
        set renderMode(value: number);
        /**
         * @en The Mesh used in mesh render mode. Effective when renderMode is 4.
         * @zh 网格渲染模式所使用的Mesh。renderMode为4时生效。
         */
        get mesh(): Mesh;
        set mesh(value: Mesh);
        /**
         * @ignore
         * @en Creates a new instance of ShurikenParticleRender class.
         * @zh 创建ShurikenParticleRender类的新实例。
         */
        constructor();
        /**
         * @override
         */
        protected _getcommonUniformMap(): Array<string>;
        /**
        * @override
        */
        protected _onAdded(): void;
        /**
        * @override
        */
        protected _onEnable(): void;
        /**
        * @override
        */
        protected _onDisable(): void;
        /**
         * @perfTag PerformanceDefine.T_ShurikenUpdate
         * @en Update the render state.
         * @param context The render context.
         * @zh 更新渲染状态。
         * @param context 渲染上下文。
         */
        renderUpdate(context: RenderContext3D): void;
        /**
         * @override
         * @en The bounding box. Read-only, not allowed to modify its value.
         * @zh 包围盒。只读，不允许修改其值。
         */
        get bounds(): Bounds;
        protected _onDestroy(): void;
        protected _statAdd(): void;
        protected _statRemove(): void;
    }
    /**
     * @en The ShurikenParticleSystem class is used to create 3D particle data templates.
     * @zh ShurikenParticleSystem 类用于创建3D粒子数据模板。
     */
    class ShurikenParticleSystem extends GeometryElement implements IClone {
        protected _emissionLastPosition: Vector3;
        /**
         * @en Total duration of particle system runtime, in seconds.
         * @zh 粒子运行的总时长，单位为秒。
         */
        duration: number;
        /**
         * @en Whether the particle system is looping.
         * @zh 是否循环。
         */
        looping: boolean;
        /**
         * @en Whether to prewarm the particle system. Currently not supported.
         * @zh 是否预热。暂不支持。
         */
        prewarm: boolean;
        /**
         * @en Start delay type. 0 for constant mode, 1 for random between two constants. Cannot be used with prewarm.
         * @zh 开始延迟类型，0为常量模式，1为随机双常量模式。不能和prewarm一起使用。
         */
        startDelayType: number;
        /**
         * @en Start play delay. Cannot be used with prewarm.
         * @zh 开始播放延迟。不能和prewarm一起使用。
         */
        startDelay: number;
        /**
         * @en Minimum start play delay. Cannot be used with prewarm.
         * @zh 开始播放最小延迟。不能和prewarm一起使用。
         */
        startDelayMin: number;
        /**
         * @en Maximum start play delay. Cannot be used with prewarm.
         * @zh 开始播放最大延迟。不能和prewarm一起使用。
         */
        startDelayMax: number;
        /**
         * @en Start speed mode. 0 for constant speed, 2 for random between two constants. Modes 1 and 3 are missing.
         * @zh 开始速度模式。0为恒定速度，2为两个恒定速度的随机插值。缺少1、3模式。
         */
        startSpeedType: number;
        /**
         * @en Start speed for mode 0.
         * @zh 开始速度，0模式。
         */
        startSpeedConstant: number;
        /**
         * @en Minimum start speed for mode 1.
         * @zh 最小开始速度，1模式。
         */
        startSpeedConstantMin: number;
        /**
         * @en Maximum start speed for mode 1.
         * @zh 最大开始速度，1模式。
         */
        startSpeedConstantMax: number;
        /**
         * @en Drag type. 0 for constant speed, 2 for random between two constants.
         * @zh 阻力模式。0为恒定速度，2为两个恒定速度的随机插值。
         */
        dragType: number;
        /**
         * @en Constant drag for mode 0.
         * @zh 恒定阻力，0模式。
         */
        dragConstant: number;
        /**
         * @en Minimum drag speed for mode 1.
         * @zh 最小阻力速度，1模式。
         */
        dragSpeedConstantMin: number;
        /**
         * @en Maximum drag speed for mode 1.
         * @zh 最大阻力速度，1模式。
         */
        dragSpeedConstantMax: number;
        /**
         * @en Whether the start size is in 3D mode.
         * @zh 开始尺寸是否为3D模式。
         */
        threeDStartSize: boolean;
        /**
         * @en Start size mode. 0 for constant size, 2 for random between two constants. Modes 1 and 3 and corresponding 3D modes are missing.
         * @zh 开始尺寸模式。0为恒定尺寸，2为两个恒定尺寸的随机插值。缺少1、3模式和对应的两种3D模式。
         */
        startSizeType: number;
        /**
         * @en Start size for mode 0.
         * @zh 开始尺寸，0模式。
         */
        startSizeConstant: number;
        /**
         * @en Start 3D size for mode 0.
         * @zh 开始三维尺寸，0模式。
         */
        startSizeConstantSeparate: Vector3;
        /**
         * @en Minimum start size for mode 2.
         * @zh 最小开始尺寸，2模式。
         */
        startSizeConstantMin: number;
        /**
         * @en Maximum start size for mode 2.
         * @zh 最大开始尺寸，2模式。
         */
        startSizeConstantMax: number;
        /**
         * @en Minimum 3D start size for mode 2.
         * @zh 最小三维开始尺寸，2模式。
         */
        startSizeConstantMinSeparate: Vector3;
        /**
         * @en Maximum 3D start size for mode 2.
         * @zh 最大三维开始尺寸，2模式。
         */
        startSizeConstantMaxSeparate: Vector3;
        /**
         * @en Whether to use 3D start rotation.
         * @zh 是否使用3D开始旋转。
         */
        threeDStartRotation: boolean;
        /**
         * @en Start rotation mode. 0 for constant rotation, 2 for random between two constants. Two modes and corresponding four 3D modes are missing.
         * @zh 开始旋转模式。0为恒定旋转，2为两个恒定旋转的随机插值。缺少2种模式和对应的四种3D模式。
         */
        startRotationType: number;
        /**
         * @en Start rotation for mode 0.
         * @zh 开始旋转，0模式。
         */
        startRotationConstant: number;
        /**
         * @en Start 3D rotation for mode 0.
         * @zh 开始三维旋转，0模式。
         */
        startRotationConstantSeparate: Vector3;
        /**
         * @en Minimum start rotation for mode 1.
         * @zh 最小开始旋转，1模式。
         */
        startRotationConstantMin: number;
        /**
         * @en Maximum start rotation for mode 1.
         * @zh 最大开始旋转，1模式。
         */
        startRotationConstantMax: number;
        /**
         * @en Minimum start 3D rotation for mode 1.
         * @zh 最小开始三维旋转，1模式。
         */
        startRotationConstantMinSeparate: Vector3;
        /**
         * @en Maximum start 3D rotation for mode 1.
         * @zh 最大开始三维旋转，1模式。
         */
        startRotationConstantMaxSeparate: Vector3;
        /**
         * @en Random rotation direction, range from 0.0 to 1.0.
         * @zh 随机旋转方向，范围为0.0到1.0。
         */
        randomizeRotationDirection: number;
        /**
         * @en Start color mode. 0 for constant color, 2 for random between two constant colors. Two modes are missing.
         * @zh 开始颜色模式。0为恒定颜色，2为两个恒定颜色的随机插值。缺少2种模式。
         */
        startColorType: number;
        /**
         * @en Start color for mode 0.
         * @zh 开始颜色，0模式。
         */
        startColorConstant: Vector4;
        /**
         * @en Minimum start color for mode 1.
         * @zh 最小开始颜色，1模式。
         */
        startColorConstantMin: Vector4;
        /**
         * @en Maximum start color for mode 1.
         * @zh 最大开始颜色，1模式。
         */
        startColorConstantMax: Vector4;
        /**
         * @en Gravity modifier.
         * @zh 重力敏感度。
         */
        gravityModifier: number;
        /**
         * @en Simulation space. 0 for World, 1 for Local. Custom is currently not supported.
         * @zh 模拟器空间。0为World，1为Local。暂不支持Custom。
         */
        simulationSpace: number;
        /**
         * @en Playback speed of particles.
         * @zh 粒子的播放速度。
         */
        simulationSpeed: number;
        /**
         * @en Scale mode. 0 for Hierarchy (world), 1 for Local, 2 for World.
         * @zh 缩放模式。0为Hierarchy (world)，1为Local，2为World。
         */
        scaleMode: number;
        /**
         * @en Whether to play automatically when activated.
         * @zh 激活时是否自动播放。
         */
        playOnAwake: boolean;
        /**
         * @en Random seed. Note: Effective when set before play().
         * @zh 随机种子。注：在play()之前设置有效。
         */
        randomSeed: Uint32Array;
        /**
         * @en Whether to use a random seed.
         * @zh 是否使用随机种子。
         */
        autoRandomSeed: boolean;
        /**
         * @en Whether it's in performance mode. In performance mode, particle release will be delayed.
         * @zh 是否为性能模式。性能模式下会延迟粒子释放。
         */
        isPerformanceMode: boolean;
        /**
         * @en Maximum number of particles
         * @zh 最大粒子数。
         */
        get maxParticles(): number;
        set maxParticles(value: number);
        /**
         * @en Emission.
         * @zh 发射器。
         */
        get emission(): Emission;
        /**
         * @en Number of alive particles
         * @zh 粒子存活个数。
         */
        get aliveParticleCount(): number;
        /**
         * @en Accumulated time within one cycle.
         * @zh 一次循环内的累计时间。
         */
        get emissionTime(): number;
        /**
         * @en Particle shape
         * @zh 粒子形状。
         */
        get shape(): BaseShape;
        set shape(value: BaseShape);
        /**
         * @en If the particle system is still alive.
         * @zh 粒子系统是否仍然存活。
         */
        get isAlive(): boolean;
        /**
         * @en If the particle system is currently emitting particles.
         * @zh 粒子系统是否正在发射粒子。
         */
        get isEmitting(): boolean;
        /**
         * @en If the particle system is currently playing.
         * @zh 粒子系统是否正在播放。
         */
        get isPlaying(): boolean;
        /**
         * @en If the particle system is currently paused.
         * @zh 粒子系统是否已暂停。
         */
        get isPaused(): boolean;
        /**
         * @en The lifectime mode of particles. 0: Constant, 1: Gradient, 2: Random Between Two Constants, 3: Random Between Two Gradients.
         * @zh 粒子的生命周期模式。0: 固定时间, 1: 渐变时间, 2: 两个固定值之间的随机插值, 3: 两个渐变时间的随机插值。
         */
        get startLifetimeType(): number;
        set startLifetimeType(value: number);
        /**
         * @en The lifecycle mode of particles: Constant(0), unit is seconds.
         * @zh 粒子生命周期模式：固定时间(模式0)，单位为秒。
         */
        get startLifetimeConstant(): number;
        set startLifetimeConstant(value: number);
        /**
         * @en The lifecycle mode of particles: Gradient(1), unit is seconds.
         * @zh 粒子生命周期模式：渐变时间(模式1)，单位为秒。
         */
        get startLifeTimeGradient(): GradientDataNumber;
        set startLifeTimeGradient(value: GradientDataNumber);
        /**
         * @en The minimum particle lifecycle, the lifecycle mode of particles: Random Between Two Constants（2）, unit is seconds.
         * @zh 最小粒子生命周期，粒子生命周期模式: 两个固定值之间的随机插值(模式2)，单位为秒。
         */
        get startLifetimeConstantMin(): number;
        set startLifetimeConstantMin(value: number);
        /**
         * @en The maximum particle lifecycle, the lifecycle mode of particles: Random Between Two Constants（2）, unit is seconds.
         * @zh 最大粒子生命周期，粒子生命周期模式: 两个固定值之间的随机插值(模式2)，单位为秒。
         */
        get startLifetimeConstantMax(): number;
        set startLifetimeConstantMax(value: number);
        /**
         * @en Minimum value of gradient time, the lifecycle mode of particles: Random Between Two Gradients（3）, unit is seconds.
         * @zh 渐变时间的最小值，粒子生命周期模式: 两个渐变时间的随机插值(模式3)，单位为秒。
         */
        get startLifeTimeGradientMin(): GradientDataNumber;
        set startLifeTimeGradientMin(value: GradientDataNumber);
        /**
         * @en Maximum value of gradient time, the lifecycle mode of particles: Random Between Two Gradients（3）, unit is seconds.
         * @zh 渐变时间的最大值，粒子生命周期模式: 两个渐变时间的随机插值(模式3)，单位为秒。
         */
        get startLifeTimeGradientMax(): GradientDataNumber;
        set startLifeTimeGradientMax(value: GradientDataNumber);
        /**
         * @en The velocity over lifetime. Note: If you modify certain properties of this value, you need to reassign this property for it to take effect.
         * @zh 生命周期速度。注意：如修改该值的某些属性，需重新赋值此属性才可生效。
         */
        get velocityOverLifetime(): VelocityOverLifetime;
        set velocityOverLifetime(value: VelocityOverLifetime);
        /**
         * @en The color over lifetime. Note: If you modify certain properties of this value, you need to reassign this property for it to take effect.
         * @zh 生命周期颜色。注意：如修改该值的某些属性，需重新赋值此属性才可生效。
         */
        get colorOverLifetime(): ColorOverLifetime;
        set colorOverLifetime(value: ColorOverLifetime);
        /**
         * @en The size over lifetime. Note: If you modify certain properties of this value, you need to reassign this property for it to take effect.
         * @zh 生命周期尺寸。注意：如修改该值的某些属性，需重新赋值此属性才可生效。
         */
        get sizeOverLifetime(): SizeOverLifetime;
        set sizeOverLifetime(value: SizeOverLifetime);
        /**
         * @en The rotation over lifetime. Note: If you modify certain properties of this value, you need to reassign this property for it to take effect.
         * @zh 生命周期旋转。注意：如修改该值的某些属性，需重新赋值此属性才可生效。
         */
        get rotationOverLifetime(): RotationOverLifetime;
        set rotationOverLifetime(value: RotationOverLifetime);
        /**
         * @en The texture sheet animation over lifetime. Note: If you modify certain properties of this value, you need to reassign this property for it to take effect.
         * @zh 生命周期纹理动画。注意：如修改该值的某些属性，需重新赋值此属性才可生效。
         */
        get textureSheetAnimation(): TextureSheetAnimation;
        set textureSheetAnimation(value: TextureSheetAnimation);
        /**
         * @en Creates a new instance of the ParticleSystem class.
         * @param render The ShurikenParticleRenderer associated with this particle system.
         * @param meshTopology The topology used by the mesh, default is MeshTopology.Triangles.
         * @param drawType The draw type used for rendering, default is DrawType.DrawElement.
         * @zh 创建ShuriknParticleSystem类的新实例。
         * @param render 与该粒子系统关联的 ShurikenParticleRenderer。
         * @param meshTopology 网格使用的拓扑结构，默认为 MeshTopology.Triangles。
         * @param drawType 用于渲染的绘制类型，默认为 DrawType.DrawElement。
         */
        constructor(render: ShurikenParticleRenderer, meshTopology?: MeshTopology, drawType?: DrawType);
        /**
         * @en Custom bounds
         * @zh 自定义 包围盒
         */
        get customBounds(): Bounds;
        set customBounds(value: Bounds);
        /**
         * @en Emits a particle.
         * @zh 发射一个粒子。
         */
        emit(time: number, elapsedTime: number): boolean;
        /**
         * @en Add a new particle to the particle system.
         * @param position The initial position of the particle.
         * @param direction The initial direction of the particle.
         * @param time The current simulation time.
         * @returns Whether the particle was successfully added.
         * @zh 向粒子系统添加一个新粒子。
         * @param position 粒子的初始位置。
         * @param direction 粒子的初始方向。
         * @param time 当前的模拟时间。
         * @returns 粒子是否成功添加。
         */
        addParticle(position: Vector3, direction: Vector3, time: number, elapsedTime: number): boolean;
        /**
         * @en Add new particles to the vertex buffer.
         * @zh 将新粒子添加到顶点缓冲区。
         */
        addNewParticlesToVertexBuffer(): void;
        /**
         * @inheritDoc
         * @override
         */
        _getType(): number;
        /**
         * @en Start emitting particles
         * @zh 开始发射粒子。
         */
        play(): void;
        /**
         * @en Pause emitting particles
         * @zh 暂停发射粒子。
         */
        pause(): void;
        /**
         * @en Advance the particle simulation by a specified time and pause playback.
         * @param time The time to advance the simulation. If restart is true, the particle playback time will be reset to zero before updating progress.
         * @param restart Whether to reset the playback state. Default is true.
         * @zh 通过指定时间增加粒子播放进度，并暂停播放。
         * @param time 进度时间。如果restart为true，粒子播放时间会归零后再更新进度。
         * @param restart 是否重置播放状态。默认为true。
         */
        simulate(time: number, restart?: boolean): void;
        /**
         * @en Stop emitting particles.
         * @zh 停止发射粒子。
         */
        stop(): void;
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: ShurikenParticleSystem): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en The `PixelLineData` class is used to represent line data.
     * @zh `PixelLineData` 类用于表示线数据。
     */
    class PixelLineData {
        /**
         * @en The starting position of the line.
         * @zh 线的起始位置。
         */
        startPosition: Vector3;
        /**
         * @en The ending position of the line.
         * @zh 线的结束位置。
         */
        endPosition: Vector3;
        /**
         * @en The color at the start of the line.
         * @zh 线的起始颜色。
         */
        startColor: Color;
        /**
         * @en The color at the end of the line.
         * @zh 线的结束颜色。
         */
        endColor: Color;
        /**
         * @en Line start normal
         * @zh 线开始法线
         */
        startNormal: Vector3;
        /**
         * @en Line end normal
         * @zh 线结束法线
         */
        endNormal: Vector3;
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: PixelLineData): void;
    }
    /**
     * @en The `PixelLineFilter` class is used for line filtering.
     * @zh `PixelLineFilter` 类用于线过滤器。
     */
    class PixelLineFilter extends GeometryElement {
        /**
         * @ignore
         * @en initialize pixeLineFilter instance.
         * @param owner The rendering sprite node.
         * @param maxLineCount The maximum line count.
         * @zh 初始化pixeLineFilter实例。
         * @param owner 渲染精灵节点。
         * @param maxLineCount 最大线段数量。
         */
        constructor(owner: PixelLineRenderer, maxLineCount: number);
        /**
         * @en Get the line segment data.
         * @param index The index of the line segment.
         * @param out The output PixelLineData object.
         * @zh 获取线段数据。
         * @param index 线段的索引。
         * @param out 输出的PixelLineData对象。
         */
        _getLineData(index: number, out: PixelLineData): void;
        /**
         * @inheritDoc
         * @override
         * @en Destroy the PixelLineFilter instance.
         * @zh 销毁PixelLineFilter实例。
         */
        destroy(): void;
    }
    /**
     * @en The PixelLineMaterial class is used to implement pixel line material.
     * @zh PixelLineMaterial 类用于实现像素线材质。
     */
    class PixelLineMaterial extends Material {
        /**
         * @en Default material, no modification allowed
         * @zh 默认材质，禁止修改
         */
        static defaultMaterial: Material;
        /**
         * @en The color of the pixel line.
         * @zh 像素线的颜色。
         */
        get color(): Vector4;
        set color(value: Vector4);
        /**
         * @ignore
         * @en Initialize PixelLineMaterial instance.
         * @zh 初始化PixelLineMaterial实例
         */
        constructor();
    }
    /**
     * @en PixelLineRenderer class for line rendering.
     * @zh PixelLineRenderer 类用于线渲染器。
     */
    class PixelLineRenderer extends BaseRender {
        /** @private 是否调用active */
        private _isRenderActive;
        /** @private 是否加入渲染队列*/
        private _isInRenders;
        private _needUpdatelines;
        /**
         * @ignore
         * @en Initialize PixelLineRenderer instance.
         * @zh 初始化PixelLineRenderer实例。
         */
        constructor();
        /**
         * @en The bounds of the line renderer.
         * @zh 线渲染器的包围盒。
         */
        get bounds(): Bounds;
        private _lines;
        /**
         * @en The line segment data.
         * @zh 线段数据。
         */
        get pixelLinesDatas(): PixelLineData[];
        set pixelLinesDatas(value: PixelLineData[]);
        /**
         * @en The maximum number of lines.
         * @zh 最大线数量。
         */
        get maxLineCount(): number;
        set maxLineCount(value: number);
        /**
         * @en The current number of lines.
         * @zh 当前线数量。
         */
        get lineCount(): number;
        protected _createBaseRenderNode(): IMeshRenderNode;
        /**
         * @en Update the render context.
         * @param context The render context.
         * @zh 更新渲染上下文。
         * @param context 渲染上下文。
         */
        renderUpdate(context: RenderContext3D): void;
        /**
         * @en Add a line.
         * @param startPosition Initial point position
         * @param endPosition End point position
         * @param startColor Initial point color
         * @param endColor End point color
         * @zh 增加一条线。
         * @param startPosition 初始点位置
         * @param endPosition 结束点位置
         * @param startColor 初始点颜色
         * @param endColor 结束点颜色
         */
        addLine(startPosition: Vector3, endPosition: Vector3, startColor: Color, endColor: Color): void;
        /**
         * @en Add a line with normal.
         * @param startPosition Initial point position
         * @param endPosition End point position
         * @param startColor Initial point color
         * @param endColor End point color
         * @param startNormal Initial point normal
         * @param endNormal End point normal
         * @zh 增加一条带有法线的线。
         * @param startPosition 初始点位置
         * @param endPosition 结束点位置
         * @param startColor 初始点颜色
         * @param endColor 结束点颜色
         * @param startNormal 初始点法线
         * @param endNormal 结束点法线
         */
        addLineWithNormal(startPosition: Vector3, endPosition: Vector3, startColor: Color, endColor: Color, startNormal: Vector3, endNormal: Vector3): void;
        /**
         * @en Add multiple line segments.
         * @param lines Line segment data
         * @zh 添加多条线段。
         * @param lines 线段数据
         */
        addLines(lines: PixelLineData[]): void;
        /**
         * @en Remove a line segment.
         * @param index Index of the line to remove
         * @zh 移除一条线段。
         * @param index 线段索引。
         */
        removeLine(index: number): void;
        /**
         * @en Update a line.
         * @param index Index of the line to update
         * @param startPosition Initial point position
         * @param endPosition End point position
         * @param startColor Initial point color
         * @param endColor End point color
         * @zh 更新线。
         * @param index 线段索引。
         * @param startPosition 初始点位置。
         * @param endPosition 结束点位置。
         * @param startColor 初始点颜色。
         * @param endColor 结束点颜色。
         */
        setLine(index: number, startPosition: Vector3, endPosition: Vector3, startColor: Color, endColor: Color): void;
        /**
         * @en Update a line with normal.
         * @param index Index of the line to update
         * @param startPosition Initial point position
         * @param endPosition End point position
         * @param startColor Initial point color
         * @param endColor End point color
         * @param startNormal Initial point normal
         * @param endNormal End point normal
         * @zh 更新带有法线的线。
         * @param index 线段索引。
         * @param startPosition 初始点位置。
         * @param endPosition 结束点位置。
         * @param startColor 初始点颜色。
         * @param endColor 结束点颜色。
         * @param startNormal 初始点法线。
         * @param endNormal 结束点法线。
         */
        setLineWithNormal(index: number, startPosition: Vector3, endPosition: Vector3, startColor: Color, endColor: Color, startNormal: Vector3, endNormal: Vector3): void;
        /**
         * @en Get line segment data.
         * @param index Index of the line to get
         * @param out Output line segment data
         * @zh 获取线段数据。
         * @param index 线段索引。
         * @param out 线段数据。
         */
        getLine(index: number, out: PixelLineData): void;
        /**
         * @en Clear all line segments.
         * @zh 清除所有线段。
         */
        clear(): void;
    }
    /**
     * @en PixelLineSprite3D class is used for pixel line rendering sprites.
     * @zh PixelLineSprite3D 类用于像素线渲染精灵。
     */
    class PixelLineSprite3D extends RenderableSprite3D {
        _render: PixelLineRenderer;
        /** @private 是否调用active */
        private _isRenderActive;
        /** @private 是否加入渲染队列*/
        private _isInRenders;
        /**
         * @en The maximum line count.
         * @zh 最大线数量。
         */
        get maxLineCount(): number;
        set maxLineCount(value: number);
        /**
         * @en The current line count.
         * @zh 当前线数量。
         */
        get lineCount(): number;
        /**
         * @en The pixel line renderer.
         * @zh 像素线渲染器。
         */
        get pixelLineRenderer(): PixelLineRenderer;
        /**
         * @ignore
         * @en Initaialize pixelLineSprite3D instance.
         * @param maxCount Maximum number of line segments.
         * @param name Name of the instance.
         * @zh 初始化PixeLineSprite3D实例。
         * @param maxCount 最大线段数量。
         * @param name  实例的名称。
         */
        constructor(maxCount?: number, name?: string);
        /**
         * @en Add a single line.
         * @param startPosition  Start position of the line.
         * @param endPosition  End position of the line.
         * @param startColor  Start color of the line.
         * @param endColor  End color of the line.
         * @zh 增加一条线。
         * @param startPosition  线段起点位置。
         * @param endPosition  线段终点位置。
         * @param startColor  线段起点颜色。
         * @param endColor  线段终点颜色。
         */
        addLine(startPosition: Vector3, endPosition: Vector3, startColor: Color, endColor: Color): void;
        /**
         * @en Add multiple line segments.
         * @param lines  Array of line segment data.
         * @zh 添加多条线段。
         * @param lines  线段数据
         */
        addLines(lines: PixelLineData[]): void;
        /**
         * @en Remove a line segment.
         * @param index Index of the line to remove.
         * @zh 移除一条线段。
         * @param index 要移除的线段索引。
         */
        removeLine(index: number): void;
        /**
         * @en Update a line segment.
         * @param index  Index of the line to update.
         * @param startPosition  New start position of the line.
         * @param endPosition  New end position of the line.
         * @param startColor - New start color of the line.
         * @param endColor  New end color of the line.
         * @zh 更新一条线段。
         * @param index  要更新的线段索引。
         * @param startPosition  新的线段起点位置。
         * @param endPosition  新的线段终点位置。
         * @param startColor  新的线段起点颜色。
         * @param endColor  新的线段终点颜色。
         */
        setLine(index: number, startPosition: Vector3, endPosition: Vector3, startColor: Color, endColor: Color): void;
        /**
         * @en Get line segment data.
         * @param index  Index of the line to get.
         * @param out  Output object to store the line data.
         * @zh 获取线段数据。
         * @param index  要获取的线段索引。
         * @param out  输出对象，用于存储线段数据。
         */
        getLine(index: number, out: PixelLineData): void;
        /**
         * @en Clear all line segments.
         * @zh 清除所有线段。
         */
        clear(): void;
    }
    /**
     * @en The `QuaternionKeyframe` class is used to create quaternion keyframe instances.
     * @zh `QuaternionKeyframe` 类用于创建四元数关键帧实例。
     */
    class QuaternionKeyframe extends Keyframe {
        /**
         * @en In-tangent of the keyframe
         * @zh 内切线
         */
        inTangent: Vector4;
        /**
         * @en Out-tangent of the keyframe
         * @zh 外切线
         */
        outTangent: Vector4;
        /**
         * @en Frame data (quaternion value)
         * @zh 帧数据（四元数值）
         */
        value: Quaternion;
        /**
         * @en In-weight of the keyframe
         * @zh 内权重
         */
        inWeight: Vector4;
        /**
         * @en Out-weight of the keyframe
         * @zh 外权重
         */
        outWeight: Vector4;
        /**
         * @en Weight mode of the keyframe
         * @zh 权重模式
         */
        weightedMode: Vector4;
        /**
         * @en Creates an instance of `QuaternionKeyframe`.
         * @param weightMode Whether to enable weight mode
         * @zh 创建一个 `QuaternionKeyframe` 的实例。
          * @param weightMode 是否启用权重模式
         */
        constructor(weightMode?: boolean);
        /**
         * @override
        * @en Clone the QuaternionKeyframe.
        * @param dest The target object to clone to
        * @zh 克隆。
        * @param dest 克隆源。
        */
        cloneTo(dest: QuaternionKeyframe): void;
    }
    enum RenderBitFlag {
        RenderBitFlag_CullFlag = 0,
        RenderBitFlag_Batch = 1,
        RenderBitFlag_Editor = 2,
        RenderBitFlag_InstanceBatch = 3,
        RenderBitFlag_VertexMergeBatch = 4
    }
    enum IrradianceMode {
        LightMap = 0,
        VolumetricGI = 1,
        Common = 2
    }
    /**
     * @en The `BaseRender` class is the parent class for renderers and is an abstract class that should not be instantiated.
     * @zh `BaseRender` 类是渲染器的父类，是一个抽象类，不允许实例化。
     */
    class BaseRender extends Component {
        /**
         * @en Initialize the BaseRender class.
         * @zh 初始化 BaseRender 类。
         */
        static __init__(): void;
        /**
         * @en Change vertex shader definitions based on mesh changes.
         * @param oldMesh The old mesh.
         * @param mesh The new mesh.
         * @param defineDatas The shader data containing definitions.
         * @zh 根据网格变化更改顶点着色器宏定义。
         * @param oldMesh 旧的网格。
         * @param mesh 新的网格。
         * @param defineDatas 包含着色器定义的着色器数据。
         */
        static changeVertexDefine(oldMesh: Mesh, mesh: Mesh, defineDatas: ShaderData): void;
        /**
         * @en Macro definition initialization
         * @zh 宏定义初始化
         */
        static shaderValueInit(): void;
        /**@interface */
        _receiveShadow: boolean;
        _renderElements: RenderElement[];
        /**
         * @en Whether to enable the renderer.
         * @zh 是否启用。
         */
        get enabled(): boolean;
        set enabled(value: boolean);
        /**
         * @en The sorting fudge value.
         * @zh 排序矫正值。
         */
        get sortingFudge(): number;
        set sortingFudge(value: number);
        /**
         * @en The render bit flag of the render node.
         * @zh 渲染节点的渲染禁用位。
         */
        get renderbitFlag(): number;
        /**
         * @en Whether the bounds have changed.
         * @zh 包围盒是否更新。
         */
        get boundsChange(): boolean;
        set boundsChange(value: boolean);
        /**
         * 渲染数据
         */
        /**
         * @en The render node.
         * @zh 渲染节点。
         */
        get renderNode(): IBaseRenderNode;
        /**
         * @en The distance used for sorting.
         * @zh 排序距离。
         */
        get distanceForSort(): number;
        set distanceForSort(value: number);
        /**
         * @en The Geometry Bounds.
         * If this bounds is set, the render bounding box will be updated based on geometryBounds and transform, and the native layer will be sunk.
         * @zh 几何包围盒，
         * 如果设置了此包围盒，渲染包围盒会根据 geometryBounds 和变换来更新，并且原生层会下沉。
         */
        get geometryBounds(): Bounds;
        set geometryBounds(value: Bounds);
        /**
         * @en The lightmap index.
         * @zh 光照贴图的索引。
         */
        get lightmapIndex(): number;
        set lightmapIndex(value: number);
        /**
         * @en The irradient mode.
         * @zh 间接光照功能。
         */
        get irradientMode(): IrradianceMode;
        /**
         * @en The lightmap scale and offset.
         * @zh 光照贴图的缩放和偏移。
         */
        get lightmapScaleOffset(): Vector4;
        set lightmapScaleOffset(value: Vector4);
        /**
         * @en The first material.
         * @zh 第一个材质。
         */
        get sharedMaterial(): Material;
        set sharedMaterial(value: Material);
        /**
         * @en All shared materials.
         * @zh 所有渲染材质。
         */
        get sharedMaterials(): Material[];
        set sharedMaterials(value: Material[]);
        /**
         * @en The bounds. Read-only, do not modify its value.
         * @zh 包围盒。只读，不允许修改其值。
         */
        get bounds(): Bounds;
        /**
         * @en Whether the object receives shadows.
         * @zh 是否接收阴影属性。
         */
        get receiveShadow(): boolean;
        set receiveShadow(value: boolean);
        /**
         * @en Whether the object casts shadows.
         * @zh 是否产生阴影。
         */
        get castShadow(): boolean;
        set castShadow(value: boolean);
        /**
         * @en The reflection mode.
         * @zh 反射模式。
         */
        get reflectionMode(): ReflectionProbeMode;
        set reflectionMode(value: ReflectionProbeMode);
        /**
         * @en The volume light probe.
         * @zh 体积光探针。
         */
        get volume(): Volume;
        set volume(value: Volume);
        set probReflection(value: ReflectionProbe);
        /**
         * @en The light probe.
         * @zh 光照探针。
         */
        get lightProbe(): VolumetricGI;
        set lightProbe(volumetricGI: VolumetricGI);
        /**
         * @ignore
         * @en consructor of BaseRender.
         * @zh 构造函数，初始化BaseRender。
         */
        constructor();
        /**
         * @en The function called by the bounding box calculation for each frame.
         * @zh 每一帧计算包围盒会调用的函数
         */
        _calculateBoundingBox?(): void;
        /**
         * @en Update the calling function of SpriteShaderData before rendering each frame.
         * @param context3D The 3D rendering context.
         * @zh 每一帧渲染前更新SpriteShaderData的调用函数。
         * @param context3D 3D渲染上下文。
         */
        _renderUpdate?(context3D: IRenderContext3D): void;
        /**
         * set BaseRenderElement
         * @param mesh
         */
        protected _setRenderElements(): void;
        /**
         * @protected
         * @param context
         */
        renderUpdate(context: RenderContext3D): void;
        protected _statAdd(): void;
        protected _statRemove(): void;
        /**
         * @en Sets the rendering flag, where each bit represents a different culling reason, 1 indicates LOD culling.
         * @param flag The flag to set, refer to RenderBitFlag for related flags or define custom bit flags.
         * @param pass Whether to set the flag.
         * @zh 设置渲染标志，每一位都代表不同的淘汰原因，1表示LOD淘汰。
         * @param flag 标记，可以查RenderBitFlag相关，也可以自定义标签位
         * @param pass 设置标签值
         */
        setRenderbitFlag(flag: number, pass: boolean): void;
        /**
         * @deprecated 请使用shareMaterial接口
         * 返回第一个实例材质,第一次使用会拷贝实例对象。
         */
        get material(): Material;
        set material(value: Material);
        set materials(value: Material[]);
    }
    /**
     * @en Class used for creating instructions to output from a render source to a render target.
     * @zh 类用于创建从渲染源输出到渲染目标的指令。
     */
    class BlitFrameBufferCMD {
        /**
         * @en Create a render command set.
         * @param source The source texture.
         * @param dest The destination render texture.
         * @param viewport The viewport for rendering.
         * @param offsetScale The offset and scale vector. Default is null.
         * @param shader The shader to use. Default is null.
         * @param shaderData The shader data to use. Default is null.
         * @param subShader The sub-shader index. Default is 0.
         * @returns The created BlitFrameBufferCMD instance.
         * @zh 创建渲染命令集。
         * @param source 源纹理。
         * @param dest 目标渲染纹理。
         * @param viewport 渲染视口。
         * @param offsetScale 偏移和缩放向量。默认为 null。
         * @param shader 要使用的着色器。默认为 null。
         * @param shaderData 要使用的着色器数据。默认为 null。
         * @param subShader 子着色器索引。默认为 0。
         * @returns 创建的 BlitFrameBufferCMD 实例。
         */
        static create(source: BaseTexture, dest: RenderTexture, viewport: Viewport, offsetScale?: Vector4, shader?: Shader3D, shaderData?: ShaderData, subShader?: number): BlitFrameBufferCMD;
        constructor();
        /**
         * @en The shader data for the command.
         * @zh 命令的着色器数据。
         */
        set shaderData(value: ShaderData);
        /**
         * @en Set the shader, sub-shader, and shader data for the command.
         * @param shader The shader to set. If null, uses the default screen shader.
         * @param subShader The sub-shader index. Default is 0.
         * @param shaderData The shader data to set.
         * @zh 设置命令的着色器、子着色器和着色器数据。
         * @param shader 要设置的着色器。如果为 null，则使用默认屏幕着色器。
         * @param subShader 子着色器索引。默认为 0。
         * @param shaderData 要设置的着色器数据。
         */
        setshader(shader: Shader3D, subShader: number, shaderData: ShaderData): void;
        /**
         * @inheritDoc
         * @override
         * @en Execute the render command.
         * @zh 执行渲染命令。
         */
        run(): void;
        /**
         * @inheritDoc
         * @override
         * @en Recycle the command instance.
         * @zh 回收命令实例。
         */
        recover(): void;
    }
    /**
     * @en The BlitScreenQuadCMD class is used to create render the source texture to the destination render texture by using the full screen quad command.
     * @zh BlitScreenQuadCMD 类用于创建通过全屏四边形将源纹理渲染到目标渲染纹理的指令
     */
    class BlitScreenQuadCMD extends Command {
        /**
         * @en Create command stream
         * @param source  The source texture. If set to null, it will use the default RenderTexture from the Camera process.
         * @param dest  The destination texture. If set to null, it will use the default rendering target of the camera.
         * @param offsetScale  Offset scaling.
         * @param shader  The shader to use for rendering.
         * @param shaderData  The shader data for rendering.
         * @param subShader  The subShader index. Default is 0.
         * @param screenType  The screen type for rendering.
         * @param commandbuffer  The command buffer to use.
         * @zh 创建命令流
         * @param source 原始贴图 如果设置为null  将会使用默认的Camera流程中的原RenderTexture
         * @param dest 目标贴图 如果设置为null，将会使用默认的camera渲染目标
         * @param offsetScale 偏移缩放
         * @param shader 用于渲染的着色器。。
         * @param shaderData 用于渲染的着色器数据。
         * @param subShader subshader的节点
         * @param screenType 渲染的屏幕类型
         * @param commandbuffer 命令缓冲
         */
        static create(source: BaseTexture, dest: RenderTexture, offsetScale?: Vector4, shader?: Shader3D, shaderData?: ShaderData, subShader?: number, screenType?: number, commandbuffer?: CommandBuffer): BlitScreenQuadCMD;
        constructor();
        /**
         * @en The offset and scale for rendering.
         * @zh 渲染的偏移和缩放。
         */
        get offsetScale(): Vector4;
        set offsetScale(value: Vector4);
        /**
         * @en The destination render texture.
         * @zh 目标渲染纹理。
         */
        get dest(): RenderTexture;
        set dest(value: RenderTexture);
        /**
         * @en The shader data for rendering.
         * @zh 渲染的着色器数据。
         */
        set shaderData(value: ShaderData);
        /**
         * @inheritDoc
         * @override
         * @en Execute the command.
         * @zh 执行命令。
         */
        run(): void;
        /**
         * @inheritDoc
         * @override
         * @en Recover the command for reuse.
         * @zh 回收命令以重复使用。
         */
        recover(): void;
        /**
         * @en Destroy the command and release resources.
         * @zh 销毁命令并释放资源。
         */
        destroy(): void;
    }
    /**
     * @en The `Command` class is used to create commands.
     * @zh `Command` 类用于创建指令。
     */
    class Command {
        /**@ignore */
        constructor();
        /**
         * @en Organizes rendering commands.
         * @zh 组织渲染指令。
         */
        run?(): void;
        /**
         * @en Recycles the rendering command.
         * @zh 回收渲染指令。
         */
        recover(): void;
    }
    /**
     * @en The `CommandBuffer` Class used to create command buffer
     * @zh `CommandBuffer` 类用于创建命令缓冲区。
     */
    class CommandBuffer {
        static instance: CommandBuffer;
        /** @ignore */
        constructor(name?: string, shadowCaster?: boolean);
        /**
         * @en The name of the command buffer.
         * @zh 命令缓冲区的名称。
         */
        get name(): string;
        /**
         * @en Whether the command buffer casts shadows.
         * @zh 命令缓冲区是否投射阴影。
         */
        get casterShadow(): boolean;
        /**
         * @en The rendering context for the command buffer.
         * @zh 命令缓冲区的渲染上下文。
         */
        get context(): RenderContext3D;
        set context(value: RenderContext3D);
        /**
         * @en Executes all rendering commands.
         * @zh 调用所有渲染指令。
         */
        _apply(render?: boolean): void;
        /**
         * @en Executes a single command from the command buffer.
         * @zh 从命令缓冲区执行单个命令。
         */
        _applyOne(): boolean;
        /**
         * @en Gets the number of commands contained in the command buffer
         * @zh 获取命令缓冲区包含的命令数量
         */
        getCommandsSize(): number;
        /**
         * @en Sets the texture data for a shader.
         * @param shaderData The collection of shader data.
         * @param nameID The Uniform ID for the texture.
         * @param source The source of the texture.
         * @zh 设置着色器的纹理数据。
         * @param shaderData 着色器数据集合。
         * @param nameID 纹理的 Uniform ID。
         * @param source 纹理源。
         */
        setShaderDataTexture(shaderData: ShaderData, nameID: number, source: BaseTexture): void;
        /**
         * @en Sets the global texture data.
         * @param nameID The Uniform ID for the texture.
         * @param source The source of the texture.
         * @zh 设置全局纹理数据。
         * @param nameID 纹理的 Uniform ID。
         * @param source 纹理源。
         */
        setGlobalTexture(nameID: number, source: BaseTexture): void;
        /**
         * @en Sets the color data for a shader.
         * @param shaderData The collection of shader data.
         * @param nameID The ID of the data.
         * @param value The color value.
         * @zh 设置着色器的颜色数据。
         * @param shaderData 着色器数据集合。
         * @param nameID 数据 ID。
         * @param value 颜色值。
         */
        setShaderDataColor(shaderData: ShaderData, nameID: number, value: Color): void;
        /**
         * @en Sets the global color.
         * @param nameID The ID of the data.
         * @param source The color data to be set.
         * @zh 设置全局颜色。
         * @param nameID 数据ID。
         * @param source 要设置的颜色数据。
         */
        setGlobalColor(nameID: number, source: Color): void;
        /**
         * @en Sets the Vector4 data for a shader.
         * @param shaderData The collection of shader data.
         * @param nameID The ID of the data.
         * @param value The Vector4 data to be set.
         * @zh 设置着色器的 Vector4 数据。
         * @param shaderData 着色器数据集合。
         * @param nameID 数据ID
         * @param value 要设置的Vector4数据。
         */
        setShaderDataVector(shaderData: ShaderData, nameID: number, value: Vector4): void;
        /**
         * @en Sets the global Vector4 data.
         * @param nameID The ID of the data.
         * @param source The Vector4 data to be set.
         * @zh 设置全局 Vector4 数据。
         * @param nameID 数据ID
         * @param source 要设置的Vector4数据。
         */
        setGlobalVector(nameID: number, source: Vector4): void;
        /**
         * @en Sets the Vector3 data for a shader.
         * @param shaderData The collection of shader data.
         * @param nameID The ID of the data.
         * @param value The Vector3 data to be set.
         * @zh 设置着色器的 Vector3 数据。
         * @param shaderData 着色器数据集合。
         * @param nameID 数据ID
         * @param value 要设置的Vector3数据。
         */
        setShaderDataVector3(shaderData: ShaderData, nameID: number, value: Vector3): void;
        /**
         * @en Sets the global Vector3 data.
         * @param nameID The ID of the data.
         * @param source The Vector3 data to be set.
         * @zh 设置全局 Vector3 数据。
         * @param nameID 数据ID
         * @param source 要设置的Vector3数据。
         */
        setGlobalVector3(nameID: number, source: Vector3): void;
        /**
         * @en Sets the Vector2 data for a shader.
         * @param shaderData The collection of shader data.
         * @param nameID The ID of the data.
         * @param value The Vector2 data to be set.
         * @zh 设置着色器的 Vector2 数据。
         * @param shaderData 着色器数据集合。
         * @param nameID 数据ID
         * @param value 要设置的Vector2数据。
         */
        setShaderDataVector2(shaderData: ShaderData, nameID: number, value: Vector2): void;
        /**
         * @en Sets the global Vector2 data.
         * @param nameID The ID of the data.
         * @param source The Vector2 data to be set.
         * @zh 设置全局 Vector2 数据。
         * @param nameID 数据ID
         * @param source 要设置的Vector2数据。
         */
        setGlobalVector2(nameID: number, source: Vector2): void;
        /**
         * @en Sets the Number property for a shader.
         * @param shaderData The collection of shader data.
         * @param nameID The ID of the data.
         * @param value The Number data to be set.
         * @zh 设置着色器的 Number 属性。
         * @param shaderData 着色器数据集合。
         * @param nameID 数据ID
         * @param value 要设置的Number数据。
         */
        setShaderDataNumber(shaderData: ShaderData, nameID: number, value: number): void;
        /**
         * @en Sets the global Number property.
         * @param nameID The ID of the data.
         * @param source The Number data to be set.
         * @zh 设置全局 Number 属性。
         * @param nameID 数据ID
         * @param source 要设置的Number数据。
         */
        setGlobalNumber(nameID: number, source: number): void;
        /**
         * @en Sets the Int property for a shader.
         * @param shaderData The collection of shader data.
         * @param nameID The ID of the data.
         * @param value The Int data to be set.
         * @zh 设置着色器的 Int 属性。
         * @param shaderData 着色器数据集合。
         * @param nameID 数据ID
         * @param value 要设置的Int数据。
         */
        setShaderDataInt(shaderData: ShaderData, nameID: number, value: number): void;
        /**
         * @en Sets the global integer property.
         * @param nameID The ID of the data.
         * @param source The data to be set.
         * @zh 设置全局的整型属性。
         * @param nameID 数据ID
         * @param source 要设置的数据。
         */
        setGlobalInt(nameID: number, source: number): void;
        /**
         * @en Sets the Matrix property for a shader.
         * @param shaderData The collection of shader data.
         * @param nameID The ID of the data.
         * @param value The Matrix data to be set.
         * @zh 设置着色器的矩阵属性。
         * @param shaderData 着色器数据集合。
         * @param nameID 数据ID。
         * @param value 要设置的矩阵数据。
         */
        setShaderDataMatrix(shaderData: ShaderData, nameID: number, value: Matrix4x4): void;
        /**
         * @en Sets a shader define.
         * @param shaderData The collection of shader data.
         * @param define The shader define to be set.
         * @param value A boolean value indicating whether to add (true) or remove (false) the define.
         * @zh 设置着色器的定义。
         * @param shaderData 着色器数据集合。
         * @param define 要设置的着色器定义。
         * @param value 布尔值，表示是添加（true）还是移除（false）该定义。
         */
        setShaderDefine(shaderData: ShaderData, define: ShaderDefine, value: boolean): void;
        /**
         * @en Sets the global Matrix property.
         * @param nameID The ID of the data.
         * @param source The Matrix data to be set.
         * @zh 设置全局的矩阵属性。
         * @param nameID 数据ID
         * @param source 要设置的矩阵数据。
         */
        setGlobalMatrix(nameID: number, source: number): void;
        /**
         * @en Adds a fullscreen quad rendering command to the command buffer.
         * @param source The source texture. If null, the previous render result is used as the original texture.
         * @param dest The destination texture. If null, it renders directly to the final canvas.
         * @param offsetScale Offset scaling
         * @param shader The shader. If null, the internal copy shader is used without any processing.
         * @param shaderData The shader data. If null, only the sourceTexture is accepted.
         * @param subShader The subShader index, defaults to 0.
         * @zh 向命令缓冲区添加一条通过全屏四边形渲染命令。
         * @param source 源纹理。如果为null，则使用之前的渲染结果作为原纹理。
         * @param dest 目标纹理。如果为null，直接渲染到最终画布。
         * @param offsetScale 偏移缩放。
         * @param shader 着色器。如果为null，则使用内部拷贝着色器，不进行任何处理。
         * @param shaderData 着色器数据。如果为null，只接受sourceTexture。
         * @param subShader SubShader索引，默认值为0。
         */
        blitScreenQuad(source: BaseTexture, dest: RenderTexture, offsetScale?: Vector4, shader?: Shader3D, shaderData?: ShaderData, subShader?: number): void;
        /**
         * @en Add a command to render the source texture to the target texture through a full screen quadrilateral.
         * @param source The source texture. If null, the previous render result is used as the original texture.
         * @param dest The destination texture. If null, it renders directly to the final canvas.
         * @param offsetScale Offset scaling.
         * @param material The material.
         * @param subShader The shader index.
         * @zh 添加一条通过全屏四边形将源纹理渲染到目标渲染纹理指令。
         * @param source 源纹理。如果为null，则使用之前的渲染结果作为原纹理。
         * @param dest 目标纹理。如果为null，直接渲染到最终画布。
         * @param offsetScale 偏移缩放。
         * @param material 材质。
         * @param subShader Shader索引。
         */
        blitScreenQuadByMaterial(source: BaseTexture, dest: RenderTexture, offsetScale?: Vector4, material?: Material, subShader?: number): void;
        /**
         * @en Add a command to render the source texture to the target texture through full screen triangles.
         * @param source The source texture.
         * @param dest The destination texture.
         * @param offsetScale Offset scaling.
         * @param shader The shader. If null, the internal copy shader is used without any processing.
         * @param shaderData The shader data. If null, only the sourceTexture is accepted.
         * @param subShader The subShader index, defaults to 0.
         * @zh 添加一条通过全屏三角形将源纹理渲染到目标渲染纹理指令。
         * @param source 源纹理。
         * @param dest 目标纹理。
         * @param offsetScale 偏移缩放。
         * @param shader 着色器。如果为null，则使用内部拷贝着色器，不进行任何处理。
         * @param shaderData 着色器数据。如果为null，只接受sourceTexture。
         * @param subShader SubShader索引，默认值为0。
         */
        blitScreenTriangle(source: BaseTexture, dest: RenderTexture, offsetScale?: Vector4, shader?: Shader3D, shaderData?: ShaderData, subShader?: number): void;
        /**
         * @en Sets the render target for the command buffer.
         * @param renderTexture The render target texture.
         * @param clearColor Whether to clear the color buffer.
         * @param clearDepth Whether to clear the depth buffer.
         * @param backgroundColor The background color when clearing. Defaults to black.
         * @param depth The depth value when clearing. Defaults to 1.
         * @zh 设置命令缓冲区的渲染目标。
         * @param renderTexture 渲染目标纹理。
         * @param clearColor 是否清除颜色缓冲区。
         * @param clearDepth 是否清除深度缓冲区。
         * @param backgroundColor 清除时的背景颜色，默认为黑色。
         * @param depth 清除时的深度值，默认为1。
         */
        setRenderTarget(renderTexture: RenderTexture, clearColor: boolean, clearDepth: boolean, backgroundColor?: Color, depth?: number): void;
        /**
         * @en Renders a Mesh.
         * @param mesh The original mesh information.
         * @param matrix The world matrix of the mesh.
         * @param material The material applied to the mesh.
         * @param submeshIndex The index of the submesh.
         * @param subShaderIndex The index of the sub-shader, generally 0.
         * @zh 渲染一个网格。
         * @param mesh 原始网格信息。
         * @param matrix 网格的世界矩阵。
         * @param material 应用到网格的材质。
         * @param submeshIndex 子网格的索引。
         * @param subShaderIndex 子着色器的索引，默认为0。
         */
        drawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, submeshIndex: number, subShaderIndex: number): void;
        /**
         * @en Renders a Render object.
         * @param render The renderer object to be rendered.
         * @param material The material applied to the renderer.
         * @param subMeshIndex The index of the sub-shader, defaults to 0.
         * @zh 渲染一个渲染对象。
         * @param render 要渲染的渲染器对象。
         * @param material 应用到渲染器的材质。
         * @param subMeshIndex 子着色器的索引，默认为0。
         */
        drawRender(render: BaseRender, material: Material, subMeshIndex?: number): void;
        /**
         * @en Renders a RenderElement.
         * @param renderElement The RenderElement to be rendered.
         * @zh 渲染一个渲染元素。
         * @param renderElement 要渲染的渲染元素。
         */
        drawRenderElement(renderElement: RenderElement): void;
        /**
         * @en Renders a Mesh using instanced rendering for dynamic batching.
         * @param mesh The original mesh information.
         * @param subMeshIndex The index of the mesh.
         * @param matrixs An array of world matrices for rendering, describing the position of each Mesh to be rendered. If null, no world matrix buffer will be created or updated.
         * @param material The material used for rendering.
         * @param subShaderIndex The shader index of the rendering material.
         * @param instanceProperty Custom properties for the instance.
         * @param drawnums The number of instances to render.
         * @zh 使用实例化渲染动态合批方式渲染网格。
         * @param mesh 原始网格信息。
         * @param subMeshIndex 网格索引。
         * @param matrixs 渲染的世界矩阵数组，描述每个网格需要渲染的位置。如果为null，则不会创建或更新世界矩阵缓冲区。
         * @param material 渲染材质。
         * @param subShaderIndex 渲染材质的着色器索引。
         * @param instanceProperty 实例的自定义属性。
         * @param drawnums 要渲染的实例数量。
         */
        drawMeshInstance(mesh: Mesh, subMeshIndex: number, matrixs: Matrix4x4[], material: Material, subShaderIndex: number, instanceProperty: MaterialInstancePropertyBlock, drawnums: number): any;
        /**
         * @en Adds a custom render command.
         * @param command The custom command to add.
         * @zh 添加一个自定义的渲染命令。
         * @param command 要添加的自定义命令。
         */
        addCustomCMD(command: Command): void;
    }
    /**
     * @en DrawMeshInstancedCMD class for instanced mesh drawing command.
     * @zh DrawMeshInstancedCMD 类，用于实例化网格绘制命令。
     */
    class DrawMeshInstancedCMD extends Command {
        /**
         * @en Maximum number of draw instances.
         * @zh 设置最大DrawInstance数。
         */
        static maxInstanceCount: number;
        constructor();
        /**
         * @en The material for the command.
         * @zh 命令的材质。
         */
        set material(value: Material);
        /**
         * @en The buffer state.
         * @zh 缓冲状态。
         */
        get bufferState(): VertexBuffer3D;
        /**
         * @en The mesh of the command.
         * @zh 命令的网格。
         */
        get mesh(): Mesh;
        set mesh(value: Mesh);
        /**
         * @en Reset the world matrix array for DrawInstance.
         * @param worldMatrixArray Array of world matrices.
         * @zh 重置DrawInstance的世界矩阵数组。
         * @param worldMatrixArray 世界矩阵数组
         */
        setWorldMatrix(worldMatrixArray: Matrix4x4[]): void;
        /**
         * @en Reset the number of instances to draw.
         * @param drawNums Number of instances to draw.
         * @zh 重置渲染个数。
         * @param drawNums 渲染个数。
         */
        setDrawNums(drawNums: number): void;
        /**
         * @en Update the render element.
         * @param renderElement The render element to update.
         * @param context The render context.
         * @returns The updated IRenderElement3D.
         * @zh 更新渲染元素。
         * @param renderElement 要更新的渲染元素。
         * @param context 渲染上下文。
         * @return 更新后的IRenderElement3D。
         */
        renderUpdateElement(renderElement: RenderElement, context: RenderContext3D): IRenderElement3D;
        /**
         * @en Execute the command.
         * @zh 执行命令。
         */
        run(): void;
        /**
         * @inheritDoc
         * @override
         * @en Recycle the command.
         * @zh 回收命令。
         */
        recover(): void;
    }
    /**
     * @en Represents a draw render command.
     * @zh 表示一个绘制渲染命令。
     */
    class DrawRenderCMD extends Command {
        /**
         * @en The render object.
         * @zh 渲染对象。
         */
        get render(): BaseRender;
        set render(render: BaseRender);
        /**
         * @en The material.
         * @zh 材质。
         */
        get material(): Material;
        set material(value: Material);
        private _subMeshIndex;
        /**
         * @en The sub-mesh index.
         * @zh 子网格索引。
         */
        get subMeshIndex(): number;
        set subMeshIndex(value: number);
        constructor();
        /**
         * @en Gets the render command data.
         * @zh 获取渲染命令数据。
         */
        getRenderCMD(): DrawNodeCMDData;
        /**
         * @en Runs the  command.
         * @zh 运行命令。
         */
        run(): void;
        /**
         * @inheritDoc
         * @override
         * @en Recovers the render command for reuse.
         * @zh 回收渲染命令以供重用。
         */
        recover(): void;
        /**
         * @en Destroys the render command.
         * @zh 销毁渲染命令。
         */
        destroy(): void;
    }
    /**
     * @en Represents a draw render element command.
     * @zh 表示一个绘制渲染元素命令。
     */
    class DrawRenderElementCMD extends Command {
        /**
         * @en Creates a new instance of the command or retrieves one from the pool.
         * @param renderElement The render element associated with this command.
         * @returns A new or pooled instance of `DrawRenderElementCMD`.
         * @zh 创建命令的新实例或从池中检索一个实例。
         * @param renderElement 与此命令关联的渲染元素。
         * @return 一个新的或从池中检索到的 `DrawRenderElementCMD` 实例。
         */
        static create(renderElement: RenderElement): DrawRenderElementCMD;
        /**
         * @en The render element of this command.
         * @zh 此命令的渲染元素。
         */
        get renderElement(): RenderElement;
        set renderElement(value: RenderElement);
        constructor();
        /**
         * @inheritDoc
         * @override
         * @en Recovers the command for reuse.
         * @zh 回收命令以供重用。
         */
        recover(): void;
        /**
         * @en Destroys the command.
         * @zh 销毁命令。
         */
        destroy(): void;
    }
    enum InstanceLocation {
        CUSTOME0 = 12,
        CUSTOME1 = 13,
        CUSTOME2 = 14,
        CUSTOME3 = 15
    }
    /**
     * @en Material instance property block.
     * @zh 材质实例属性块。
     */
    class MaterialInstancePropertyBlock {
        /**Instance合并方案 */
        /**
         * @en Attribute instance rendering scheme. Advantages: High merge quantity, high merge efficiency, good rendering performance. Disadvantages: Few instance variable elements.
         * @zh 属性实例渲染方案。优点：合并数量多，合并效率高，渲染性能优。缺点：实例变量元素少。
         */
        static INSTANCETYPE_ATTRIBUTE: number;
        /**
         * @en Uniform instance rendering scheme. Advantages: Many instance variables, flexible. Disadvantages: Merge quantity affected by WebGLContext._maxUniformFragmentVectors, low merge efficiency.
         * @zh 统一实例渲染方案。优点：实例变量多，灵活。缺点：合并数量受 WebGLContext._maxUniformFragmentVectors 的影响，合并效率低。
         */
        static INSTANCETYPE_UNIFORMBUFFER: number;
        constructor();
        /**
         * 创建instance属性
         * @param attributeName name
         * @param arrays data
         * @param vertexStride vertex size
         * @param vertexformat vertexFormat
         * @param attributeLocation  attribute location
         */
        private _creatProperty;
        /**
         * @en Set Vector4 material array property.
         * @param attributeName The attribute name (should correspond to the Shader).
         * @param arrays The data.
         * @param attributeLocation The attribute Shader location (needs to correspond one-to-one with the Attribute declaration in the shader).
         * @zh 设置 Vector4 材质数组属性。
         * @param attributeName 属性名称（要对应到 Shader 中）。
         * @param arrays 数据。
         * @param attributeLocation 属性 Shader 位置（需要与 shader 中的声明 Attribute 一一对应）。
         */
        setVectorArray(attributeName: string, arrays: Vector4[] | Float32Array, attributeLocation: InstanceLocation): void;
        /**
         * @en Set Vector3 material array property.
         * @param attributeName The attribute name (should correspond to the Shader).
         * @param arrays The data.
         * @param attributeLocation The attribute Shader location (needs to correspond one-to-one with the Attribute declaration in the shader).
         * @zh 设置 Vector3 材质数组属性。
         * @param attributeName 属性名称（要对应到 Shader 中）。
         * @param arrays 数据。
         * @param attributeLocation 属性 Shader 位置（需要与 shader 中的声明 Attribute 一一对应）。
         */
        setVector3Array(attributeName: string, arrays: Vector3[] | Float32Array, attributeLocation: InstanceLocation): void;
        /**
         * @en Set Vector2 material array property.
         * @param attributeName The attribute name (should correspond to the Shader).
         * @param arrays The data.
         * @param attributeLocation The attribute Shader location (needs to correspond one-to-one with the Attribute declaration in the shader).
         * @zh 设置 Vector2 材质数组属性。
         * @param attributeName 属性名称（要对应到 Shader 中）。
         * @param arrays 数据。
         * @param attributeLocation 属性 Shader 位置（需要与 shader 中的声明 Attribute 一一对应）。
         */
        setVector2Array(attributeName: string, arrays: Vector2[] | Float32Array, attributeLocation: InstanceLocation): void;
        /**
         * @en Set Number material array property.
         * @param attributeName The attribute name (should correspond to the Shader).
         * @param arrays The data.
         * @param attributeLocation The attribute Shader location (needs to correspond one-to-one with the Attribute declaration in the shader).
         * @zh 设置 Number 材质数组属性。
         * @param attributeName 属性名称（要对应到 Shader 中）。
         * @param arrays 数据。
         * @param attributeLocation 属性 Shader 位置（需要与 shader 中的声明 Attribute 一一对应）。
         */
        setNumberArray(attributeName: string, arrays: Float32Array, attributeLocation: InstanceLocation): void;
        /**
         * @en Get property data.
         * @param attributeLocation The attribute Shader location.
         * @zh 获得属性数据。
         * @param attributeLocation 属性 Shader 位置。
         */
        getPropertyArray(attributeLocation: InstanceLocation): Vector4[] | Vector3[] | Vector2[] | Float32Array;
        /**
         * @en Clear all properties.
         * @zh 清除所有属性。
         */
        clear(): void;
    }
    class SetDefineCMD extends Command {
        constructor();
        /**
         * @inheritDoc
         * @override
         */
        recover(): void;
    }
    /**
     * @en The `InstanceRenderElement` is used for instanced rendering.
     * @zh `InstanceRenderElement` 类用于实例化渲染。
     */
    class InstanceRenderElement extends RenderElement {
        /**
         * @en Creates an instance of `InstanceRenderElement`, reusing from the pool if available.
         * @zh 创建 `InstanceRenderElement` 的实例，如果池中有可用的实例则重用。
         */
        static create(): InstanceRenderElement;
        constructor();
        set InvertFront(value: boolean);
        protected _createRenderElementOBJ(): void;
        /** @ignore */
        compileShader(context: IRenderContext3D): void;
        /**@ignore */
        _renderUpdatePre(context: RenderContext3D): void;
        /**@ignore */
        updateInstanceData(mesh: Mesh): void;
        /**
         * @en Clears the instance render element.
         * @zh 清除实例渲染元素。
         */
        clear(): void;
        /**
         * @en Recovers the render element to its original state.
         * @zh 恢复渲染元素到原始状态。
         */
        recover(): void;
    }
    /**
     * @en The BloomEffect class is used to create a flood effect.
     * @zh BloomEffect 类用于创建泛光效果。
     */
    class BloomEffect extends PostProcessEffect {
        /**
         * @en Bloom resource initialize
         * @zh 泛光资源初始化
         */
        static init(): void;
        /**泛光颜色。*/
        private _color;
        /**是否开启快速模式。该模式通过降低质量来提升性能。*/
        private _fastMode;
        /**镜头污渍纹路,用于为泛光特效增加污渍灰尘效果*/
        private _dirtTexture;
        /**
         * @en The number of the bloom pixel, this value is in gamma space
         * @zh 泛光像素的数量,该值在伽马空间
         */
        get clamp(): number;
        set clamp(value: number);
        /**
         * @en Flood color.
         * @zh 泛光颜色。
         */
        get color(): Color;
        set color(value: Color);
        /**
         * @en Fast mode.
         * @zh 快速模式
         */
        get fastMode(): boolean;
        set fastMode(value: boolean);
        /**
         * @en Dirty texture
         * @zh 脏迹贴图
         */
        get dirtTexture(): BaseTexture;
        set dirtTexture(value: BaseTexture);
        /**
         * @en Intensity of floodlight filter, the minimum value is 0.
         * @zh 泛光过滤器强度,最小值为0。
         */
        get intensity(): number;
        set intensity(value: number);
        /**
         * @en The flood threshold, below which pixels with brightness will be filtered out, is in gamma space.
         * @zh 泛光阈值,在该阈值亮度以下的像素会被过滤掉,该值在伽马空间。
         */
        get threshold(): number;
        set threshold(value: number);
        /**
         * @en Soft knee transition strength. Gradual transition occurs below the threshold (0 for completely hard transition, 1 for completely soft transition).
         * @zh 软膝盖过渡强度，在阈值以下进行渐变过渡（0为完全硬过度，1为完全软过度）。
         */
        get softKnee(): number;
        set softKnee(value: number);
        /**
         * @en Diffusion value, changes the bloom spread range. It's best to use integer values for the best effect. This value changes the internal iteration count, range is 1 to 10.
         * @zh 扩散值，改变泛光的扩散范围。最好使用整数值以保证效果，该值会改变内部的迭代次数，范围是1到10。
         */
        get diffusion(): number;
        set diffusion(value: number);
        /**
         * @en Anamorphic ratio, distorts the bloom to produce a visual deformation. Negative values for vertical distortion, positive values for horizontal distortion. Range: -1 to 1.
         * @zh 形变比，通过扭曲泛光产生视觉上的形变。负值为垂直扭曲，正值为水平扭曲。范围：-1到1。
         */
        get anamorphicRatio(): number;
        set anamorphicRatio(value: number);
        /**
         * @en Dirt intensity. Range: 0 to 1.
         * @zh 污渍强度。范围：0到1。
         */
        get dirtIntensity(): number;
        set dirtIntensity(value: number);
        /**
         * @en initializate the bloom effect instance.
         * @zh 初始化泛光效果实例。
         */
        constructor();
        /**
         * @en Called when added to the post-processing stack.
         * @param postprocess The post-processing component.
         * @zh 添加到后期处理栈时调用。
         * @param postprocess 后期处理组件。
         */
        effectInit(postprocess: PostProcess): void;
        /**
         * @inheritDoc
         * @override
         * @en Get the camera depth texture mode flag according to the post-processing settings.
         * @returns The camera depth texture mode flag.
         * @zh 根据后期处理设置获取相机深度纹理模式标志。
         * @returns 相机深度纹理模式标志。
         */
        getCameraDepthTextureModeFlag(): number;
        /**
         * @en Release the Effect.
         * @param postprocess The post-processing component.
         * @zh 释放Effect。
         * @param postprocess 后期处理组件。
         */
        release(postprocess: PostProcess): void;
    }
    enum ToneMappingType {
        None = 0,
        ACES = 1
    }
    /**
     * @en Class of ColorGradEffect used to create tone mapping effect.
     * @zh ColorGradEffect 类用于创建调色效果
     */
    class ColorGradEffect extends PostProcessEffect {
        /**
         * @en Initialize shader definitions.
         * @zh 初始化着色器定义。
         */
        static __initDefine__(): void;
        private _needBuildLUT;
        private _lutBuilderMat;
        private _LUTShader;
        private _lutShaderData;
        private _blitlutParams;
        private _splitShadow;
        private _splitBalance;
        private _splithighlights;
        private _u_SplitShadow;
        private _enableSMH;
        private _enableLiftGammaGain;
        private _enableBalance;
        private _tint;
        private _temperature;
        /**
         * @en the tone mapping type.
         * @zh 色调映射类型
         */
        get toneMapping(): ToneMappingType;
        set toneMapping(value: ToneMappingType);
        /**
         * @en Whether split tone effect is enabled.
         * @zh 是否启用分离色调效果。
         */
        get enableSplitTone(): boolean;
        set enableSplitTone(value: boolean);
        /**
       * @en The color of shadows in split tone effect.
       * @zh 分离色调效果中阴影的颜色。
       */
        get splitShadow(): Vector3;
        set splitShadow(value: Vector3);
        /**
         * @en The color of highlights in split tone effect.
         * @zh 分离色调效果中高光的颜色。
         */
        get splithighlights(): Vector3;
        set splithighlights(value: Vector3);
        /**
        * @en The balance between shadow and highlight coloring in split tone effect.
        * @zh 分离色调效果中阴影和高光着色的平衡。
        */
        get splitBalance(): number;
        set splitBalance(value: number);
        /**
         * @en wheather to enable shadows, midtones, highlights
         * @zh 是否启用阴影，中亮，高亮调节
         */
        get enableSMH(): boolean;
        set enableSMH(value: boolean);
        /**
         * @en Shadows value, range 0-5.
         * @zh 阴影值，取值范围0-5
         */
        get shadows(): Vector3;
        set shadows(value: Vector3);
        /**
         * @en Midtones value, range 0-5.
         * @zh 中亮值，取值范围0-5
         */
        get midtones(): Vector3;
        set midtones(value: Vector3);
        /**
         * @en Highlights value, range 0-5.
         * @zh 高亮值，取值范围0-5
         */
        get highlights(): Vector3;
        set highlights(value: Vector3);
        /**
         * @en Shadow limit start 0-1
         * @zh 阴影限界起点，取值范围0-1
         */
        get shadowLimitStart(): number;
        set shadowLimitStart(value: number);
        /**
         * @en Shadow limit end 0-1
         * @zh 阴影限界终点，取值范围0-1
         */
        get shadowLimitEnd(): number;
        set shadowLimitEnd(value: number);
        /**
         * @en HighLight limit start 0-1
         * @zh 高光限界起点，取值范围0-1
         */
        get highLightLimitStart(): number;
        set highLightLimitStart(value: number);
        /**
         * @en HighLight limit end 0-1
         * @zh 高光限界终点，取值范围0-1
         */
        get highLightLimitEnd(): number;
        set highLightLimitEnd(value: number);
        /**
         * @en Whether lift, gamma, gain adjustments are enabled.
         * @zh 是否启用暗部、中间调、亮部调整。
         */
        get enableLiftGammaGain(): boolean;
        set enableLiftGammaGain(value: boolean);
        /**
         * @en The lift adjustment value. Primarily affects the shadow areas of the image, with a range of -1-1.
         * @zh 暗部调整值。主要影响图像的阴影区域，范围 -1-1
         */
        get lift(): Vector3;
        set lift(value: Vector3);
        /**
         * @en The gamma adjustment value. Affects the midtones of the image, but also influences shadows and highlights. with a range of 999-0.5.
         * @zh 中间调调整值。影响图像的中间调，范围 999-0.5
         */
        get gamma(): Vector3;
        set gamma(value: Vector3);
        /**
         * @en The gain adjustment value. Primarily affects the highlight areas of the image, with a range of 0-2.
         * @zh 亮部调整值。主要影响图像的高光区域，范围 0-2
         */
        get gain(): Vector3;
        set gain(value: Vector3);
        private _StandardIlluminantY;
        private _CIExyToLMS;
        private _ColorBalanceToLMSCoeffs;
        /**
         * @zh Wheather to enable white balance.
         * @zh 白平衡是否开启
         */
        get enableBalance(): boolean;
        set enableBalance(value: boolean);
        /**
         * @en Controls the white balance color to compensate for a green or magenta tint. Range -100-100.
         * @zh 白平衡颜色，用于补偿绿色或品红色。范围 -100-100。
         */
        get tint(): number;
        set tint(value: number);
        /**
         * @en White Balance Temperature. Range -100-100.
         * @zh 白平衡色温。范围 -100-100.
         */
        get temperature(): number;
        set temperature(value: number);
        /**
         * @en Whether color adjust is enabled.
         * @zh 是否开启颜色调整
         */
        get enableColorAdjust(): boolean;
        set enableColorAdjust(value: boolean);
        /**
         * @en The overall exposure of the scene.
         * @zh 场景的整体曝光
         */
        get postExposure(): number;
        set postExposure(value: number);
        /**
         * @en Color Contrast. Range 0-2.
         * @zh 颜色对比度，范围 0-2
         */
        get contrast(): number;
        set contrast(value: number);
        /**
         * @en The color filter.
         * @zh 颜色过滤器
         */
        get colorFilter(): Color;
        set colorFilter(value: Color);
        /**
         * @en The Hue Shift. Range -0.5-0.5.
         * @zh 色相偏移，范围 -0.5-0.5
         */
        get HueShift(): number;
        set HueShift(value: number);
        /**
         * @en Saturation.
         * @zh 饱和度
         */
        get saturation(): number;
        set saturation(value: number);
        /**
         * @en initialize the color grad effect instance.
         * @zh 初始化调色效果实例
         */
        constructor();
        private get lutSize();
        private set lutSize(value);
        private default_balance;
        private default_splitShadow;
        private default_splithighlights;
        private default_shadow;
        private default_midtones;
        private default_highlight;
        private default_limint;
        private default_lift;
        private default_gamma;
        private default_gain;
        private default_ColorFilter;
        private default_HueSatCon;
        private _postProcess;
        /**
         * @en Called when added to the post-processing stack.
         * @param postprocess The post-processing node.
         * @zh 在添加到后期处理栈时调用。
         * @param postprocess 后期处理节点。
         */
        effectInit(postprocess: PostProcess): void;
        /**
         * @en Release the Effect.
         * @param postprocess The post-processing node.
         * @zh 释放Effect。
         * @param postprocess 后期处理节点。
         */
        release(postprocess: PostProcess): void;
    }
    /**
     * @en The `GaussianDoF` class is used to create a Gaussian Depth of Field effect.
     * Only supports far field blur.
     * - start: The depth at which the far field begins to blur.
     * - end: The depth at which the far field reaches its maximum blur radius.
     * - maxRadius: The maximum blur radius for the far field.
     * @zh `GaussianDoF` 类用于创建高斯景深效果。
     * 仅支持远景模糊。
     * - start: 开始远景模糊的深度
     * - end: 达到最大模糊半径的远景深度
     * - maxRadius: 远景模糊最大半径
     */
    class GaussianDoF extends PostProcessEffect {
        /**
         * @en GaussianDOF resource init
         * @zh 高斯DOF资源初始化
         */
        static init(): void;
        /**
         * @ignore
         * @en initialization GaussianDOF effect instance.
         * @zh 初始化高斯DOF效果实例
         */
        constructor();
        /**
         * @en The depth at which far field blur begins.
         * @zh 开始远景模糊的深度。
         */
        get farStart(): number;
        set farStart(value: number);
        /**
         * @en The depth at which maximum blur radius is reached for far field.
         * @zh 达到最大模糊半径的远景深度。
         */
        get farEnd(): number;
        set farEnd(value: number);
        /**
         * @en The maximum blur radius.
         * @zh 最大模糊半径。
         */
        get maxRadius(): number;
        set maxRadius(value: number);
    }
    /**
     * @en Represents lens flare command
     * @zh 表示镜头光晕指令
     */
    class LensFlareCMD {
        private _instanceCount;
        /**
         * @en The number of instances drawn
         * @zh instance绘制的个数
         */
        get instanceCount(): number;
        set instanceCount(value: number);
        /**
         * @ignore
         * @en Constructor method, initialize instance.
         * @zh 构造方法，初始化实例
         */
        constructor();
        /**
         * init material
         */
        private _initMaterial;
        set lensFlareElement(value: LensFlareElement);
        /**
         * @en apply element Data
         * @zh 应用元素数据
         */
        applyElementData(): void;
        /**
         * @inheritDoc
         * @override
         * @en Execute the command.
         * @zh 执行命令
         */
        run(cmd: CommandBuffer): void;
    }
    /**
     * @en lens Flare Element
     * @zh 镜头光晕元素
     */
    class LensFlareElement {
        private _startPosition;
        private _angularOffset;
        /**
         * @en Whether the element is active.
         * @zh 是否激活
         */
        get active(): boolean;
        set active(value: boolean);
        /**
         * @en The tint color of the lens flare.
         * @zh 光晕的颜色
         */
        get tint(): Color;
        set tint(value: Color);
        /**
         * @en The intensity of the lens flare.
         * @zh 光晕的强度
         */
        get intensity(): number;
        set intensity(value: number);
        /**
         * @en The texture of the lens flare.
         * @zh 光晕的贴图
         */
        get texture(): BaseTexture;
        set texture(value: BaseTexture);
        /**
         * @en The position offset of the lens flare in screen space.
         * @zh 光晕的位置偏移(屏幕空间下)
         */
        get positionOffset(): Vector2;
        set positionOffset(value: Vector2);
        /**
         * @en The scale of the lens flare in each dimension.
         * @zh 光晕的缩放(每个轴上)
         */
        get scale(): Vector2;
        set scale(value: Vector2);
        /**
         * @en Whether to enable automatic rotation.
         * @zh 是否开启自动旋转
         */
        get autoRotate(): boolean;
        set autoRotate(value: boolean);
        /**
         * @en The rotation of the lens flare.
         * @zh 光晕的旋转角度
         */
        get rotation(): number;
        set rotation(value: number);
        /**
         * @en The start position of the lens flare.
         * @zh 光晕的起始位置
         */
        get startPosition(): number;
        set startPosition(value: number);
        /**
         * @en The angle offset of the lens flare.
         * @zh 光晕的角度偏移
         */
        get angularOffset(): number;
        set angularOffset(value: number);
    }
    /**
     * @en Lens Flare Data
     * @zh 镜头光晕的资源数据
     */
    class LensFlareData extends Resource {
        constructor();
        /**
         * @en Lens Flare Element Collection
         * @zh 镜头光晕元素集合
         */
        elements: LensFlareElement[];
    }
    /**
     * @en Lens Flare Effect
     * @zh 镜头光晕效果
     */
    class LensFlareEffect extends PostProcessEffect {
        /**
         * @en Initialize Shader and Geometry
         * @zh 初始化着色器和几何体
         */
        static init(): void;
        /**
         * @en LensFlareData
         * @zh 镜头光晕数据
         */
        get lensFlareData(): LensFlareData;
        set lensFlareData(value: LensFlareData);
        /**
         * @en Bind light
         * @zh 绑定光源
         */
        get bindLight(): Light;
        set bindLight(light: Light);
        /**
         * @en Post-processing effect intensity
         * @zh 后处理效果强度
         */
        get effectIntensity(): number;
        set effectIntensity(value: number);
        /**
         * @en Post-processing effect scale
         * @zh 后处理效果缩放
         */
        get effectScale(): number;
        set effectScale(value: number);
        constructor();
        /**
         * @en Calculate the center point of directional light
         * @param camera The camera
         * @zh 计算直射光中心点
         * @param camera 摄像机
         */
        caculateDirCenter(camera: Camera): void;
        /**
         * @en Calculate point light
         * @param camera The camera
         * @zh 计算点光源
         * @param camera 相机
         */
        caculatePointCenter(camera: Camera): void;
        /**
         * @en Calculate spot light
         * @param value Screen point
         * @zh 计算聚光灯
         * @param value 屏幕点
         */
        caculateSpotCenter(value: Vector2): void;
        /**
         * @en Render process
         * @param context Post-processing render context
         * @zh 渲染流程
         * @param context 后期处理渲染上下文
         */
        render(context: PostProcessRenderContext): void;
        /**
         * @inheritDoc
         * @override
         * @en Release the effect
         * @param postprocess Post-processing node
         * @zh 释放效果
         * @param postprocess 后期处理节点
         */
        release(postprocess: PostProcess): void;
    }
    /**
     * @en Represents the geometry of a lens flare element.
     * @zh 表示镜头光晕元素的几何体。
     */
    class LensFlareElementGeomtry extends GeometryElement {
        /**
         * @en Constant representing the position and UV attributes.
         * @zh 表示位置和UV属性的常量。
         */
        static PositionUV: number;
        /**
         * @en Constant representing the position, rotation, and scale attributes.
         * @zh 表示位置、旋转和缩放属性的常量。
         */
        static PositionRotationScale: number;
        /**
         * @en Initializes the data for lens flare element geometry.
         * @zh 初始化镜头光晕元素几何体的数据。
         */
        static init(): void;
        /**
         * @ignore
         * @en Constructor method, initialize the instance.
         * @zh 构造方法，初始化实例
         */
        constructor();
        /**
         * @en Destroys the lens flare element geometry and releases its resources.
         * @zh 销毁镜头光晕元素几何体并释放其资源。
         */
        destroy(): void;
    }
    /**
     * @en Initialize the lens flare element shader.
     * @zh 初始化镜头光晕元素着色器
     */
    class LensFlareShaderInit {
        /**
         * @en Initialize the lens flare element shader.
         * @zh 初始化镜头光晕元素着色器
         */
        static init(): void;
    }
    /**
     * @en The quality of AO.
     * @zh AO质量
     */
    enum AOQUALITY {
        /**
         * @en High quality.
         * @zh 高质量
         */
        High = 0,
        /**
         * @en Medium quality.
         * @zh 中质量
         */
        MEDIUM = 1,
        /**
         * @en Low quality.
         * @zh 低质量
         */
        LOWEST = 2
    }
    /**
     * @en The ScalableAO class is used to create ambient occlusion effect.
     * @zh ScalableAO 类用于创建环境光遮罩效果。
     */
    class ScalableAO extends PostProcessEffect {
        /**
         * @en ScaleAO resource init
         * @zh 初始化AO资源
         */
        static init(): void;
        private _aoQuality;
        /**
         * @ignore
         * @en initializes the effect.
         * @zh 构造函数, 初始化实例。
         */
        constructor();
        /**
         * @en The color of ambient occlusion.
         * @zh 环境光遮挡的颜色
         */
        get aoColor(): Color;
        set aoColor(value: Color);
        /**
         * @en The intensity of ambient occlusion.
         * @zh 环境光遮挡的强度
         */
        get intensity(): number;
        set intensity(value: number);
        /**
         * @en The influence radius of ambient occlusion.
         * @zh 环境光遮挡的影响半径
         */
        get radius(): number;
        set radius(value: number);
        /**
         * @en The quality of ambient occlusion.
         * @zh 环境光遮挡的质量
         */
        get aoQuality(): AOQUALITY;
        set aoQuality(value: AOQUALITY);
    }
    /**
     * @en Used to create post-processing rendering effects.
     * @zh 后期处理渲染效果的基类。
     */
    class PostProcessEffect {
        /**
         * @ignore
         * @en constructor, initialize instance.
         * @zh 构造函数, 初始化实例。
         */
        constructor();
        set singleton(value: boolean);
        /**
         * @en Whether the effect is enabled.
         * @zh 效果是否开启。
         */
        get active(): boolean;
        set active(value: boolean);
        /**
         * @inheritDoc
         * @override
         * @en Gets the camera depth texture mode flag based on post-processing settings.
         * @zh 根据后期处理设置获取摄像机深度纹理模式标志。
         */
        getCameraDepthTextureModeFlag?(): number;
        /**
         * @inheritDoc
         * @override
         * @en Called when added to the post-processing stack.
         * @param postprocess The post-processing component.
         * @zh 在添加到后期处理栈时调用。
         * @param postprocess 后期处理组件。
         */
        effectInit?(postprocess: PostProcess): void;
        /**
         * @inheritDoc
         * @override
         * @en Releases the effect.
         * @param postprocess The post-processing component.
         * @zh 释放效果。
         * @param postprocess 后期处理组件。
         */
        release?(postprocess: PostProcess): void;
        /**
         * @en Renders the effect.
         * @param context The post-processing rendering context.
         * @zh 渲染效果。
         * @param context 后期处理渲染上下文。
         */
        render?(context: PostProcessRenderContext): void;
    }
    /**
     * @en The `PostProcessRenderContext` class is used to create a post-processing rendering context.
     * @zh `PostProcessRenderContext` 类用于创建后期处理渲染上下文。
     */
    class PostProcessRenderContext {
        /**
         * @en The original RenderTexture that is rendered to initially. Do not modify this RT.
         * @zh 原始渲染 RenderTexture (RT)，禁止改变此 RT。
         */
        source: RenderTexture | null;
        /**
         * @en forward effect target
         * @zh 上个后期处理的结果
         */
        indirectTarget: RenderTexture | null;
        /**
         * @en The RenderTexture where the processed result should be drawn to.
         * @zh 需要将处理后的结果画入此 RenderTexture。
         */
        destination: RenderTexture | null;
        /**
         * @en The rendering camera.
         * @zh 渲染相机。
         */
        camera: Camera | null;
        /**
         * @en The composite shader data.
         * @zh 合成着色器数据。
         */
        compositeShaderData: ShaderData | null;
        /**
         * @en The post-processing command buffer.
         * @zh 后期处理指令流。
         */
        command: CommandBuffer | null;
        /**
         * @en Temporary texture array. You can put created textures here or select an RT to use from here to save memory.
         * @zh 临时纹理数组。可以将创建的纹理放入此数组，也可以从这里选取要用的 RT 来节省显存。
         */
        deferredReleaseTextures: RenderTexture[];
        /**
         * @en Selects an RT from recycled RTs to save memory.
         * @param width The width of the RenderTexture.
         * @param height The height of the RenderTexture.
         * @param colorFormat The color format of the RenderTexture.
         * @param depthFormat The depth format of the RenderTexture.
         * @param mipmap Whether to generate mipmaps.
         * @param multiSamples The number of multisamples.
         * @param depthTexture Whether to generate a depth texture.
         * @param sRGB Whether the RenderTexture is in sRGB color space.
         * @returns The selected RenderTexture or null if no match is found.
         * @zh 从回收的 RT 中选择一个 RT 用来节省内存。
         * @param width 纹理的宽度。
         * @param height 纹理的高度。
         * @param colorFormat 纹理的颜色格式。
         * @param depthFormat 纹理的深度格式。
         * @param mipmap 是否生成 mipmap。
         * @param multiSamples 多重采样数。
         * @param depthTexture 是否生成深度纹理。
         * @param sRGB 纹理是否在 sRGB 色彩空间。
         * @returns 选择到的 RenderTexture，如果没有匹配的，则返回 null。
         */
        createRTByContextReleaseTexture(width: number, height: number, colorFormat: RenderTargetFormat, depthFormat: RenderTargetFormat, mipmap?: boolean, multiSamples?: number, depthTexture?: boolean, sRGB?: boolean): RenderTexture;
    }
    /**
     * @en Used to implement rendering states.
     * @zh 用于实现渲染状态。
     */
    class RenderContext3D {
        /**
         * @en The singleton instance of the RenderContext3D.
         * @zh RenderContext3D的单例实例。
         */
        static _instance: RenderContext3D;
        /**
         * @en The width of the rendering area.
         * @zh 渲染区域的宽度。
         */
        static clientWidth: number;
        /**
         * @en The height of the rendering area.
         * @zh 渲染区域的高度。
         */
        static clientHeight: number;
        private _camera;
        get camera(): Camera;
        set camera(value: Camera);
        /**
         * @en The rendering pipeline mode.
         * @zh 渲染管线模式
         */
        configPipeLineMode: PipelineMode;
        /**
         * @en The viewport for rendering.
         * @zh 渲染视口。
         */
        set viewport(value: Viewport);
        /**
         * @en The scissor rectangle for rendering.
         * @zh 渲染裁剪矩形。
         */
        set scissor(value: Vector4);
        set invertY(value: boolean);
        set pipelineMode(value: PipelineMode);
        /**
         * @en The camera shader data.
         * @zh 相机着色器数据。
         */
        get cameraShaderValue(): ShaderData;
        set cameraShaderValue(value: ShaderData);
        set scene(value: Scene3D);
        /**
         * @en Changes the viewport.
         * @param x The x-coordinate of the viewport.
         * @param y The y-coordinate of the viewport.
         * @param width The width of the viewport.
         * @param height The height of the viewport.
         * @zh 更改视口。
         * @param x 视口 x 坐标。
         * @param y 视口 y 坐标。
         * @param width 视口的宽度。
         * @param height 视口的高度。
         */
        changeViewport(x: number, y: number, width: number, height: number): void;
        /**
         * @en Changes the scissor rectangle.
         * @param x The x-coordinate of the scissor rectangle.
         * @param y The y-coordinate of the scissor rectangle.
         * @param width The width of the scissor rectangle.
         * @param height The height of the scissor rectangle.
         * @zh 更改裁剪矩形。
         * @param x 裁剪矩形的 x 坐标。
         * @param y 裁剪矩形的 y 坐标。
         * @param width 裁剪矩形的宽度。
         * @param height 裁剪矩形的高度。
         */
        changeScissor(x: number, y: number, width: number, height: number): void;
        /**
         * @en Applies the context with the given camera update mark.
         * @param cameraUpdateMark The camera update mark.
         * @zh 应用具有给定相机更新标记的上下文。
         * @param cameraUpdateMark 相机更新标记。
         */
        applyContext(cameraUpdateMark: number): void;
        /**
         * @en Draws a single render element.
         * @param renderelemt The render element to draw.
         * @zh 渲染单个渲染元素。
         * @param renderelemt 要绘制的渲染元素。
         */
        drawRenderElement(renderelemt: IRenderElement3D): void;
        /**@ignore */
        constructor();
    }
    /**
     * @en RenderElement class is used to implement rendering elements.
     * @zh RenderElement 类用于实现渲染元素。
     */
    class RenderElement {
        /**
         * @en Can submit underlying rendering nodes
         * @zh 可提交底层的渲染节点
         */
        _renderElementOBJ: IRenderElement3D;
        set transform(value: Transform3D);
        /**
         * @en The material of the render element.
         * @zh 渲染元素的材质。
         */
        get material(): Material;
        set material(value: Material);
        /**
         * @en The SubShader of the render element.
         * @zh 渲染元素的 SubShader。
         */
        get renderSubShader(): SubShader;
        set renderSubShader(value: SubShader);
        /**
         * @en The SubShader index of the render element.
         * @zh 渲染元素的 SubShader 索引。
         */
        get subShaderIndex(): number;
        set subShaderIndex(value: number);
        set render(value: BaseRender);
        /**@ignore */
        constructor();
        protected _createRenderElementOBJ(): void;
        /**
         * @en Set the transform of the render element.
         * @param transform The transform to set.
         * @zh 设置渲染元素的位置变换。
         * @param transform 要设置的变换。
         */
        setTransform(transform: Transform3D): void;
        /**
         * @en Set the geometry information of the render element.
         * @param geometry The geometry to set.
         * @zh 设置渲染元素的几何信息。
         * @param geometry 要设置的几何信息。
         */
        setGeometry(geometry: GeometryElement): void;
    }
    /**
     * @en The `ScreenQuad` class is used to create a fullscreen quad.
     * @zh `ScreenQuad` 类用于创建全屏四边形。
     */
    class ScreenQuad extends GeometryElement {
        static InvertInstance: ScreenQuad;
        /**
         * @ignore
         * @en Construcutor method, do not use.
         * @zh 构造方法，禁止使用。
         */
        constructor();
        /**
         * @en Sets whether to invert the Y-axis and selects the corresponding buffer state.
         * @param value Whether to invert the Y-axis
         * @zh 设置Y轴是否反转，并选择相应的缓冲状态。
         * @param value 是否反转Y轴
         */
        set invertY(value: boolean);
        /**
         * @inheritDoc
         * @override
         * @en Destroys the ScreenQuad instance.
         * @zh 销毁ScreenQuad实例。
         */
        destroy(): void;
    }
    /**
     * @en The `SkyRenderElement` class is a render element that represents the sky.
     * @zh `SkyRenderElement` 类表示天空渲染元素。
     */
    class SkyRenderElement extends RenderElement {
        /**
         * @en The render element object that is declared for rendering.
         * @zh 声明用于渲染的渲染元素对象。
         */
        _renderElementOBJ: IRenderElement3D;
        private _viewMatrix;
        private _projectionMatrix;
        private _projectViewMatrix;
        constructor();
        /**
         * @en Calculates the view matrix based on the camera's view matrix.
         * @param cameraViewMat The camera's view matrix.
         * @zh 根据摄像机的视图矩阵计算视图矩阵。
         * @param cameraViewMat 摄像机的视图矩阵。
         */
        calculateViewMatrix(cameraViewMat: Matrix4x4): void;
        /**
         * @en Calculates the projection matrix based on the camera's projection matrix and other parameters.
         * @param cameraProjMat The camera's projection matrix.
         * @param aspectRatio The aspect ratio of the projection.
         * @param nearPlane The near plane distance of the projection.
         * @param farPlane The far plane distance of the projection.
         * @param fov The field of view for the perspective projection.
         * @param orthographic Whether to use an orthographic projection.
         * @zh 根据摄像机的投影矩阵和其他参数计算投影矩阵。
         * @param cameraProjMat 摄像机的投影矩阵。
         * @param aspectRatio 投影的纵横比。
         * @param nearPlane 投影的近平面距离。
         * @param farPlane 投影的远平面距离。
         * @param fov 透视投影的视场角。
         * @param orthographic 是否使用正交投影。
         */
        caluclateProjectionMatrix(cameraProjMat: Matrix4x4, aspectRatio: number, nearPlane: number, farPlane: number, fov: number, orthographic: boolean): void;
        /**
         * @en Prepares for rendering by setting up matrices and lighting information for sky rendering.
         * @param context The rendering context.
         * @zh 渲染前的准备工作，设置天空渲染所需的矩阵和光照信息。
         * @param context 渲染上下文。
         */
        renderpre(context: RenderContext3D): void;
    }
    /**
     * @en The `Sprite3DRenderDeclaration` class contains shader defines used in 3D sprite rendering.
     * @zh `Sprite3DRenderDeclaration` 类包含了3D精灵渲染中使用的着色器定义。
     */
    class Sprite3DRenderDeclaration {
        /**
         * @en Box reflection macro
         * @zh 盒子反射宏 */
        static SHADERDEFINE_SPECCUBE_BOX_PROJECTION: ShaderDefine;
        /**
         * @en Volumetric Global Illumination macro
         * @zh 体积全局光照宏
         */
        static SHADERDEFINE_VOLUMETRICGI: ShaderDefine;
    }
    /**
     * @deprecated
     * <code>RenderableSprite3D</code> 类用于可渲染3D精灵的父类，抽象类不允许实例。
     */
    class RenderableSprite3D extends Sprite3D {
        /**精灵级着色器宏定义,接收阴影。*/
        static SHADERDEFINE_RECEIVE_SHADOW: ShaderDefine;
        /**精灵级着色器宏定义,光照贴图。*/
        static SAHDERDEFINE_LIGHTMAP: ShaderDefine;
        /**精灵级着色器宏定义,光照贴图方向。 */
        static SHADERDEFINE_LIGHTMAP_DIRECTIONAL: ShaderDefine;
        /**着色器变量名，光照贴图缩放和偏移。*/
        static LIGHTMAPSCALEOFFSET: number;
        /**着色器变量名，光照贴图。*/
        static LIGHTMAP: number;
        /**着色器变量名，光照贴图方向。*/
        static LIGHTMAP_DIRECTION: number;
        /**拾取颜色。*/
        static PICKCOLOR: number;
        /** 反射探针位置 最大、最小值*/
        static REFLECTIONCUBE_PROBEPOSITION: number;
        static REFLECTIONCUBE_PROBEBOXMAX: number;
        static REFLECTIONCUBE_PROBEBOXMIN: number;
        /** volumetric GI */
        static VOLUMETRICGI_PROBECOUNTS: number;
        static VOLUMETRICGI_PROBESTEPS: number;
        static VOLUMETRICGI_PROBESTARTPOS: number;
        static VOLUMETRICGI_PROBEPARAMS: number;
        static VOLUMETRICGI_IRRADIANCE: number;
        static VOLUMETRICGI_DISTANCE: number;
        static SHADERDEFINE_MORPHTARGET: ShaderDefine;
        static SHADERDEFINE_MORPHTARGET_POSITION: ShaderDefine;
        static SHADERDEFINE_MORPHTARGET_NORMAL: ShaderDefine;
        static SHADERDEFINE_MORPHTARGET_TANGENT: ShaderDefine;
        /**
         * @deprecated
         *  反射贴图
         */
        static REFLECTIONTEXTURE: number;
        /**
         * @deprecated
         *  反射贴图参数
         */
        static REFLECTIONCUBE_HDR_PARAMS: number;
        /**
         * @deprecated
         * 创建一个 <code>RenderableSprite3D</code> 实例。
         */
        constructor(name: string);
    }
    /**
     * @en Environment light mode.
     * @zh 环境光模式。
     */
    enum AmbientMode {
        /**
         * @en Fixed color
         * @zh 固定颜色。
         */
        SolidColor = 0,
        /**
         * @en Spherical harmonic illumination generates spherical harmonic data through the sky box.
         * @zh 球谐光照, 通过天空盒生成的球谐数据。
         */
        SphericalHarmonics = 1
    }
    /**
     * @en Interface for the overall management of a type of component within a 3D scene.
     * @zh 用于3D场景中某类型组件的全面管理的接口。
     */
    interface IElementComponentManager {
        /**
         * @en An internal identifier used to find the manager by Scene3D.
         * @zh 由Scene3D用来查找管理器的内部名称。
         */
        name: string;
        /**
         * @en Initialization method called during Scene3D initialization.
         * @zh 在Scene3D初始化期间调用的方法。
         */
        Init(data: any): void;
        /**
         * @en Update method called every frame in the render loop.
         * @zh 在渲染循环中每帧调用的更新方法。
         */
        update(dt: number): void;
    }
    /**
     * @en Lightmap.
     * @zh 光照贴图。
     */
    class Lightmap {
        private _lightmapColor;
        /**
         * @en The color of the lightmap.
         * @zh 光照贴图的颜色。
         */
        get lightmapColor(): Texture2D;
        set lightmapColor(value: Texture2D);
        /** 光照贴图方向。 */
        private _lightmapDirection;
        /**
         * @en The direction of the lightmap.
         * @zh 光照贴图的方向。
         */
        get lightmapDirection(): Texture2D;
        set lightmapDirection(value: Texture2D);
    }
    enum FogMode {
        Linear = 0,
        EXP = 1,
        EXP2 = 2
    }
    /**
     * @en The Scene3D class is used to create a 3D scene.
     * @zh Scene3D类用于实现3D场景。
     */
    class Scene3D extends Sprite {
        /**Scene3D UniformMap */
        static sceneUniformMap: CommandUniformMap;
        /**
         * @en Scene component management table
         * @zh 场景组件管理表
         */
        static componentManagerMap: Map<string, any>;
        /**
         * @en The update mark of the scene.
         * @zh 场景更新标记。
         */
        static get _updateMark(): number;
        /**
         * @en Registers a manager within the scene.
         * @param type The type of the manager to register.
         * @param cla The instance of the manager.
         * @zh 注册场景内的管理器。
         * @param type 要注册的管理器类型。
         * @param cla 管理器实例。
         */
        static regManager(type: string, cla: any): void;
        /**
         * @en init shaderData
         * @zh 着色器数据初始化
         */
        static shaderValueInit(): void;
        /**
         * @en Initializes legacy lighting values for the ShaderData.
         * This function sets up the uniform mappings between the shader and the scene for various types of lights,
         * including directional lights, point lights, and spotlights.
         * @zh 初始化 ShaderData 的传统光照值。
         * 此函数为各种类型的灯光（包括方向光、点光源和聚光灯）设置着色器与场景之间的统一映射。
         */
        static legacyLightingValueInit(): void;
        /**
         * @deprecated 请使用Loader.load(url:string, type: ILaya.Loader.HIERARCHY)
         * @en Loads the scene, note: not cached.
         * @param url The template address.
         * @param complete The completion callback.
         * @zh 加载场景,注意:不缓存。
         * @param url 模板地址。
         * @param complete 完成回调。
         */
        static load(url: string, complete: Handler): void;
        /**
         * @en The mask layer to which the sprite belongs is currently being created.
         * @zh 当前创建精灵所属遮罩层。
         */
        currentCreationLayer: number;
        /**
         * @en Whether to enable lighting.
         * @zh 是否启用灯光。
         */
        enableLight: boolean;
        /**
         * @en The 2D scene to which the Scene3D belongs, used when the scene is loaded by the IDE editor.
         * @zh Scene3D所属的2D场景，使用IDE编辑的场景载入后具有此属性。
         */
        get scene2D(): Scene;
        /**
         * @en The SceneRenderableManager.
         * @zh 场景渲染管理器。
         */
        get sceneRenderableManager(): SceneRenderManager;
        set sceneRenderableManager(manager: SceneRenderManager);
        /**
         * @en Whether fog is enabled.
         * @zh 是否启用雾化效果。
         */
        get enableFog(): boolean;
        set enableFog(value: boolean);
        /**
         * @en The fog mode.
         * @zh 雾化模式。
         */
        get fogMode(): FogMode;
        set fogMode(value: FogMode);
        /**
         * @en The fog color.
         * @zh 雾化颜色。
         */
        get fogColor(): Color;
        set fogColor(value: Color);
        /**
         * @en The fog start position.
         * @zh 雾化起始位置。
         */
        get fogStart(): number;
        set fogStart(value: number);
        /**
         * @en The fog end range.
         * @zh 雾化结束范围。
         */
        get fogEnd(): number;
        set fogEnd(value: number);
        /**
         * @en The fog density.
         * @zh 雾化密度。
         */
        get fogDensity(): number;
        set fogDensity(value: number);
        set fogParams(value: Vector4);
        /**
         * @en The GI rotation value. The value should be between 0 and 2PI.
         * @zh 全局光照旋转值。 值应在 0 到 2PI 之间。
         */
        get GIRotate(): number;
        set GIRotate(value: number);
        /**
         * @en The ambient light mode.
         * If the value is AmbientMode.SolidColor, the ambientColor is generally used as the ambient light source. If the value is AmbientMode.SphericalHarmonics, the ambientSphericalHarmonics is generally used as the ambient light source.
         * @zh 环境光模式。
         * 如果值为 AmbientMode.SolidColor，则通常使用 ambientColor 作为环境光源。如果值为 AmbientMode.SphericalHarmonics，则通常使用 ambientSphericalHarmonics 作为环境光源。
         */
        get ambientMode(): AmbientMode;
        set ambientMode(value: AmbientMode);
        /**
         * @en The scene reflection probe.
         * @zh 场景反射探针。
         */
        get sceneReflectionProb(): ReflectionProbe;
        /**
         * @en The fixed color ambient light.
         * @zh 固定颜色环境光。
         */
        get ambientColor(): Color;
        set ambientColor(value: Color);
        /**
         * @en The ambient light intensity.
         * @zh 环境漫反射的强度。
         */
        get ambientIntensity(): number;
        set ambientIntensity(value: number);
        /**
         * @en The reflection probe intensity.
         * @zh 反射探针强度。
         */
        get reflectionIntensity(): number;
        set reflectionIntensity(value: number);
        /**
         * @en The ambient spherical harmonics coefficients.
         * @zh 环境光球谐系数。
         */
        get ambientSH(): Float32Array;
        set ambientSH(value: Float32Array);
        /**
         * @en The IBL texture .
         * @zh IBL纹理。
         */
        get iblTex(): TextureCube;
        set iblTex(value: TextureCube);
        /**
         * @en Checks if the ambient IBL texture is using RGBD compression.
         * @zh 检查环境光贴图是否使用 RGBD 压缩。
         */
        get iblTexRGBD(): boolean;
        set iblTexRGBD(value: boolean);
        /**
         * @en The sky renderer.
         * @zh 天空渲染器。
         */
        get skyRenderer(): SkyRenderer;
        /**
         * @en The physics simulation.
         * @zh 物理模拟器。
         */
        get physicsSimulation(): IPhysicsManager;
        /**
         * @override
         * @en The scene timer.
         * @zh 场景时钟。
         */
        get timer(): Timer;
        set timer(value: Timer);
        /**
         * @en The array of lightmaps. The returned value is a shallow copy of the array.
         * @zh 光照贴图数组。返回的是一个浅拷贝数组。
         */
        get lightmaps(): Lightmap[];
        set lightmaps(value: Lightmap[]);
        /**
         * @en The shadow map update frequency. Increasing the frequency can optimize performance if there are no self-shadows.
         * @zh 阴影图更新频率。如果没有自阴影，增加频率可以优化性能。
         */
        get shadowMapFrequency(): number;
        set shadowMapFrequency(value: number);
        /**
         * @ignore
         * @en Creates an instance of the Scene3D class.
         * @zh 创建一个Scene3D的实例。
         */
        constructor();
        /**
         * @en The component element data map.
         * @zh 组件元素数据映射表。
         */
        get componentElementDatasMap(): any;
        private _cullInfoCamera;
        /**
         * @en The culling camera used for determining the visibility of scene elements.
         * @zh 用于确定场景元素可见性的剔除摄像机。
         */
        get cullInfoCamera(): Camera;
        /**
         * @en Recalculate the culling camera.
         * @zh 重新计算剔除摄像机。
         */
        recaculateCullCamera(): void;
        /**
         * @inheritDoc
         * @override
         * @en Destroys the scene.
         * @param destroyChild Whether to destroy the child node.
         * @zh 销毁场景。
         * @param destroyChild 是否删除子节点
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @en Gets the manager for a specific component type.
         * @param type The type of the component manager.
         * @zh 根据组件类型获取对应的管理器。
         * @param type 组件管理器的类型。
         */
        getComponentElementManager(type: string): IElementComponentManager;
        /**
         * @en The rendering entry.
         * @zh 渲染入口
         */
        renderSubmit(): void;
        /**
         * @en Sets a global shader value for rendering.
         * @param name The name corresponding to the shader.
         * @param type The type of the shader data.
         * @param value The value of the rendering data.
         * @zh 设置全局渲染着色器值。
         * @param name 数据对应着色器名字
         * @param type 渲染数据类型
         * @param value 渲染数据值
         */
        setGlobalShaderValue(name: string, type: ShaderDataType, value: ShaderDataItem): void;
        /**
         * @deprecated
         * 雾效范围
         */
        get fogRange(): number;
        set fogRange(value: number);
        /**
         * @deprecated
         * 设置光照贴图。
         * @param value 光照贴图。
         */
        setlightmaps(value: Texture2D[]): void;
        /**
         * @deprecated
         * 获取光照贴图浅拷贝列表。
         * @return 获取光照贴图浅拷贝列表。
         */
        getlightmaps(): Texture2D[];
    }
    /**
     * @en The class is used to implement scene rendering node management.
     * @zh 该类用于实现场景渲染节点的管理。
     */
    class SceneRenderManager {
        /**
         * @ignore
         * @en Creates an instance of SceneRenderManager.
         * @zh 创建一个 SceneRenderManager 的实例。
         */
        constructor();
        /**
         * @en The render list.
         * @zh 渲染列表。
         */
        get list(): SingletonList<BaseRender>;
        set list(value: SingletonList<BaseRender>);
        /**
         * @en Adds a render node to the manager.
         * @param object The render object to add.
         * @zh 向管理器添加渲染节点。
         * @param object 要添加的渲染对象。
         */
        addRenderObject(object: BaseRender): void;
        /**
         * @en Removes a render node from the manager.
         * @param object The render object to remove.
         * @zh 从管理器移除渲染节点。
         * @param object 要移除的渲染对象。
         */
        removeRenderObject(object: BaseRender): void;
        /**
         * @en Removes a motion object from the manager.
         * @param object The motion object to remove.
         * @zh 从管理器移除运动对象。
         * @param object 要移除的运动对象。
         */
        removeMotionObject(object: BaseRender): void;
        /**
         * @en Updates all motion render data.
         * @zh 更新所有运动渲染数据。
         */
        updateMotionObjects(): void;
        /**
         * @en Updates the scene render.
         * @zh 更新场景渲染。
         */
        renderUpdate(): void;
        /**
         * @en Adds motion render data to the manager.
         * @param object The motion render object to add.
         * @zh 向管理器添加运动渲染数据。
         * @param object 要添加的运动渲染对象。
         */
        addMotionObject(object: BaseRender): void;
        /**
         * @en Destroys and cleans up the manager resources.
         * @zh 销毁并清理管理器资源。
         */
        destroy(): void;
    }
    class SimpleSkinnedMeshRenderer extends SkinnedMeshRenderer {
        private _ownerSimpleRenderNode;
        protected _isISkinRenderNode(): any;
        /**
         * @ignore
         * @en Creates an instance of SimpleSkinnedMeshRenderer.
         * @zh 创建一个 SimpleSkinnedMeshRenderer 的实例。
         */
        constructor();
        protected _computeSkinnedData(): void;
        /**
         * @perfTag PerformanceDefine.T_SkinBoneUpdate
         * @en Update the render state of the skinned mesh.
         * @param context The 3D render context
         * @zh 更新蒙皮网格的渲染状态。
         * @param context 3D 渲染上下文。
         */
        renderUpdate(context: RenderContext3D): void;
        /**
         * @en Set custom data
         * @param value1 Custom data 1
         * @param value2 Custom data 2
         * @zh 自定义数据
         * @param value1 自定义数据1
         * @param value2 自定义数据1
         */
        setCustomData(value1: number, value2?: number): void;
    }
    /**
     * @en The `SimpleSkinnedMeshSprite3D` class is used to create a simple skinned mesh.
     * @zh `SimpleSkinnedMeshSprite3D` 类用于创建简单网格。
     */
    class SimpleSkinnedMeshSprite3D extends RenderableSprite3D {
        /** */
        static SIMPLE_SIMPLEANIMATORTEXTURE: number;
        static SIMPLE_SIMPLEANIMATORPARAMS: number;
        static SIMPLE_SIMPLEANIMATORTEXTURESIZE: number;
        /**
         * @en The mesh filter component.
         * @zh 网格过滤器。
         */
        get meshFilter(): MeshFilter;
        /**
         * @en The simple skinned mesh renderer component.
         * @zh 网格渲染器。
         */
        get simpleSkinnedMeshRenderer(): SimpleSkinnedMeshRenderer;
        /**
         * @en Constructor function.
         * @param mesh The mesh to use. The default material for the mesh will also be loaded.
         * @param name The name of the instance.
         * @zh 构造函数。
         * @param mesh 网格,同时会加载网格所用默认材质。
         * @param name 名字。
         */
        constructor(mesh?: Mesh, name?: string);
        /**
         * @inheritDoc
         * @override
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * @en The `SkinnedMeshRenderer` class is used for skinned mesh rendering.
     * @zh `SkinnedMeshRenderer` 类用于蒙皮网格渲染。
     */
    class SkinnedMeshRenderer extends MeshRenderer {
        owner: Sprite3D;
        private _ownerSkinRenderNode;
        /**
         * @en Local bounds.
         * @zh 局部边界。
         */
        get localBounds(): Bounds;
        set localBounds(value: Bounds);
        /**
         * @en Root node.
         * @zh 根节点。
         */
        get rootBone(): Sprite3D;
        set rootBone(value: Sprite3D);
        /**
         * @en The bones used for skinning.
         * @zh 用于蒙皮的骨骼。
         */
        get bones(): Sprite3D[];
        set bones(value: Sprite3D[]);
        /**
         * @ignore
         * @en Creates an instance of SkinnedMeshRenderer.
         * @zh 创建一个 SkinnedMeshRenderer 的实例。
         */
        constructor();
        /**
         * override it
         * @returns
         */
        protected _createBaseRenderNode(): IBaseRenderNode;
        protected _isISkinRenderNode(): any;
        protected _statAdd(): void;
        protected _statRemove(): void;
        /**
         * @perfTag PerformanceDefine.T_SkinBoneUpdate
         * @en Updates the render state of the skinned mesh renderer.
         * @param context The 3D render context.
         * @zh 更新蒙皮网格渲染器的渲染状态。
         * @param context 3D渲染上下文。
         */
        renderUpdate(context: RenderContext3D): void;
        /**
         * @override
         * @param dest
         */
        _cloneTo(dest: SkinnedMeshRenderer): void;
    }
    /**
     * @en The `SkinnedMeshSprite3D` class is used for sprite with skinned mesh and bone nodes.
     * @zh `SkinnedMeshSprite3D` 类用于绑点骨骼节点精灵。
     */
    class SkinnedMeshSprite3D extends RenderableSprite3D {
        /**
         * @en Shader variable name for skinned animation.
         * @zh 着色器变量名，用于蒙皮动画。
         */
        static BONES: number;
        /**
         * @en Mesh filter component.
         * @zh 网格过滤器。
         */
        get meshFilter(): MeshFilter;
        /**
         * @en Skinned mesh renderer component.
         * @zh 网格渲染器。
         */
        get skinnedMeshRenderer(): SkinnedMeshRenderer;
        /**
         * @ignore
         * @en Creates an instance of SkinnedMeshSprite3D.
         * @param mesh The mesh to be used. The default material for the mesh will also be loaded.
         * @param name The name of the sprite.
         * @zh 创建一个 SkinnedMeshSprite3D 的实例。
         * @param mesh 网格,同时会加载网格所用默认材质。
         * @param name 名字。
         */
        constructor(mesh?: Mesh, name?: string);
        /**
         * @inheritDoc
         * @override
         * @en Destroy the SkinnedMeshSprite3D instance.
         * @param destroyChild Whether to destroy child nodes.
         * @zh 销毁 SkinnedMeshSprite3D 实例。
         * @param destroyChild 是否销毁子节点。
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * @en Class for Skinned Mesh Sprite3D Shader Declarations
     * @zh 蒙皮网格3D精灵着色器声明类
     */
    class SkinnedMeshSprite3DShaderDeclaration {
        /**
         * @en Sprite-level shader macro definition for skinned animation.
         * @zh 精灵级着色器宏定义，用于蒙皮动画。
         */
        static SHADERDEFINE_BONE: ShaderDefine;
        /**
         * @en Sprite-level shader macro definition for simple bone animation.
         * @zh 精灵级着色器宏定义，用于简单骨骼动画。
         */
        static SHADERDEFINE_SIMPLEBONE: ShaderDefine;
    }
    /**
     * @en The `Sprite3D` class is used to implement 3D sprites.
     * @zh `Sprite3D` 类用于实现3D精灵。
     */
    class Sprite3D extends Node {
        /**
         * @en Indicates the front face direction. -1 for inverted back face, 1 for normal situation.
         * @zh -1 表示翻转了背面，1 表示正常情况。
         */
        static WORLDINVERTFRONT: number;
        /**
         * @en Create a clone instance of the sprite.
         * @param original The original sprite.
         * @param parent The parent node. Default is null.
         * @param worldPositionStays Whether to maintain its own world transformation. Default is true.
         * @param position World position, effective when worldPositionStays is false. Default is null.
         * @param rotation World rotation, effective when worldPositionStays is false. Default is null.
         * @returns The cloned instance.
         * @zh 创建精灵的克隆实例。
         * @param original 原始精灵。
         * @param parent 父节点。默认为 null。
         * @param worldPositionStays 是否保持自身世界变换。默认为 true。
         * @param position 世界位置，worldPositionStays 为 false 时生效。默认为 null。
         * @param rotation 世界旋转，worldPositionStays 为 false 时生效。默认为 null。
         * @returns 克隆实例。
         */
        static instantiate(original: Sprite3D, parent?: Node, worldPositionStays?: boolean, position?: Vector3, rotation?: Quaternion): Sprite3D;
        /**
         * @deprecated 请使用Loader.load(url:string, type: ILaya.Loader.HIERARCHY)
         * @en Load mesh template.
         * @param url The template URL.
         * @param complete The completion callback.
         * @zh 加载网格模板。
         * @param url 模板地址。
         * @param complete 完成回调。
         */
        static load(url: string, complete: Handler): void;
        /**
         * @en Unique identifier ID.
         * @zh 唯一标识ID。
         */
        get id(): number;
        /**
         * @en Mask layer.
         * @zh 蒙版层。
         */
        get layer(): number;
        set layer(value: number);
        /**
         * @en Whether the sprite is static.
         * @zh 是否为静态。
         */
        get isStatic(): boolean;
        /**
         * @en Sprite transformation.
         * @zh 精灵变换。
         */
        get transform(): Transform3D;
        /**
         * @en Get the scene to which the sprite belongs.
         * @zh 获取精灵所属的场景。
         */
        get scene(): Scene3D;
        /**
         * @en Creates an instance of the Sprite3D class.
         * @param name Sprite name.
         * @param isStatic Whether it is static.
         * @zh 创建 Sprite3D 类的实例。
         * @param name 精灵名称。
         * @param isStatic 是否为静态。
         */
        constructor(name?: string, isStatic?: boolean);
        /**
         * @en clone.
         * @returns clone instance.
         * @zh 克隆。
         * @returns	克隆副本。
         */
        clone(): Node;
        /**
         * @en destroy
         * @param destroyChild whether to destroy the child node.
         * @zh 销毁
         * @param destroyChild 是否销毁子节点
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * @en Enum for trail alignment options.
     * @zh 拖尾对齐方式枚举。
     */
    enum TrailAlignment {
        /**
         * @en Align the trail to face the camera.
         * @zh 使拖尾面向摄像机。
         */
        View = 0,
        /**
         * @en Align the trail with the direction of the component
         * @zh 使拖尾与组件的方向对齐。
         */
        TransformZ = 1
    }
    /**
     * @en The TrailFilter class is used to create a trailing filter.
     * @zh TrailFilter 类用于创建拖尾过滤器。
     */
    class TrailFilter {
        /**
         * @en The trail alignment.
         * @zh 轨迹准线。
         */
        alignment: TrailAlignment;
        /**
         * @en Fade out time.
         * @zh 淡出时间。
         */
        get time(): number;
        set time(value: number);
        /**
         * @en Minimum distance between new and old vertices
         * @zh 新旧顶点之间最小距离。
         */
        get minVertexDistance(): number;
        set minVertexDistance(value: number);
        /**
         * @en The width multiplier.
         * @zh 宽度倍数。
         */
        get widthMultiplier(): number;
        set widthMultiplier(value: number);
        /**
         * @en The width curve. The maximum number is 10.
         * @zh 宽度曲线。最多10个。
         */
        get widthCurve(): FloatKeyframe[];
        set widthCurve(value: FloatKeyframe[]);
        /**
         * @en The color gradient.
         * @zh 颜色梯度。
         */
        get colorGradient(): Gradient;
        set colorGradient(value: Gradient);
        /**
         * @en The texture mode.
         * @zh 纹理模式。
         */
        get textureMode(): TrailTextureMode;
        set textureMode(value: TrailTextureMode);
        /** @ignore */
        constructor(owner: TrailRenderer);
        /**
         * @en Clears the trail.
         * @zh 清除拖尾。
         */
        clear(): void;
    }
    /**
     * @en The `TrailGeometry` class is used to create trail rendering elements.
     * @zh `TrailGeometry` 类用于创建拖尾渲染单元。
     */
    class TrailGeometry extends GeometryElement {
        /**
         * @en Alignment of the trail ti j wq e o face the camera.
         * @zh 轨迹准线_面向摄像机。
         */
        static ALIGNMENT_VIEW: number;
        /**
         * @en Alignment of the trail to face the direction of movement.
         * @zh 轨迹准线_面向运动方向。
         */
        static ALIGNMENT_TRANSFORM_Z: number;
        /** @private */
        private _disappearBoundsMode;
        constructor(owner: TrailFilter);
        /**
         * @inheritDoc
         * @override
         * @en Get the type.
         * @zh 获取类型。
         */
        _getType(): number;
        /**
         * @inheritDoc
         * @override
         * @en Destroys the instance and releases resources.
         * @zh 销毁实例并释放资源。
         */
        destroy(): void;
        /**
         * @en Clear.
         * @zh 清除。
         */
        clear(): void;
    }
    /**
     * @en The `TrailMaterial` class is used to implement trail materials.
     * @zh `TrailMaterial` 类用于实现拖尾材质。
     */
    class TrailMaterial extends Material {
        /**
         * @en The default material, do not modify.
         * @zh 默认材质，禁止修改。
         */
        static defaultMaterial: TrailMaterial;
        /**
         * @en The color of the material.
         * @zh 材质的颜色。
         */
        get color(): Color;
        set color(value: Color);
        /**
         * @en The texture of the material.
         * @zh 材质贴图。
         */
        get texture(): BaseTexture;
        set texture(value: BaseTexture);
        /**
         * @en The tiling and offset of the texture.
         * @zh 纹理的平铺和偏移。
         */
        get tilingOffset(): Vector4;
        set tilingOffset(value: Vector4);
        /**@ignore */
        constructor();
        /**
         * @inheritdoc
         * @override
         * @en Clones the material.
         * @returns A cloned instance of the material.
         * @zh 克隆材质。
         * @returns 材质的一个克隆实例。
         */
        clone(): any;
        /**
         * @deprecated
         * 渲染状态_透明混合。
         */
        static RENDERMODE_ALPHABLENDED: number;
        /**
        * @deprecated
        * 渲染状态_加色法混合。
        */
        static RENDERMODE_ADDTIVE: number;
        /**
         * @deprecated
         * 渲染模式。现在可以直接使用materialRenderMode
         */
        set renderMode(value: number);
    }
    /**
     * @en The `TrailRenderer` class is used to create a trail renderer.
     * @zh `TrailRenderer` 类用于创建拖尾渲染器。
     */
    class TrailRenderer extends BaseRender {
        /** @ignore */
        constructor();
        protected _getcommonUniformMap(): Array<string>;
        protected _createBaseRenderNode(): IBaseRenderNode;
        /**
         * @en Fade out time. Unit: s.
         * @zh 淡出时间。单位: 秒。
         */
        get time(): number;
        set time(value: number);
        /**
         * @en Minimum distance between new and old vertices.
         * @zh 新旧顶点之间最小距离。
         */
        get minVertexDistance(): number;
        set minVertexDistance(value: number);
        /**
         * @en The width multiplier.
         * @zh 宽度倍数。
         */
        get widthMultiplier(): number;
        set widthMultiplier(value: number);
        /**
         * @en The width curve. Maximum 10.
         * @zh 宽度曲线。最多10个。
         */
        get widthCurve(): FloatKeyframe[];
        set widthCurve(value: FloatKeyframe[]);
        /**
         * @en The color gradient.
         * @zh 颜色梯度。
         */
        get colorGradient(): Gradient;
        set colorGradient(value: Gradient);
        /**
         * @en The texture mode.
         * @zh 纹理模式。
         */
        get textureMode(): TrailTextureMode;
        set textureMode(value: TrailTextureMode);
        /**
         * @en The trail alignment.
         * @zh 拖尾轨迹准线
         */
        get alignment(): TrailAlignment;
        set alignment(value: TrailAlignment);
        /**
         * @en Render update.
         * @param context 3D rendering context.
         * @zh 渲染更新。
         * @param context 3D渲染上下文
         */
        renderUpdate(context: RenderContext3D): void;
        /**
         * @en The bounding box. Read-only, do not modify its value.
         * @zh 包围盒,只读,不允许修改其值。
         */
        get bounds(): Bounds;
        /**
         * @en Clear the trail.
         * @zh 清除拖尾
         */
        clear(): void;
    }
    /**
     * @en Trail Texture Mode
     * @zh 拖尾纹理模式
     */
    class TrailTextureMode {
        /**
         * @en Stretch mode.
         * @zh 拉伸模式。
         */
        static Stretch: number;
        /**
         * @en Tile mode.
         * @zh 平铺模式。
         */
        static Tile: number;
    }
    /**
     * @en The `Transform3D` class is used to implement 3D transformations.
     * @zh `Transform3D` 类用于实现3D变换。
     */
    class Transform3D extends EventDispatcher {
        /**
         * @en Whether it is the default matrix. If `true`, it indicates that there is no change relative to the parent node, and calculations will be skipped based on this parameter.
         * @zh 是否为默认矩阵，如果为true，表示自身相对于父节点并无任何改变，将通过这个参数忽略计算。
         */
        get isDefaultMatrix(): boolean;
        /**
         * @en Whether the front face is clockwise.
         * @zh 获取是否前向顺时针面。
         */
        getFrontFaceValue(): number;
        /**
         * @en The sprite to which this transform belongs.
         * @zh 所属精灵。
         */
        get owner(): Sprite3D;
        /**
         * @en Whether the world matrix needs to be updated.
         * @zh 世界矩阵是否需要更新。
         */
        get worldNeedUpdate(): boolean;
        /**
         * @en The X component of the local position.
         * @zh 局部位置X轴分量。
         */
        get localPositionX(): number;
        set localPositionX(x: number);
        /**
         * @en The Y component of the local position.
         * @zh 局部位置Y轴分量。
         */
        get localPositionY(): number;
        set localPositionY(y: number);
        /**
         * @en The Z component of the local position.
         * @zh 局部位置Z轴分量。
         */
        get localPositionZ(): number;
        set localPositionZ(z: number);
        /**
         * @en The local position.
         * @zh 局部位置。
         */
        get localPosition(): Vector3;
        set localPosition(value: Vector3);
        /**
         * @en The X component of the local rotation quaternion.
         * @zh 局部旋转四元数X分量。
         */
        get localRotationX(): number;
        set localRotationX(x: number);
        /**
         * @en The Y component of the local rotation quaternion.
         * @zh 局部旋转四元数Y分量。
         */
        get localRotationY(): number;
        set localRotationY(y: number);
        /**
         * @en The Z component of the local rotation quaternion.
         * @zh 局部旋转四元数Z分量。
         */
        get localRotationZ(): number;
        set localRotationZ(z: number);
        /**
         * @en The W component of the local rotation quaternion.
         * @zh 局部旋转四元数W分量。
         */
        get localRotationW(): number;
        set localRotationW(w: number);
        /**
         * @en The local rotation.
         * @zh 局部旋转。
         */
        get localRotation(): Quaternion;
        set localRotation(value: Quaternion);
        /**
         * @en The X component of the local scale.
         * @zh 局部缩放X。
         */
        get localScaleX(): number;
        set localScaleX(value: number);
        /**
         * @en The Y component of the local scale.
         * @zh 局部缩放Y。
         */
        get localScaleY(): number;
        set localScaleY(value: number);
        /**
         * @en The Z component of the local scale.
         * @zh 局部缩放Z。
         */
        get localScaleZ(): number;
        set localScaleZ(value: number);
        /**
         * @en The local scale of the transform.
         * @zh 局部缩放。
         */
        get localScale(): Vector3;
        set localScale(value: Vector3);
        /**
         * @en The X component of the local rotation euler angles.
         * @zh 局部空间的X轴欧拉角。
         */
        get localRotationEulerX(): number;
        set localRotationEulerX(value: number);
        /**
         * @en The Y component of the local rotation euler angles.
         * @zh 局部空间的Y轴欧拉角。
         */
        get localRotationEulerY(): number;
        set localRotationEulerY(value: number);
        /**
         * @en The Z component of the local rotation euler angles.
         * @zh 局部空间的Z轴欧拉角。
         */
        get localRotationEulerZ(): number;
        set localRotationEulerZ(value: number);
        /**
         * @en The local rotation euler angles of the transform.
         * @zh 局部空间欧拉角。
         */
        get localRotationEuler(): Vector3;
        set localRotationEuler(value: Vector3);
        /**
         * @en The local matrix.
         * @zh 局部矩阵。
         */
        get localMatrix(): Matrix4x4;
        set localMatrix(value: Matrix4x4);
        /**
         * @en World position.
         * @zh 世界位置。
         */
        get position(): Vector3;
        set position(value: Vector3);
        /**
         * @en World rotation.
         * @zh 世界旋转。
         */
        get rotation(): Quaternion;
        set rotation(value: Quaternion);
        /**
         * @en Rotation angles in world space, in the order of x, y, z.
         * @zh 世界空间的旋转角度，顺序为x、y、z。
         */
        get rotationEuler(): Vector3;
        set rotationEuler(value: Vector3);
        /**
         * @en World matrix.
         * @zh 世界矩阵。
         */
        get worldMatrix(): Matrix4x4;
        set worldMatrix(value: Matrix4x4);
        protected _initProperty(): void;
        /**
         * @en Perform translation transformation.
         * @param translation The distance to move.
         * @param isLocal Whether to use local space. Default is true.
         * @zh 平移变换。
         * @param translation 移动距离。
         * @param isLocal 是否局部空间。默认为 true。
         */
        translate(translation: Vector3, isLocal?: boolean): void;
        /**
         * @en Perform rotation transformation.
         * @param rotation The rotation amount.
         * @param isLocal Whether to use local space. Default is true.
         * @param isRadian Whether the rotation is in radians. Default is true.
         * @zh 旋转变换。
         * @param rotation 旋转幅度。
         * @param isLocal 是否局部空间。默认为 true。
         * @param isRadian 是否弧度制。默认为 true。
         */
        rotate(rotation: Vector3, isLocal?: boolean, isRadian?: boolean): void;
        /**
         * @en Get the forward direction.
         * @param forward The vector to the forward direction.
         * @zh 获取向前方向。
         * @param forward 前方向。
         */
        getForward(forward: Vector3): void;
        /**
         * @en Get the up direction.
         * @param up The vector to the up direction.
         * @zh 获取向上方向。
         * @param up 上方向。
         */
        getUp(up: Vector3): void;
        /**
         * @en Get the right direction.
         * @param right The vector to the right direction.
         * @zh 获取向右方向。
         * @param right 右方向。
         */
        getRight(right: Vector3): void;
        /**
         * @en Look at a target position.
         * @param target The target to look at.
         * @param up The up vector.
         * @param isLocal Whether to use local space. Default is false.
         * @param isCamera Whether it's a camera. Default is true.
         * @zh 观察目标位置。
         * @param target 观察目标。
         * @param up 向上向量。
         * @param isLocal 是否局部空间。默认为 false。
         * @param isCamera 是否为相机。默认为 true。
         */
        lookAt(target: Vector3, up: Vector3, isLocal?: boolean, isCamera?: boolean): void;
        /**
         * @en Make the object face towards a target.
         * @param target The target position to face.
         * @param up The up vector.
         * @param isLocal Whether to use local space. Default is false.
         * @zh 对象朝向目标。
         * @param target 朝向目标位置。
         * @param up 向上向量。
         * @param isLocal 是否局部空间。默认为 false。
         */
        objLookat(target: Vector3, up: Vector3, isLocal?: boolean): void;
        /**
         * @en The world scale.
         * Under certain conditions, obtaining this value may not be accurate (e.g., when the parent node has scaling and the child node has rotation).
         * The scaling may be skewed and cannot be correctly represented using Vector3. A Matrix3x3 matrix must be used for correct representation.
         * @returns The world scale.
         * @zh 世界缩放。
         * 某种条件下获取该值可能不正确（例如：父节点有缩放，子节点有旋转）。
         * 缩放会倾斜，无法使用Vector3正确表示，必须使用Matrix3x3矩阵才能正确表示。
         * @returns 世界缩放。
         */
        getWorldLossyScale(): Vector3;
        /**
         * @en Set the world scale.
         * Under certain conditions, setting this value may not be accurate (e.g., when the parent node has scaling and the child node has rotation).
         * The scaling may be skewed and cannot be correctly represented using Vector3. A Matrix3x3 matrix must be used for correct representation.
         * @param value The world scale to set.
         * @return The world scale.
         * @zh 设置世界缩放。
         * 某种条件下设置该值可能不正确（例如：父节点有缩放，子节点有旋转）。
         * 缩放会倾斜，无法使用Vector3正确表示，必须使用Matrix3x3矩阵才能正确表示。
         * @param value 要设置的世界缩放。
         * @return	世界缩放。
         */
        setWorldLossyScale(value: Vector3): void;
        /**
         * @en Transform a local vector to global space.
         * @param value The local vector to transform.
         * @param out The output global vector.
         * @zh 将局部向量转换为全局向量。
         * @param value 要转换的局部向量。
         * @param out 输出的全局向量。
         */
        localToGlobal(value: Vector3, out: Vector3): void;
        /**
         * @en Transform a global position to local space.
         * @param pos The world position to transform.
         * @param out The output local position.
         * @zh 将世界坐标转换为局部坐标。
         * @param pos 要转换的世界坐标。
         * @param out 输出的局部坐标。
         */
        globalToLocal(pos: Vector3, out: Vector3): void;
        /**
         * @en Transform a global normal vector to local space.
         * @param pos The global normal vector to transform.
         * @param out The output local normal vector.
         * @zh 将全局法线向量转换为局部空间。
         * @param pos 要转换的全局法线向量。
         * @param out 输出的局部法线向量。
         */
        toLocalNormal(pos: Vector3, out: Vector3): void;
        /**
         * @en Rotate to face a specified direction.
         * @param forward The forward vector.
         * @param dir The target direction to face.
         * @zh 朝向指定方向。
         * @param forward 前向向量。
         * @param dir 目标朝向方向。
         */
        toDir(forward: Vector3, dir: Vector3): void;
        /**
         * @en This is a function from glmatrix. Sets a quaternion to represent the shortest rotation from one vector to another.
         * Both vectors are assumed to be unit length.
         * @param out The receiving quaternion.
         * @param a The initial vector (normalized).
         * @param b The destination vector (normalized).
         * @returns {boolean} True if a rotation was applied, false if the vectors are already aligned.
         * @zh 这是一个 glmatrix 中的函数。设置一个四元数来表示从一个向量到另一个向量的最短旋转。
         * 假设两个向量都是单位长度。
         * @param out 接收结果的四元数。
         * @param a 初始向量（已归一化）。
         * @param b 目标向量（已归一化）。
         * @returns {boolean} 如果应用了旋转则返回 true，如果向量已经对齐则返回 false。
         */
        rotationTo(out: Quaternion, a: Vector3, b: Vector3): boolean;
        /**
         * 世界坐标系缩放。
         * @deprecated
         */
        get scale(): Vector3;
        /**
         * @deprecated
         */
        set scale(value: Vector3);
    }
    /**
     * @en UI3D class, used to create 3D UI components.
     * @zh UI3D类，用于创建3D UI组件。
     */
    class UI3D extends BaseRender {
        /**
         * @en The Sprite3D owner of this UI3D component.
         * @zh 3D UI组件所属的3D节点。
         */
        owner: Sprite3D;
        private _shellSprite;
        protected _worldParams: Vector4;
        /**
         * @en UI nodes for 3D rendering
         * @zh 3D渲染的UI节点
         */
        get sprite(): Sprite;
        set sprite(value: Sprite);
        /**
         * IDE
         * @en The 3D rendering UI prefab.
         * @zh 3D渲染的UI预制体。
         */
        get prefab(): Prefab;
        set prefab(value: Prefab);
        /**
         * @en Mesh scale for 3D UI.
         * @zh 3D UI的网格缩放。
         */
        get scale(): Vector2;
        set scale(value: Vector2);
        /**
         * @en The UI render mode.
         * @zh UI渲染模式。
         */
        get renderMode(): MaterialRenderMode;
        set renderMode(value: MaterialRenderMode);
        /**
         * @en The UI culling mode.
         * @zh UI剔除模式。
         */
        get cull(): number;
        set cull(value: number);
        /**
         * @en The resolution rate.
         * @zh 分辨率比例。
         */
        get resolutionRate(): number;
        set resolutionRate(value: number);
        /**
         * @en The UI3D component is billboard mode.
         * @zh 面向相机模式
         */
        get billboard(): boolean;
        set billboard(value: boolean);
        /**
         * @en Detect mouse events, disable optimization performance, enable to trigger mouse events.
         * @zh 检测鼠标事件，关闭优化性能，开启可以触发鼠标事件
         */
        get enableHit(): boolean;
        set enableHit(value: boolean);
        /** @ignore
         * @en constructor method, initialize 3D UI.
         * @zh 构造方法，初始化3D UI。
        */
        constructor();
        private _creatDefaultMat;
        /**
        * 分析碰撞点
        * @param hit
        */
        private _parseHit;
        /**
         * @en Get the UI rendering texture.
         * @zh 获得ui渲染图
         */
        getUITexture(): BaseTexture;
        private _transByRotate;
    }
    /**
     * @en UI3DGeometry class is used to create and manage the geometry structure of 3D UI elements.
     * @zh UI3DGeometry 类用于创建和管理 3D UI元素的几何结构的类。
     */
    class UI3DGeometry extends GeometryElement {
        private _changeVertex;
        /**
         * @inheritDoc
         * @override
         * @en Destroys the instance and releases resources.
         * @zh 销毁实例并释放资源。
         */
        destroy(): void;
    }
    /**
     * @en UI3DManager calss is used to create 3D UI manager, which manages all 3D UI objects.
     * @zh UI3DManager 类用于创建3D-UI管理器，管理所有3D-UI对象。
     */
    class UI3DManager {
        /**
         * @en A list to store 3D UI elements.
         * @zh 存储3D-UI元素的列表。
         */
        _UI3Dlist: FastSinglelist<UI3D>;
        /** @ignore */
        constructor();
        /**
         * @en Adds a 3D UI element to the manager.
         * @param value The 3D UI element to add.
         * @zh 向管理器添加一个3D-UI元素。
         * @param value 要添加的3D-UI元素。
         */
        add(value: UI3D): void;
        /**
         * @en Removes a 3D UI element from the manager.
         * @param value The 3D UI element to remove.
         * @zh 从管理器中移除一个3D-UI元素。
         * @param value 要移除的3D-UI元素。
         */
        remove(value: UI3D): void;
        /**
         * @en Updates the 3D UI elements in the scene.
         * @zh 更新场景中的3D-UI元素。
         */
        update(): void;
        /**
         * @en Performs a ray cast to determine if there is a collision with any 3D UI elements.
         * @param ray The ray for the ray casting.
         * @returns The hit result or null if no collision occurs.
         * @zh 执行射线投射以判断是否与任何3D-UI元素发生碰撞。
         * @param ray 射线投射的射线。
         * @returns 返回碰撞结果或如果没有碰撞发生则返回null。
         */
        rayCast(ray: Ray): any;
        /**
         * @en Destroys the 3D UI elements managed by the list.
         * @zh 销毁列表中存储的3D-UI元素。
         */
        destory(): void;
    }
    /**
     * @en The `Vector2Keyframe` class is used to create instances of two-dimensional vector keyframes.
     * @zh `Vector2Keyframe` 类用于创建二维向量关键帧实例。
     */
    class Vector2Keyframe extends Keyframe {
        /**
         * @en In tangent.
         * @zh 内切线。
         */
        inTangent: Vector2;
        /**
         * @en Out tangent.
         * @zh 外切线。
         */
        outTangent: Vector2;
        /**
         * @en Frame data.
         * @zh 帧数据。
         */
        value: Vector2;
        /**
         * @en In weight.
         * @zh 内权重。
         */
        inWeight: Vector2;
        /**
         * @en Out weight.
         * @zh 外权重。
         */
        outWeight: Vector2;
        /**
         * @en Weight mode.
         * @zh 权重模式。
         */
        weightedMode: Vector2;
        /**
         * @en Creates an instance of Vector2Keyframe.
         * @param weightMode Whether to use weight mode. Default is false.
         * @zh 创建 Vector2Keyframe 的实例。
         * @param weightMode 是否使用权重模式。默认为 false。
         */
        constructor(weightMode?: boolean);
        /**
        * @override
        * @en Clone
        * @param dest The target object to clone to.
        * @zh 克隆
        * @param dest 克隆源。
        */
        cloneTo(dest: Vector2Keyframe): void;
    }
    /**
     * @en The `Vector3Keyframe` class is used to create instances of three-dimensional vector keyframes.
     * @zh `Vector3Keyframe` 类用于创建三维向量关键帧实例。
     */
    class Vector3Keyframe extends Keyframe {
        /**
         * @en In tangent.
         * @zh 内切线。
         */
        inTangent: Vector3;
        /**
         * @en Out tangent.
         * @zh 外切线。
         */
        outTangent: Vector3;
        /**
         * @en Frame data.
         * @zh 帧数据。
         */
        value: Vector3;
        /**
         * @en In weight.
         * @zh 内权重。
         */
        inWeight: Vector3;
        /**
         * @en Out weight.
         * @zh 外权重。
         */
        outWeight: Vector3;
        /**
         * @en Weight mode.
         * @zh 权重模式。
         */
        weightedMode: Vector3;
        /**
         * @en Creates an instance of Vector3Keyframe.
         * @param weightMode Whether to use weight mode. Default is false.
         * @zh 创建一个Vector3Keyframe实例。
         * @param weightMode 是否使用权重模式。默认为 false。
         */
        constructor(weightMode?: boolean);
        /**
        * @override
        * @en Clone
        * @param dest The target object to clone to.
        * @zh 克隆
        * @param dest 克隆源。
        */
        cloneTo(dest: Vector3Keyframe): void;
    }
    /**
     * @en The `Vector4Keyframe` class is used to create instances of four-dimensional vector keyframes.
     * @zh `Vector4Keyframe` 类用于创建四维向量关键帧实例。
     */
    class Vector4Keyframe extends Keyframe {
        /**
         * @en In tangent.
         * @zh 内切线。
         */
        inTangent: Vector4;
        /**
         * @en Out tangent.
         * @zh 外切线。
         */
        outTangent: Vector4;
        /**
         * @en Frame data.
         * @zh 帧数据。
         */
        value: Vector4;
        /**
         * @en In weight.
         * @zh 内权重。
         */
        inWeight: Vector4;
        /**
         * @en Out weight.
         * @zh 外权重。
         */
        outWeight: Vector4;
        /**
         * @en Out weight.
         * @zh 外权重。
         */
        weightedMode: Vector4;
        /**
         * @en Creates an instance of the `Vector4Keyframe` class.
         * @param weightMode Whether to use weight mode. Default is false.
         * @zh 创建 `Vector4Keyframe` 类的实例。
         * @param weightMode 是否使用权重模式。默认为 false。
         */
        constructor(weightMode?: boolean);
        /**
        * @override
        * @en Clone
        * @param dest The target object to clone to.
        * @zh 克隆
        * @param dest 克隆源。
        */
        cloneTo(dest: Vector4Keyframe): void;
    }
    /**
     * @en DepthCasterData class for managing depth casting data.
     * @zh DepthCasterData 类，用于管理深度投射数据。
     */
    class DepthCasterData {
        /**
         * @en Stores the uniform buffer data for the depth caster
         * @zh 存储深度投射器的统一缓冲数据
         */
        static DepthCasterUBOData: UnifromBufferData;
    }
    /**
     * @en The `DepthPass` class is responsible for handling depth rendering and shadow mapping in a 3D scene.
     * @zh `DepthPass` 类负责处理3D场景中的深度渲染和阴影映射。
     */
    class DepthPass {
        static SHADOW_BIAS: Vector4;
        private _zBufferParams;
        static __init__(): void;
        /** @ignore */
        constructor();
        /**
         * @en Creates and assigns the appropriate render texture for capturing depth information based on the specified depth texture mode. This method configures the camera's properties to hold newly created textures prepared for depth or depth normals rendering.
         * @param camera The camera for which the depth texture is being prepared.
         * @param depthType The type of depth texture to create, which determines the kind of data the texture will capture (e.g., depth only, depth and normals).
         * @param depthTextureFormat The format of the depth texture, defining how the data is represented.
         * @zh 根据指定的深度纹理模式创建并分配相应的渲染纹理，用于捕捉深度信息。
         * 此方法配置相机的属性，以保存为深度或深度法线渲染准备的新创建的纹理。
         * @param camera 准备深度纹理的相机。
         * @param depthType 要创建的深度纹理类型，决定纹理将捕捉的数据种类（如仅深度，深度加法线等）。
         * @param depthTextureFormat 深度纹理的格式，定义数据的表示方式。
         */
        getTarget(camera: Camera, depthType: DepthTextureMode, depthTextureFormat: RenderTargetFormat): void;
    }
    /**
     * @en IndexBuffer3D class is used to create index buffer. Please use LayaGL.RenderOBJCreate.createIndexBuffer3D to create.
     * @zh IndexBuffer3D 类用于创建索引缓冲。请使用LayaGL.RenderOBJCreate.createIndexBuffer3D来创建。
     */
    class IndexBuffer3D {
        private _indexType;
        _byteLength: number;
        _buffer: Float32Array | Uint16Array | Uint8Array | Uint32Array;
        bufferUsage: BufferUsage;
        /**
         * @en The index type.
         * @zh 索引类型。
         */
        get indexType(): IndexFormat;
        /**
         * @en The byte count of the index type.
         * @zh 索引类型字节数量。
         */
        get indexTypeByteCount(): number;
        /**
         * @en The number of indices.
         * @zh 索引个数。
         */
        get indexCount(): number;
        /**
         * @en Whether the buffer can be read.
         * @zh 是否可读。
         */
        get canRead(): boolean;
        /**
         * @en Constructor method, create index buffer.
         * @param	indexType Index type.
         * @param	indexCount Index count.
         * @param	bufferUsage IndexBuffer3D usage type.
         * @param	canRead Whether the buffer can be read.
         * @zh 构造方法,创建索引缓冲。
         * @param	indexType 索引类型。
         * @param	indexCount 索引个数。
         * @param	bufferUsage IndexBuffer3D用途类型。
         * @param	canRead 是否可读。
         */
        constructor(indexType: IndexFormat, indexCount: number, bufferUsage?: BufferUsage, canRead?: boolean);
        /**
         * @en Sets the data for the index buffer.
         * @param data The index data.
         * @param bufferOffset The offset within the index buffer.
         * @param dataStartIndex The offset within the data.
         * @param dataCount The number of indices to set.
         * @zh 设置索引缓冲区的数据。
         * @param data 索引数据。
         * @param bufferOffset 索引缓冲中的偏移。
         * @param dataStartIndex 索引数据的偏移。
         * @param dataCount 索引数据的数量。
         */
        setData(data: any, bufferOffset?: number, dataStartIndex?: number, dataCount?: number): void;
        /**
         * @en Gets the index data.
         * @returns The index data.
         * @zh 获取索引数据。
         * @returns 返回索引数据。
         */
        getData(): Uint16Array | Uint32Array;
        /**
         * @inheritDoc
         * @override
         * @en Destroys this IndexBuffer3D.
         * @zh 销毁此索引缓冲。
         */
        destroy(): void;
    }
    /**
     * @en The IVertex interface is used to create vertex declarations.
     * @zh IVertex 接口用于实现创建顶点声明。
     */
    interface IVertex {
        /**
         * @en The vertex declaration.
         * @zh 顶点声明
         */
        vertexDeclaration: VertexDeclaration;
    }
    /**
     * @en Second-order spherical harmonics function.
     * @zh 二阶球谐函数。
     */
    class SphericalHarmonicsL2 {
        /**
         * @en Gets the coefficient for a specific color channel.
         * @param i The channel index, ranging from 0 to 2.
         * @param j The coefficient index, ranging from 0 to 8.
         * @returns The coefficient value.
         * @zh 获取特定颜色通道的系数。
         * @param i 通道索引，范围0到2。
         * @param j 系数索引，范围0到8。
         * @returns 系数值。
         */
        getCoefficient(i: number, j: number): number;
        /**
         * @en Sets the coefficient for a specific color channel.
         * @param i The channel index, ranging from 0 to 2.
         * @param j The coefficient index, ranging from 0 to 8.
         * @param coefficient The coefficient value to set.
         * @zh 设置特定颜色通道的系数。
         * @param i 通道索引，范围0到2。
         * @param j 系数索引，范围0到8。
         * @param coefficient 要设置的系数值。
         */
        setCoefficient(i: number, j: number, coefficient: number): void;
        /**
         * @en Sets the coefficients for a specific color channel.
         * @param i The channel index, ranging from 0 to 2.
         * @param coefficient0 Coefficient 0
         * @param coefficient1 Coefficient 1
         * @param coefficient2 Coefficient 2
         * @param coefficient3 Coefficient 3
         * @param coefficient4 Coefficient 4
         * @param coefficient5 Coefficient 5
         * @param coefficient6 Coefficient 6
         * @param coefficient7 Coefficient 7
         * @param coefficient8 Coefficient 8
         * @zh 设置颜色通道的系数。
         * @param i 通道索引，范围0到2。
         * @param coefficient0 系数0
         * @param coefficient1 系数1
         * @param coefficient2 系数2
         * @param coefficient3 系数3
         * @param coefficient4 系数4
         * @param coefficient5 系数5
         * @param coefficient6 系数6
         * @param coefficient7 系数7
         * @param coefficient8 系数8
         */
        setCoefficients(i: number, coefficient0: number, coefficient1: number, coefficient2: number, coefficient3: number, coefficient4: number, coefficient5: number, coefficient6: number, coefficient7: number, coefficient8: number): void;
        /**
         * @en Clones the spherical harmonics data to another instance.
         * @param dest The destination instance to which the data is cloned.
         * @zh 克隆球谐函数数据到另一个实例。
         * @param dest 克隆数据的目标实例。
         */
        cloneTo(dest: SphericalHarmonicsL2): void;
    }
    /**
     * @en The `VertexBuffer3D` class is used to create vertex buffers. To create an instance of `VertexBuffer3D`, use `LayaGL.RenderOBJCreate.createIndexBuffer3D`.
     * @zh `VertexBuffer3D` 类用于创建顶点缓冲。要创建 `VertexBuffer3D` 的实例，请使用 `LayaGL.RenderOBJCreate.createIndexBuffer3D`。
     */
    class VertexBuffer3D {
        _byteLength: number;
        _buffer: Float32Array | Uint16Array | Uint8Array | Uint32Array;
        bufferUsage: BufferUsage;
        /**
         * @en The vertex declaration.
         * @zh 顶点声明。
         */
        get vertexDeclaration(): VertexDeclaration | null;
        set vertexDeclaration(value: VertexDeclaration | null);
        /**
         * @en Whether this is an instance buffer.
         * @zh 是否是实例缓冲区。
         */
        get instanceBuffer(): boolean;
        set instanceBuffer(value: boolean);
        /**
         * @en Whether the buffer is readable.
         * @zh 缓冲区是否可读。
         */
        get canRead(): boolean;
        /**
         * @en Constructor method.
         * @param byteLength The byte length of the buffer.
         * @param bufferUsage The usage type of the VertexBuffer3D.
         * @param canRead Whether the buffer is readable.
         * @zh 构造方法。
         * @param byteLength 字节长度。
         * @param bufferUsage VertexBuffer3D用途类型。
         * @param canRead 是否可读。
         */
        constructor(byteLength: number, bufferUsage: BufferUsage, canRead?: boolean);
        /**
         * @en Sets the data for the vertex buffer.
         * @param buffer The data to set.
         * @param bufferOffset The offset within the vertex buffer, in bytes.
         * @param dataStartIndex The starting index within the data, in bytes.
         * @param dataCount The number of bytes to set.
         * @zh 设置顶点缓冲区的数据。
         * @param buffer 要设置的数据。
         * @param bufferOffset 顶点缓冲中的偏移,以字节为单位。
         * @param dataStartIndex 顶点数据的偏移,以字节为单位。
         * @param dataCount 顶点数据的长度,以字节为单位。
         */
        setData(buffer: ArrayBuffer, bufferOffset?: number, dataStartIndex?: number, dataCount?: number): void;
        /**
         * @en Gets the vertex data as a `Uint8Array`.
         * @zh 以 `Uint8Array` 形式获取顶点数据。
         */
        getUint8Data(): Uint8Array;
        /**
         * @ignore
         * @en Gets the vertex data as a `Float32Array`, if the buffer is readable.
         * @zh 如果缓冲区可读，以 `Float32Array` 形式获取顶点数据。
         */
        getFloat32Data(): Float32Array | null;
        /**
         * @ignore
         * @en Marks the buffer as unreadable and releases the data.
         * @zh 将缓冲区标记为不可读并释放数据。
         */
        markAsUnreadbale(): void;
        /**
         * @inheritDoc
         * @override
         * @en Destroys the vertex buffer and releases the resources.
         * @zh 销毁顶点缓冲区并释放资源。
         */
        destroy(): void;
    }
    /**
     * @ignore
     * @en Used for loading cubemap textures.
     * @zh 用于加载立方体纹理资源。
     */
    class CubemapLoader implements IResourceLoader {
        constructor();
        /**
         * @en Load a cubemap texture resource.
         * @param task The load task.
         * @returns A Promise, when loaded successfully, it is resolves with the loaded texture or null if loading fails.
         * @zh 加载立方体贴图资源。
         * @param task 加载任务。
         * @returns 一个Promise, 加载成功时解析为加载的纹理，加载失败时为 null。
         */
        load(task: ILoadTask): Promise<TextureCube>;
        private move;
    }
    /**
     * @ignore
     * @en Usedfor loading lens flare.
     * @zh 用于加载镜头光晕数据资源。
     */
    class LensFlareSettingsLoader implements IResourceLoader {
        /**
         * @en Load lens flare from a specified URL.
         * @param task The load task that contains the URL and other loading options.
         * @returns A Promise, when loaded successfully, it is resolves with the loaded `LensFlareData` object or null if loading fails.
         * @zh 加载指定的镜头光晕数据资源。
         * @param task 包含 URL 和其他加载选项的加载任务。
         * @returns 一个Promise，加载成功时解析为加载的 `LensFlareData` 对象，加载失败时为 null。
         */
        load(task: ILoadTask): Promise<LensFlareData>;
    }
    /**
     * @ignore
     * @en Used for loading 2D texture array resources(.tex2darray).
     * @zh 用于加载纹理数组资源（.tex2darray）。
     */
    class Texture2DArrayLoader implements IResourceLoader {
        constructor();
        /**
         * @en Load a 2D texture array from the specified URL.
         * @param task The load task that contains the URL and other loading options.
         * @returns A promise that resolves with the loaded texture array or null if loading fails.
         * @zh 加载指定的纹理数组资源。
         * @param task 包含 URL 和其他加载选项的加载任务。
         * @returns 一个Promise，加载成功时解析为加载的纹理数组，加载失败时为 null。
         */
        load(task: ILoadTask): Promise<any>;
    }
    /**
     * @en The `BoundBox` class is used for creating a bounding box.
     * @zh `BoundBox` 类用于创建包围盒。
     */
    class BoundBox implements IClone {
        /**
         * @en The minimum vertex of the bounding box.
         * @zh 包围盒的最小顶点。
         */
        min: Vector3;
        /**
         * @en The maximum vertex of the bounding box.
         * @zh 包围盒的最大顶点。
         */
        max: Vector3;
        /**
         * @en Constructor method of the bounding box.
         * @param	min The minimum vertex of the bounding box.
         * @param	max The maximum vertex of the bounding box.
         * @zh 包围盒的构造方法。
         * @param	min 包围盒的最小顶点。
         * @param	max 包围盒的最大顶点。
         */
        constructor(min: Vector3, max: Vector3);
        /**
         * @en Retrieves the 8 corner vertices of the bounding box.
         * @param corners The array to store the corner vertices.
         * @zh 获取包围盒的8个角顶点。
         * @param corners 角顶点的输出数组。
         */
        getCorners(corners: Vector3[]): void;
        /**
         * @en Retrieves the center point of the bounding box.。
         * @param out The vector to store the center point.
         * @zh 获取包围盒的中心点。
         * @param out 存储中心点的向量。
         */
        getCenter(out: Vector3): void;
        /**
         * @en Retrieves the extents of the bounding box.
         * @param out The vector to store the extents.
         * @zh 获取包围盒的范围。
         * @param out 存储轴半径的向量。
         */
        getExtent(out: Vector3): void;
        /**
         * @en Sets the center and extents of the bounding box.
         * @param center The center point of the bounding box.
         * @param extent The axis radius of the bounding box.
         * @zh 设置包围盒的中心点和范围
         * @param center 包围盒的中心点。
         * @param extent 包围盒的轴半径
         */
        setCenterAndExtent(center: Vector3, extent: Vector3): void;
        /**
         * @en Resets the bounding box to its default values.
         * @zh 将包围盒重置为其默认值。
         */
        toDefault(): void;
        /**
         * @en Creates a bounding box from a set of points.
         * @param points The set of points.
         * @param out The resulting bounding box.
         * @zh 从一组顶点生成包围盒。
         * @param points 所需顶点队列。
         * @param out 生成的包围盒。
         */
        static createfromPoints(points: Vector3[], out: BoundBox): void;
        /**
         * @en Merges two bounding boxes into one.
         * @param box1 The first bounding box.
         * @param box2 The second bounding box.
         * @param out The merged bounding box
         * @zh 合并两个包围盒为一个。
         * @param box1 第一个包围盒。
         * @param box2 第二个包围盒。
         * @param out 合并后的包围盒。
         */
        static merge(box1: BoundBox, box2: BoundBox, out: BoundBox): void;
        /**
         * @en Clones this bounding box to another object.
         * @param destObject The object to receive the clone.
         * @zh 克隆这个包围盒到另一个对象。
         * @param destObject 接收克隆的对象。
         */
        cloneTo(destObject: BoundBox): void;
        /**
         * @en Creates a clone of this bounding box.
         * @return The cloned bounding box.
         * @zh 创建这个包围盒的克隆。
         * @return 克隆的包围盒。
         */
        clone(): any;
    }
    /**
     * @en The corner of frustum.
     * @zh 锥体角点。
     */
    enum FrustumCorner {
        FarBottomLeft = 0,
        FarTopLeft = 1,
        FarTopRight = 2,
        FarBottomRight = 3,
        nearBottomLeft = 4,
        nearTopLeft = 5,
        nearTopRight = 6,
        nearBottomRight = 7,
        unknown = 8
    }
    /**
     * @en The BoundFrustum class is used to create a frustum.
     * @zh BoundFrustum 类用于创建截锥体。
     */
    class BoundFrustum implements IClone {
        /**
         * @en Obtain 6 enclosing planes based on the matrix.
         * @param  m The matrix that describes the frustum.
         * @param  np The near plane.
         * @param  fp The far plane.
         * @param  lp The left plane.
         * @param  rp The right plane.
         * @param  tp The top plane.
         * @param  bp The bottom plane.
         * @zh 根据矩阵获取6个包围平面。
         * @param  m 描述矩阵。
         * @param  np 近平面。
         * @param  fp 远平面。
         * @param  lp 左平面。
         * @param  rp 右平面。
         * @param  tp 顶平面。
         * @param  bp 底平面。
         */
        static getPlanesFromMatrix(m: Matrix4x4, np: Plane, fp: Plane, lp: Plane, rp: Plane, tp: Plane, bp: Plane): void;
        /**
         * @en Constructor method.
         * @param matrix The 4x4 matrix that describes the frustum.
         * @zh 构造方法。
         * @param matrix 锥截体的描述4x4矩阵。
         */
        constructor(matrix: Matrix4x4);
        protected initBoundingPlane(): void;
        /**
         * @en The matrix that describes the frustum.
         * @zh 描述矩阵。
         */
        get matrix(): Matrix4x4;
        set matrix(matrix: Matrix4x4);
        /**
         * @en The near plane.
         * @zh 近平面。
         */
        get near(): Plane;
        /**
         * @en The far plane.
         * @zh 远平面。
         */
        get far(): Plane;
        /**
         * @en The left plane.
         * @zh 左平面。
         */
        get left(): Plane;
        /**
         * @en The right plane.
         * @zh 右平面。
         */
        get right(): Plane;
        /**
         * @en The top plane.
         * @zh 顶平面。
         */
        get top(): Plane;
        /**
         * @en The bottom plane.
         * @zh 底平面。
         */
        get bottom(): Plane;
        /**
         * @en Determines whether this bound frustum is equal to another bound frustum.
         * @param other The other bound frustum to compare.
         * @zh 判断这个截锥体是否与另一个截锥体相等。
         * @param other 要比较的另一个截锥体。
         */
        equalsBoundFrustum(other: BoundFrustum): boolean;
        /**
         * @en Determines whether this object is equal to another object.
         * @param obj The object to compare.
         * @zh 判断此对象是否等于另一个对象。
         * @param obj 要比较的另一个对象。
         */
        equalsObj(obj: any): boolean;
        /**
         * @en Gets a specific plane of the frustum.
         * @param index The index of the plane to retrieve. Indices:
         * - 0: Near plane
         * - 1: Far plane
         * - 2: Left plane
         * - 3: Right plane
         * - 4: Top plane
         * - 5: Bottom plane
         * @returns The requested plane or `null` if the index is out of range.
         * @zh 获取截锥体的特定平面。
         * @param index 要检索的平面的索引。索引：
         * - 0: 近平面
         * - 1: 远平面
         * - 2: 左平面
         * - 3: 右平面
         * - 4: 顶平面
         * - 5: 底平面
         * @returns 所请求的平面或 `null` 如果索引超出范围。
         */
        getPlane(index: number): Plane;
        /**
         * @en Calculates the intersection point of three planes within the frustum.
         * @param p1 The first plane.
         * @param p2 The second plane.
         * @param p3 The third plane.
         * @param out The vector to store the intersection point.
         * @zh 计算截锥体中三个平面的交点。
         * @param p1 第一个平面。
         * @param p2 第二个平面。
         * @param p3 第三个平面。
         * @param out 存储交点的向量。
         */
        static get3PlaneInterPoint(p1: Plane, p2: Plane, p3: Plane, out: Vector3): void;
        /**
         * @en Retrieves the eight corner points of the frustum.
         * @param corners The array to store the corner points.
         * @zh 获取截锥体的八个角点
         * @param corners 存储角点的数组。
         */
        getCorners(corners: Vector3[]): void;
        /**
         * @en Determines the relationship between the frustum and a point.
         * @param point The point to test.
         * @returns The relationship between the point and the frustum:
         * - 1: The point is inside the frustum.
         * - 2: The point intersects the frustum.
         * - 0: The point is outside and does not intersect the frustum.
         * @zh 确定截锥体与点的关系。
         * @param point  要测试的点。
         * @returns 点与截锥体之间的关系：
         * - 1: 点在截锥体内。
         * - 2: 点与截锥体相交。
         * - 0: 点在截锥体外且不相交。
         */
        containsPoint(point: Vector3): number;
        /**
         * @en Determines whether this frustum intersects with a bounding box.
         * @param box The bounding box to test against.
         * @returns `true` if they intersect; otherwise, `false`.
         * @zh 判断这个截锥体是否与包围盒相交。
         * @param box 要测试的包围盒。
         * @returns 如果相交返回 `true`；否则返回 `false`。
         */
        intersects(box: BoundBox | Bounds): boolean;
        /**
         * @en Determines the spatial relationship between this frustum and a bounding box.
         * @param box The bounding box to test.
         * @returns The spatial relationship:
         * - 1: The bounding box is inside the frustum.
         * - 2: The bounding box intersects the frustum.
         * - 0: The bounding box is outside and does not intersect the frustum.
         * @zh 确定这个截锥体和包围盒之间的空间关系。
         * @param box 要测试的包围盒。
         * @returns 关系类型：
         * - 1: 包围盒在截锥体内。
         * - 2: 包围盒与截锥体相交。
         * - 0: 包围盒在截锥体外且不相交。
         */
        containsBoundBox(box: BoundBox | Bounds): number;
        /**
         * @en Determines the spatial relationship between this frustum and a bounding sphere.
         * @param sphere The bounding sphere to test.
         * @returns The relationship type:
         * - 1: The sphere is inside the frustum.
         * - 2: The sphere intersects the frustum.
         * - 0: The sphere is outside and does not intersect the frustum.
         * @zh 确定这个截锥体和包围球之间的空间关系。
         * @param sphere 要测试的包围球。
         * @returns 关系类型：
         * - 1: 包围球在截锥体内。
         * - 2: 包围球与截锥体相交。
         * - 0: 包围球在截锥体外且不相交。
         */
        containsBoundSphere(sphere: BoundSphere): number;
        /**
         * @en Clones this frustum into another object.
         * @param dest The destination BoundFrustum to copy the values into.
         * @zh 克隆这个截锥体到另一个对象。
         * @param dest 目标对象，用以复制值。
         */
        cloneTo(dest: BoundFrustum): void;
        /**
         * @en Creates a clone of this frustum.
         * @returns A new BoundFrustum that is a clone of this one.
         * @zh 创建这个截锥体的克隆。
         * @returns 一个克隆自当前截锥体的新的 BoundFrustum。
         */
        clone(): BoundFrustum;
    }
    /**
     * @en used for creating a bounding volume.
     * @zh 用于创建包围体。
     */
    class Bounds implements IClone {
        /**
         * @en Merges two bounding boxes into one.
         * @param box1 The first bounding box.
         * @param box2 The second bounding box.
         * @param out The merged bounding box.
         * @zh 合并两个包围盒。
         * @param box1 第一个包围盒。
         * @param box2 第二个包围盒。
         * @param out 生成的包围盒。
         */
        static merge(box1: Bounds, box2: Bounds, out: Bounds): void;
        /**
         * @en Determines whether the bounding box contains a point.
         * @param box The bounding box.
         * @param point The point to check.
         * @returns `true` if the point is inside the bounding box; otherwise, `false`.
         * @zh 判断包围盒是否包含一个点。
         * @param box 包围盒。
         * @param point 需要检测的点。
         * @return 如果点在包围盒内返回 `true`；否则返回 `false`。
         */
        static containPoint(box: Bounds, point: Vector3): boolean;
        /**
         * @en The minimum point of the bounding box.
         * @zh 包围盒的最小点
         */
        get min(): Vector3;
        set min(value: Vector3);
        /**
         * @en The maximum point of the bounding box.
         * @zh 包围盒的最大点
         */
        get max(): Vector3;
        set max(value: Vector3);
        /**
         * @en The center point of the bounding box.
         * @param value The new center point of the bounding box.
         * @zh 设置包围盒的最小点。
         * @param value	包围盒的新最小点。
         */
        setMin(value: Vector3): void;
        /**
         * @en Gets the minimum point of the bounding box.
         * @return The minimum point of the bounding box.
         * @zh 获取包围盒的最小点。
         * @return	包围盒的最小点。
         */
        getMin(): Vector3;
        /**
         * @en Sets the maximum point of the bounding box.
         * @param value The new maximum point of the bounding box.
         * @zh 设置包围盒的最大点。
         * @param value	包围盒的新最大点。
         */
        setMax(value: Vector3): void;
        /**
         * @en Gets the maximum point of the bounding box.
         * @return The maximum point of the bounding box.
         * @zh 获取包围盒的最大点。
         * @return	包围盒的最大点。
         */
        getMax(): Vector3;
        /**
         * @en Sets the center point of the bounding box.
         * @param value The new center point of the bounding box.
         * @zh 设置包围盒的中心点。
         * @param value	包围盒的新中心点。
         */
        setCenter(value: Vector3): void;
        /**
         * @en Gets the center point of the bounding box.
         * @return The center point of the bounding box.
         * @zh 获取包围盒的中心点。
         * @return	包围盒的中心点。
         */
        getCenter(): Vector3;
        /**
         * @en Sets the range of the bounding box.
         * @param value The new range of the bounding box.
         * @zh 设置包围盒的范围。
         * @param value	包围盒的新范围。
         */
        setExtent(value: Vector3): void;
        /**
         * @en Gets the range of the bounding box.
         * @return The range of the bounding box.
         * @zh 获取包围盒的范围。
         * @return	包围盒的范围。
         */
        getExtent(): Vector3;
        /**
         * @en Constructor method.
         * @param	min  The minimum point of the bounding box.
         * @param	max  The maximum point of the bounding box.
         * @zh 构造方法。
         * @param	min  min 最小坐标
         * @param	max  max 最大坐标。
         */
        constructor(min?: Vector3, max?: Vector3);
        /**
         * @en Retrieves the eight corner vertices of the bounding box.
         * @param corners The array to store the corner vertices.
         * @zh 获取包围盒的八个角顶点
         * @param corners 存储角顶点的数组。
         */
        getCorners(corners: Vector3[]): void;
        /**
         * @en Gets the bounding box.
         * @param box The bounding box to store the result.
         * @zh 获取包围盒
         * @param box 用于存储结果的包围盒。
         */
        getBoundBox(box: BoundBox): void;
        /**
         * @en Calculate whether two bounding boxes intersect
         * @param bounds The bounding box to calculate the intersection volume.
         * @return -1 if the two bounding boxes do not intersect; when not 0, the return value is the intersecting volume
         * @zh 计算两个包围盒是否相交
         * @param bounds 需要计算包围盒
         * @returns -1为不相交 不为0的时候返回值为相交体积
         */
        calculateBoundsintersection(bounds: Bounds): number;
        /**
         * @en Clones this bounds into another object.
         * @param destObject The destination object to clone into.
         * @zh 克隆这个边界到另一个对象。
         * @param destObject 克隆目标对象。
         */
        cloneTo(destObject: Bounds): void;
        /**
         * @en Creates a clone of this bounds.
         * @return A new `Bounds` instance that is a clone of this one.
         * @zh 创建这个边界的克隆。
         * @return 一个新的 `Bounds` 实例，是当前边界的克隆。
         */
        clone(): any;
    }
    /**
     * @en BoundsImpl class is used to create a bounding box.
     * @zh BoundsImpl 类用于创建包围体。
     */
    class BoundsImpl implements IClone {
        /**
         * @en The minimum point of the bounding box.
         * @zh 包围盒的最小点。
         */
        get min(): Vector3;
        set min(value: Vector3);
        /**
         * @en The maximum point of the bounding box.
         * @zh 包围盒的最大点。
         */
        get max(): Vector3;
        set max(value: Vector3);
        /**
         * @en Sets the minimum point of the bounding box.
         * @param value The new minimum point to set for the bounding box.
         * @zh 设置包围盒的最小点。
         * @param value 为包围盒设置的新最小点。
         */
        setMin(value: Vector3): void;
        /**
         * @en Gets the minimum point of the bounding box.
         * @return The minimum point of the bounding box.
         * @zh 获取包围盒的最小点。
         * @return 包围盒的最小点。
         */
        getMin(): Vector3;
        /**
         * @en Sets the maximum point of the bounding box.
         * @param value The new maximum point to set for the bounding box.
         * @zh 设置包围盒的最大点。
         * @param value	要设置的包围盒的新最大点。
         */
        setMax(value: Vector3): void;
        /**
         * @en Gets the maximum point of the bounding box.
         * @return The maximum point of the bounding box.
         * @zh 获取包围盒的最大点。
         * @return	包围盒的最大点。
         */
        getMax(): Vector3;
        /**
         * @en Sets the center point of the bounding box.
         * @param value The new center point to set for the bounding box.
         * @zh 设置包围盒的中心点。
         * @param value	要设置的包围盒的新中心点。
         */
        setCenter(value: Vector3): void;
        /**
         * @en Gets the center point of the bounding box.
         * @return The center point of the bounding box.
         * @zh 获取包围盒的中心点。
         * @return	包围盒的中心点。
         */
        getCenter(): Vector3;
        /**
         * @en Sets the range of the bounding box.
         * @param value The new range to set for the bounding box.
         * @zh 设置包围盒的范围。
         * @param value	要设置的包围盒的新范围。
         */
        setExtent(value: Vector3): void;
        /**
         * @en Gets the range of the bounding box.
         * @return The range of the bounding box.
         * @zh 获取包围盒的范围。
         * @return	包围盒的范围。
         */
        getExtent(): Vector3;
        /**
         * @en Constructor method.
         * @param	min  The minimum point of the bounding box.
         * @param	max  The maximum point of the bounding box.
         * @zh 构造方法。
         * @param	min  min 最小坐标
         * @param	max  max 最大坐标。
         */
        constructor(min?: Vector3, max?: Vector3);
        /**
         * @en Calculates the intersection volume between this bounds implementation and another `BoundsImpl` instance.
         * @param bounds The `BoundsImpl` instance to calculate the intersection with.
         * @returns -1 if the bounds do not intersect; when not 0, the return value is the intersecting volume
         * @zh 计算此边界实现与另一个 `BoundsImpl` 实例之间的相交体积。
         * @param bounds 要计算相交的 `BoundsImpl` 实例。
         * @returns -1 如果边界不相交；不为0的时候返回值为相交体积。
         */
        calculateBoundsintersection(bounds: BoundsImpl): number;
        /**
         * @en Clones the current bounding box into another object.
         * @param destObject The destination object to clone into.
         * @zh 将当前包围体克隆到另一个对象中。
         * @param destObject  克隆的目标对象。
         */
        cloneTo(destObject: BoundsImpl): void;
        /**
         * @en Creates a clone of the bounding box.
         * @return A new `BoundsImpl` instance that is a clone of the current bounding box.
         * @zh 创建当前包围体的克隆。
         * @return 一个新的 `BoundsImpl` 实例，是当前包围体的克隆。
         */
        clone(): any;
    }
    /**
     * @en The BoundSphere class is used to create bounding balls.
     * @zh BoundSphere 类用于创建包围球。
     */
    class BoundSphere implements IClone {
        /**
         * @en The center of the bounding sphere.
         * @zh 包围球的中心。
         */
        get center(): Vector3;
        set center(value: Vector3);
        /**
         * @en The radius of the bounding sphere.
         * @zh 包围球的半径。
         */
        get radius(): number;
        set radius(value: number);
        /**
         * @en Constructor method.
         * @param center The center of the bounding sphere.
         * @param radius The radius of the bounding sphere.
         * @zh 构造方法
         * @param center 包围球的中心。
         * @param radius 包围球的半径。
         */
        constructor(center?: Vector3, radius?: number);
        /**
         * @en Resets the bound sphere to its default state.
         * @zh 将包围球重置为其默认状态。
         */
        toDefault(): void;
        /**
         * @en Generates a bounding sphere from a subset of vertex points.
         * @param points The array of vertex points.
         * @param start The starting offset of the vertex subset.
         * @param count The number of vertices in the subset.
         * @param out The resulting bounding sphere.
         * @zh 从顶点的子队列生成包围球。
         * @param points 顶点的队列。
         * @param start 顶点子队列的起始偏移。
         * @param count 顶点子队列的顶点数。
         * @param out 生成的包围球。
         */
        static createFromSubPoints(points: Vector3[], start: number, count: number, out: BoundSphere): void;
        /**
         * @en Generates a bounding sphere from a vertex point array.
         * @param points The array of vertex points.
         * @param out The resulting bounding sphere.
         * @zh 从顶点队列生成包围球。
         * @param points 顶点的队列。
         * @param out 生成的包围球。
         */
        static createfromPoints(points: Vector3[], out: BoundSphere): void;
        /**
         * @en Determines whether a ray intersects with the bounding sphere and returns the distance to the intersection point.
         * @param ray The ray.
         * @returns The distance to the intersection point, or -1 if there is no intersection.
         * @zh 判断射线是否与包围球相交，并返回到交点的距离。
         * @param ray 射线。
         * @returns 到交点的距离，如果没有交点则为 -1。
         */
        intersectsRayDistance(ray: Ray): number;
        /**
         * @en Determines whether a ray intersects with the bounding sphere and returns the intersection point.
         * @param ray The ray.
         * @param outPoint The intersection point.
         * @returns The distance to the intersection point, or -1 if there is no intersection.
         * @zh 判断射线是否与包围球相交，并返回交点。
         * @param ray 射线。
         * @param outPoint 交点。
         * @returns 到交点的距离，如果没有交点则为 -1。
         */
        intersectsRayPoint(ray: Ray, outPoint: Vector3): number;
        /**
         * @en Clones this bounding sphere into another object.
         * @param destObject The destination object to clone into.
         * @zh 克隆这个包围球到另一个对象。
         * @param destObject 克隆目标对象。
         */
        cloneTo(destObject: BoundSphere): void;
        /**
         * @en Creates a clone of this bounding sphere.
         * @return A new `BoundSphere` instance that is a clone of this one.
         * @zh 创建这个包围球的克隆。
         * @return 一个新的 `BoundSphere` 实例，是当前包围球的克隆。
         */
        clone(): any;
    }
    /**
     * @en Collision class is used to detect collisions
     * @zh Collision 类用于检测碰撞。
     */
    class CollisionUtils {
        /**
         * @en constructor
         * @zh 构造方法
         */
        constructor();
        /**
         * @en Calculates the distance from a point to a plane in space.
         * @param plane The plane.
         * @param point The point.
         * @returns The distance from the point to the plane.
         * @zh 计算空间中点到平面的距离。
         * @param plane 平面。
         * @param point 点。
         * @returns 点到平面的距离。
         */
        static distancePlaneToPoint(plane: Plane, point: Vector3): number;
        /**
         * @en Calculates the distance from a point to a bounding box in space.
         * @param box The bounding box.
         * @param point The point.
         * @returns The distance from the point to the bounding box.
         * @zh 计算空间中点到包围盒的距离。
         * @param box 包围盒。
         * @param point 点。
         * @returns 点到包围盒的距离。
         */
        static distanceBoxToPoint(box: BoundBox, point: Vector3): number;
        /**
         * @en Calculates the distance between two bounding boxes in space.
         * @param box1 The first bounding box.
         * @param box2 The second bounding box.
         * @returns The distance between the two bounding boxes.
         * @zh 计算空间中两个包围盒之间的距离。
         * @param box1 第一个包围盒。
         * @param box2 第二个包围盒。
         * @returns 两个包围盒之间的距离。
         */
        static distanceBoxToBox(box1: BoundBox, box2: BoundBox): number;
        /**
         * @en Calculates the distance from a point to a bounding sphere in space.
         * @param sphere The bounding sphere.
         * @param point The point in space.
         * @returns The distance from the point to the bounding sphere.
         * @zh 计算空间中点到包围球的距离。
         * @param sphere 包围球。
         * @param point 空间中的点。
         * @returns 点到包围球的距离
         */
        static distanceSphereToPoint(sphere: BoundSphere, point: Vector3): number;
        /**
         * @en Calculates the distance between two bounding spheres in space.
         * @param sphere1 The first bounding sphere.
         * @param sphere2 The second bounding sphere.
         * @returns The distance between the two bounding spheres.
         * @zh 计算空间中两个包围球之间的距离。
         * @param sphere1 第一个包围球。
         * @param sphere2 第二个包围球。
         * @returns 两个包围球之间的距离。
         */
        static distanceSphereToSphere(sphere1: BoundSphere, sphere2: BoundSphere): number;
        /**
         * @en Determines whether a ray intersects with a triangle and outputs the distance to the intersection.
         * @param ray The ray.
         * @param vertex1 The first vertex of the triangle.
         * @param vertex2 The second vertex of the triangle.
         * @param vertex3 The third vertex of the triangle.
         * @param out The distance to the intersection point.
         * @returns True if there is an intersection, otherwise false.
         * @zh 判断射线是否与三角形相交，并输出到交点的距离。
         * @param ray 射线。
         * @param vertex1 三角形的第一个顶点。
         * @param vertex2 三角形的第二个顶点。
         * @param vertex3 三角形的第三个顶点。
         * @param out 点和三角面间距离。
         * @returns 如果相交返回真，否则返回假。
         */
        static intersectsRayAndTriangleRD(ray: Ray, vertex1: Vector3, vertex2: Vector3, vertex3: Vector3, out: number): boolean;
        /**
         * @en Determines whether a ray intersects with a triangle and outputs the intersection point.
         * @param ray The ray.
         * @param vertex1 The first vertex of the triangle.
         * @param vertex2 The second vertex of the triangle.
         * @param vertex3 The third vertex of the triangle.
         * @param out The intersection point.
         * @returns True if there is an intersection, otherwise false.
         * @zh 判断射线是否与三角形相交，并输出交点。
         * @param ray 射线。
         * @param vertex1 三角形的第一个顶点。
         * @param vertex2 三角形的第二个顶点。
         * @param vertex3 三角形的第三个顶点。
         * @param out 交点。
         * @returns 如果相交返回真，否则返回假。
         */
        static intersectsRayAndTriangleRP(ray: Ray, vertex1: Vector3, vertex2: Vector3, vertex3: Vector3, out: Vector3): boolean;
        /**
         * @en Determines whether a ray intersects with a point.
         * @param ray The ray.
         * @param point The point.
         * @returns True if there is an intersection, otherwise false.
         * @zh 判断射线是否与点相交。
         * @param ray 射线。
         * @param point 点。
         * @returns 如果相交返回真，否则返回假。
         */
        static intersectsRayAndPoint(ray: Ray, point: Vector3): boolean;
        /**
         * @en Determines whether two rays intersect and outputs the intersection point.
         * @param ray1 The first ray.
         * @param ray2 The second ray.
         * @param out The intersection point.
         * @returns True if there is an intersection, otherwise false.
         * @zh 判断两条射线是否相交，并输出交点。
         * @param ray1 第一个射线。
         * @param ray2 第二个射线。
         * @param out 交点。
         * @returns 如果相交返回真，否则返回假。
         */
        static intersectsRayAndRay(ray1: Ray, ray2: Ray, out: Vector3): boolean;
        /**
         * @en Determines whether a plane intersects with a triangle in space and returns the spatial relationship.
         * @param plane The plane.
         * @param vertex1 The first vertex of the triangle.
         * @param vertex2 The second vertex of the triangle.
         * @param vertex3 The third vertex of the triangle.
         * @returns The spatial relationship between the plane and the triangle：
         * - 0(PlaneIntersectionType_Back): back,
         * - 1(PlaneIntersectionType_Front): front,
         * - 2(PlaneIntersectionType_Intersecting): intersecting.
         * @zh 判断空间中的平面是否与三角形相交，并返回空间位置关系。
         * @param plane 平面。
         * @param vertex1 三角形的第一个顶点。
         * @param vertex2 三角形的第二个顶点。
         * @param vertex3 三角形的第三个顶点。
         * @returns 平面与三角面的相交类型：
         * - 0(PlaneIntersectionType_Back): 背面，
         * - 1(PlaneIntersectionType_Front): 正面，
         * - 2(PlaneIntersectionType_Intersecting): 相交。
         */
        static intersectsPlaneAndTriangle(plane: Plane, vertex1: Vector3, vertex2: Vector3, vertex3: Vector3): number;
        /**
         * @en Determines whether a ray intersects with a plane and returns the distance to the intersection.
         * @param ray The ray.
         * @param plane The plane.
         * @returns The distance to the intersection point, or -1 if there is no intersection.
         * @zh 判断射线是否与平面相交，并返回到交点的距离。
         * @param ray 射线。
         * @param plane 平面。
         * @returns 到交点的距离，如果没有交点则为 -1。
         */
        static intersectsRayAndPlaneRD(ray: Ray, plane: Plane): number;
        /**
         * @en Determines whether a ray intersects with a plane and outputs the intersection point.
         * @param ray The ray.
         * @param plane The plane.
         * @param out The intersection point.
         * @returns True if there is an intersection, otherwise false.
         * @zh 判断射线是否与平面相交，并输出交点。
         * @param ray 射线。
         * @param plane 平面。
         * @param out 交点。
         * @returns 如果相交返回真，否则返回假。
         */
        static intersectsRayAndPlaneRP(ray: Ray, plane: Plane, out: Vector3): boolean;
        /**
         * @en Determines whether a ray intersects with a bounding box and outputs the distance to the intersection.
         * @param ray The ray.
         * @param box The bounding box.
         * @returns The distance to the intersection point, or -1 if there is no intersection.
         * @zh 判断射线是否与包围盒相交，并输出到交点的距离。
         * @param ray 射线。
         * @param box 包围盒。
         * @returns 到交点的距离，如果没有交点则为 -1。
         */
        static intersectsRayAndBoxRD(ray: Ray, box: BoundBox): number;
        /**
         * @en Determines whether a ray intersects with a bounding box and returns the intersection point.
         * @param ray The ray.
         * @param box The bounding box.
         * @param out The intersection point.
         * @returns The distance to the intersection, or -1 if there is no intersection.
         * @zh 判断射线是否与包围盒相交，并返回交点。
         * @param ray 射线。
         * @param box 包围盒。
         * @param out 交点。
         * @returns 到交点的距离，如果没有交点则为 -1。
         */
        static intersectsRayAndBoxRP(ray: Ray, box: BoundBox, out: Vector3): number;
        /**
         * @en Determines whether a ray intersects with a bounding sphere and returns the distance to the intersection.
         * @param ray The ray.
         * @param sphere The bounding sphere.
         * @returns The distance to the intersection point, or -1 if there is no intersection.
         * @zh 判断射线是否与包围球相交，并返回到交点的距离。
         * @param ray 射线。
         * @param sphere 包围球。
         * @returns 到交点的距离，如果没有交点则为 -1。
         */
        static intersectsRayAndSphereRD(ray: Ray, sphere: BoundSphere): number;
        /**
         * @en Determines whether a ray intersects with a bounding sphere and returns the distance to the intersection.
         * @param ray The ray.
         * @param sphere The bounding sphere.
         * @param out The intersection point.
         * @returns The distance to the intersection, or -1 if there is no intersection.
         * @zh 判断射线是否与包围球相交并返回到交点的距离。
         * @param ray 射线。
         * @param sphere 包围球。
         * @param out 交点。
         * @returns 到交点的距离，如果没有交点则为 -1。
         */
        static intersectsRayAndSphereRP(ray: Ray, sphere: BoundSphere, out: Vector3): number;
        /**
         * @en Determines whether a bounding sphere intersects with a triangle.
         * @param sphere The bounding sphere.
         * @param vertex1 The first vertex of the triangle.
         * @param vertex2 The second vertex of the triangle.
         * @param vertex3 The third vertex of the triangle.
         * @returns True if they intersect, otherwise false.
         * @zh 判断包围球是否与三角形相交。
         * @param sphere 包围球。
         * @param vertex1 三角形的第一个顶点。
         * @param vertex2 三角形的第二个顶点。
         * @param vertex3 三角形的第三个顶点。
         * @returns 如果相交返回真，否则返回假。
         */
        static intersectsSphereAndTriangle(sphere: BoundSphere, vertex1: Vector3, vertex2: Vector3, vertex3: Vector3): boolean;
        /**
         * @en Determines the intersection status between a point and a plane.
         * @param plane The plane.
         * @param point The point.
         * @returns The type of intersection between a point and a plane:
         * - 0(PlaneIntersectionType_Back): back,
         * - 1(PlaneIntersectionType_Front): front,
         * - 2(PlaneIntersectionType_Intersecting): intersecting.
         * @zh 判断点与平面之间的相交状态。
         * @param plane 平面。
         * @param point 点。
         * @returns 点与平面的相交类型：
         * - 0(PlaneIntersectionType_Back): 背面，
         * - 1(PlaneIntersectionType_Front): 正面，
         * - 2(PlaneIntersectionType_Intersecting): 相交。
         */
        static intersectsPlaneAndPoint(plane: Plane, point: Vector3): number;
        /**
         * @en Determines whether two planes intersect.
         * @param plane1 The first plane.
         * @param plane2 The second plane.
         * @returns True if they intersect, otherwise false.
         * @zh 判断两个平面是否相交。
         * @param plane1 第一个平面。
         * @param plane2 第二个平面。
         * @returns 如果相交返回真，否则返回假。
         */
        static intersectsPlaneAndPlane(plane1: Plane, plane2: Plane): boolean;
        /**
         * @en Determines whether two planes intersect and outputs the line of intersection.
         * @param plane1 The first plane.
         * @param plane2 The second plane.
         * @param line The line representing the intersection.
         * @returns True if they intersect, otherwise false.
         * @zh 判断两个平面是否相交并输出相交线。
         * @param plane1 第一个平面。
         * @param plane2 第二个平面。
         * @param line 相交线。
         * @returns 如果相交返回真，否则返回假。
         */
        static intersectsPlaneAndPlaneRL(plane1: Plane, plane2: Plane, line: Ray): boolean;
        /**
         * @en Determines the intersection status between a plane and a bounding box.
         * @param plane The plane.
         * @param box The bounding box.
         * @returns The intersection type of the plane and the bounding box:
         * - 0(PlaneIntersectionType_Back): back,
         * - 1(PlaneIntersectionType_Front): front,
         * - 2(PlaneIntersectionType_Intersecting): intersecting.
         * @zh 判断平面与包围盒之间的相交状态。
         * @param plane 平面。
         * @param box 包围盒。
         * @returns 平面与包围盒的相交类型:
         * - 0(PlaneIntersectionType_Back): 背面，
         * - 1(PlaneIntersectionType_Front): 正面，
         * - 2(PlaneIntersectionType_Intersecting): 相交。
         */
        static intersectsPlaneAndBox(plane: Plane, box: BoundBox): number;
        /**
         * @en Determines the intersection status between a plane and a bounding sphere.
         * @param plane The plane.
         * @param sphere The bounding sphere.
         * @returns The intersection type of the plane and the bounding sphere: 0-back, 1-front, 2-intersecting.
         * @zh 判断平面与包围球之间的相交状态。
         * @param plane 平面。
         * @param sphere 包围球。
         * @returns 平面与包围球的相交类型:  0-背面，1-正面，2-相交。
         */
        static intersectsPlaneAndSphere(plane: Plane, sphere: BoundSphere): number;
        /**
         * @en Determines whether two bounding boxes intersect.
         * @param box1 The first bounding box.
         * @param box2 The second bounding box.
         * @returns True if they intersect, otherwise false.
         * @zh 判断两个包围盒是否相交。
         * @param box1 第一个包围盒。
         * @param box2 第二个包围盒。
         * @returns 如果相交返回真，否则返回假。
         */
        static intersectsBoxAndBox(box1: BoundBox, box2: BoundBox): boolean;
        /**
         * @en Determines whether a bounding box intersects with a bounding sphere.
         * @param box The bounding box.
         * @param sphere The bounding sphere.
         * @returns True if they intersect, otherwise false.
         * @zh 判断包围盒是否与包围球是否相交。
         * @param box 包围盒。
         * @param sphere 包围球。
         * @returns 如果相交返回真，否则返回假。
         */
        static intersectsBoxAndSphere(box: BoundBox, sphere: BoundSphere): boolean;
        /**
         * @en Determines whether one bounding sphere intersects with another bounding sphere.
         * @param sphere1 The first bounding sphere.
         * @param sphere2 The second bounding sphere.
         * @returns True if they intersect, otherwise false.
         * @zh 判断一个包围球是否与另一个包围球相交。
         * @param sphere1 第一个包围球。
         * @param sphere2 第二个包围球。
         * @returns 如果相交返回真，否则返回假。
         */
        static intersectsSphereAndSphere(sphere1: BoundSphere, sphere2: BoundSphere): boolean;
        /**
         * @en Determines the spatial relationship between a bounding box and a point.
         * @param box The bounding box.
         * @param point The point.
         * @returns The relationship type: 0 for disjoint, 1 for contains, 2 for intersecting.
         * @zh 确定包围盒和点之间的空间关系。
         * @param box 包围盒。
         * @param point 点。
         * @returns 位置关系：0 表示不相交，1 表示包含，2 表示相交。
         */
        static boxContainsPoint(box: BoundBox, point: Vector3): number;
        /**
         * @en Determines the spatial relationship between two bounding boxes.
         * @param box1 The first bounding box.
         * @param box2 The second bounding box.
         * @returns The relationship type: 0 for disjoint, 1 for contains, 2 for intersecting.
         * @zh 确定两个包围盒之间的空间关系。
         * @param box1 第一个包围盒。
         * @param box2 第二个包围盒。
         * @returns 位置关系：0 表示不相交，1 表示包含，2 表示相交。
         */
        static boxContainsBox(box1: BoundBox, box2: BoundBox): number;
        /**
         * @en Determines the spatial relationship between a bounding box and a bounding sphere.
         * @param box The bounding box.
         * @param sphere The bounding sphere.
         * @returns The relationship type:  0 for disjoint, 1 for contains, 2 for intersecting.
         * @zh 确定包围盒和包围球之间的空间关系。
         * @param box 包围盒。
         * @param sphere 包围球。
         * @returns 位置关系: 0 表示不相交，1 表示包含，2 表示相交。
         */
        static boxContainsSphere(box: BoundBox, sphere: BoundSphere): number;
        /**
         * @en Determines the spatial relationship between a bounding sphere and a point.
         * @param sphere The bounding sphere.
         * @param point The point.
         * @returns The relationship type: 0 for disjoint, 1 for contains, 2 for intersecting.
         * @zh 确定包围球和点之间的空间关系。
         * @param sphere 包围球。
         * @param point 点。
         * @returns 位置关系：0 表示不相交，1 表示包含，2 表示相交。
         */
        static sphereContainsPoint(sphere: BoundSphere, point: Vector3): number;
        /**
         * @en Determines the spatial relationship between a bounding sphere and a triangle.
         * @param sphere The bounding sphere.
         * @param vertex1 The first vertex of the triangle.
         * @param vertex2 The second vertex of the triangle.
         * @param vertex3 The third vertex of the triangle.
         * @returns The relationship type:  0 for disjoint, 1 for contains, 2 for intersecting.
         * @zh 确定包围球和三角形之间的空间关系。
         * @param sphere 包围球。
         * @param vertex1 第一个顶点。
         * @param vertex2 第二个顶点。
         * @param vertex3 第三个顶点。
         * @returns 位置关系：0 表示不相交，1 表示包含，2 表示相交。
         */
        static sphereContainsTriangle(sphere: BoundSphere, vertex1: Vector3, vertex2: Vector3, vertex3: Vector3): number;
        /**
         * @en Determines whether a bounding sphere contains a bounding box.
         * @param sphere The bounding sphere.
         * @param box The bounding box.
         * @returns The spatial relationship: 0 for disjoint, 1 for contains, 2 for intersecting.
         * @zh 判断包围球是否包含包围盒。
         * @param sphere 包围球。
         * @param box 包围盒。
         * @returns 位置关系：0 表示不相交，1 表示包含，2 表示相交。
         */
        static sphereContainsBox(sphere: BoundSphere, box: BoundBox): number;
        /**
         * @en Determines whether one bounding sphere contains another bounding sphere.
         * @param sphere1 The first bounding sphere.
         * @param sphere2 The second bounding sphere.
         * @returns The spatial relationship: 0 for disjoint, 1 for contains, 2 for intersecting.
         * @zh 判断一个包围球是否包含另一个包围球。
         * @param sphere1 第一个包围球。
         * @param sphere2 第二个包围球。
         * @returns 位置关系：0 表示不相交，1 表示包含，2 表示相交。
         */
        static sphereContainsSphere(sphere1: BoundSphere, sphere2: BoundSphere): number;
        /**
         * @en Finds the closest point on a triangle to a given point in space.
         * @param point The point in space.
         * @param vertex1 The first vertex of the triangle.
         * @param vertex2 The second vertex of the triangle.
         * @param vertex3 The third vertex of the triangle.
         * @param out The closest point on the triangle.
         * @zh 找到空间中点到三角形的最近点。
         * @param point 空间中的点。
         * @param vertex1 三角形的第一个顶点。
         * @param vertex2 三角形的第二个顶点。
         * @param vertex3 三角形的第三个顶点。
         * @param out 三角形上的最近点。
         */
        static closestPointPointTriangle(point: Vector3, vertex1: Vector3, vertex2: Vector3, vertex3: Vector3, out: Vector3): void;
        /**
         * @en Finds the closest point on a plane to a given point in space.
         * @param plane The plane.
         * @param point The point in space.
         * @param out The closest point on the plane.
         * @zh 找到空间中点到平面的最近点。
         * @param plane 平面。
         * @param point 空间中的点。
         * @param out 平面上的最近点。
         */
        static closestPointPlanePoint(plane: Plane, point: Vector3, out: Vector3): void;
        /**
         * @en Finds the closest point on a bounding box to a given point in space.
         * @param box The bounding box.
         * @param point The point in space.
         * @param out The closest point on the bounding box.
         * @zh 找到空间中点到包围盒的最近点。
         * @param box 包围盒。
         * @param point 空间中的点。
         * @param out 包围盒上的最近点。
         */
        static closestPointBoxPoint(box: BoundBox, point: Vector3, out: Vector3): void;
        /**
         * @en Finds the closest point on a bounding sphere to a given point in space.
         * @param sphere The bounding sphere.
         * @param point The point in space.
         * @param out The closest point on the bounding sphere.
         * @zh 找到空间中点到包围球的最近点。
         * @param sphere 包围球。
         * @param point 空间中的点。
         * @param out 包围球上的最近点。
         */
        static closestPointSpherePoint(sphere: BoundSphere, point: Vector3, out: Vector3): void;
        /**
         * @en Finds the closest points between two bounding spheres.
         * @param sphere1 The first bounding sphere.
         * @param sphere2 The second bounding sphere.
         * @param out The closest point on the first bounding sphere to the second.
         * @zh 找到两个包围球之间的最近点。
         * @param sphere1 第一个包围球。
         * @param sphere2 第二个包围球。
         * @param out 第一个包围球上到第二个包围球的最近点。
         */
        static closestPointSphereSphere(sphere1: BoundSphere, sphere2: BoundSphere, out: Vector3): void;
    }
    /**
     * @en ContainmentType class defines the space object position relationship.
     * @zh ContainmentType 类用于定义空间物体位置关系。
     */
    class ContainmentType {
        /**
         * @en Disjoint.
         * @zh 不相交
         */
        static Disjoint: number;
        /**
         * @en Contains.
         * @zh 包含
         */
        static Contains: number;
        /**
         * @en Intersects.
         * @zh 相交
         */
        static Intersects: number;
    }
    /**
     * @en Plane in 3D space.
     * @zh 三维空间中的平面。
     */
    class Plane {
        /**
         * @en Intersection type of the plane with other geometries, indicating the back side.
         * @zh 平面与其他几何体相交类型，表示背面。
         */
        static PlaneIntersectionType_Back: number;
        /**
         * @en Intersection type of the plane with other geometries, indicating the front side.
         * @zh 平面与其他几何体相交类型，表示正面。
         */
        static PlaneIntersectionType_Front: number;
        /**
         * @en Intersection type of the plane with other geometries, indicating intersection.
         * @zh 平面与其他几何体相交类型，表示相交。
         */
        static PlaneIntersectionType_Intersecting: number;
        /**
         * @en Constructor method of the plane.
         * @param normal The normal vector of the plane.
         * @param d The distance from the plane to the origin of the coordinate system.
         * @zh 平面的构造方法
         * @param normal 平面的向量
         * @param d  平面到原点的距离
         */
        constructor(normal?: Vector3, d?: number);
        /**
         * @en Creates a plane defined by three points.
         * @param point0 The first point.
         * @param point1 The second point.
         * @param point2 The third point.
         * @param out The plane to store the result.
         * @zh 通过三个点创建一个平面。
         * @param point0 第一个点。
         * @param point1 第二个点。
         * @param point2 第三个点。
         * @param out 存储结果的平面。
         */
        static createPlaneBy3P(point0: Vector3, point1: Vector3, point2: Vector3, out: Plane): void;
        /**
         * @en Normalizes the plane's normal vector to unit length.
         * @zh 使平面的法线向量成为单位长度。
         */
        normalize(): void;
        /**
         * @en Clones the plane into another object.
         * @param destObject The destination object to clone into.
         * @zh 克隆平面到另一个对象。
         * @param destObject 克隆目标对象。
         */
        cloneTo(destObject: Plane): void;
        /**
         * @en Creates a clone of this plane.
         * @return A new Plane instance that is a clone of this one.
         * @zh 创建这个平面的克隆。
         * @return 一个新的 Plane 实例，是当前平面的克隆。
         */
        clone(): Plane;
    }
    /**
     * @en The Rand class is used to create random numbers using a 32-bit unsigned integer seed.
     * @zh Rand 类用于通过32位无符号整型随机种子创建随机数。
     */
    class Rand {
        /**
         * @en Obtain unsigned 32-bit floating-point random numbers through unsigned 32-bit shaping
         * @param v The unsigned 32-bit integer random number.
         * @returns The 32-bit floating-point random number.
         * @zh 通过无符号32位整形，获取32位浮点随机数。
         * @param v 无符号32位整数随机数。
         * @returns 32位浮点随机数。
         */
        static getFloatFromInt(v: number): number;
        /**
         * @en Obtain an unsigned 8-bit byte random number through unsigned 32-bit shaping.
         * @param v The unsigned 32-bit integer random number.
         * @returns The unsigned 8-bit byte random number.
         * @zh 通过无符号32位整形，获取无符号8位字节随机数。
         * @param v 无符号32位整数随机数。
         * @returns 无符号8位字节随机数。
         */
        static getByteFromInt(v: number): number;
        /**
         * @en Obtain random seeds
         * @zh 获取随机种子。
         */
        seeds: Uint32Array;
        /**
         * @en The random seed.
         * @zh 随机种子。
         */
        get seed(): number;
        set seed(seed: number);
        /**
         * @en Constructor method.
         * @param	seed  32bit unsigned integer random seed.
         * @zh 构造方法。
         * @param	seed  32位无符号整型随机种子。
         */
        constructor(seed: number);
        /**
         * @en Gets an unsigned 32-bit integer random number.
         * @returns The unsigned 32-bit integer random number.
         * @zh 获取无符号32位整数随机数
         * @returns 无符号32位整数随机数。
         */
        getUint(): number;
        /**
         * @en Gets a floating-point random number between 0 and 1.
         * @returns The floating-point random number between 0 and 1.
         * @zh 获取0到1之间的浮点随机数。
         * @returns 0到1之间的浮点随机数。
         */
        getFloat(): number;
        /**
         * @en Gets a floating-point random number between -1 and 1.
         * @returns The floating-point random number between -1 and 1.
         * @zh 获取-1到1之间的浮点随机数。
         * @returns -1到1之间的浮点随机数。
         */
        getSignedFloat(): number;
    }
    /**
     * @en The `RandX` class is used to generate random numbers using a 128-bit integer seed. The algorithm comes from the provided link: https://github.com/AndreasMadsen/xorshift
     * @zh `RandX` 类用于通过128位整型种子创建随机数。算法来自提供的链接：https://github.com/AndreasMadsen/xorshift
     */
    class RandX {
        /**
         * @en A random number generator seeded based on the current time.
         * @zh 基于当前时间种子的随机数生成器。
         */
        static defaultRand: RandX;
        /**
         * @en Constructor method.
         * @param seed  Random seed.
         * @zh 构造方法
         * @param seed  随机种子。
         */
        constructor(seed: any[]);
        /**
         * @en Return a 64 bit random number through a 2x32-bit array.
         * @returns 64 bit random number.
         * @zh 通过2x32位的数组，返回64位的随机数。
         * @returns 64位的随机数。
         */
        randomint(): any[];
        /**
         * @en Returns a random number in the range [0, 1).
         * @returns A random number in the range [0, 1).
         * @zh 返回一个介于[0, 1)范围内的随机数。
         * @returns 介于[0, 1)范围内的随机数。
         */
        random(): number;
    }
    /**
     * @en Ray class used to create a ray.
     * @zh Ray 类用于创建射线。
     */
    class Ray {
        /**
         * @en The origin point of the ray.
         * @zh 射线的原点。
         */
        origin: Vector3;
        /**
         * @en The direction of the ray.
         * @zh 射线的方向。
         */
        direction: Vector3;
        /**
         * @en Constructor method of the ray class.
         * @param origin The origin point of the ray.
         * @param direction The direction vector of the ray.
         * @zh 射线的构造方法
         * @param origin 射线的起点
         * @param direction 射线的方向
         */
        constructor(origin: Vector3, direction: Vector3);
        /**
         * @en Calculates a point on the ray at the specified parameter t.
         * @param t The parameter along the ray at which to calculate the point.
         * @param out The `Vector3` object to store the result.
         * @zh 计算在指定参数 t 处的射线上的点。
         * @param t 沿射线计算点的参数。
         * @param out 存储结果的 `Vector3` 对象。
         */
        at(t: number, out: Vector3): void;
    }
    /**
     * @en CharacterController class is used to create a character controller.
     * @zh CharacterController 类用于创建角色控制器。
     */
    class CharacterController extends PhysicsColliderComponent {
        protected _onEnable(): void;
        /**
         * @ignore
         * @en The frame loop.
         * @zh 帧循环
         */
        onUpdate(): void;
        /**
         * @en The capsule radius.
         * @zh 胶囊碰撞形状的半径。
         */
        get radius(): number;
        set radius(value: number);
        /**
         * @en The capsule height.
         * @zh 胶囊碰撞形状的高度。
         */
        get height(): number;
        set height(value: number);
        /**
         * @en The minimum step distance when a character moves using `move`. This feature is only effective in the PhysX engine.
         * @zh 角色移动（通过move）时的单步最小距离。该功能只在PhysX引擎中有效。
         **/
        get minDistance(): number;
        set minDistance(value: number);
        /**
         * @en The center offset of the capsule.
         * @zh 胶囊碰撞形状的本地偏移
         */
        get centerOffset(): Vector3;
        set centerOffset(value: Vector3);
        /**
         * @en gravity.  The gravity will affect the movement of rigidbody, making it accelerate in a certain direction (usually downward, negative Y-axis) and simulate the free fall effect in real world.
         * The default gravity value is **(0, -9.8, 0)**, which means the object will fall with an acceleration of 9.8 m/s² downward.
         * @zh 重力。重力会影响刚体的运动，使其向某个方向（通常是向下，即 Y 轴负方向）持续加速，从而模拟真实世界中的自由落体效果。默认的重力值为 **(0, -9.8, 0)**，表示物体会以 9.8 m/s² 的加速度向下坠落
         */
        get gravity(): Vector3;
        set gravity(value: Vector3);
        /**
         * @en The skin width of the CharacterController.
         * - This property is only effective in the PhysX engine.
         * - It defines the distance between the collider surface and where collision detection actually occurs. This helps in triggering collision detection and response earlier, improving the stability and reliability of the object's physical simulation.
         * @zh 碰撞器外表的宽度;
         * - 该属性仅在 PhysX 引擎中有效。
         * - 用于定义碰撞器表面与实际发生碰撞检测的距离，用于提前触发碰撞检测和响应，从而提高物体在物理模拟中的稳定性和可靠性。
         */
        get skinWidth(): number;
        set skinWidth(value: number);
        /**
         * @en The maximum slope angle that the character can climb.
         * If the slope angle exceeds the set value, the character will be unable to continue moving upward and may start sliding down or stop at the bottom of the slope.
         * @zh 角色行走的最大坡度（角度值）。
         * 如果坡度角度超过设定的值，角色将无法继续向上移动，可能会开始滑落或停在斜坡下方。
         */
        get maxSlope(): number;
        set maxSlope(value: number);
        /**
         * @en The height of the character's step. It represents the maximum height that the character can step over.
         * @zh 角色行走的脚步高度，表示角色能够跨越的最大台阶高度。
         */
        get stepHeight(): number;
        set stepHeight(value: number);
        /**
         * @deprecated
         * @zh 角色的向上轴, 由于和其它方法设置存在冲突, 为避免开发者误解, 废弃掉.
         */
        get upAxis(): Vector3;
        set upAxis(value: Vector3);
        /**
         * @en The character's position.
         * @zh 角色位置
         */
        get position(): Vector3;
        set position(v: Vector3);
        /**
         * @en The magnitude of the push force.
         * @zh 推动力的大小。
         */
        get pushForce(): number;
        set pushForce(value: number);
        /**
         * @deprecated
         * @zh 原本是用于jump没有设置值的时候,用于影响向上轴的跳跃速度与高度.考虑到建议在jump时设置速度,避免开发者的误解,所以废弃了这个属性.
         */
        get jumpSpeed(): number;
        set jumpSpeed(value: number);
        /**
         * @ignore
         */
        constructor();
        /**
         * @en Gets the vertical speed.
         * - When the character performs a jump action, the vertical speed starts from a positive value (rising phase), then decreases to zero and finally becomes negative (falling phase).
         * Developers can detect changes in vertical speed to determine whether the character is rising, at the peak or falling.
         * @zh 获取角色的垂直速度。
         * - 当角色执行跳跃动作时，垂直速度会从正值开始（上升阶段），然后逐渐减小到零，再变为负值（下落阶段）。
         * 开发者可以通过检测垂直速度的变化来判断角色处于上升、顶点或下落状态
         */
        getVerticalVel(): number;
        /**
         * @en Moves the character by the specified movement vector. By continuously calling the `move` method and passing in a movement vector, the character will move in the specified direction and distance.
         * When you need to stop, not only stopping calling the move movement vector. But also resetting the move's movement vector to zero vector. Otherwise it will continue moving based on the last set vector
         * @param movement The movement vector.
         * @zh 通过指定移动向量移动角色。通过不断调用 `move` 方法并传入移动向量，角色会按照指定的方向和距离进行移动。
         * 当需要停止的时候，不仅仅是停止调用move移动向量。还要将move的移动向量重置为零向量。否则会一直基于最后一次设置的向量移动。
         * @param movement 移动向量。
         */
        move(movement: Vector3): void;
        /**
         * @en The jump vector, direction and height.
         * It is usually the opposite direction of gravity (positive Y axis), and the absolute value is larger, the higher the single jump height.
         * @param velocity The jump vector, each axis's direction and height.
         * @zh 用于控制角色控制器的跳跃方向和高度，通常是重力相反的方向（Y轴正方向），绝对值越大，单次跳跃的高度越高。
         * @param velocity 跳跃向量，各轴的方向与高度。
         */
        jump(velocity?: Vector3): void;
        /**
         * @en Whether the character is on the ground.
         * @returns Whether the character is on the ground.
         * @zh 是否在地面上。
         * @returns 是否在地面上。
         */
        isGrounded(): boolean;
    }
    /**
     * @en The Collision class is used to create physical collision information.
     * @zh Collision 类用于创建物理碰撞信息。
     */
    class Collision {
        /**
         * @readonly
         * @en List of collision information generated by collision.
         * @zh 碰撞产生的碰撞信息列表。
         */
        contacts: ContactPoint[];
        /**
         * @readonly
         * @en Another collision object involved in the collision.
         * @zh 碰撞中涉及的另一个碰撞体组件。
         */
        other: PhysicsColliderComponent;
        /**
         * @en constructor of Collision.
         * @zh Collision构造方法。
         */
        constructor();
    }
    /**
     * @en The ConfigurableConstraint class is used for configurable constraint components.
     * @zh ConfigurableConstraint类用于可设置的约束组件
     */
    class ConfigurableConstraint extends ConstraintComponent {
        /** @ignore */
        constructor();
        private _setDriveLinearX;
        private _setDriveLinearY;
        private _setDriveLinearZ;
        private _setAngularXDrive;
        private _setAngularYZDrive;
        private _setAngularSlerpDrive;
        private _setDistanceLimit;
        private _setAngularXLimit;
        private _setSwingLimit;
        private _setTargetTransform;
        /**
         * axis
         */
        private _setAxis;
        private _setTargetVelocirty;
        /**
         * @en Main axis
         * @zh 主轴
         */
        get axis(): Vector3;
        set axis(value: Vector3);
        /**
         * @en Secondary axis
         * @zh 副轴
         */
        get secondaryAxis(): Vector3;
        set secondaryAxis(value: Vector3);
        /**
         * @en The motion type for X translation.
         * @zh X位移运动类型。
         */
        get XMotion(): D6Axis;
        set XMotion(value: D6Axis);
        /**
         * @en The motion type for Y translation.
         * @zh Y位移运动类型。
         */
        get YMotion(): D6Axis;
        set YMotion(value: D6Axis);
        /**
         * @en The motion type for Z translation.
         * @zh Z位移运动类型。
         */
        get ZMotion(): D6Axis;
        set ZMotion(value: D6Axis);
        /**
         * @en The motion type for X-axis rotation.
         * @zh 绕 X 轴旋转的角运动类型
         */
        get angularXMotion(): D6Axis;
        set angularXMotion(value: D6Axis);
        /**
         * @en The motion type for Y-axis rotation.
         * @zh 绕 Y 轴旋转的角运动类型
         */
        get angularYMotion(): D6Axis;
        set angularYMotion(value: D6Axis);
        /**
         * @en The motion type for Z-axis rotation.
         * @zh 绕 Z 轴旋转的角运动类型
         */
        get angularZMotion(): D6Axis;
        set angularZMotion(value: D6Axis);
        /**
         * @en The limit value for joint translation.
         * @zh 关节位移值。
         */
        get distanceLimit(): number;
        set distanceLimit(value: number);
        /**
         * @en The bounciness value after the joint translation limit is reached.
         * @zh 关节位移限制后的弹力值。
         */
        get distanceBounciness(): number;
        set distanceBounciness(value: number);
        /**
         * @en The bounciness threshold after the joint translation limit is reached.
         * @zh 关节位移限制后弹力阈值。
         */
        get distanceBounceThreshold(): number;
        set distanceBounceThreshold(value: number);
        /**
         * @en The spring coefficient value for joint translation.
         * @zh 关节位移的弹簧系数。
         */
        get distanceSpring(): number;
        set distanceSpring(value: number);
        /**
         * @en The damping coefficient value for joint translation.
         * @zh 关节位移的阻尼值。
         */
        get distanceDamper(): number;
        set distanceDamper(value: number);
        /**
         * @en The maximum angle value for the joint's X-axis, ranging from -180° to 180°.
         * @zh 关节X轴的最大角度值，范围从 -180° 到 180°。
         */
        get angularXMaxLimit(): number;
        set angularXMaxLimit(value: number);
        /**
         * @en The minimum angle value for the joint's X-axis.
         * @zh 关节X轴的最小角度值。
         */
        get angularXMinLimit(): number;
        set angularXMinLimit(value: number);
        /**
         * @en The bounciness value after the joint's X-axis angle reaches its maximum value.
         * @zh 关节X轴角度达到最大值后的弹力值。
         */
        get AngleXLimitBounceness(): number;
        set AngleXLimitBounceness(value: number);
        /**
         * @en The bounciness threshold after the joint's X-axis angle reaches its maximum value.
         * @zh 关节X轴角度达到最大值后的弹力阈值。
         */
        get AngleXLimitBounceThreshold(): number;
        set AngleXLimitBounceThreshold(value: number);
        /**
         * @en The spring coefficient value for the joint's X-axis angle.
         * @zh 关节X轴角度弹簧系数。
         */
        get AngleXLimitSpring(): number;
        set AngleXLimitSpring(value: number);
        /**
         * @en The damping value of joint X-axis angle
         * @zh 关节X轴角度阻尼值
         */
        get AngleXLimitDamp(): number;
        set AngleXLimitDamp(value: number);
        /**
         * @en The angle limit value for the joint's Y-axis.
         * @zh 关节Y轴的角度限制值。
         */
        get AngleYLimit(): number;
        set AngleYLimit(value: number);
        /**
         * @en The angle limit value for the joint's Z-axis.
         * @zh 关节Z轴的角度限制值。
         */
        get AngleZLimit(): number;
        set AngleZLimit(value: number);
        /**
         * @en The bounciness value after the joint's YZ-plane angle reaches its maximum limit.
         * @zh 关节YZ平面角度达到最大限制后的弹力值。
         */
        get AngleYZLimitBounciness(): number;
        set AngleYZLimitBounciness(value: number);
        /**
         * @en The bounciness threshold after the joint's YZ-plane angle reaches its maximum limit.
         * @zh 关节YZ平面角度达到最大限制后的弹力阈值。
         */
        get AngleYZLimitBounceThreshold(): number;
        set AngleYZLimitBounceThreshold(value: number);
        /**
         * @en The spring coefficient value for the joint's YZ-axis rotation.
         * @zh 关节YZ轴旋转的弹簧系数。
         */
        get AngleYZLimitSpring(): number;
        set AngleYZLimitSpring(value: number);
        /**
         * @en The damping value for the joint's YZ-axis rotation.
         * @zh 关节YZ轴旋转的阻尼值。
         */
        get AngleYZLimitDamping(): number;
        set AngleYZLimitDamping(value: number);
        /**
         * @en The target position the joint is moving towards.
         * @zh 关节移动到的目标位置。
         */
        get targetPosition(): Vector3;
        set targetPosition(value: Vector3);
        /**
         * @en The target rotation direction for the joint's rotation drive.
         * @zh 关节旋转驱动的目标方向。
         */
        get targetRotation(): Vector3;
        set targetRotation(value: Vector3);
        /**
         * @en The velocity at which the joint moves towards the target position.
         * @zh 关节移动到目标位置的速度。
         */
        get targetPositionVelocity(): Vector3;
        set targetPositionVelocity(value: Vector3);
        /**
         * @en The angular velocity driven by joint rotation to the target angle.
         * @zh 关节旋转到目标角度驱动的角速度。
         */
        get targetAngularVelocity(): Vector3;
        set targetAngularVelocity(value: Vector3);
        /**
         * @en The spring coefficient value for the joint along the X-axis.
         * @zh 关节在X轴方向上的弹簧系数。
         */
        get XDriveSpring(): number;
        set XDriveSpring(value: number);
        /**
         * @en The spring coefficient value for the joint along the Y-axis.
         * @zh 关节在Y轴方向上的弹簧系数。
         */
        get YDriveSpring(): number;
        set YDriveSpring(value: number);
        /**
         * @en The spring coefficient value for the joint along the Z-axis.
         * @zh 关节在Z轴方向上的弹簧系数。
         */
        get ZDriveSpring(): number;
        set ZDriveSpring(value: number);
        /**
         * @en The damping value along the X-axis of the joint drive.
         * @zh 关节在X轴方向上的阻尼值。
         */
        get XDriveDamp(): number;
        set XDriveDamp(value: number);
        /**
         * @en The damping value along the Y-axis of the joint drive.
         * @zh 关节在Y轴方向上的阻尼值。
         */
        get YDriveDamp(): number;
        set YDriveDamp(value: number);
        /**
         * @en The damping value along the Z-axis of the joint drive.
         * @zh 关节在Z轴方向上的阻尼值。
         */
        get ZDriveDamp(): number;
        set ZDriveDamp(value: number);
        /**
         * @en The maximum force limit along the X-axis of the joint drive.
         * @zh 关节在X轴方向上的最大驱动力值。
         */
        get XDriveForceLimit(): number;
        set XDriveForceLimit(value: number);
        /**
         * @en The maximum force limit along the Y-axis of the joint drive.
         * @zh 关节在Y轴方向上的最大驱动力值。
         */
        get YDriveForceLimit(): number;
        set YDriveForceLimit(value: number);
        /**
         * @en The maximum force limit along the Z-axis of the joint drive.
         * @zh 关节在Z轴方向上的最大驱动力值。
         */
        get ZDriveForceLimit(): number;
        set ZDriveForceLimit(value: number);
        /**
         * @en The maximum rotational driving force of the joint on the X-axis.
         * @zh 关节在X轴上的最大旋转驱动力。
         */
        get angularXDriveForceLimit(): number;
        set angularXDriveForceLimit(value: number);
        /**
         * @en The drive force for the joint's rotation around the X-axis.
         * @zh 关节在X轴上的旋转驱动力。
         */
        get angularXDriveForce(): number;
        set angularXDriveForce(value: number);
        /**
         * @en The rotational damping value of the joint in the X-axis direction.
         * @zh 关节在X轴方向上的旋转阻尼值。
         */
        get angularXDriveDamp(): number;
        set angularXDriveDamp(value: number);
        /**
         * @en The maximum drive force for the joint's rotation in the YZ-plane.
         * @zh 关节在YZ平面旋转驱动力的最大值。
         */
        get angularYZDriveForceLimit(): number;
        set angularYZDriveForceLimit(value: number);
        /**
         * @en The drive force for the joint's rotation in the YZ-plane.
         * @zh 关节在YZ平面上的旋转驱动力。
         */
        get angularYZDriveForce(): number;
        set angularYZDriveForce(value: number);
        /**
         * @en The damping for the joint's rotation in the YZ-plane.
         * @zh 关节在YZ平面上的阻尼。
         */
        get angularYZDriveDamp(): number;
        set angularYZDriveDamp(value: number);
        /**
         * @en The maximum drive force for the joint's angular slerp interpolation.
         * @zh 关节的角度插值驱动力的最大值。
         */
        get angularSlerpDriveForceLimit(): number;
        set angularSlerpDriveForceLimit(value: number);
        /**
         * @en The drive force for the joint's angular slerp interpolation.
         * @zh 关节的角度插值驱动力。
         */
        get angularSlerpDriveForce(): number;
        set angularSlerpDriveForce(value: number);
        /**
         * @en The damping for the joint's angular slerp interpolation.
         * @zh 角度插值阻尼。
         */
        get angularSlerpDriveDamp(): number;
        set angularSlerpDriveDamp(value: number);
    }
    /**
     * @en ConstraintComponent class is the base class for creating constraints.
     * @zh ConstraintComponent 类用于创建约束的父类。
     */
    class ConstraintComponent extends Component {
        private _isJointInit;
        /**
         * @en Initializes the joint instance.
         * @zh 初始化关节实例。
         */
        initJoint(): void;
        /**
         * @en Physical components of joint connections rigid body
         * @zh 关节连接的物理组件刚体
         */
        get connectedBody(): PhysicsColliderComponent;
        set connectedBody(value: PhysicsColliderComponent);
        /**
         * @en The owner rigid body of the joint, which is the physical component that the joint is attached to.
         * @zh 关节所属的物理组件刚体。
         */
        get ownBody(): PhysicsColliderComponent;
        set ownBody(value: PhysicsColliderComponent);
        /**
         * @en The total force applied to the joint.
         * @zh 作用在关节上的总力。
         */
        get currentForce(): Vector3;
        /**
         * @en The total torque applied to the joint.
         * @zh 作用在关节上的总力矩。
         */
        get currentTorque(): Vector3;
        /**
         * @en The maximum force the joint can withstand before breaking.
         * @zh 关节在断裂前能承受的最大力。
         */
        get breakForce(): number;
        set breakForce(value: number);
        /**
         * @en The maximum torque the joint can withstand before breaking.
         * @zh 关节在断裂前能承受的最大扭矩。
         */
        get breakTorque(): number;
        set breakTorque(value: number);
        /**
         * @en The anchor point.
         * @zh 锚点
         */
        get anchor(): Vector3;
        set anchor(value: Vector3);
        /**
         * @en The connected anchor point.
         * @zh 连接锚点位置
         */
        get connectAnchor(): Vector3;
        set connectAnchor(value: Vector3);
        /**
         * @en Enables or disables collision between the connected bodies of the joint.
         * @zh 是否启用关节连接体之间的碰撞。
         */
        get enableCollison(): boolean;
        set enableCollison(value: boolean);
        /** @ignore */
        constructor();
        /**
         * @en Sets the number of solver iterations used to resolve the constraint. Higher values increase the precision but may reduce performance.
         * @param overideNumIterations The number of iterations to override with.
         * @zh 设置用于解决约束的求解器迭代次数。次数越高，精度越准确，但可能会降低性能。
         * @param overideNumIterations 要使用的迭代次数。
         */
        setOverrideNumSolverIterations(overideNumIterations: number): void;
        /**
         * @en Enables or disables the constraint.
         * @param enable True to enable the constraint, false to disable it.
         * @zh 启用或禁用约束。
         * @param enable 是否启用约束。
         */
        setConstraintEnabled(enable: boolean): void;
    }
    /**
     * @en Fixed constraint. Used to fix two rigidbodies together.
     * @zh 固定约束，用于将两个刚体固定在一起。
     */
    class FixedConstraint extends ConstraintComponent {
        /** @ignore */
        constructor();
    }
    /**
     * @en Represents a hinge constraint between two rigid bodies.
     * @zh 两个刚体之间的铰链约束。
     */
    class HingeConstraint extends ConstraintComponent {
        /** @ignore */
        constructor();
        /**
         * @en Main axis. Set Hinge Rotation Axis, value by rigidbody0.
         * @zh 主轴。设置铰链旋转轴，值由刚体0决定。
         */
        get Axis(): Vector3;
        set Axis(value: Vector3);
        /**
         * @en The minimum limit value for joints.
         * @zh 关节的最小限制值。
         */
        get lowerLimit(): number;
        set lowerLimit(value: number);
        /**
         * @en The maximum limit value of the joint.
         * @zh 关节的最大限制值。
         */
        get uperLimit(): number;
        set uperLimit(value: number);
        /**
         * @en Bounciness value after joint limit.
         * @zh 关节限制值后的弹力值。
         */
        get bounceness(): number;
        set bounceness(value: number);
        /**
         * @en Minimum velocity for bounce after joint limit.
         * @zh 关节限制值后弹力反弹的最小速度。
         */
        get bouncenMinVelocity(): number;
        set bouncenMinVelocity(value: number);
        /**
         * @en Contact distance value of the joint, continuous collision within this distance.
         * @zh 关节的接触距离值，在此距离内持续碰撞。
         */
        get contactDistance(): number;
        set contactDistance(value: number);
        /**
         * @en Rotation limit of the joint.
         * @zh 关节的旋转限制。
         */
        get limit(): boolean;
        set limit(value: boolean);
        /**
         * @en Whether it is a motor (self-driven).
         * @zh 是否为马达（自驱动）。
         */
        get motor(): boolean;
        set motor(value: boolean);
        /**
         * @en Self driving acceleration (not maintaining a constant driving speed)
         * @zh 自驱动加速（不保持恒定驱动速度）。
         */
        get freeSpin(): boolean;
        set freeSpin(value: boolean);
        /**
         * @en The target velocity for the drive model.
         * @zh 驱动模型的目标速度。
         */
        get targetVelocity(): number;
        set targetVelocity(velocity: number);
        /**
         * @en Get the current angle in degrees of the joint relative to its rest position.
         * @zh 获取关节相对于其静止位置的当前角度(度)。
         */
        getAngle(): number;
        /**
         * @en The angular velocity of the joint in degrees per second.
         * @zh 获取关节的角速度，单位为度每秒。
         */
        getVelocity(): Vector3;
    }
    /**
     * @en The `SpringConstraint` class represents a type of constraint that simulates spring behavior in a physics simulation.
     * @zh `SpringConstraint` 类表示一种在物理模拟中模拟弹簧行为的约束类型。
     */
    class SpringConstraint extends ConstraintComponent {
        protected _onEnable(): void;
        protected _onDisable(): void;
        /**
         * @en the minimum distance at which a spring constraint begins to exert a separating force when the distance between objects reaches or falls below this value.
         * If the objects get closer than this, the spring applies a separating force to push them apart to a safe distance. When the distance is at or above the set value, the spring doesn't exert any stretching force.
         * @zh 弹簧关节在物体间距达到或小于此值时开始施加分离力的最小距离。
         * 如果物体间距小于这个值，弹簧会施加分离力将它们推开到安全距离。而当距离达到或超过设定值时，弹簧不会施加任何拉伸力。
         */
        get minDistance(): number;
        set minDistance(value: number);
        /**
         * @en the maximum distance in a spring constraint, where the spring starts pulling the objects together if they exceed this distance.
         * @zh 两个物体之间的最大允许距离。当物体间距超过这个值时，弹簧会施加拉力使物体靠近。
         */
        get maxDistance(): number;
        set maxDistance(value: number);
        /**
         * @en refers to the allowable margin of error in a physics engine, used to handle contact or constraints between objects, ensuring the system has a certain degree of tolerance in calculations.
         * @zh 弹簧的误差容限。
         * 用于处理物体之间的接触或约束时，确保系统在计算中具有一定的容忍度，以避免由于数值计算精度问题导致的不稳定或错误行为。
         */
        get tolerance(): number;
        set tolerance(value: number);
        /**
         * @en used to set the stiffness of a spring or constraint, adjusting the strength of the force or constraint between objects.
         * @zh 弹簧的刚度，以控制物体之间的弹力或约束强度。
         */
        get spring(): number;
        set spring(value: number);
        /**
         * @en The damping of the spring.
         * @zh 弹簧的阻尼值。
         */
        get damping(): number;
        set damping(value: number);
    }
    /**
     * @en ContactPoint class used to create physical contact information.
     * @zh ContactPoint 类用于创建物理碰撞信息。
     */
    class ContactPoint {
        /**
         * @en Collider A.
         * @zh 碰撞器A。
         */
        _colliderA: ICollider;
        /**
         * @en Collider B.
         * @zh 碰撞器B。
         */
        _colliderB: ICollider;
        /**
         * @en Distance.
         * @zh 距离。
         */
        distance: number;
        /**
         * @en Normal.
         * @zh 法线。
         */
        normal: Vector3;
        /**
         * @en Collider A's contact point.
         * @zh 碰撞器A的碰撞点。
         */
        positionOnA: Vector3;
        /**
         * @en Collider B's contact point.
         * @zh 碰撞器B的碰撞点。
         */
        positionOnB: Vector3;
        /**
         * @en constructor of ContactPoint.
         * @zh ContactPoint 构造函数。
         */
        constructor();
    }
    /**
     * @en The HitResult class is used to store the result of raycasting or shape scanning.
     * @zh HitResult 类用于实现射线检测或形状扫描的结果。
     */
    class HitResult {
        /**
         * @en Whether the raycast or shape scan is successful.
         * @zh 射线检测或形状扫描是否成功。
         */
        succeeded: boolean;
        /**
         * @en The collider that was hit.
         * @zh 发生碰撞的碰撞组件。
         */
        collider: ICollider;
        /**
         * @en The Collision point.
         * @zh 碰撞点。
         */
        point: Vector3;
        /**
         * @en Collision normals.
         * @zh 碰撞法线。
         */
        normal: Vector3;
        /**
         * @en Hit Fraction
         * @zh 碰撞分数。
         */
        hitFraction: number;
        /** @ignore */
        constructor();
    }
    /**
     * @en PhysicsCollider is a class used to create physical collider.
     * @zh PhysicsCollider 类用于创建物理碰撞器。
     */
    class PhysicsCollider extends PhysicsColliderComponent {
        /** @ignore */
        constructor();
        _onEnable(): void;
        /**
         * @en If this collider is a trigger. A trigger will trigger events but not produce actual physical blocking effects.
         * @zh 此碰撞器是否为触发器。触发器会触发事件但不会产生实际的物理阻挡效果。
         */
        get isTrigger(): boolean;
        set isTrigger(value: boolean);
        /**
         * @en Whether the collider allows sleep.
         * @zh 是否允许碰撞器睡眠。
         */
        get allowSleep(): boolean;
        set allowSleep(value: boolean);
    }
    /**
     * @en Describes how the physics materials of colliding objects are combined.
     * @zh 描述碰撞对象的物理材料是如何组合的。
     */
    enum PhysicsCombineMode {
        /**
         * @en Averages the friction/bounce of the two colliding materials.
         * @zh 平均值，对两个碰撞材料的摩擦力/反弹力取平均值。
         */
        Average = 0,
        /**
         * @en Uses the smaller friction/bounce of the two colliding materials.
         * @zh 最小值，使用两个碰撞材料中较小的摩擦力/反弹力。
         */
        Minimum = 1,
        /**
         * @en Multiplies the friction/bounce of the two colliding materials.
         * @zh 乘积，将两个碰撞材料的摩擦力/反弹力相乘，得到最终的摩擦系数。
         */
        Multiply = 2,
        /**
         * @en Uses the larger friction/bounce of the two colliding materials.
         * @zh 最大值，使用两个碰撞材料中较大的摩擦力/反弹力。
         */
        Maximum = 3
    }
    /**
     * @en Describes the mode of applying physics forces.
     * @zh 描述应用物理力的模式。
     */
    enum PhysicsForceMode {
        /**
         * @en Applies a continuous force to the object.
         * @zh 对物体施加持续的力。
         */
        Force = 0,
        /**
         * @en Applies an instantaneous velocity change to the object, equivalent to an impulse.
         * @zh 对物体施加瞬时速度变化，相当于冲量。
         */
        Impulse = 1
    }
    /**
     * @en PhysicsColliderComponent is the base class for creating physics components.
     * @zh PhysicsColliderComponent 类用于创建物理组件的父类。
     */
    class PhysicsColliderComponent extends Component {
        private _isColliderInit;
        owner: Sprite3D;
        /**
         * @en The collider object. Used to access the underlying physics engine's collider object and directly operate on the underlying physics engine's collision characteristics.
         * @zh 碰撞器对象。用于访问底层物理引擎的碰撞器对象，直接操作底层物理引擎的碰撞特性。
         */
        get collider(): ICollider;
        /**
         * @en The restitution coefficient is a key parameter in the physics engine that controls the elasticity of object collisions.
         * @zh 恢复系数是物理引擎中控制物体碰撞弹性程度的关键参数，在中文物理学术语中也被称为"弹性系数"或"反弹系数"。
         */
        get restitution(): number;
        set restitution(value: number);
        /**
         * @en The friction of the collider defines the friction coefficient of the object's surface, affecting the difficulty of the object sliding on the contact surface. The larger the value, the greater the friction, making it harder for the object to slide.
         * @zh 碰撞器的摩擦力。用于定义物体表面的摩擦系数，影响物体在接触面上滑动的难易程度。值越大，摩擦力越大，物体越难以滑动。
         */
        get friction(): number;
        set friction(value: number);
        /**
         * @en The rolling friction of the collider. Controls the resistance of an object as it rolls on a surface, affecting how quickly the object slows down when rolling. The larger the value, the faster the object's roll deceleration.
         * @zh 碰撞器的滚动摩擦力。用于控制物体在表面上滚动时的阻力，影响物体的滚动减速速率。值越大，物体滚动减速越快。
         */
        get rollingFriction(): number;
        set rollingFriction(value: number);
        /**
         * @en The dynamic friction of the collider. Defines the friction coefficient of an object when it is already in motion.
         * @zh 碰撞器的动态摩擦力。定义物体在已经运动状态下的摩擦系数。
         */
        get dynamicFriction(): number;
        set dynamicFriction(value: number);
        /**
         * @en The static friction of the collider. Defines the friction coefficient of an object when it is stationary, resisting its movement. Typically greater than or equal to dynamic friction.
         * @zh 碰撞器的静态摩擦力。定义物体在静止状态时抵抗开始移动的摩擦系数。通常大于或等于动态摩擦力。
         */
        get staticFriction(): number;
        set staticFriction(value: number);
        /**
         * @en Friction combination mode, used to define how the friction coefficients of two objects are combined during a collision to determine the final friction force.
         * The values include:
         * - Average: The friction coefficients of the two objects are averaged.
         * - Minimum: The minimum friction coefficient of the two objects is used.
         * - Maximum: The maximum friction coefficient of the two objects is used.
         * - Multiply: The friction coefficients of the two objects are multiplied to get the final friction coefficient.
         * @zh 摩擦力组合模式，用于定义在两个物体发生碰撞时，如何组合它们的摩擦系数，以确定最终的摩擦力。
         * 值包括：
         * - Average（平均值）：两个物体的摩擦系数取平均值。
         * - Minimum（最小值）：使用两个物体摩擦系数中的最小值。
         * - Maximum（最大值）：使用两个物体摩擦系数中的最大值。
         * - Multiply（乘积）：将两个物体的摩擦系数相乘，得到最终的摩擦系数。
         */
        get frictionCombine(): PhysicsCombineMode;
        set frictionCombine(value: PhysicsCombineMode);
        /**
         * @en The restitution mode of the collider.
         * The values include:
         * - Average: The friction coefficients of the two objects are averaged.
         * - Minimum: The minimum friction coefficient of the two objects is used.
         * - Maximum: The maximum friction coefficient of the two objects is used.
         * - Multiply: The friction coefficients of the two objects are multiplied to get the final friction coefficient.
         * @zh 恢复系数(弹力)组合模式，用于定义在两个物体发生碰撞时，如何组合它们的恢复系数，以确定最终的反弹效果。
         * 值为：
         * - Average（平均值）：两个物体的摩擦系数取平均值。
         * - Minimum（最小值）：使用两个物体摩擦系数中的最小值。
         * - Maximum（最大值）：使用两个物体摩擦系数中的最大值。
         * - Multiply（乘积）：将两个物体的摩擦系数相乘，得到最终的摩擦系数。
         */
        get restitutionCombine(): PhysicsCombineMode;
        set restitutionCombine(value: PhysicsCombineMode);
        /**
         * @en The collider shape of the physics collider. Used to set the geometric shape used by a physics collider, such as box, sphere, capsule, etc., defining the physical boundaries of an object.
         * @zh 物理碰撞器的碰撞形状。用于设置物理碰撞器使用的几何形状，如盒体、球体、胶囊体等，用于定义物体的物理边界。
         */
        get colliderShape(): Physics3DColliderShape;
        set colliderShape(value: Physics3DColliderShape);
        /**
         * @en The collision group this collider belongs to, used to control which objects can collide with it based on bitwise operations.
         * @zh 此碰撞器所属的碰撞组，用于控制哪些物体可以与之碰撞，基于位掩码实现。
         */
        get collisionGroup(): number;
        set collisionGroup(value: number);
        /**
         * @en The collision groups this collider can collide with, based on bitwise operations.
         * @zh 此碰撞器可以与之碰撞的碰撞组，基于位运算。
         */
        get canCollideWith(): number;
        set canCollideWith(value: number);
        /** @ignore */
        constructor();
    }
    /**
     * @en The PhysicsSettings class is used to create physics configuration information.
     * @zh PhysicsSettings 类用于创建物理配置信息。
     */
    class PhysicsSettings {
        /**
         * @en Flags that determine the behavior of the physics engine.
         * @zh 标志位，用于确定物理引擎的行为。
         */
        flags: number;
        /**
         * @en Used in the physics engine to specify the maximum number of substeps allowed per frame to improve the accuracy and stability of the physics simulation.
         * @zh 最大子步数,在物理引擎中用于指定每一帧允许的最大子步骤数，以提高物理模拟的精度和稳定性。
         */
        maxSubSteps: number;
        /**
         * @en The time step of the physics simulation.
         * @zh 固定时间步长，物理模拟器帧的间隔时间。
         */
        fixedTimeStep: number;
        /**
         * @en Whether to enable continuous collision detection.
         * @zh 是否开启连续碰撞检测
         */
        enableCCD: boolean;
        /**
         * @en The threshold for Continuous Collision Detection (CCD).
         * @zh 连续碰撞检测的阈值。
         */
        ccdThreshold: number;
        /**
         * @en The radius of the sphere used for Continuous Collision Detection.
         * @zh 连续碰撞检测的球体半径。
         */
        ccdSphereRadius: number;
    }
    /**
     * @en The `PhysicsUpdateList` class is used to manage the physics update queue.
     * @zh `PhysicsUpdateList` 类用于实现物理更新队列。
     */
    class PhysicsUpdateList extends SingletonList<ICollider> {
        /** @ignore */
        constructor();
    }
    /**
     * @en Rigidbody3D is a component that creates a rigidbody collider.
     * @zh Rigidbody3D 类用于创建刚体碰撞器。
     */
    class Rigidbody3D extends PhysicsColliderComponent {
        /**
         * @en The mass of the rigidbody. It affects the size of acceleration and momentum transfer during force application in collisions.
         * @zh 刚体的质量。影响其受力时的加速度大小和在碰撞中的动量传递。
         */
        get mass(): number;
        set mass(value: number);
        /**
         * @en Determines if the rigidbody is kinematic. If true, the rigidbody can only be moved by transform property, not by other force-related properties.
         * @zh 设置刚体是否为运动学控制模式。如果为true仅可通过transform属性移动物体,而非其他力相关属性。
         */
        get isKinematic(): boolean;
        set isKinematic(value: boolean);
        /**
         * @en The linear damping of the rigidbody. It simulates air resistance and other environmental factors to make the object slow down gradually.
         * @zh 控制刚体线性运动的阻尼系数，模拟空气阻力等环境因素，使物体逐渐减速。
         */
        get linearDamping(): number;
        set linearDamping(value: number);
        /**
         * @en The angular damping of the rigidbody. It simulates angular resistance and other environmental factors to make the object's rotation slow down gradually.
         * @zh 刚体的角速度阻尼。控制刚体旋转运动的阻尼系数，使旋转逐渐减速，防止永久旋转。
         */
        get angularDamping(): number;
        set angularDamping(value: number);
        /**
         * @en Sets the gravity vector applied to the rigidbody, allowing customization of direction and magnitude.
         * @zh 设置作用于刚体的重力向量，可自定义方向和大小。
         */
        get gravity(): Vector3;
        set gravity(value: Vector3);
        /**
         * @en The linear motion scaling factor for each axis of the rigidbody.
         * If the value of any axis is 0, it means that the linear motion is frozen on that axis.
         * If the value is 1, it means that linear motion on that axis is not restricted.
         * @zh 限制刚体在特定轴向的线性运动, 如果某一轴的值为0表示冻结在该轴的线性运动。为1表示在该轴的线性运动不受限制。
         */
        get linearFactor(): Vector3;
        set linearFactor(value: Vector3);
        /**
         * @en The linear velocity of the rigidbody.
         * It is represented by a three-dimensional vector (x, y, z) that corresponds to the linear velocity components of the rigidbody on the X, Y, and Z axes.
         * This value not only represents the magnitude but also includes direction.
         * @zh 刚体的线速度。由一个三维向量（x, y, z）表示，分别对应刚体在X、Y、Z 轴上的速度分量，该分量值既有大小又有方向。
         */
        get linearVelocity(): Vector3;
        set linearVelocity(value: Vector3);
        /**
         * @en The angular motion scaling factor for each axis of the rigidbody. If the value of any axis is 0, it means that the angular motion is frozen on that axis.
         * @zh 限制刚体在特定轴向的旋转运动，如果某一轴的值为0表示冻结在该轴的角度运动。
         */
        get angularFactor(): Vector3;
        set angularFactor(value: Vector3);
        /**
         * @en The angular velocity of the rigidbody.
         * It is represented by a three-dimensional vector (x, y, z) that corresponds to the angular velocity components of the rigidbody around X, Y, and Z axes.
         * This value not only represents the magnitude but also includes direction. The unit is **radians per second**.
         * @zh 刚体的角速度。由一个三维向量（Vector3）表示，分别对应刚体围绕X、Y、Z 轴的旋转速率分量，该分量值既有大小又有方向。单位是**弧度/秒**。
         */
        get angularVelocity(): Vector3;
        set angularVelocity(value: Vector3);
        /**
         * @en Set whether the rigidbody allows sleep.
         * @zh 设置刚体是否允许睡眠。
         */
        set allowSleep(value: boolean);
        get allowSleep(): boolean;
        /**
        * @en Whether it is sleeping.
        * @zh 是否处于睡眠状态。
        */
        get isSleeping(): boolean;
        /**
         * @en The linear velocity threshold below which the rigidbody will go to sleep.
         * @zh 刚体进入睡眠状态的线速度阈值。
         */
        get sleepThreshold(): number;
        set sleepThreshold(value: number);
        /**
         * @en The angular velocity threshold below which the rigidbody will go to sleep.
         * @zh 刚体进入睡眠状态的角速度阈值。
         */
        get sleepAngularThreshold(): number;
        set sleepAngularThreshold(value: number);
        /**
         * @en Directly sets the physical position of the rigidbody.
         * @zh 直接设置刚体的物理位置。
         */
        set position(pos: Vector3);
        /**
         * @en Directly sets the physical rotation of the rigidbody.
         * @zh 直接设置刚体的物理旋转。
         */
        set orientation(q: Quaternion);
        /**
         * @en Sets whether the rigidbody is a trigger. Triggers can detect collisions but do not produce physical reactions.
         * @zh 设置刚体是否作为触发器使用。触发器可以检测碰撞但不产生物理反应。
         */
        get trigger(): boolean;
        set trigger(value: boolean);
        /**
         * @en The collision detection mode of the rigidbody.
         * @zh 刚体的碰撞检测模式。
         */
        get collisionDetectionMode(): number;
        set collisionDetectionMode(value: number);
        /** @ignore */
        constructor();
        /**
         * @en Applies a force to the rigidbody.
         * @param force The force to apply.
         * @param localOffset The offset, if it is null, it is the center point.
         * @zh 应用作用力。
         * @param force 作用力。
         * @param localOffset 偏移,如果为null则为中心点
         */
        applyForce(force: Vector3, localOffset?: Vector3): void;
        /**
         * @en Applies a torque to the rigidbody.
         * @param torque The torque vector to apply.
         * @zh 对刚体应用扭转力。
         * @param torque 扭转力
         */
        applyTorque(torque: Vector3): void;
        /**
         * @en Applies an impulse to the rigidbody.
         * @param impulse The impulse vector to apply.
         * @param localOffset The offset at which the impulse is applied, relative to the rigidbody's center of mass. If null, the impulse is applied at the center.
         * @zh 对刚体应用冲量。
         * @param impulse 冲量。
         * @param localOffset 冲量相对于质心的偏移。如果为null，则冲量应用在质心处。
         */
        applyImpulse(impulse: Vector3, localOffset?: Vector3): void;
        /**
         * @en Applies a torque impulse (rotational impulse) to the rigidbody.
         * @param torqueImpulse The torque impulse vector to apply.
         * @zh 对刚体应用扭转冲量（旋转冲量）。
         * @param torqueImpulse 扭转冲量
         */
        applyTorqueImpulse(torqueImpulse: Vector3): void;
        /**
         * @en Wakes up the rigidbody.
         * @zh 唤醒刚体。
         */
        wakeUp(): void;
        /**
         * @deprecated
         * 刚体睡眠的线速度阈值。
         */
        get sleepLinearVelocity(): number;
        set sleepLinearVelocity(value: number);
        /**
         * @deprecated
         * 刚体睡眠的角速度阈值。
         */
        get sleepAngularVelocity(): number;
        set sleepAngularVelocity(value: number);
        /**
         * @deprecated
         * 应用作用力
         * @param fx x轴方向的力
         * @param fy y轴方向的力
         * @param fz z轴方向的力
         * @param localOffset 受力点距离质点的偏移
         */
        applyForceXYZ(fx: number, fy: number, fz: number, localOffset?: Vector3): void;
    }
    /**
     * @en BoxColliderShape class is used to create box collider shape.
     * @zh BoxColliderShape 类用于创建盒子形状碰撞器。
     */
    class BoxColliderShape extends Physics3DColliderShape {
        /**
         * @en Constructor method, initializes the box collider shape with a specified size.
         * @param sizeX The size of the box along the X-axis.
         * @param sizeY The size of the box along the Y-axis.
         * @param sizeZ The size of the box along the Z-axis.
         * @zh 盒形碰撞器的构造方法，初始化为指定尺寸。
         * @param sizeX 盒子X轴尺寸。
         * @param sizeY 盒子Y轴尺寸。
         * @param sizeZ 盒子Z轴尺寸。
         */
        constructor(sizeX?: number, sizeY?: number, sizeZ?: number);
        /**
         * @en Box size
         * @zh 盒子尺寸
         */
        get size(): Vector3;
        set size(value: Vector3);
        /**
         * @inheritDoc
         * @override
         * @en Clone a new BoxColliderShape object.
         * @zh 克隆一个新的 BoxColliderShape 对象。
         */
        clone(): any;
        /**
         * @en Clone data to target object.
         * @param destObject target object.
         * @zh 克隆数据到目标对象
         * @param destObject 目标对象
         */
        cloneTo(destObject: BoxColliderShape): void;
        /**
         * @deprecated
         * @en X-axis size.
         * @zh X轴尺寸。
         */
        get sizeX(): number;
        set sizeX(value: number);
        /**
         * @deprecated
         * @en Y-axis size.
         * @zh Y轴尺寸。
         */
        get sizeY(): number;
        set sizeY(value: number);
        /**
         * @deprecated
         * @en Z-axis size.
         * @zh Z轴尺寸。
         */
        get sizeZ(): number;
        set sizeZ(value: number);
    }
    /**
     * @en CapsuleColliderShape class is used to create capsule collider shape.
     * @zh CapsuleColliderShape 类用于创建胶囊形状碰撞器。
     */
    class CapsuleColliderShape extends Physics3DColliderShape {
        /**
         * @en The radius of the capsule collider.
         * @zh 胶囊碰撞器的半径。
         */
        get radius(): number;
        set radius(value: number);
        /**
         * @en The length of the capsule collider.
         * @zh 胶囊碰撞器的长度。
         */
        get length(): number;
        set length(value: number);
        /**
         * @en The orientation of the capsule collider.
         * @zh 胶囊碰撞器的方向。
         */
        get orientation(): number;
        set orientation(value: number);
        /**
         * @en initialize the capsule collider radius, length and direction.
         * @param radius The radius of the capsule collider.
         * @param length The length of the capsule collider.
         * @param orientation The orientation of the capsule collider.
         * @zh 初始化胶囊碰撞器的半径、长度和方向。
         * @param radius 胶囊半径。
         * @param length 胶囊长度。
         * @param orientation 胶囊体方向。
         */
        constructor(radius?: number, length?: number, orientation?: number);
        /**
         * @inheritDoc
         * @override
         * @en Clone a new CapsuleColliderShape object.
         * @return Clone CapsuleColliderShape object.
         * @zh 克隆一个新的 胶囊形状碰撞器 对象。
         * @return 克隆的 胶囊形状碰撞器 对象。
         */
        clone(): any;
        /**
         * @inheritDoc
         * @override
         * @en Clone data to target.
         * @param destObject Clone target.
         * @zh 克隆数据到目标
         * @param destObject 克隆目标
         */
        cloneTo(destObject: CapsuleColliderShape): void;
    }
    /**
     * @en use to create compound collider.
     * @zh 用于创建组合碰撞器。
     */
    class CompoundColliderShape extends Physics3DColliderShape {
        _shape: ICompoundColliderShape;
        /**
         * @en create a new instance of CompoundColliderShape.
         * @zh 创建一个新的组合碰撞形状实例。
         */
        constructor();
        protected _createShape(): void;
        /**
         * @en set the physics shape array.
         * @zh 设置物理形状数组。
         */
        set shapes(value: any[]);
        get shapes(): any[];
        /**
         * @en add a child collider shape.
         * @param shape.
         * @zh 添加一个子碰撞器形状。
         * @param shape 子碰撞器形状。
         */
        addChildShape(shape: Physics3DColliderShape): void;
        /**
         * @en remove a child collider shape.
         * @param shape.
         * @zh 移除一个子碰撞器形状。
         * @param shape 子碰撞器形状。
         */
        removeChildShape(shape: Physics3DColliderShape): void;
        /**
         * @en clear the child collider shape.
         * @zh 清空子碰撞器形状。
         */
        clearChildShape(): void;
        /**
         * @en get the child shape count.
         * @zh 获取子形状数量。
         */
        getChildShapeCount(): number;
        /**
         * @en clone the data to the destination node.
         * @zh 将数据克隆到目标节点。
         */
        cloneTo(destObject: CompoundColliderShape): void;
        /**
         * @en clone the data to the destination node.
         * @zh 将数据克隆到目标节点。
         */
        clone(): any;
        /**
         * @en destroy the instance.
         * @zh 销毁实例。
         */
        destroy(): void;
    }
    /**
     * @en ConeColliderShape class is used to create cone collider.
     * @zh ConeColliderShape 类用于创建圆锥碰撞器。
     */
    class ConeColliderShape extends Physics3DColliderShape {
        /**
         * @en The radius of the cone collider.
         * @zh 圆锥碰撞器的半径。
         */
        get radius(): number;
        set radius(value: number);
        /**
         * @en The height of the cone collider.
         * @zh 圆锥碰撞器的高度。
         */
        get height(): number;
        set height(value: number);
        /**
         * @en The orientation of the cone collider.
         * @zh 圆锥碰撞器的方向。
         */
        get orientation(): number;
        set orientation(value: number);
        /**
         * @en Constructor method, initialize ConeColliderShape.
         * @param radius The radius of the cone collider.
         * @param height The height of the cone collider.
         * @param orientation The orientation of the cone collider.
         * @zh 构造方法，初始化圆锥碰撞器。
         * @param radius 半径。
         * @param height 圆锥的高度。
         * @param orientation 圆锥的朝向。
         */
        constructor(radius?: number, height?: number, orientation?: number);
        /**
         * @inheritDoc
         * @override
         * @en Clone a new ConeColliderShape object.
         * @return A new ConeColliderShape object.
         * @zh 克隆一个新的 圆锥碰撞器 对象。
         * @return 一个新的 圆锥碰撞器 对象。
         */
        clone(): any;
        /**
         * @inheritDoc
         * @override
         * @en Clone data to target object.
         * @param destObject Target object.
         * @zh 将数据克隆到目标对象
         * @param destObject 目标对象。
         */
        cloneTo(destObject: ConeColliderShape): void;
    }
    /**
     * @en CylinderColliderShape class is used to create a cylinder collider.
     * @zh CylinderColliderShape 类用于创建圆柱碰撞器。
     */
    class CylinderColliderShape extends Physics3DColliderShape {
        /**
         * @en The radius of the cylinder collider.
         * @zh 圆柱碰撞器的半径。
         */
        get radius(): number;
        set radius(value: number);
        /**
         * @en The height of the cylinder collider.
         * @zh 圆柱碰撞器的高度。
         */
        get height(): number;
        set height(value: number);
        /**
         * @en The orientation of the cylinder collider.
         * @zh 圆柱碰撞器的方向。
         */
        get orientation(): number;
        set orientation(value: number);
        /**
         * @en Constructor method, initialize a cylinder collider.
         * @param radius The radius of the cylinder collider.
         * @param height The height of the cylinder collider.
         * @param orientation The orientation of the cylinder collider.
         * @zh 构造方法，初始化圆柱碰撞器。
         * @param radius 圆柱的半径。
         * @param height 圆柱的高度。
         * @param orientation 圆柱的朝向。
         */
        constructor(radius?: number, height?: number, orientation?: number);
        /**
         * @inheritDoc
         * @override
         * @en Clone a new CylinderColliderShape object.
         * @return A new CylinderColliderShape object.
         * @zh 克隆一个新的 圆柱碰撞器 对象。
         * @return 一个新的 圆柱碰撞器 对象。
         */
        clone(): any;
        /**
         * @inheritDoc
         * @override
         * @en Clone data to target object.
         * @param destObject Target object.
         * @zh 将数据克隆到目标对象
         * @param destObject 目标对象。
         */
        cloneTo(destObject: CylinderColliderShape): void;
    }
    /**
     * @en Interface for height field data.
     * @zh 高度场数据接口。
     */
    interface heightFieldData {
        /**
         * @en The number of rows in the height field.
         * @zh 高度场中的行数。
         */
        numRows: number;
        /**
         * @en The number of columns in the height field.
         * @zh 高度场中的列数。
         */
        numCols: number;
        /**
         * @en The height data of the field.
         * @zh 高度场的高度数据。
         */
        heightData: Float32Array;
        /**
         * @en The tessellation flags for the height field, where 0 and 1 indicate whether the terrain triangle faces left or right.
         * @zh 镶嵌标志，0 和 1 分别表示地形三角形朝向左还是朝右。
         */
        flag: Uint8Array;
        /**
         * @en The scale of the height field.
         * @zh 高度场的缩放。
         */
        scale: Vector3;
    }
    /**
     * @en Class describing the physics collision of a height field.
     * @zh 描述高度场物理碰撞的类。
     */
    class HeightFieldColliderShape extends Physics3DColliderShape {
        /**
         * @ignore
         * @en Constructor method, initialize height field data.
         * @param heightFieldData Height field data.
         * @zh 构造方法, 初始化高度场数据。
         * @param heightFieldData 高度场数据。
         */
        constructor(heightFieldData: heightFieldData);
    }
    /**
     * @en The `MeshColliderShape` class is used to create mesh colliders.
     * @zh `MeshColliderShape` 类用于创建网格碰撞器。
     */
    class MeshColliderShape extends Physics3DColliderShape {
        /**
         * @en The mesh of the collider.
         * @zh 碰撞器的网格。
         */
        get mesh(): Mesh;
        set mesh(value: Mesh);
        private _changeShape;
        /**
         * @en The maximum number of convex vertices.
         * @zh 凸多边形顶点的最大数量。
         */
        get convexVertexMax(): number;
        set convexVertexMax(value: number);
        /**
         * @en Whether the collider uses a convex shape.
         * @zh 碰撞器是否使用凸多边形形状。
         */
        get convex(): boolean;
        set convex(value: boolean);
        /** @ignore */
        constructor();
        /**
         * @inheritDoc
         * @override
         * @en Clone data to target object.
         * @param destObject Target object.
         * @zh 将数据克隆到目标对象
         * @param destObject 目标对象。
         */
        cloneTo(destObject: MeshColliderShape): void;
        /**
         * @inheritDoc
         * @override
         * @en Clone a new MeshColliderShape object.
         * @return A new MeshColliderShape object.
         * @zh 克隆一个新的 网格碰撞器 对象。
         * @return 一个新的 网格碰撞器 对象。
         */
        clone(): any;
    }
    /**
     * @en The Physics3DColliderShape class serves as the base class for creating collider shapes and is an abstract class.
     * @zh 类是用于创建形状碰撞器的父类，该类为抽象类。
     */
    class Physics3DColliderShape implements IClone {
        /**
         * @en Shape orientation: along the positive X-axis.
         * @zh 形状方向：沿 X 轴正向。
         */
        static SHAPEORIENTATION_UPX: number;
        /**
         * @en Shape orientation: along the positive Y-axis.
         * @zh 形状方向：沿 Y 轴正向。
         */
        static SHAPEORIENTATION_UPY: number;
        /**
         * @en Shape orientation: along the positive Z-axis.
         * @zh 形状方向：沿 Z 轴正向。
         */
        static SHAPEORIENTATION_UPZ: number;
        /**
         * @en The physics component of the collider.
         * @zh 碰撞器的物理组件。
         */
        private _physicsComponent;
        /**
         * @en The shape of the collider.
         * @zh 碰撞器的形状。
         */
        get shape(): IColliderShape;
        /**
         * @en The local offset of the shape.
         * @zh 形状的本地偏移。
         */
        get localOffset(): Vector3;
        set localOffset(value: Vector3);
        /**
         * @en The physics component of the collider.
         * @zh 碰撞器的物理组件。
         */
        get physicsComponent(): PhysicsColliderComponent;
        set physicsComponent(value: PhysicsColliderComponent);
        /**@ignore */
        constructor();
        /**
         * @en Clone this object to a destination object.
         * @param destObject The destination object.
         * @zh 将此对象克隆到目标对象。
         * @param destObject 目标对象。
         */
        cloneTo(destObject: Physics3DColliderShape): void;
        /**
         * @en Clone.
         * @return A clone of this object.
         * @zh 克隆。
         * @return 此对象的克隆
         */
        clone(): any;
        /**
         * @en Destroy this object.
         * @zh 销毁此对象。
         */
        destroy(): void;
    }
    /**
     * @en The `SphereColliderShape` class is used to create spherical colliders.
     * @zh `SphereColliderShape` 类用于创建球形碰撞器。
     */
    class SphereColliderShape extends Physics3DColliderShape {
        /**
         * @en The radius of the sphere collider.
         * @zh 球形碰撞器的半径。
         */
        get radius(): number;
        set radius(value: number);
        /**
         * @en Constructor method, initialize the sphere collider.
         * @param radius The radius of the sphere collider.
         * @zh 构造方法，初始化球形碰撞器。
         * @param radius 球形碰撞器的半径。
         */
        constructor(radius?: number);
        /**
         * @inheritDoc
         * @override
         * @en Clone a new SphereColliderShape object.
         * @return A new SphereColliderShape object.
         * @zh 克隆一个新的 球形碰撞器 对象。
         * @return 一个新的 球形碰撞器 对象。
         */
        clone(): any;
    }
    class Laya3DRender {
        static Render3DModuleDataFactory: I3DRenderModuleFactory;
        static Render3DPassFactory: I3DRenderPassFactory;
        /**
         * @deprecated
         */
        static renderOBJCreate: IRenderEngine3DOBJFactory;
    }
    /**
     * @en Mesh class is used to create a template for file mesh data.
     * @zh Mesh 类用于创建文件网格数据模板。
     */
    class Mesh extends Resource implements IClone {
        /**
         * @deprecated 请使用Loader.load(url:string, type: ILaya.Loader.MESH)
         * @en Loads a mesh template from the specified URL and calls the complete callback upon completion.
         * @param url The URL of the mesh template.
         * @param complete The callback function to call when the mesh is loaded.
         * @zh 从指定的URL加载网格模板，并在加载完成后执行完成回调。
         * @param url 网格模板的URL。
         * @param complete 加载完成后的回调函数。
         */
        static load(url: string, complete: Handler): void;
        /**
         * @en Morph target data for the mesh.
         * @zh 网格的变形目标数据。
         */
        morphTargetData: MorphTargetData;
        /**
         * @en The array of inverse absolute bind poses for the mesh.
         * @zh 网格的全局默认绑定动作逆矩阵数组。
         */
        get inverseAbsoluteBindPoses(): Matrix4x4[];
        /**
         * @en The number of vertices in the mesh.
         * @zh 网格中的顶点数。
         */
        get vertexCount(): number;
        /**
         * @en The number of indices in the mesh.
         * @zh 网格中的索引个数。
         */
        get indexCount(): number;
        /**
         * @en The number of SubMeshes in the mesh.
         * @zh 子网格的个数。
         */
        get subMeshCount(): number;
        /**
         * @en The bounds of the mesh.
         * @zh 网格的边界
         */
        get bounds(): Bounds;
        set bounds(value: Bounds);
        /**
         * @en The index format of the mesh.
         * @zh 网格的索引格式。
         */
        get indexFormat(): IndexFormat;
        set indexFormat(value: IndexFormat);
        /**
         * @en Constructor method, do not use.
         * @param isReadable 是否可读。
         * @zh 构造方法，禁止使用。
         * @param isReadable 是否可读。
         */
        constructor(isReadable?: boolean);
        /**
         * @en Retrieves a sub-mesh based on the index.
         * @param index The index of the sub-mesh.
         * @returns The sub-mesh at the specified index.
         * @zh 根据索引获取子网格。
         * @param index 子网格的索引。
         * @returns 索引处的子网格。
         */
        getSubMesh(index: number): SubMesh;
        /**
         * @en Copies and fills position data into an array.This method is a copy operation, which may be time-consuming.
         * @param positions The array to fill with position data.
         * @zh 拷贝并填充位置数据至数组。该方法为拷贝操作，比较耗费性能。
         * @param positions 用于填充位置数据的数组。
         */
        getPositions(positions: Vector3[]): void;
        /**
         * @en Sets the position data.
         * @param positions The new position data to set.
         * @zh 设置位置数据。
         * @param positions 要设置的新位置数据。
         */
        setPositions(positions: Vector3[]): void;
        /**
         * @en Copies and fills color data into an array.This method is a copy operation, which may be time-consuming.
         * @param colors The array to fill with color data.
         * @zh 拷贝并填充颜色数据至数组。该方法为拷贝操作，比较耗费性
         * @param colors 用于填充颜色数据的数组。
         */
        getColors(colors: Color[]): void;
        /**
         * @en Sets the color data.
         * @param colors The new color data to set.
         * @zh 设置颜色数据。
         * @param colors 要设置的新颜色数据。
         */
        setColors(colors: Color[]): void;
        /**
         * @en Copies and fills texture coordinate data into an array.This method is a copy operation, which may be time-consuming.
         * @param uvs The array to fill with texture coordinate data.
         * @param channel The texture coordinate channel.
         * @zh 拷贝并填充纹理坐标数据至数组。该方法为拷贝操作，比较耗费性能。
         * @param uvs 纹理坐标数组。
         * @param channel 纹理坐标通道。
         */
        getUVs(uvs: Vector2[], channel?: number): void;
        /**
         * @en Sets the texture coordinate data.
         * @param uvs The new texture coordinate data to set.
         * @param channel The texture coordinate channel.
         * @zh 设置纹理坐标数据。
         * @param uvs 要设置的新纹理坐标数据。
         * @param channel 纹理坐标通道。
         */
        setUVs(uvs: Vector2[], channel?: number): void;
        /**
         * @en Copies and fills normal data into an array.This method is a copy operation, which may be time-consuming.
         * @param normals The array to fill with normal data.
         * @zh 拷贝并填充法线数据至数组。该方法为拷贝操作，比较耗费性能。
         * @param normals 用于填充法线数据的数组。
         */
        getNormals(normals: Vector3[]): void;
        /**
         * @en Sets the normal data.
         * @param normals The new normal data to set.
         * @zh 设置法线数据。
         * @param normals 要设置的新法线数据。
         */
        setNormals(normals: Vector3[]): void;
        /**
         * @en Copies and fills tangent data into an array.
         * @param tangents The array to fill with tangent data.
         * @zh 拷贝并填充切线数据至数组。
         * @param tangents 用于填充切线数据的数组。
         */
        getTangents(tangents: Vector4[]): void;
        /**
         * @en Sets the tangent data.
         * @param tangents The new tangent data to set.
         * @zh 设置切线数据。
         * @param tangents 要设置的新切线数据。
         */
        setTangents(tangents: Vector4[]): void;
        /**
         * @en Copies and fills bone weight data into an array.
         * @param boneWeights The array to fill with bone weight data.
         * @zh 拷贝并填充骨骼权重数据至数组。
         * @param boneWeights 用于填充骨骼权重数据的数组。
         */
        getBoneWeights(boneWeights: Vector4[]): void;
        /**
         * @en Copy and fill the bone weight data into the array.
         * @param boneWeights Bone weight data.
         * @zh 拷贝并填充骨骼权重数据至数组。
         * @param boneWeights 骨骼权重。
         */
        setBoneWeights(boneWeights: Vector4[]): void;
        /**
         * @en Gets the bone indices.
         * @param boneIndices The bone indices
         * @zh 获取骨骼索引。
         * @param boneIndices 骨骼索引。
         */
        getBoneIndices(boneIndices: Vector4[]): void;
        /**
         * @en Sets the bone index data.
         * @param boneIndices The new bone index data to set.
         * @zh 设置骨骼索引数据。
         * @param boneIndices 要设置的新骨骼索引数据。
         */
        setBoneIndices(boneIndices: Vector4[]): void;
        /**
         * @en Marks the Mesh as non-readable, which can reduce memory usage. Once marked, no read methods can be called.
         * @zh 将Mesh标记为不可读，可以减少内存使用。标记后，不能再调用任何读取方法。
         */
        markAsUnreadbale(): void;
        /**
         * @en Gets the vertex declaration.
         * @zh 获取顶点声明。
         */
        getVertexDeclaration(): VertexDeclaration;
        /**
         * @en Copies and retrieves a copy of the vertex data.
         * @returns A copy of the vertex data.
         * @zh 拷贝并获取顶点数据的副本。
         * @returns 顶点数据副本。
         */
        getVertices(): ArrayBuffer;
        /**
         * @en Sets the vertex data.
         * @param vertices The vertex data to set.
         * @zh 设置顶点数据。
         * @param vertices 要设置的顶点数据。
         */
        setVertices(vertices: ArrayBuffer): void;
        /**
         * @en Copies and retrieves a copy of the mesh indices.
         * @returns A copy of the mesh indices.
         * @zh 拷贝并获取网格索引的副本。
         * @returns 网格索引的副本。
         */
        getIndices(): Uint8Array | Uint16Array | Uint32Array;
        /**
         * @en Sets the mesh indices.
         * @param indices The mesh indices to set.
         * @zh 设置网格索引。
         * @param indices 要设置的网格索引。
         */
        setIndices(indices: Uint8Array | Uint16Array | Uint32Array): void;
        /**
         * @en Generates a bounding box from the model's position data.
         * @zh 从模型位置数据生成包围盒。
         */
        calculateBounds(): void;
        /**
         * @en Gets the convex model.
         * @returns The convex mesh.
         * @zh 获取凸包模型。
         * @returns 凸包网格。
         */
        getCorveMesh(): Mesh;
        /**
         * @en Clones this mesh to the destination object.
         * @param destObject The destination object to clone to.
         * @zh 克隆当前网格到目标对象。
         * @param destObject 克隆的目标对象。
         */
        cloneTo(destObject: Mesh): void;
        /**
         * @en Clones this mesh.
         * @returns A clone of the current mesh.
         * @zh 克隆当前网格。
         * @return 当前网格的克隆副本。
         */
        clone(): any;
    }
    /**
     * @en Utility class for mesh operations
     * @zh Mesh操作的实用工具类
     */
    class MeshUtil {
        /**
         * @en Get the shader defines for a mesh
         * @param mesh The mesh to analyze
         * @param out Array to store the resulting shader defines
         * @zh 获取mesh的着色器宏定义
         * @param mesh 输入的Mesh对象
         * @param out 用于存储着色器宏定义的输出数组
         */
        static getMeshDefine(mesh: Mesh, out: Array<ShaderDefine>): void;
    }
    /**
     * @en Represents a morph target in 3D modeling
     * @zh 表示3D建模中的变形目标
     */
    class MorphTarget {
        /**
         * @en The name of the morph target
         * @zh 变形目标的名称
         */
        name: string;
        /**
         * @en The full weight of the morph target
         * @zh 变形目标的完整权重
         */
        fullWeight: number;
        /**
         * @en The data of the morph target
         * @zh 变形目标的数据
         */
        data: Float32Array;
        /** @ignore */
        constructor();
    }
    /**
     * @en Represents a channel of morph targets
     * @zh 表示变形目标的通道
     */
    class MorphTargetChannel {
        /**
         * @en The name of the morph target channel
         * @zh 变形目标通道的名称
         */
        name: string;
        /**
         * @en The list of morph targets in this channel.
         * @zh 此通道中的变形目标列表。
         */
        targets: Array<MorphTarget>;
        /**
         * @en The count of targets in this channel
         * @zh 此通道中目标的数量
         */
        targetCount: number;
        constructor();
        /**
         * @en Get a target by its index
         * @param index The index of the target
         * @returns The MorphTarget at the specified index
         * @zh 通过索引获取目标
         * @param index 目标的索引
         * @returns 指定索引处的MorphTarget
         */
        getTargetByIndex(index: number): MorphTarget;
        /**
         * @en Add a target to this channel
         * @param target The MorphTarget to add
         * @zh 向此通道添加目标
         * @param target 要添加的MorphTarget
         */
        addTarget(target: MorphTarget): void;
    }
    /**
     * @en Morph target data.
     * @zh 变形目标数据。
     */
    class MorphTargetData {
        private targets;
        private channels;
        /**
         * @en The count of vertices in the morph target data.
         * @zh 变形目标数据中的顶点计数。
         */
        vertexCount: number;
        /**
         * @en Removed, replaced by getting it from the VertexDeclaration.
         * @zh 移除，改为从 VertexDeclaration 中获取
         */
        elementCount: number;
        /**
         * @en The vertex declaration associated with the morph target data.
         * @zh 与变形目标数据关联的顶点声明。
         */
        vertexDec: VertexDeclaration;
        /**
         * @en The bounding box.
         * @zh 包围盒
         */
        bounds: Bounds;
        /** @ignore */
        constructor();
        /**
         * @en Adds a morph target channel to the data.
         * @param channel The morph target channel to add.
         * @zh 向数据添加一个变形目标通道。
         * @param channel 要添加的变形目标通道。
         */
        addMorphChannel(channel: MorphTargetChannel): void;
        /**
         * @en Retrieves a morph target channel by its name.
         * @param name The name of the morph target channel to retrieve.
         * @returns The morph target channel with the specified name.
         * @zh 通过名称检索变形目标通道。
         * @param name 要检索的变形目标通道的名称。
         * @returns 具有指定名称的变形目标通道。
         */
        getMorphChannel(name: string): MorphTargetChannel;
        /**
         * @en Retrieves a morph target channel by its index.
         * @param index The index of the morph target channel to retrieve.
         * @returns The morph target channel at the specified index.
         * @zh 通过索引检索变形目标通道。
         * @param index 要检索的变形目标通道的索引。
         * @returns 在指定索引处的变形目标通道。
         */
        getMorphChannelbyIndex(index: number): MorphTargetChannel;
        /**
         * @en Initializes the data for the morph targets.
         * @zh 初始化变形目标的数据。
         */
        initData(): void;
        /**
         * @en Cleans up and destroys the resources associated with the morph target data.
         * @zh 清理并销毁与变形目标数据关联的资源。
         */
        destroy(): void;
        /**
         * @en Clone the morph target data.
         * @returns A cloned instance of the morph target data.
         * @zh 克隆变形目标数据。
         * @returns 变形目标数据的克隆实例。
         */
        clone(): MorphTargetData;
    }
    /**
     * @en The `PrimitiveMesh` class is used to create simple meshes.
     * @zh `PrimitiveMesh` 类用于创建简单的网格。
     */
    class PrimitiveMesh {
        static __init__(): void;
        /**
         * @en Creates a box mesh.
         * @param long The length of the box. Default is 1.
         * @param height The height of the box. Default is 1.
         * @param width The width of the box. Default is 1.
         * @return The created Mesh instance.
         * @zh 创建一个立方体网格。
         * @param long 立方体的长度，默认值为1。
         * @param height 立方体的高度，默认值为1。
         * @param width 立方体的宽度，默认值为1。
         * @return 创建的网格实例。
         */
        static createBox(long?: number, height?: number, width?: number): Mesh;
        /**
         * @en Creates a capsule mesh.
         * @param radius The radius of the capsule. Default is 0.5.
         * @param height The height of the capsule. Default is 2.
         * @param stacks The number of stacks, typically half the number of vertical slices. Default is 16.
         * @param slices The number of vertical slices. Default is 32.
         * @zh 创建一个胶囊体网格。
         * @param radius 胶囊的半径，默认值为0.5。
         * @param height 胶囊的高度，默认值为2。
         * @param stacks 水平层数，默认为16，一般设为垂直层数的一半。
         * @param slices 垂直层数，默认为32。
         */
        static createCapsule(radius?: number, height?: number, stacks?: number, slices?: number): Mesh;
        /**
         * @en Creates a cone mesh.
         * @param radius The radius of the base of the cone. Default is 0.5.
         * @param height The height of the cone. Default is 1.
         * @param slices The number of segments around the base of the cone. Default is 32.
         * @return The created Mesh instance.
         * @zh 创建一个圆锥体网格。
         * @param radius 圆锥底面的半径，默认值为0.5。
         * @param height 圆锥的高度，默认值为1。
         * @param slices 圆锥底面圆周的分段数，默认为32。
         * @return 创建的网格实例。
         */
        static createCone(radius?: number, height?: number, slices?: number): Mesh;
        /**
         * @en Creates a cylinder mesh.
         * @param radius The radius of the cylinder. Default is 0.5.
         * @param height The height of the cylinder. Default is 2.
         * @param slices The number of vertical segments of the cylinder. Default is 32.
         * @return The created Mesh instance.
         * @zh 创建一个圆柱体网格。
         * @param radius 圆柱的半径，默认值为0.5。
         * @param height 圆柱的高度，默认值为2。
         * @param slices 圆柱的垂直层数，默认为32。
         * @return 创建的网格实例。
         */
        static createCylinder(radius?: number, height?: number, slices?: number): Mesh;
        /**
         * @en Creates a plane mesh.
         * @param long The length of the plane. Default is 10.
         * @param width The width of the plane. Default is 10.
         * @param stacks The number of longitudinal subdivisions. Default is 10.
         * @param slices The number of latitudinal subdivisions. Default is 10.
         * @return The created Mesh instance.
         * @zh 创建一个平面网格。
         * @param long 平面的长。默认值为10。
         * @param width 平面的宽。默认值为10。
         * @param stacks 纵向细分的数量。默认为10。
         * @param slices 横向细分的数量。默认为10。
         * @return 创建的网格实例。
         */
        static createPlane(long?: number, width?: number, stacks?: number, slices?: number): Mesh;
        /**
         * @en Creates a quad mesh.
         * @param long The length of the quad. Default is 1.
         * @param width The width of the quad. Default is 1.
         * @return The created Mesh instance.
         * @zh 创建一个四边形网格。
         * @param long 四边形的长度。默认是1。
         * @param width 四边形的宽度。默认是1。
         * @return 创建的网格实例。
         */
        static createQuad(long?: number, width?: number): Mesh;
        /**
         * @en Creates a sphere mesh.
         * @param radius The radius of the sphere. Default is 0.5.
         * @param stacks The number of stacks, typically used for the vertical slices. Default is 32.
         * @param slices The number of slices, typically used for the horizontal circles. Default is 32.
         * @return The created Mesh instance.
         * @zh 创建一个球体网格。
         * @param radius 球体的半径。默认是0.5。
         * @param stacks 水平层数，通常用作垂直切分。默认是32。
         * @param slices 垂直层数，通常用作水平圆周切分。默认是32。
         * @return 创建的网格实例。
         */
        static createSphere(radius?: number, stacks?: number, slices?: number): Mesh;
    }
    /**
     * @en SkyBox class used to create a skybox.
     * @zh SkyBox 类用于创建天空盒。
     */
    class SkyBox extends GeometryElement {
        /**
         * @en The singleton instance of the SkyBox class.
         * @zh SkyBox类的单例实例。
         */
        static instance: SkyBox;
        /**
         * @ignore
         * @en Creates an instance of SkyBox.
         * @zh 创建 SkyBox 的实例。
         */
        constructor();
    }
    /**
     * @en SkyDome class is used to create a sky dome.
     * @zh SkyDome 类用于创建天空球。
     */
    class SkyDome extends GeometryElement {
        /**
         * @en The singleton instance of the SkyDome.
         * @zh SkyDome的实例。
         */
        static instance: SkyDome;
        /**
         * @en Creates an instance of SkyDome.
         * @param stacks The number of stacks of the SkyDome.
         * @param slices The number of slices of the SkyDome.
         * @zh 创建一个 SkyDome 的实例。
         * @param stacks SkyDome的堆数。
         * @param slices SkyDome的层数。
         */
        constructor(stacks?: number, slices?: number);
    }
    /**
     * @en SkyRenderer class used to implement sky rendering.
     * @zh SkyRenderer 类用于实现天空渲染器。
     */
    class SkyRenderer {
        private _renderData;
        private _renderGeometry;
        private _cacheRenderElement;
        /**
         * @en The material.
         * @zh 材质。
         */
        get material(): Material;
        set material(value: Material);
        /**
         * @en The mesh of the renderer.
         * @zh 渲染器网格。
         */
        get mesh(): GeometryElement;
        set mesh(value: GeometryElement);
        /**
         * @ignore
         * @en Creates an instance of SkyRenderer.
         * @zh 创建一个 SkyRenderer 的实例。
         */
        constructor();
        /**
         * @en Sets the render element for the sky.
         * @param skyRenderElement The render element to set.
         * @zh 设置天空的渲染元素。
         * @param skyRenderElement 要设置的渲染元素。
         */
        setRenderElement(skyRenderElement: SkyRenderElement): void;
    }
    /**
     * @en SubMesh class used to create submesh data template.
     * @zh SubMesh 类用于创建子网格数据模板。
     */
    class SubMesh extends GeometryElement {
        /**
         * @en The number of indices.
         * @zh 索引的数量。
         */
        get indexCount(): number;
        /**
         * @en Creates an instance of SubMesh.
         * @param mesh  The mesh data template.
         * @zh 创建 SubMesh 实例。
         * @param mesh  网格数据模板。
         */
        constructor(mesh: Mesh);
        /**
         * @en Copies and gets a copy of the submesh index data.
         * @returns A copy of the indices.
         * @zh 拷贝并获取子网格索引数据的副本。
         * @returns 索引的副本。
         */
        getIndices(): Uint16Array | Uint32Array;
        /**
         * @en Sets the indices for the submesh.
         * @param indices The indices to set.
         * @zh 设置子网格的索引。
         * @param indices 要设置的索引。
         */
        setIndices(indices: Uint16Array): void;
        /**
         * @en Destroys the submesh and releases resources.
         * @zh 销毁子网格并释放资源。
         */
        destroy(): void;
    }
    class BlinnPhongShaderInit {
        static init(): void;
    }
    class PBRShaderLib {
        /**
         * emission
         */
        static DEFINE_EMISSION: ShaderDefine;
        /**
         * clear coat
         */
        static DEFINE_CLEARCOAT: ShaderDefine;
        static DEFINE_CLEARCOAT_NORMAL: ShaderDefine;
        /**
         * anisotropy
         */
        static DEFINE_ANISOTROPY: ShaderDefine;
        /**
         * ior
         */
        static DEFINE_IOR: ShaderDefine;
        /**
         * iridescence
         */
        static DEFINE_IRIDESCENCE: ShaderDefine;
        /**
         * sheen
         */
        static DEFINE_SHEEN: ShaderDefine;
        /**
         * transmission
         */
        static DEFINE_TRANSMISSION: ShaderDefine;
        /**
         * thick / volume
         */
        static DEFINE_THICKNESS: ShaderDefine;
        static init(): void;
    }
    class PBRStandardShaderInit {
        static init(): void;
    }
    class ACESShaderLib {
        static init(): void;
    }
    class BlitScreenShaderInit {
        static init(): void;
        private static lutBuilderInit;
    }
    /**
     * ParticleShuriKen Shader init
     */
    class ParticleShuriKenShaderInit {
        static init(): void;
    }
    class SkyBoxShaderInit {
        static init(): void;
    }
    class SkyPanoramicShaderInit {
        static init(): void;
    }
    class SkyProceduralShaderInit {
        static init(): void;
    }
    class TrailShaderInit {
        static init(): void;
    }
    class UnlitShaderInit {
        static init(): void;
    }
    /**
     * @en Shadow Light enum
     * @zh 阴影光类型
     */
    enum ShadowLightType {
        /**
         * @en Directional Light
         * @zh 方向光
         */
        DirectionLight = 0,
        /**
         * @en Spot Light
         * @zh 聚光
         */
        SpotLight = 1,
        /**
         * @en Point Light
         * @zh 点光
         */
        PointLight = 2
    }
    /**
     * @en Camera culling information class.
     * @zh 摄像机裁剪信息类。
     */
    class CameraCullInfo {
        /**
         * @en Position of the camera in the scene.
         * @zh 摄像机在场景中的位置。
         */
        position: Vector3;
        /**
         * @en Whether to use occlusion culling.
         * @zh 是否遮挡剔除
         */
        useOcclusionCulling: Boolean;
        /**
         * @en Frustum that bounds the camera's view.
         * @zh 摄像机视锥体的包围盒。
         */
        boundFrustum: BoundFrustum;
        /**
         * @en Occlusion Mask
         * @zh 遮挡标记
         */
        cullingMask: number;
        /**
         * @en Static Mask
         * @zh 静态标记
         */
        staticMask: number;
        /**
         * @en Create a new instance of CameraCullInfo.
         * @zh 创建 CameraCullInfo 类的新实例。
         */
        constructor();
    }
    /**
     * @en Shadow culling information.
     * @zh 阴影裁剪信息
     */
    class ShadowCullInfo {
        /**
         * @en Position.
         * @zh 位置。
         */
        position: Vector3;
        /**
         * @en Direction.
         * @zh 方向。
         */
        direction: Vector3;
        /**
         * @en Array of planes used for culling.
         * @zh 用于裁剪的平面数组。
         */
        cullPlanes: Plane[];
        /**
         * @en Sphere used for culling.
         * @zh 用于裁剪的球体。
         */
        cullSphere: BoundSphere;
        /**
         * @en Number of culling planes.
         * @zh 裁剪平面的数量。
         */
        cullPlaneCount: number;
    }
    /**
     * @en Spotlight Shadow Data
     * @zh 聚光灯阴影数据
     */
    class ShadowSpotData {
        /**
         * @en The camera shader data.
         * @zh 摄像机着色器数据。
         */
        cameraShaderValue: ShaderData;
        /**
         * @en Position of the shadow.
         * @zh 阴影的位置。
         */
        position: Vector3;
        /**
         * @en Offset on the X-axis for the shadow map.
         * @zh 阴影贴图在X轴上的偏移。
         */
        offsetX: number;
        /**
         * @en Offset on the Y-axis for the shadow map.
         * @zh 阴影贴图在Y轴上的偏移。
         */
        offsetY: number;
        /**
         * @en Resolution of the shadow map.
         * @zh 阴影贴图的分辨率。
         */
        resolution: number;
        /**
         * @en View matrix of the shadow.
         * @zh 阴影的视图矩阵。
         */
        viewMatrix: Matrix4x4;
        /**
         * @en Projection matrix of the shadow.
         * @zh 阴影的投影矩阵。
         */
        projectionMatrix: Matrix4x4;
        /**
         * @en Combined view and projection matrix of the shadow.
         * @zh 阴影的视图投影矩阵。
         */
        viewProjectMatrix: Matrix4x4;
        /**
         * @en Culling information for the shadow camera.
         * @zh 阴影摄像机的裁剪信息。
         */
        cameraCullInfo: CameraCullInfo;
        /**
         * @en Uniform buffer object for the camera.
         * @zh 摄像机的统一缓冲对象。
         */
        cameraUBO: UniformBufferObject;
        /**
         * @en Uniform buffer data for the camera.
         * @zh 摄像机的统一缓冲数据。
         */
        cameraUBData: UnifromBufferData;
        /**
         * @en Create a new instance of ShadowSpotData.
         * @zh 创建 ShadowSpotData 类的新实例。
         */
        constructor();
        destroy(): void;
    }
    /**
     * @en TextMesh class used to create text mesh.
     * @zh TextMesh 类用于创建文本网格。
     */
    class TextMesh {
        private _text;
        private _fontSize;
        private _color;
        /**
         * @en The text of the TextMesh.
         * @zh 文本网格的文本。
         */
        get text(): string;
        set text(value: string);
        /**
         * @en The font size of the TextMesh.
         * @zh 字体尺寸。
         */
        get fontSize(): number;
        set fontSize(value: number);
        /**
         * @en The color of the TextMesh.
         * @zh 文本网格的颜色
         */
        get color(): Color;
        set color(value: Color);
        /** @ignore */
        constructor();
    }
    /**
     * @en Physics3DUtils class represents a 3D physics collision group.
     * @zh Physics3DUtils 类表示3D物理碰撞组。
     */
    class Physics3DUtils {
        /**
         * @en Default collision filter group.
         * @zh 默认碰撞组。
         */
        static COLLISIONFILTERGROUP_DEFAULTFILTER: number;
        /**
         * @en Static collision filter group.
         * @zh 静态碰撞组。
         */
        static COLLISIONFILTERGROUP_STATICFILTER: number;
        /**
         * @en Kinematic rigid body collision filter group.
         * @zh 运动学刚体碰撞组。
         */
        static COLLISIONFILTERGROUP_KINEMATICFILTER: number;
        /**
         * @en Debris collision filter group.
         * @zh 碎片碰撞组。
         */
        static COLLISIONFILTERGROUP_DEBRISFILTER: number;
        /**
         * @en Sensor trigger filter group.
         * @zh 传感器触发器。
         */
        static COLLISIONFILTERGROUP_SENSORTRIGGER: number;
        /**
         * @en Character filter group.
         * @zh 字符过滤器。
         */
        static COLLISIONFILTERGROUP_CHARACTERFILTER: number;
        /**
         * @en Custom filter group 1.
         * @zh 自定义过滤1。
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER1: number;
        /**
         * @en Custom filter group 2.
         * @zh 自定义过滤2。
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER2: number;
        /**
         * @en Custom filter group 3.
         * @zh 自定义过滤3。
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER3: number;
        /**
         * @en Custom filter group 4.
         * @zh 自定义过滤4。
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER4: number;
        /**
         * @en Custom filter group 5.
         * @zh 自定义过滤5。
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER5: number;
        /**
         * @en Custom filter group 6.
         * @zh 自定义过滤6。
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER6: number;
        /**
         * @en Custom filter group 7.
         * @zh 自定义过滤7。
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER7: number;
        /**
         * @en Custom filter group 8.
         * @zh 自定义过滤8。
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER8: number;
        /**
         * @en Custom filter group 9.
         * @zh 自定义过滤9。
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER9: number;
        /**
         * @en Custom filter group 10.
         * @zh 自定义过滤10。
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER10: number;
        /**
         * @en All filter group that includes all other filter groups.
         * @zh 包含所有其他过滤组的所有过滤组。
         */
        static COLLISIONFILTERGROUP_ALLFILTER: number;
        /**
         * @en Default mask value used in PhysX.
         * @zh 在PhysX中使用的默认掩码值。
         */
        static PHYSXDEFAULTMASKVALUE: number;
    }
    /**
     * @en Picker class used to create picking.
     * @zh Picker 类用于创建拾取。
     */
    class Picker {
        /** @ignore */
        constructor();
        /**
         * @en Calculates a ray originating from the mouse position.
         * @param point The mouse position in screen space.
         * @param viewPort The viewport dimensions.
         * @param projectionMatrix The projection (perspective) matrix.
         * @param viewMatrix The view matrix.
         * @param world The world offset matrix.
         * @param out The output ray.
         * @zh 根据鼠标位置计算射线。
         * @param point 屏幕空间中的鼠标位置。
         * @param viewPort 视口尺寸。
         * @param projectionMatrix 投影（透视）矩阵。
         * @param viewMatrix 视图矩阵。
         * @param world 世界偏移矩阵。
         * @param out 输出射线。
         */
        static calculateCursorRay(point: Vector2, viewPort: Viewport, projectionMatrix: Matrix4x4, viewMatrix: Matrix4x4, world: Matrix4x4, out: Ray): void;
        /**
         * @en Calculates the intersection of a ray with a triangle and returns the intersection distance.
         * @param ray The ray.
         * @param vertex1 The first vertex of the triangle.
         * @param vertex2 The second vertex of the triangle.
         * @param vertex3 The third vertex of the triangle.
         * @returns The distance from the ray to the triangle, or `Number.NaN` if there is no intersection.
         * @zh 计算射线与三角形的交点并返回交点距离。
         * @param ray 射线。
         * @param vertex1 三角形的第一个顶点。
         * @param vertex2 三角形的第二个顶点。
         * @param vertex3 三角形的第三个顶点。
         * @returns 射线到三角形的距离，如果没有交点则返回 `Number.NaN`。
         */
        static rayIntersectsTriangle(ray: Ray, vertex1: Vector3, vertex2: Vector3, vertex3: Vector3): number;
        /**
         * @en Detects the intersection point between a ray and a plane.
         * @param ray The ray.
         * @param plane The plane.
         * @returns The intersection point, or `null` if there is no intersection.
         * @zh 检测射线和平面的交点。
         * @param ray 射线。
         * @param plane 平面。
         * @returns 交点，如果没有交点则返回 `null`。
         */
        static rayPlaneIntersection(ray: Ray, plane: Plane): Vector3;
    }
    /**
     * @en The `Size` class represents the dimensions of a rectangle or other shape in 2D space.
     * @zh `Size` 类表示2D空间中矩形或其他形状的尺寸。
     */
    class Size {
        /**
         * @en Gets the screen size of the global scene.
         * @return Returns a `Size` instance with both width and height set to -1, indicating full screen.
         * @zh 获取全局场景的屏幕尺寸。
         * @return 返回一个宽度和高度都设置为 -1 的 `Size` 实例，表示全屏。
         */
        static get fullScreen(): Size;
        private _width;
        private _height;
        /**
         * @en Width.
         * @zh 宽度
         */
        get width(): number;
        /**
         * @en Height.
         * @zh 高度
         */
        get height(): number;
        /**
         * @en Creates an instance of  `Size`.
         * @param width  Width.
         * @param height Height.
         * @zh 创建一个 `Size` 实例。
         * @param width 宽度
         * @param height 高度
         */
        constructor(width: number, height: number);
    }
    /**
     * @en Utils3D is a class used to create 3D tools.
     * @zh Utils3D 类用于创建3D工具。
     */
    class Utils3D {
        /**
         *通过数平移、旋转、缩放值计算到结果矩阵数组,骨骼动画专用。
         * @param tx left矩阵数组。
         * @param ty left矩阵数组的偏移。
         * @param tz right矩阵数组。
         * @param qx right矩阵数组的偏移。
         * @param qy 输出矩阵数组。
         * @param qz 输出矩阵数组的偏移。
         * @param qw 输出矩阵数组的偏移。
         * @param sx 输出矩阵数组的偏移。
         * @param sy 输出矩阵数组的偏移。
         * @param sz 输出矩阵数组的偏移。
         * @param outArray 结果矩阵数组。
         * @param outOffset 结果矩阵数组的偏移。
         */
        private static _rotationTransformScaleSkinAnimation;
        /**
         * @en Convert vertices to a billboard
         * @zh 将顶点进行广告牌转换
         */
        static billboardTrans(v0: Vector3, cameraDir: Vector3, cameraUp: Vector3, out: Vector3): void;
        /**
         * @en Determines if point P is within the triangle formed by points A, B, and C. https://mathworld.wolfram.com/BarycentricCoordinates.html
         * @param A The first vertex of the triangle.
         * @param B The second vertex of the triangle.
         * @param C The third vertex of the triangle.
         * @param P The point to check.
         * @returns True if P is inside the triangle, false otherwise.
         * @zh 判断点P是否在由点A、B、C组成的三角形内。https://mathworld.wolfram.com/BarycentricCoordinates.html
         * @param A 三角形的第一个顶点。
         * @param B 三角形的第二个顶点。
         * @param C 三角形的第三个顶点。
         * @param P 需要判断的点。
         * @returns 若P在三角形内，返回true，否则返回false。
         */
        static PointinTriangle(A: Vector3, B: Vector3, C: Vector3, P: Vector3): boolean;
        /**
         * @en Rotates a 3D vector using a quaternion.
         * @param sourceArray The source vector components in a Float32Array.
         * @param sourceOffset The offset in the source array where the source vector starts.
         * @param rotation The quaternion representing the rotation.
         * @param outArray The array to store the result of the rotation.
         * @param outOffset The offset in the output array where the result will be stored.
         * @zh 使用四元数旋转三维向量。
         * @param sourceArray 源三维向量的数组。
         * @param sourceOffset 源三维向量的偏移。
         * @param rotation 四元数。
         * @param outArray 输出数组。
         * @param outOffset 输出数组的偏移。
         */
        static transformVector3ArrayByQuat(sourceArray: Float32Array, sourceOffset: number, rotation: Quaternion, outArray: Float32Array, outOffset: number): void;
        /**
         * @en Multiplies two matrices using array data.
         * @param leftArray The left-hand side matrix array.
         * @param leftOffset The offset in the left-hand side array.
         * @param rightArray The right-hand side matrix array.
         * @param rightOffset The offset in the right-hand side array.
         * @param outArray The output matrix array where the result will be stored.
         * @param outOffset The offset in the output array.
         * @zh 通过数组数据计算矩阵乘法。
         * @param leftArray 左矩阵数组。
         * @param leftOffset 左矩阵数组的偏移。
         * @param rightArray 右矩阵数组。
         * @param rightOffset 右矩阵数组的偏移。
         * @param outArray 输出矩阵数组。
         * @param outOffset 输出矩阵数组的偏移。
         */
        static mulMatrixByArray(leftArray: Float32Array, leftOffset: number, rightArray: Float32Array, rightOffset: number, outArray: Float32Array, outOffset: number): void;
        /**
         * @en Multiplies two matrices using array data, with the restriction that rightArray and outArray cannot be the same array reference.
         * @param leftArray The left-hand side matrix array.
         * @param leftOffset The offset in the left-hand side array.
         * @param rightArray The right-hand side matrix array.
         * @param rightOffset The offset in the right-hand side array.
         * @param outArray The output matrix array where the result will be stored.
         * @param outOffset The offset in the output array.
         * @zh 通过数组数据计算矩阵乘法，注意 rightArray 和 outArray 不能是同一个数组引用。
         * @param leftArray 左矩阵数组。
         * @param leftOffset 左矩阵数组的偏移。
         * @param rightArray 右矩阵数组。
         * @param rightOffset 右矩阵数组的偏移。
         * @param outArray 输出矩阵数组。
         * @param outOffset 输出矩阵数组的偏移。
         */
        static mulMatrixByArrayFast(leftArray: Float32Array, leftOffset: number, rightArray: Float32Array, rightOffset: number, outArray: Float32Array, outOffset: number): void;
        /**
         * @en Multiplies a matrix by an array and another matrix, with the restriction that rightArray and outArray cannot be the same array reference.
         * @param leftArray The left-hand side matrix array.
         * @param leftOffset The offset in the left-hand side array.
         * @param rightMatrix The right-hand side matrix.
         * @param outArray The output matrix array where the result will be stored.
         * @param outOffset The offset in the output array.
         * @zh 通过数组数据和一个矩阵计算矩阵乘法，注意 rightArray 和 outArray 不能是同一个数组引用。
         * @param leftArray 左矩阵数组。
         * @param leftOffset 左矩阵数组的偏移。
         * @param rightMatrix 右矩阵。
         * @param outArray 输出矩阵数组。
         * @param outOffset 输出矩阵数组的偏移。
         */
        static mulMatrixByArrayAndMatrixFast(leftArray: Float32Array, leftOffset: number, rightMatrix: Matrix4x4, outArray: Float32Array, outOffset: number): void;
        /**
         * @en Calculates the result matrix array by the given translation, rotation, and scale values.
         * @param tX X axis translation.
         * @param tY Y axis translation.
         * @param tZ Z axis translation.
         * @param rX X axis rotation.
         * @param rY Y axis rotation.
         * @param rZ Z axis rotation.
         * @param rW W component of the rotation quaternion.
         * @param sX X axis scale.
         * @param sY Y axis scale.
         * @param sZ Z axis scale.
         * @param outArray Output matrix array.
         * @param outOffset Output matrix array offset.
         * @zh 通过数平移、旋转、缩放值计算到结果矩阵数组。
         * @param tX X轴的平移量。
         * @param tY Y轴的平移量。
         * @param tZ Z轴的平移量。
         * @param rX 旋转四元数的X分量。
         * @param rY 旋转四元数的Y分量。
         * @param rZ 旋转四元数的Z分量。
         * @param rW 旋转四元数的实部（W分量）。
         * @param sX X轴的缩放因子。
         * @param sY Y轴的缩放因子。
         * @param sZ Z轴的缩放因子。
         * @param outArray 输出矩阵数组。
         * @param outOffset 输出矩阵数组的偏移。
         */
        static createAffineTransformationArray(tX: number, tY: number, tZ: number, rX: number, rY: number, rZ: number, rW: number, sX: number, sY: number, sZ: number, outArray: Float32Array, outOffset: number): void;
        /**
         * @en Transforms a 3D vector from one array to another using a transformation matrix.
         * @param source The source vector array.
         * @param sourceOffset The offset in the source array.
         * @param transform The transformation matrix.
         * @param result The resulting vector array.
         * @param resultOffset The offset in the resulting array.
         * @zh 使用变换矩阵将一个三维向量从一个数组转换到另一个数组。
         * @param source 源三维向量所在数组。
         * @param sourceOffset 源三维向量数组偏移。
         * @param transform  变换矩阵。
         * @param result 输出三维向量所在数组。
         * @param resultOffset 输出三维向量数组偏移。
         */
        static transformVector3ArrayToVector3ArrayCoordinate(source: Float32Array, sourceOffset: number, transform: Matrix4x4, result: Float32Array, resultOffset: number): void;
        /**
         * @en Transforms a 3D vector array from one array to another using a transformation matrix, and normalizes the resulting vector array.
         * @param source The source normal vector array.
         * @param sourceOffset The offset in the source array.
         * @param transform The transformation matrix.
         * @param result The resulting normal vector array.
         * @param resultOffset The offset in the resulting array.
         * @zh 通过矩阵转换一个三维向量数组到另外一个归一化的三维向量数组。
         * @param source 源三维向量法线所在数组。
         * @param sourceOffset 源三维向量法线数组偏移。
         * @param transform 变换矩阵。
         * @param result 输出三维向量法线所在数组。
         * @param resultOffset 输出三维向量法线数组偏移。
         */
        static transformVector3ArrayToVector3ArrayNormal(source: Float32Array, sourceOffset: number, transform: Matrix4x4, result: Float32Array, resultOffset: number): void;
        /**
         * @en Retrieves the version string from a URL.
         * @param url The URL to extract the version from.
         * @returns The version string or null if not found.
         * @zh 从URL中获取版本字符串。
         * @param url 要提取版本的URL。
         * @returns 版本字符串或null。
         */
        static getURLVerion(url: string): string;
        /**
         * @en Applies a rotation to a 3D vector using a quaternion.
         * @param source The original 3D vector.
         * @param rotation The quaternion array representing the rotation.
         * @param out The resulting rotated vector.
         * @zh 使用四元数对三维向量应用旋转。
         * @param source 原始三维向量。
         * @param rotation 旋转四元数数组。
         * @param out 结果旋转后的向量。
         */
        static transformQuat(source: Vector3, rotation: Float32Array, out: Vector3): void;
        /**
         * @en Modifies the weight of a quaternion.
         * @param f The original quaternion.
         * @param weight The weight to apply to the quaternion.
         * @param e The target data.
         * @zh 修改四元数的权重。
         * @param f 元数据
         * @param weight 要应用于四元数的权重。
         * @param e 目标数据。
         */
        static quaternionWeight(f: Quaternion, weight: number, e: Quaternion): void;
        static _getParentNodeByHierarchyPath(rootSprite: Node, path: number[]): Node;
        /**
         * @deprecated 请使用uint8ArrayToArrayBufferAsync函数代替
         * 将RenderTexture转换为Base64
         * @param rendertexture 渲染Buffer
         * @returns
         */
        static uint8ArrayToArrayBuffer(rendertexture: RenderTexture): string;
        /**
         * @en Converts a RenderTexture to a Base64 encoded string.
         * @param rendertexture The RenderTexture to convert.
         * @returns A promise that resolves to a Base64 string representing the RenderTexture.
         * @zh 将 RenderTexture 转换为 Base64 编码的字符串。
         * @param rendertexture 要转换的 RenderTexture。
         * @returns 一个 Promise，该 Promise 将解析为表示 RenderTexture 的 Base64 字符串。
         */
        static uint8ArrayToArrayBufferAsync(rendertexture: RenderTexture): Promise<String>;
    }
    /**
     * @en This class is used to manage XRCamera
     * @zh 此类用来管理XRCamera
     */
    class WebXRCameraManager {
        /**
         * reference Quaternin
         */
        private _referenceQuaternion;
        /**
         * reference Position
         */
        private _referencedPosition;
        /**
         * WebXR Session Manager
         */
        private _webXRSessionManager;
        /**
         * first Frame Flag
         */
        private _firstFrame;
        /**
         * WebXR RenderTexture
         */
        private _XRRenderTexture;
        /**
         * WebXRCamera Array
         */
        private _rigCameras;
        /**
         * Reference position
         */
        private _position;
        /**
         * @en The parent object that owns this camera manager.
         * @zh 拥有此摄像机管理器的父对象。
         */
        owner: any;
        /**
         * @en The position of the camera.
         * @zh 摄像机的位置。
         */
        get position(): Vector3;
        set position(newPosition: Vector3);
        /**
         * @en The rotation of the camera.
         * @zh 摄像机的旋转
         */
        get rotationQuaternion(): Quaternion;
        set rotationQuaternion(value: Quaternion);
        /**
         * @en The array of rig cameras.
         * @zh 绑定在此摄像机管理器上的摄像机数组。
         */
        get rigCameras(): WebXRCamera[];
        /**
         * @en Creates a new instance of the WebXRCameraManager class.
         * @param camera The parent object that owns this camera manager.
         * @param manager WebXR Session Manager.
         * @zh 创建 WebXRCameraManager 类的新实例。
         * @param camera 父对象，拥有此摄像机管理器。
         * @param manager WebXR管理器。
         */
        constructor(camera: any, manager?: WebXRSessionManager);
        /**
         * @en Updates the frame by the WebXR session, adjusting the camera's position, rotation, and viewport based on the XR session's viewer pose.
         * @zh 通过WebXR会话更新帧，根据XR会话的观察者姿势调整相机的位置、旋转和视口。
         */
        _updateFromXRSession(): void;
        /**
         * update number of WebXRCamera
         * @param viewCount
         */
        private _updateNumberOfRigCameras;
        /**
         * TODO:update of Reference Space
         */
        private _updateReferenceSpace;
        /**
         * @en Destroys and cleans up resources used by the WebXRCameraManager.
         * @zh 销毁 WebXRCameraManager 并清理使用的资源。
         */
        destroy(): void;
    }
    class WebXRCameraInfo {
        /**depth far */
        depthFar: number;
        /**depth near */
        depthNear: number;
        /**camera */
        camera: any;
    }
    /**
     * @en Used to manage WebXR
     * @zh 用来管理WebXR
     */
    class WebXRExperienceHelper {
        /**
         * @en The WebGL instance.
         * @zh WebGL 实例。
         */
        static glInstance: any;
        /**
         * @en The singleton instance of the XR session manager.
         * @zh XR 会话管理器的单例实例。
         */
        static xr_Manager: WebXRSessionManager;
        /**
         * @en Indicates whether WebXR is supported in the current environment.
         * @zh 表示当前环境是否支持 WebXR。
         */
        static supported: boolean;
        /**
         * @en Default options for the XRWebGLLayer.
         * @zh XRWebGLLayer 的默认选项。
         */
        static canvasOptions: {
            antialias: boolean;
            depth: boolean;
            stencil: boolean;
            alpha: boolean;
            multiview: boolean;
            framebufferScaleFactor: number;
        };
        /**
         * @en Checks if a specific XRSession mode is supported.
         * @param sessionMode The session mode to check, e.g., "inline", "immersive-vr", "immersive-ar".
         * @returns A promise that resolves to a boolean indicating whether the mode is supported.
         * @zh 检查是否支持特定的 XRSession 模式。
         * @param sessionMode 要检查的会话模式，例如："inline"、"immersive-vr"、"immersive-ar"。
         * @returns 一个 Promise，该 Promise 将解析为一个布尔值，表示是否支持。
         */
        static supportXR(sessionMode: string): Promise<boolean>;
        /**
         * @en Enters the specified XR session mode and sets up the reference space and WebGL layer.
         * @param sessionMode The session mode, e.g., "inline", "immersive-vr", "immersive-ar".
         * @param referenceSpaceType The reference space type, e.g., "viewer", "local", "local-floor", "unbounded".
         * @param cameraInfo The WebXR camera settings.
         * @returns A promise that resolves to the WebXRSessionManager.
         * @zh 进入指定的 XR 会话模式，并设置引用空间和 WebGL 层。
         * @param sessionMode 要进入的会话模式，例如："inline"、"immersive-vr"、"immersive-ar"。
         * @param referenceSpaceType 要使用的参考空间类型，例如："viewer"、"local"、"local-floor"、"unbounded"。
         * @param cameraInfo WebXR相机设置。
         * @returns 一个 Promise，该 Promise 将解析为 WebXRSessionManager。
         */
        static enterXRAsync(sessionMode: string, referenceSpaceType: string, cameraInfo: WebXRCameraInfo): Promise<WebXRSessionManager>;
        /**
         * @en Configures a WebXRCameraManager with the given camera and session manager.
         * @param camera The camera to configure.
         * @param manager The WebXR session manager.
         * @returns A new WebXRCameraManager instance.
         * @zh 使用给定的摄像机和会话管理器配置 WebXRCameraManager。
         * @param camera 要配置的摄像机。
         * @param manager WebXR 会话管理器。
         * @returns 一个新的 WebXRCameraManager 实例。
         */
        static setWebXRCamera(camera: Camera, manager: WebXRSessionManager): WebXRCameraManager;
        /**
         * @en Configures a WebXRInputManager with the given session and camera managers.
         * @param sessionManager The WebXR session manager.
         * @param cameraManager The WebXR camera manager.
         * @returns A new WebXRInputManager instance.
         * @zh 使用给定的会话和摄像机管理器配置 WebXRInputManager。
         * @param sessionManager WebXR 会话管理器。
         * @param cameraManager WebXR 摄像机管理器。
         * @returns 一个新的 WebXRInputManager 实例。
         */
        static setWebXRInput(sessionManager: WebXRSessionManager, cameraManager: WebXRCameraManager): WebXRInputManager;
    }
    /**
     * @en The class used to describe the gamepad axis
     * @zh 用于描述设备手柄上的摇杆轴
     */
    class AxiGamepad extends EventDispatcher {
        /**
         * @en Static event name for output axis events.
         * @zh 事件名称，用于输出轴事件。
         */
        static EVENT_OUTPUT: string;
        /**
         * @en The name of the axis device.
         * @zh 轴设备名字。
         */
        handness: string;
        /**
         * @en The number of axes.
         * @zh 轴数量。
         */
        axisLength: number;
        /**
         * axis Array
         */
        private axisData;
        /**
         * @en Cleans up and removes all listeners for this gamepad's axis events.
         * @zh 清理并移除此游戏手柄轴的所有事件监听器。
         */
        destroy(): void;
    }
    /**
     * @en The `ButtonGamepad` class is used to describe gamepad buttons.
     * @zh `ButtonGamepad` 类用来描述游戏手柄上的按钮。
     */
    class ButtonGamepad extends EventDispatcher {
        static EVENT_TOUCH_ENTER: string;
        static EVENT_TOUCH_STAY: string;
        static EVENT_TOUCH_OUT: string;
        static EVENT_PRESS_ENTER: string;
        static EVENT_PRESS_STAY: string;
        static EVENT_PRESS_OUT: string;
        static EVENT_PRESS_VALUE: string;
        /**
         * @en The handness of the gamepad.
         * @zh 游戏手柄的名称。
         */
        handness: string;
        /**
         * @en The index of the button on the gamepad.
         * @zh 游戏手柄上按钮的索引。
         */
        index: number;
        /**
         * front touch state
         */
        private lastTouch;
        private lastPress;
        private lastPressValue;
        /**
         * current touch state
         */
        private touch;
        private press;
        private pressValue;
        /**
         * @en Creates a new instance of the `ButtonGamepad` class.
         * @param handness The name of the gamepad.
         * @param index The index of the button on the gamepad.
         * @zh 创建 ButtonGamepad 类的新实例。
         * @param handness 设备名称
         * @param index button索引
         */
        constructor(handness: string, index: number);
        /**
         * @en Cleans up and removes all listeners for this gamepad's button events.
         * @zh 清理并移除此游戏手柄按钮的所有事件监听器。
         */
        destroy(): void;
    }
    /**
     * @en The `WebXRInput` class is used to describe input devices for WebXR.
     * @zh `WebXRInput` 类用来描述 WebXR 的输入设备。
     */
    class WebXRInput extends EventDispatcher {
        static HANDNESS_LEFT: string;
        static HANDNESS_RIGHT: string;
        static EVENT_FRAMEUPDATA_WEBXRINPUT: string;
        private static tempQua;
        /**
         * 预处理Button事件
         */
        private preButtonEventList;
        /**
         * 预处理axis事件
         */
        private preAxisEventList;
        /**
         * @en The last XR pose data.
         * @zh 上一次的 XR 姿态数据。
         */
        lastXRPose: any;
        /**
         * @en The handness of the device, "left" or "right".
         * @zh 设备名称，"left" 或 "right"。
         */
        handness: string;
        /**
         * @en The input ray representing the direction of the hand or controller.
         * @zh 表示手或控制器方向的输入射线。
         */
        ray: Ray;
        /**
         * @en The position of the hand or controller.
         * @zh 手或控制器的位置。
         */
        position: Vector3;
        /**
         * @en The rotation of the hand or controller.
         * @zh 手或控制器的旋转。
         */
        rotation: Quaternion;
        /**
         * @en The last position of the input ray.
         * @zh 输入射线的上一个位置。
         */
        _lastXRPose: any;
        /**
         * @en Information about the gamepad buttons.
         * @zh 游戏手柄按钮的信息。
         */
        gamepadButton: Array<ButtonGamepad>;
        /**
         * @en Information about the gamepad axes.
         * @zh 游戏手柄轴的信息。
         */
        gamepadAxis: AxiGamepad;
        /**
         * @ignore
         * @en Creates a new instance of the `WebXRInput` class.
         * @param handness  The handness of the device, "left" or "right".
         * @zh 创建 `WebXRInput` 类的新实例。
         * @param handness 设备名称，"left" 或 "right"。
         */
        constructor(handness: string);
        /**
         * handle gamepad Event
         */
        private _handleProcessGamepad;
        /**
         * @en Adds an event listener for a gamepad button.
         * @param index The index of the button.
         * @param type The type of event.
         * @param caller The execution scope of the event listener function.
         * @param listener The event listener function.
         * @zh 为游戏手柄按钮添加事件侦听器
         * @param index 按钮索引。
         * @param type 事件类型。
         * @param caller 事件侦听函数的执行域。
         * @param listener 事件侦听函数。
         */
        addButtonEvent(index: number, type: string, caller: any, listener: Function): void;
        /**
         * @en Adds an event listener for a gamepad axis.
         * @param index The index of the axis.
         * @param type The type of event.
         * @param caller The execution scope of the event listener function.
         * @param listener ener The event listener function.
         * @zh 为游戏手柄轴添加事件侦听器。
         * @param index 轴索引。
         * @param type 事件类型。
         * @param caller 事件侦听函数的执行域。
         * @param listener 事件侦听函数。
         */
        addAxisEvent(index: number, type: string, caller: any, listener: Function): void;
        /**
         * @en Removes an event listener for a gamepad axis.
         * @param index The index of the axis.
         * @param type The type of event.
         * @param caller The execution scope of the event listener function.
         * @param listener The event listener function.
         * @zh 移除游戏手柄轴的事件侦听器。
         * @param index 轴索引。
         * @param type 事件类型。
         * @param caller 事件侦听函数的执行域。
         * @param listener 事件侦听函数。
         */
        offAxisEvent(index: number, type: string, caller: any, listener: Function): void;
        /**
         * @en Removes an event listener for a gamepad button.
         * @param index The index of the button.
         * @param type The type of event.
         * @param caller The execution scope of the event listener function.
         * @param listener The event listener function.
         * @zh 移除游戏手柄按钮的事件侦听器
         * @param index 按钮索引。
         * @param type 事件类型。
         * @param caller 事件侦听函数的执行域。
         * @param listener 事件侦听函数。
         */
        offButtonEvent(index: number, type: string, caller: any, listener: Function): void;
        /**
         * @en Destroys and cleans up the WebXR input instance.
         * @zh 销毁并清理 WebXR 输入实例。
         */
        destroy(): void;
    }
    /**
     * @en The `WebXRInputManager` class is responsible for managing input devices in a WebXR environment.
     * - The path of the CDN from which the sample will fetch controller models:
     * - MeshSource https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.9/dist/profiles/
     * @zh `WebXRInputManager` 类用来在 WebXR 环境中管理输入设备。
     * - 样本将从此 CDN 路径获取控制器模型的路径：
     * - MeshSource <https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.9/dist/profiles/>
     */
    class WebXRInputManager {
        /**
         * Session Manager
         */
        private webXRSessionManager;
        /**
         * webXRCamera Manager
         */
        private webXRCameraManager;
        /**
         * array of XRInput
         */
        private controllers;
        /**
         * bind of XRInput Node Render
         */
        private controllerHandMesh;
        /**
         * bind of XRInput Ray Render
         */
        private controllerLineRender;
        /**
         * line Color
         */
        private lineColor;
        /**
         * Ray length
         */
        private rayLength;
        /**
         * @en Creates a new instance of the `WebXRInputManager` class.
         * @param webxrManager WebXR Session manager
         * @param webXRCamera WebXR Manager
         * @zh 创建 WebXRInputManager 类的新实例
         * @param webxrManager WebXR 会话管理器
         * @param webXRCamera WebXR 管理器
         */
        constructor(webxrManager: WebXRSessionManager, webXRCamera: WebXRCameraManager);
        /**
         * 更新输入挂点
         * @param xrInput
         */
        private _updataMeshRender;
        /**
         * WebXRInput帧循环
         * @param xrFrame
         */
        private _updateFromXRFrame;
        /**
         * @en Binds a rendering node to the input device.
         * @param meshSprite The rendering sprite to bind.
         * @param handness The handness of the device, "left" or "right".
         * @zh 将渲染节点绑定到输入设备。
         * @param meshSprite 渲染挂点。
         * @param handness 设备名称，"left" 或 "right"。
         */
        bindMeshNode(meshSprite: Sprite3D, handness: string): void;
        /**
         * @en Binds a ray to the input device for visual representation.
         * @param lineSprite The line sprite to bind as a ray.
         * @param handness The handness of the device, "left" or "right".
         * @zh 为输入设备绑定射线以进行可视化表示。
         * @param lineSprite 作为射线绑定的线条精灵。
         * @param handness 设备名称，"left" 或 "right"。
         */
        bindRayNode(lineSprite: PixelLineSprite3D, handness: string): void;
        /**
         * @en Retrieves the input device based on the specified handness.
         * @param handness The handness of the device, "left" or "right".
         * @returns The WebXRInput instance or null if handness is not valid.
         * @zh 根据指定的设备名称获得输入设备。
         * @param handness 设备名称，"left" 或 "right"。
         * @returns 返回 WebXRInput 实例，如果手部设备名称无效则返回 null。
         */
        getController(handness: string): WebXRInput;
        /**
         * @en Destroys and cleans up the WebXR input manager.
         * @zh 销毁并清理 WebXR 输入管理器。
         */
        destory(): void;
    }
    /**
     * @en The `WebXRRenderTexture` class is used to create a render texture for WebXR rendering.
     * @zh `WebXRRenderTexture` 类用来创建 WebXR 渲染的渲染纹理。
     */
    class WebXRRenderTexture extends RenderTexture {
        /**
         * @en The frame loop counter for the render texture.
         * @zh 渲染纹理的帧循环计数器。
         */
        frameLoop: number;
        /**
         * @en Creates a new instance of the `WebXRRenderTexture` class.
         * @zh 创建 WebXRRenderTexture 类的新实例
         */
        constructor();
        /**
         * @en The frame buffer for the render texture.
         * @zh 渲染纹理的帧缓冲。。
         */
        set frameBuffer(value: any);
        /**
         * No glframeBuffer create
         * @param width
         * @param height
         */
        protected _create(width: number, height: number): void;
    }
    /**
     * @en Manages an XRSession to work with the LayaAir engine.
     * @zh 管理 XRSession 用以与 LayaAir 引擎协同工作。
     */
    class WebXRSessionManager extends EventDispatcher {
        static EVENT_MANAGER_END: string;
        static EVENT_FRAME_LOOP: string;
        /**
         * @en The underlying XR session being managed.
         * @zh 被管理的底层 XR 会话。
         */
        session: any;
        /**
         * @en The XRReferenceSpace used for setting up the viewer's reference space.
         * @zh 用于设置观察者参考空间的 XRReferenceSpace。
         */
        viewerReferenceSpace: any;
        /**
         * @en The base reference space for the XR session.
         * @zh XR 会话的基参考空间。
         */
        baseReferenceSpace: any;
        /**
         * @en The current XR frame in the session.
         * @zh 会话中的当前 XR 帧。
         */
        currentFrame: any;
        /**
         * @en The WebXR timestamp updated every frame.
         * @zh 每帧更新的 WebXR 时间戳。
         */
        currentTimestamp: number;
        /**
         * @en The default height compensation used when initialization fails.
         * @zh 初始化失败后使用的高度补偿默认值。
         */
        defaultHeightCompensation: number;
        /**
         * XRReferenceSpace
         */
        private _referenceSpace;
        /** "inline" | "immersive-vr" | "immersive-ar"*/
        private _sessionMode;
        /** session enable state */
        private _sessionEnded;
        /**WebXR Base Layer */
        private _baseLayer;
        /**web XRSystem */
        private _xrNavigator;
        /**
         * @en The current reference space used in this session.
         * @zh 当前会话中使用参考空间。
         */
        get referenceSpace(): any;
        set referenceSpace(newReferenceSpace: any);
        /**
         * @en The mode for the managed XR session.
         * @zh 管理 XR 会话的模式。
         */
        get sessionMode(): any;
        /**
         * @en Stops the XR session and restores the render loop.
         * @zh 停止 XR 会话并恢复渲染循环。
         */
        exitXR(): void;
        /**
         * @en Initializes the XR layer for the session.
         * @param xrSession The XR session to initialize.
         * @param gl The WebGL rendering context.
         * @returns A promise that resolves to true if the XR layer is successfully initialized.
         * @zh 为会话初始化 XR 层。
         * @param xrSession 要初始化的 XR 会话。
         * @param gl WebGL 渲染上下文。
         * @returns 一个承诺，该承诺在 XR 层成功初始化时解决为 true。。
         */
        initializeXRGL(xrSession: any, gl: WebGLRenderingContext): Promise<boolean>;
        /**
         * @en Checks if the browser supports WebXR.
         * @returns A promise that resolves if WebXR is supported.
         * @zh 检查浏览器是否支持 WebXR。
         * @returns 如果支持 WebXR 则返回一个解决的承诺。
         */
        initializeAsync(): Promise<void>;
        /**
         * @en Checks if the session mode is supported by the browser.
         * @param sessionMode The session mode to check, "inline", "immersive-vr", or "immersive-ar".
         * @returns A promise that resolves to true if the session mode is supported, and false if not.
         * @zh 检查会话模式是否得到浏览器支持。
         * @param sessionMode 要检查的会话模式，可以是 "inline"、"immersive-vr" 或 "immersive-ar"。
         * @returns 如果会话模式得到支持则返回一个解决为 true 的承诺，如果不支持则为 false。
         */
        isSessionSupportedAsync(sessionMode: string): Promise<boolean>;
        /**
         * @en Initializes the XR session with the specified mode and initialization info.
         * @param xrSessionMode The mode for the XR session.
         * @param xrSessionInit The initialization info for the XR session.
         * @returns A promise that resolves with the XR session if successful.
         * @zh 使用指定的模式和初始化信息初始化 XR 会话。
         * @param xrSessionMode XR 会话的模式。
         * @param xrSessionInit XR 会话的初始化信息。
         * @returns 如果成功，返回一个解决为 XR 会话的承诺。
         */
        initializeSessionAsync(xrSessionMode?: string, xrSessionInit?: {}): Promise<any>;
        /**
         * @en Resets the reference space to the one used at the start of the session.
         * @zh 将参考空间重置为会话开始时使用的空间。
         */
        resetReferenceSpace(): void;
        /**
         * @en Starts the rendering loop for the XR session and binds it to the session's animation frame request.
         * @zh 启动 XR 会话的渲染循环，并将其绑定到会话的动画帧请求。
         */
        runXRRenderLoop(): void;
        /**
         * @en Ends the rendering loop for the XR session.
         * @zh 结束 XR 会话的渲染循环。
         */
        endXRRenderLoop(): void;
        /**
         * Update
         * @param xrFrame
         */
        private _updateByXrFrame;
        /**
         * @en Sets the reference space on the XR session.
         * @param referenceSpaceType The type of space to set, defaults to "local-floor".
         * @returns A promise that resolves once the reference space has been set.
         * @zh 在 XR 会话上设置参考空间。
         * @param referenceSpaceType 要设置的参考空间类型，默认为 "local-floor"。
         * @returns 一个promise，该promise在参考空间已被设置时解决。
         */
        setReferenceSpaceTypeAsync(referenceSpaceType?: string): Promise<any>;
        /**
         * @en Updates the render state of the WebXR session.
         * @param state The new render state to be applied.
         * @returns A promise that resolves once the render state has been updated.
         * @zh 更新 WebXR 会话的渲染状态。
         * @param state 要应用的新渲染状态。
         * @returns 一个promise，该promise在渲染状态已被更新时解决。
         */
        updateRenderStateAsync(state: any): any;
        /**
         * @en The current frame rate reported by the device.
         * @zh 设备报告的当前帧率。
         */
        get currentFrameRate(): number | undefined;
        /**
         * @en A list of supported frame rates, available only while in a session.
         * @zh 支持的帧率列表，此属性仅在会话中可用。
         */
        get supportedFrameRates(): Float32Array | undefined;
        /**
         * @en Sets the frame rate for the WebXR session.
         * @param rate The new frame rate to be set, must be within the supportedFrameRates range.
         * @returns A promise that resolves once the frame rate has been set.
         * @zh 为 WebXR 会话设置帧率。
         * @param rate 要设置的新帧率，必须在支持的帧率范围内。
         * @returns 一个承诺，该承诺在帧率已被设置时解决。
         */
        updateTargetFrameRate(rate: number): Promise<void>;
        /**
         * @en Cleans up and destroys the WebXR session manager.
         * @zh 清理并销毁 WebXR 会话管理器。
         */
        destroy(): void;
    }
    /**
     * @en A class that encapsulates Geolocation-related functionalities can check if the browser supports the Geolocation API by using `Geolocation.supported`.
     * @zh 封装了地理位置相关功能的类，可以通过`Geolocation.supported`查看浏览器是否支持地理位置API。
     */
    class Geolocation {
        private static navigator;
        private static position;
        /**
         * @en Indicates failure to get geographical information due to denied permission.
         * @zh 表示由于权限被拒绝造成的地理信息获取失败。
         */
        static PERMISSION_DENIED: number;
        /**
         * @en Indicates failure to get geographical information due to an internal error from the location source.
         * @zh 表示由于内部位置源返回了内部错误导致地理信息获取失败。
         */
        static POSITION_UNAVAILABLE: number;
        /**
         * @en Whether the runtime environment supports the Geolocation API.
         * @zh 信息获取所用时长超出`timeout`所设置时长。
         */
        static TIMEOUT: number;
        /**
         * @en Whether the runtime environment supports the Geolocation API.
         * @zh 运行环境是否支持地理位置API。
         */
        static supported: boolean;
        /**
         * @en If `enableHighAccuracy` set to true, and if the device can provide a more accurate location, it will get the best possible results.
         * Note that this may lead to slower response times or increased power consumption (such as when using GPS).
         * On the other hand, if set to false, it will get faster response and less power consumption.
         * The default value is false.
         * @zh 如果`enableHighAccuracy`设置为 true，并且设备能够提供一个更精确的位置，则会获取最佳可能的结果。
         * 请注意，这可能会导致响应时间变慢或电量消耗增加（例如使用 GPS）。
         * 另一方面，如果设置为 false，将会得到更快的响应和更少的电量消耗。
         * 默认值为 false。
         */
        static enableHighAccuracy: boolean;
        /**
         * @en Represents the maximum duration allowed for the device to obtain the location. The default is Infinity, meaning getCurentPosition() will not return until the location is available.
         * @zh 表示允许设备获取位置的最长时间。默认为 Infinity，意味着 `getCurentPosition()` 直到位置可用时才会返回信息。
         */
        static timeout: number;
        /**
         * @en Represents the maximum age of the cached location information that can be returned.
         * If set to 0, it means the device does not use cached locations and attempts to obtain a real-time location.
         * If set to Infinity, the device must return a cached location regardless of its age.
         * @zh 表示可被返回的缓存位置信息的最大时限。
         * 如果设置为 0，意味着设备不使用缓存位置，并且尝试获取实时位置。
         * 如果设置为 Infinity，设备必须返回缓存位置而无论其时限。
         */
        static maximumAge: number;
        constructor();
        /**
         * @en Gets the device's current position.
         * @param onSuccess Callback handler with a unique `Position` parameter.
         * @param onError Optional. Callback handler with an error message. Error code is one of Geolocation.PERMISSION_DENIED, Geolocation.POSITION_UNAVAILABLE, and Geolocation.TIMEOUT.
         * @zh 获取设备当前位置。
         * @param onSuccess 带有唯一 `Position` 参数的回调处理器。
         * @param onError 可选的。带有错误信息的回调处理器。错误代码为 Geolocation.PERMISSION_DENIED、Geolocation.POSITION_UNAVAILABLE 和 Geolocation.TIMEOUT 之一。
         */
        static getCurrentPosition(onSuccess: Handler, onError?: Handler): void;
        /**
         * @en Watches the device's current position. The callback handler is executed when the device's position changes.
         * @param onSuccess Callback handler with a unique `Position` parameter.
         * @param onError Optional. Callback handler with an error message. Error code is one of Geolocation.PERMISSION_DENIED, Geolocation.POSITION_UNAVAILABLE, and Geolocation.TIMEOUT.
         * @zh 监视设备当前位置。回调处理器在设备位置改变时被执行。
         * @param onSuccess 带有唯一 `Position` 参数的回调处理器。
         * @param onError 可选的。带有错误信息的回调处理器。错误代码为 Geolocation.PERMISSION_DENIED、Geolocation.POSITION_UNAVAILABLE 和 Geolocation.TIMEOUT 之一。
         */
        static watchPosition(onSuccess: Handler, onError: Handler): number;
        /**
         * @en Removes the specified handler installed by `watchPosition`.
         * @param id The ID of the watch position handler to clear.
         * @zh 移除 `watchPosition` 安装的指定处理器。
         * @param id 要清除的监视位置处理器的 ID。
         */
        static clearWatch(id: number): void;
    }
    /**
     * @en Represents geolocation information for a device.
     * @zh 表示设备的地理位置信息。
     */
    class GeolocationInfo {
        private pos;
        private coords;
        /**
         * @en Sets the device's latitude and longitude.
         * @param pos The position object containing latitude and longitude data.
         * @zh 设置设备的经纬度。
         * @param pos 包含纬度和经度数据的位置对象。
         */
        setPosition(pos: any): void;
        /**
         * @en The latitude of the device's current geographical coordinates.
         * @zh 设备当前地理坐标的纬度。
         */
        get latitude(): number;
        /**
         * @en The longitude of the device's current geographical coordinates.
         * @zh 设备当前地理坐标的经度。
         */
        get longitude(): number;
        /**
         * @en The altitude of the device's current geographical coordinates.
         * @zh 设备当前地理坐标的高度。
         */
        get altitude(): number;
        /**
         * @en The accuracy of the device's current geographical coordinates.
         * @zh 设备当前地理坐标的精度。
         */
        get accuracy(): number;
        /**
         * @en The altitude accuracy of the device's current geographical coordinates.
         * @zh 设备当前地理坐标的高度精度。
         */
        get altitudeAccuracy(): number;
        /**
         * @en The heading direction of the device's current travel.
         * @zh 设备当前行进方向。
         */
        get heading(): number;
        /**
         * @en The current speed of the device.
         * @zh 设备当前的速度。
         */
        get speed(): number;
        /**
         * @en The timestamp when the device obtained its current position.
         * @zh 设备得到当前位置的时间。
         */
        get timestamp(): number;
    }
    /**
     * @en The Media class is used for capturing camera and microphone input. You can capture either one or both simultaneously. Before calling getCamera, you can use supported() to check if the current browser supports it.
     * NOTE:
     * Currently, Media only supports Android on mobile platforms, not iOS. It can only be fully used in FireFox; testing in Chrome does not capture video.
     * @zh Media 类用于捕捉摄像头和麦克风。可以单独捕捉任一设备，或者同时捕捉两者。在使用之前，可以使用 `Media.supported()` 方法检查当前浏览器是否支持。
     * NOTE:
     * 目前 Media 仅在移动平台上支持 Android，不支持 iOS。只能在 FireFox 中完整使用，在 Chrome 中测试时无法捕捉视频。
     */
    class Media {
        constructor();
        /**
         * @en Check browser compatibility
         * @zh 检查浏览器兼容性。
         */
        static supported(): boolean;
        /**
         * @en Access the user's media devices (capture camera and microphone).
         * @param options A simple set of options like { audio: true, video: true } to indicate capturing both. For more details, see <i>https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia</i>.
         * @param onSuccess The success handler which is called with a single argument: the Blob URL of the media, which can be used with the Video element.
         * @param onError The error handler which is called with a single argument: the Error object.
         * @zh 获取用户的媒体设备（捕捉摄像头和麦克风）。
         * @param options 简单的可选项，如 { audio: true, video: true } 表示同时捕捉两者。更详细信息请查看 <i>https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia</i>。
         * @param onSuccess 获取成功的处理器，唯一参数返回媒体的 Blob 地址，可以将其传给 Video 。
         * @param onError 获取失败的处理器，唯一参数是 Error 对象。
         */
        static getMedia(options: any, onSuccess: Handler, onError: Handler): void;
    }
    /**
     * @en Acceleration info, The unit of acceleration x/y/z is m/s ².
     * If the hardware (gyroscope) does not support it, the values for alpha, beta, and gamma will be null.
     * @zh 加速计信息，重力加速度x/y/z的单位均为m/s²。
     * 如果硬件（陀螺仪）不支持，则 alpha、beta 和 gamma 的值将为 null。
     */
    class AccelerationInfo {
        /**
         * @en The acceleration value along the x-axis.
         * @zh x 轴上的加速度值。
         */
        x: number;
        /**
         * @en The acceleration value along the y-axis.
         * @zh y 轴上的加速度值。
         */
        y: number;
        /**
         * @en The acceleration value along the z-axis.
         * @zh z 轴上的加速度值。
         */
        z: number;
        constructor();
    }
    /**
     * @en Use Accelerator.instance to get the unique Accelerator reference. Do not call the constructor directly.
     * The callback handler of listen() accepts four parameters:
     * - acceleration: The acceleration given to the device without gravity.
     * - accelerationIncludingGravity: The total acceleration (including gravity).
     * - rotationRate: The rate of rotation.
     * - interval: The time interval for the acceleration data获取 (in milliseconds).
     * NOTE
     * For example, while the alpha in the rotationRate is documented as the z-axis rotation angle in both Apple and Mozilla documentation, actual testing shows it to be the x-axis rotation angle. To make the values represented by each property consistent with the documentation, the actual values have been swapped with other properties.
     * The mappings are as follows:
     * - alpha uses the gamma value.
     * - beta uses the alpha value.
     * - gamma uses the beta value.
     * It is currently unclear which is correct, and this serves as a note.
     * @zh 通过 Accelerator.instance 获取唯一的 Accelerator 引用，不要直接调用构造函数。
     * listen() 的回调处理器接受四个参数：
     * - acceleration: 设备的加速度（不包含重力）。
     * - accelerationIncludingGravity: 总加速度（包含重力）。
     * - rotationRate: 自转速率。
     * - interval: 获取加速度数据的时间间隔（毫秒）。
     * 注意：
     * 例如，rotationRate 中的 alpha 在 Apple 和 Mozilla 文档中都是 z 轴旋转角度，但实测是 x 轴旋转角度。为了使各属性表示的值与文档所述相同，实际值与其他属性进行了对调。
     * 具体对应如下：
     * - alpha 使用 gamma 值。
     * - beta 使用 alpha 值。
     * - gamma 使用 beta 值。
     * 目前孰是孰非尚未可知，以此为注。
     */
    class Accelerator extends EventDispatcher {
        /**
         * Accelerator的唯一引用。
         */
        private static _instance;
        /**
         * @en The singleton instance of Accelerator.
         * @zh Accelerator 的单例实例。
         */
        static get instance(): Accelerator;
        private static acceleration;
        private static accelerationIncludingGravity;
        private static rotationRate;
        constructor();
        protected onStartListeningToType(type: string): this;
        private onDeviceOrientationChange;
        private static transformedAcceleration;
        /**
         * @en Converts the acceleration values to visually correct acceleration values. This method depends on `Browser.window.orientation` and may not work on some low-end devices.
         * @param acceleration The original acceleration information.
         * @returns The transformed acceleration information.
         * @zh 将加速度值转换为视觉上正确的加速度值。此方法依赖于 `Browser.window.orientation`，在部分低端机可能无效。
         * @param acceleration 原始的加速度信息。
         * @returns 转换后的加速度信息。
         */
        static getTransformedAcceleration(acceleration: AccelerationInfo): AccelerationInfo;
    }
    /**
     * @en Use Gyroscope.instance to obtain the unique Gyroscope reference. Do not call the constructor directly.
     * The callback handler of listen() accepts two parameters:
     * - onOrientationChange: A function with the signature <code>function onOrientationChange(absolute: Boolean, info: RotationInfo): void</code>.
     * - absolute: Indicates whether the device can provide absolute orientation data (toward the Earth coordinate system) or an arbitrary coordinate system determined by the device. For more information about coordinate systems, see [Orientation and motion data explained](https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Orientation_and_motion_data_explained).
     * - info: A RotationInfo type parameter that stores the device's rotation values.
     * For browser compatibility, refer to: (http://caniuse.com/#search=deviceorientation).
     * @zh 通过 Gyroscope.instance 获取唯一的 Gyroscope 引用，不要直接调用构造函数。
     * listen() 的回调处理器接受两个参数：
     * - function onOrientationChange: 一个函数，签名为 function onOrientationChange(absolute: Boolean, info: RotationInfo): void。
     * - absolute: 指明设备是否能够提供绝对方位数据（指向地球坐标系），或者由设备决定的任意坐标系。关于坐标系更多信息，请参阅 [方位和运动数据解释](https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Orientation_and_motion_data_explained)。
     * - info: RotationInfo 类型的参数，保存设备的旋转值。
     * 浏览器兼容性信息，请参阅：(http://caniuse.com/#search=deviceorientation)。
     */
    class Gyroscope extends EventDispatcher {
        private static info;
        /**
         * Gyroscope的唯一引用。
         */
        private static _instance;
        /**
         * @en Gets the singleton instance of Gyroscope.
         * @zh 获取 Gyroscope 的单例实例。
         */
        static get instance(): Gyroscope;
        /**
         * @en Constructor method of gyroscope.
         * @param singleton An internal parameter used to enforce the singleton pattern.
         * @zh 陀螺仪的构造方法
         * @param singleton 一个内部参数，用于强制实现单例模式。
         */
        constructor(singleton: number);
        protected onStartListeningToType(type: string): this;
        private onDeviceOrientationChange;
    }
    /**
     * @en A class that saves rotation information. Do not modify the properties of this category.
     * @zh 保存旋转信息的类。请勿修改本类的属性。
     * @author Survivor
     */
    class RotationInfo {
        /**
         * @en Indicates whether the device can provide absolute orientation data (toward the Earth coordinate system) or an arbitrary coordinate system determined by the device.
         * For more information about coordinate systems, see (https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Orientation_and_motion_data_explained).
         * Note that on iOS, this value is always false. Even so, you can still obtain the correct value from `alpha`.
         * @zh 指示设备是否可以提供绝对方位数据（指向地球坐标系），或者设备决定的任意坐标系。
         * 关于坐标系的更多信息，请参阅 (https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Orientation_and_motion_data_explained)。
         * 需要注意的是，在 iOS 环境下，该值始终为 false。即使如此，你依旧可以从 `alpha` 中取得正确的值。
         */
        absolute: boolean;
        /**
         * @en The angle of rotation around the Z-axis, ranging from 0 to 360.
         * If `absolute` is true or on iOS, the `alpha` value represents the angle from north to the current direction of the device.
         * @zh Z轴旋转角度，其值范围从0至360。
         * 若 `absolute` 为 true 或在 iOS 中，`alpha` 值是从北方到当前设备方向的角度值。
         */
        alpha: number;
        /**
         * @en The angle of rotation around the X-axis, ranging from -180 to 180. Represents the front-to-back motion of the device.
         * @zh X轴旋转角度，其值范围从-180至180。代表设备从前至后的运动。
         */
        beta: number;
        /**
         * @en The angle of rotation around the Y-axis, ranging from -90 to 90. Represents the left-to-right motion of the device.
         * @zh Y轴旋转角度，其值范围从-90至90。代表设备从左至右的运动。
         */
        gamma: number;
        /**
         * @en The accuracy of the compass data in degrees. Available only on iOS.
         * @zh 罗盘数据的精确度（角度）。仅 iOS 可用。
         */
        compassAccuracy: number;
        constructor();
    }
    /**
     * @en Shake is usually achieved through the built-in accelerometer and gyroscope sensors in a mobile phone, and it only works on devices that support this operation.
     * @zh 摇动通常是通过手机内置的加速度计和陀螺仪传感器来实现，只能在支持此操作的设备环境上有效。 *
     */
    class Shake extends EventDispatcher {
        private threshold;
        private shakeInterval;
        private lastX;
        private lastY;
        private lastZ;
        private lastMillSecond;
        constructor();
        private static _instance;
        /**
         * @en The singleton instance of Shake.
         * @zh  Shake 的单例实例。
         */
        static get instance(): Shake;
        /**
         * @en Starts responding to device shaking.
         * The response is based on the threshold of instantaneous velocity and the interval between shakes.
         * @param threshold The threshold for the instantaneous velocity for a shake response, which is approximately between 5 to 10 for a mild shake.
         * @param interval The interval time for responding to device shakes.
         * @zh 开始响应设备摇晃。
         * @param threshold 响应瞬时速度的阈值，轻度摇晃的值约在 5 到 10 之间。
         * @param interval 设备摇晃的响应间隔时间。
         */
        start(threshold: number, interval: number): void;
        /**
         * @en Stops responding to device shaking.
         * @zh 停止响应设备摇晃。
         */
        stop(): void;
        private onShake;
        /**
         * @en Determines whether the device is shaken based on the acceleration differences in three directions.
         *       It checks if at least two of the acceleration differences exceed the set threshold.
         * @param deltaX The acceleration difference in the X direction.
         * @param deltaY The acceleration difference in the Y direction.
         * @param deltaZ The acceleration difference in the Z direction.
         * @returns Returns true if at least two of the acceleration differences exceed the threshold; otherwise, returns false.
         * @zh 根据三个方向的加速度差值判断设备是否发生摇晃。
         *       检查三个方向的加速度差值中是否至少有两个超过了设定的阈值。
         * @param deltaX X 方向的加速度差值。
         * @param deltaY Y 方向的加速度差值。
         * @param deltaZ Z 方向的加速度差值。
         * @returns 如果至少有两个方向的加速度差值超过阈值，则返回 true；否则返回 false。
         */
        private isShaked;
    }
    /**
     * @en The Animation class is a Graphics-based animation class. It implements interfaces for creating, playing, and controlling animations based on Graphics.
     * The animation template cache pool stores key-value pairs, where the key can be customized or read from a specified configuration file, and the value is the corresponding animation template, which is an array of Graphics objects. Each Graphics object corresponds to a frame image, and the essence of animation playback is switching Graphics objects at regular intervals.
     * This class uses an animation template cache pool, which trades some memory overhead for CPU savings. When the same animation template is used multiple times, compared to creating a new animation template each time, using the animation template cache pool only requires creation once, caching it for multiple reuses, thus saving the overhead of creating animation templates.
     * Use the set source, loadImages(...), loadAtlas(...), loadAnimation(...) methods to create animation templates. Use play(...) to play the specified animation.
     * @zh Animation 是基于 Graphics 的动画类。实现了基于 Graphics 的动画创建、播放、控制接口。
     * 本类使用了动画模版缓存池，它以一定的内存开销来节省CPU开销，当相同的动画模版被多次使用时，相比于每次都创建新的动画模版，使用动画模版缓存池，只需创建一次，缓存之后多次复用，从而节省了动画模版创建的开销。
     * 动画模版缓存池，以key-value键值对存储，key可以自定义，也可以从指定的配置文件中读取，value为对应的动画模版，是一个Graphics对象数组，每个Graphics对象对应一个帧图像，动画的播放实质就是定时切换Graphics对象。
     * 使用set source、loadImages(...)、loadAtlas(...)、loadAnimation(...)方法可以创建动画模版。使用play(...)可以播放指定动画。
     */
    class Animation extends AnimationBase {
        /**
         * @en The animation template cache pool, stored as key-value pairs. The key can be customized or read from a specified configuration file, and the value is the corresponding animation template, which is an array of Graphics objects. Each Graphics object corresponds to a frame image, and the essence of animation playback is switching Graphics objects at regular intervals.
         * Use loadImages(...), loadAtlas(...), loadAnimation(...), set source methods to create animation templates. Use play(...) to play the specified animation.
         * @zh 动画模版缓存池，以key-value键值对存储，key可以自定义，也可以从指定的配置文件中读取，value为对应的动画模版，是一个Graphics对象数组，每个Graphics对象对应一个帧图像，动画的播放实质就是定时切换Graphics对象。
         * 使用loadImages(...)、loadAtlas(...)、loadAnimation(...)、set source方法可以创建动画模版。使用play(...)可以播放指定动画。
         */
        static framesMap: any;
        protected _frames: any[];
        private _source;
        private _autoPlay;
        /**
         * @en The currently used atlas resources.
         * @zh 当前正在使用的图集资源
         */
        private _atlasCatch;
        /**
         * @en Constructor method of Animation.
         * @zh 动画类的构造方法
         */
        constructor();
        /**
         * @en Destroys the object.
         * @param destroyChild Whether to destroy child nodes
         * @zh 销毁对象。
         * @param destroyChild 是否销毁子节点
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @en Starts playing the animation. It will search for an animation template with the key value "name" in the animation template cache pool. If it exists, it will initialize the current sequence frame with this animation template. If it doesn't exist, it will use the current sequence frame.
         * The play(...) method is designed to be called at any time after creating an instance. After calling, it will be in a playing state. When the corresponding resources are loaded, the animation frame filling method (set frames) is called, or the instance is displayed on the stage, it will determine whether it is in a playing state. If so, it will start playing.
         * Combined with the wrapMode property, you can set the animation playback order type.
         * @param start (Optional) Specifies the index (int) or frame label (String) where the animation playback starts. Frame labels can be added and removed using addLabel(...) and removeLabel(...).
         * @param loop (Optional) Whether to loop playback.
         * @param name (Optional) The key of the animation template in the animation template cache pool, which can also be considered as the animation name. If name is empty, it will play the current animation sequence frame; if it is not empty, it will look for an animation template with the key value "name" in the animation template cache pool. If it exists, it will initialize the current sequence frame with this animation template and play it. If it doesn't exist, it will still play the current animation sequence frame. If there is no frame data for the current animation, it will not play, but the instance will still be in a playing state.
         * @zh 开始播放动画。会在动画模版缓存池中查找key值为name的动画模版，存在则用此动画模版初始化当前序列帧， 如果不存在，则使用当前序列帧。
         * play(...)方法被设计为在创建实例后的任何时候都可以被调用，调用后就处于播放状态，当相应的资源加载完毕、调用动画帧填充方法(set frames)或者将实例显示在舞台上时，会判断是否处于播放状态，如果是，则开始播放。
         * 配合wrapMode属性，可设置动画播放顺序类型。
         * @param start （可选）指定动画播放开始的索引(int)或帧标签(String)。帧标签可以通过addLabel(...)和removeLabel(...)进行添加和删除。
         * @param loop （可选）是否循环播放。
         * @param name （可选）动画模板在动画模版缓存池中的key，也可认为是动画名称。如果name为空，则播放当前动画序列帧；如果不为空，则在动画模版缓存池中寻找key值为name的动画模版，如果存在则用此动画模版初始化当前序列帧并播放，如果不存在，则仍然播放当前动画序列帧；如果没有当前动画的帧数据，则不播放，但该实例仍然处于播放状态。
         */
        play(start?: any, loop?: boolean, name?: string): void;
        protected _setFramesFromCache(name: string, showWarn?: boolean): boolean;
        private _copyLabels;
        protected _frameLoop(): void;
        protected _displayToIndex(value: number): void;
        /**
         * @en The current animation frame image array. In this class, each frame image is a Graphics object, and animation playback is essentially the process of switching Graphics objects at regular intervals.
         * @zh 当前动画的帧图像数组。本类中，每个帧图像是一个Graphics对象，而动画播放就是定时切换Graphics对象的过程。
         */
        get frames(): any[];
        set frames(value: any[]);
        /**
         * @en Animation data source.For example: Atlas: "xx/a1.atlas"; Image collection: "a1.png,a2.png,a3.png"; LayaAir IDE animation: "xx/a1.ani".
         * Types are as follows:
         * 1. LayaAir IDE animation file path: Using this type requires preloading the required atlas resources, otherwise it will fail to create. If you don't want to preload or need a callback when creation is complete, please use the loadAnimation(...) method.
         * 2. Atlas path: Animation templates created using this type will not be cached in the animation template cache pool. If you need caching or a callback when creation is complete, please use the loadAtlas(...) method.
         * 3. Image path collection: Animation templates created using this type will not be cached in the animation template cache pool. If you need caching, please use the loadImages(...) method.
         * @zh 动画数据源。例如：图集："xx/a1.atlas"; 图片集合："a1.png,a2.png,a3.png"; LayaAir IDE动画："xx/a1.ani"。
         * 类型如下：
         * 1. LayaAir IDE动画文件路径：使用此类型需要预加载所需的图集资源，否则会创建失败，如果不想预加载或者需要创建完毕的回调，请使用loadAnimation(...)方法；
         * 2. 图集路径：使用此类型创建的动画模版不会被缓存到动画模版缓存池中，如果需要缓存或者创建完毕的回调，请使用loadAtlas(...)方法；
         * 3. 图片路径集合：使用此类型创建的动画模版不会被缓存到动画模版缓存池中，如果需要缓存，请使用loadImages(...)方法。
         */
        get source(): string;
        set source(value: string);
        /**
         * @en Whether to auto-play, default is false. If set to true, the animation will automatically play after being created and added to the stage.
         * @zh 是否自动播放，默认为false。如果设置为true，则动画被创建并添加到舞台后自动播放。
         */
        set autoPlay(value: boolean);
        get autoPlay(): boolean;
        /**
         * @en Stops animation playback and clears object properties. It can then be stored in the object pool for easy object reuse.
         * @returns AnimationBase
         * @zh 停止动画播放，并清理对象属性。之后可存入对象池，方便对象复用。
         * @returns AnimationBase
         */
        clear(): AnimationBase;
        /**
         * @en Initializes the current animation sequence frame based on the specified animation template. The process of selecting an animation template is as follows: 1. The animation template with the key cacheName in the animation template cache pool; 2. If it doesn't exist, load the specified image collection and create an animation template. Note: Only when a non-empty cacheName is specified can the created animation template be cached in the animation template cache pool with this as the key, otherwise no caching is performed.
         * The animation template cache pool trades a certain memory overhead for CPU savings. When the same animation template is used multiple times, compared to creating a new animation template each time, using the animation template cache pool only needs to be created once, cached, and reused multiple times, thus saving the overhead of creating animation templates.
         * Because the return value is the Animation object itself, you can use the following syntax: loadImages(...).loadImages(...).play(...);
         * @param urls Image path collection. When creating an animation template, this will be used as the data source. The parameter is in the form: [url1,url2,url3,...].
         * @param cacheName (Optional) The key of the animation template in the animation template cache pool. If this parameter is not empty, it means using the animation template cache pool. If an animation template with the key cacheName exists in the animation template cache pool, this template is used. Otherwise, a new animation template is created. If cacheName is not empty, it is cached in the animation template cache pool with cacheName as the key. If cacheName is empty, no caching is performed.
         * @returns Returns the Animation object itself.
         * @zh 根据指定的动画模版初始化当前动画序列帧。选择动画模版的过程如下：1. 动画模版缓存池中key为cacheName的动画模版；2. 如果不存在，则加载指定的图片集合并创建动画模版。注意：只有指定不为空的cacheName，才能将创建好的动画模版以此为key缓存到动画模版缓存池，否则不进行缓存。
         * 动画模版缓存池是以一定的内存开销来节省CPU开销，当相同的动画模版被多次使用时，相比于每次都创建新的动画模版，使用动画模版缓存池，只需创建一次，缓存之后多次复用，从而节省了动画模版创建的开销。
         * 因为返回值为Animation对象本身，所以可以使用如下语法：loadImages(...).loadImages(...).play(...);。
         * @param urls 图片路径集合。创建动画模版时，将以此为数据源。参数形式为：[url1,url2,url3,...]。
         * @param cacheName （可选）动画模板在动画模版缓存池中的key。如果此参数不为空，表示使用动画模版缓存池。如果动画模版缓存池中存在key为cacheName的动画模版，则使用此模版。否则，创建新的动画模版，如果cacheName不为空，则以cacheName为key缓存到动画模版缓存池中，如果cacheName为空，不进行缓存。
         * @returns 返回动画本身。
         */
        loadImages(urls: any[], cacheName?: string): Animation;
        /**
         * @en Initializes the current animation sequence frame based on the specified animation template. The process of selecting an animation template is as follows: 1. The animation template with the key cacheName in the animation template cache pool; 2. If it doesn't exist, load the specified atlas and create an animation template.
         * Note: Only when a non-empty cacheName is specified can the created animation template be cached in the animation template cache pool with this as the key, otherwise no caching is performed.
         * The animation template cache pool trades a certain memory overhead for CPU savings. When the same animation template is used multiple times, compared to creating a new animation template each time, using the animation template cache pool only needs to be created once, cached, and reused multiple times, thus saving the overhead of creating animation templates.
         * Because the return value is the Animation object itself, you can use the following syntax: loadAtlas(...).loadAtlas(...).play(...);
         * @param url Atlas path. When creating an animation template, this will be used as the data source.
         * @param loaded (Optional) Callback when the animation is initialized using the specified atlas.
         * @param cacheName (Optional) The key of the animation template in the animation template cache pool. If this parameter is not empty, it means using the animation template cache pool. If an animation template with the key cacheName exists in the animation template cache pool, this template is used. Otherwise, a new animation template is created. If cacheName is not empty, it is cached in the animation template cache pool with cacheName as the key. If cacheName is empty, no caching is performed.
         * @returns Returns the Animation object itself.
         * @zh 根据指定的动画模版初始化当前动画序列帧。选择动画模版的过程如下：1. 动画模版缓存池中key为cacheName的动画模版；2. 如果不存在，则加载指定的图集并创建动画模版。
         * 注意：只有指定不为空的cacheName，才能将创建好的动画模版以此为key缓存到动画模版缓存池，否则不进行缓存。
         * 动画模版缓存池是以一定的内存开销来节省CPU开销，当相同的动画模版被多次使用时，相比于每次都创建新的动画模版，使用动画模版缓存池，只需创建一次，缓存之后多次复用，从而节省了动画模版创建的开销。
         * 因为返回值为Animation对象本身，所以可以使用如下语法：loadAtlas(...).loadAtlas(...).play(...);。
         * @param url 图集路径。需要创建动画模版时，会以此为数据源。
         * @param loaded （可选）使用指定图集初始化动画完毕的回调。
         * @param cacheName （可选）动画模板在动画模版缓存池中的key。如果此参数不为空，表示使用动画模版缓存池。如果动画模版缓存池中存在key为cacheName的动画模版，则使用此模版。否则，创建新的动画模版，如果cacheName不为空，则以cacheName为key缓存到动画模版缓存池中，如果cacheName为空，不进行缓存。
         * @return 返回动画本身。
         */
        loadAtlas(url: string, loaded?: Handler, cacheName?: string): Animation;
        /**
         * @deprecated
         * @en Loads and parses an animation file created by LayaAir IDE, which may contain multiple animations. The default frame rate is the frame rate designed in the IDE. If set interval has been called, the frame rate corresponding to this frame interval is used. After loading, it creates an animation template and caches it in the animation template cache pool. The key "url#animation name" corresponds to the animation template of the corresponding animation name, and the key "url#" corresponds to the default animation template of the animation template collection.
         * Note: If you haven't preloaded the atlas used by the animation before calling this method, please specify the atlas parameter as the corresponding atlas path, otherwise it will cause the animation creation to fail.
         * The animation template cache pool trades a certain memory overhead for CPU savings. When the same animation template is used multiple times, compared to creating a new animation template each time, using the animation template cache pool only needs to be created once, cached, and reused multiple times, thus saving the overhead of creating animation templates.
         * Because the return value is the Animation object itself, you can use the following syntax: loadAnimation(...).loadAnimation(...).play(...);
         * @param url Animation file path. Can be created and published by LayaAir IDE.
         * @param loaded (Optional) Callback when the animation is initialized using the specified animation resource.
         * @param atlas (Optional) The atlas address used by the animation (optional).
         * @returns Returns the Animation object itself.
         * @zh 加载并解析由LayaAir IDE制作的动画文件，此文件中可能包含多个动画。默认帧率为在IDE中设计的帧率，如果调用过set interval，则使用此帧间隔对应的帧率。加载后创建动画模版，并缓存到动画模版缓存池，key "url#动画名称" 对应相应动画名称的动画模板，key "url#" 对应动画模版集合的默认动画模版。
         * 注意：如果调用本方法前，还没有预加载动画使用的图集，请将atlas参数指定为对应的图集路径，否则会导致动画创建失败。
         * 动画模版缓存池是以一定的内存开销来节省CPU开销，当相同的动画模版被多次使用时，相比于每次都创建新的动画模版，使用动画模版缓存池，只需创建一次，缓存之后多次复用，从而节省了动画模版创建的开销。
         * 因为返回值为Animation对象本身，所以可以使用如下语法：loadAnimation(...).loadAnimation(...).play(...);。
         * @param url 动画文件路径。可由LayaAir IDE创建并发布。
         * @param loaded （可选）使用指定动画资源初始化动画完毕的回调。
         * @param atlas （可选）动画用到的图集地址（可选）。
         * @return 	返回动画本身。
         */
        loadAnimation(url: string, loaded?: Handler, atlas?: string): Animation;
        private _loadAnimationData;
        /**
         * @en Creates an animation template. Multiple animations can share the same animation template without having to create a new one each time, thus saving the overhead of creating a Graphics collection.
         * @param url Atlas path or image path array. If it's an atlas path, the corresponding atlas needs to be preloaded. If it's not preloaded, it will cause creation failure.
         * @param name The key of the animation template in the animation template cache pool. If it's not empty, the animation template is cached with this as the key, otherwise it's not cached.
         * @returns Animation template.
         * @zh 创建动画模板，多个动画可共享同一份动画模板，而不必每次都创建一份新的，从而节省创建Graphics集合的开销。
         * @param	url	图集路径或者图片路径数组。如果是图集路径，需要相应图集已经被预加载，如果没有预加载，会导致创建失败。
         * @param	name 动画模板在动画模版缓存池中的key。如果不为空，则以此为key缓存动画模板，否则不缓存。
         * @return	动画模板。
         */
        static createFrames(url: string | string[], name: string): any[];
        /**
         * @en Clears the animation data with the specified key value from the animation template cache pool.
         * When calling the function to create an animation template, developers can manually specify this value. For animation sets created by LayaAir IDE, the parsed key format is: "url#": represents the default animation template of the animation set, if this value is used as a parameter, it will clear the entire animation set data; "url#aniName": represents the animation template with the corresponding name.
         * @param key The key of the animation template in the animation template cache pool.
         * @zh 从动画模版缓存池中清除指定key值的动画数据。
         * 开发者在调用创建动画模版函数时，可以手动指定此值。而如果是由LayaAir IDE创建的动画集，解析后的key格式为："url#"：表示动画集的默认动画模版，如果以此值为参数，会清除整个动画集数据；"url#aniName"：表示相应名称的动画模版。
         * @param key 动画模板在动画模版缓存池中的key。
         */
        static clearCache(key: string): void;
    }
    /**
     * @en Base class for animations, providing basic animation playback control methods and frame label event-related functionality.
     * This class can be inherited, but should not be instantiated directly as some methods need to be implemented by subclasses.
     * - Event.COMPLETE dispatched when the animation playback is complete.
     * - Event.LABEL dispatched when a specific label is reached during playback.
     * @zh 动画基类，提供了基础的动画播放控制方法和帧标签事件相关功能。
     * 可以继承此类，但不要直接实例化此类，因为有些方法需要由子类实现。
     * - Event.COMPLETE 动画播放完毕后调度。
     * - Event.LABEL 播放到某标签后调度。
     */
    class AnimationBase extends Sprite {
        /**
         * @en Animation playback order type: Forward playback.
         * @zh 动画播放顺序类型：正序播放。
         */
        static WRAP_POSITIVE: number;
        /**
         * @en Animation playback order type: Reverse playback.
         * @zh 动画播放顺序类型：逆序播放。
         */
        static WRAP_REVERSE: number;
        /**
         * @en Animation playback order type: Ping-pong playback (changes playback direction after reaching the end when continuing to play).
         * @zh 动画播放顺序类型：pingpong播放(当按指定顺序播放完结尾后，如果继续播放，则会改变播放顺序)。
         */
        static WRAP_PINGPONG: number;
        /**
         * @en Whether to loop playback. This value is set to the specified parameter value when calling the play(...) method.
         * @zh 是否循环播放，调用play(...)方法时，会将此值设置为指定的参数值。
         */
        loop: boolean;
        /**
         * @en Playback order type: AnimationBase.WRAP_POSITIVE for forward playback (default), AnimationBase.WRAP_REVERSE for reverse playback, AnimationBase.WRAP_PINGPONG for ping-pong playback.
         * @zh 播放顺序类型：AnimationBase.WRAP_POSITIVE为正序播放(默认值)，AnimationBase.WRAP_REVERSE为倒序播放，AnimationBase.WRAP_PINGPONG为pingpong播放(当按指定顺序播放完结尾后，如果继续播发，则会改变播放顺序)。
         */
        wrapMode: number;
        /** 播放间隔(单位：毫秒)。*/
        protected _interval: number;
        protected _index: number;
        protected _count: number;
        protected _isPlaying: boolean;
        protected _labels: any;
        /**是否是逆序播放*/
        protected _isReverse: boolean;
        protected _frameRateChanged: boolean;
        protected _actionName: string;
        private _controlNode;
        /**
         * @en constructor method, This class can be extended, but should not be instantiated directly as some methods need to be implemented by subclasses.
         * @zh 构造方法，可以继承此类，但不要直接实例化此类，因为有些方法需要由子类实现。
         */
        constructor();
        /**
         * @en Starts playing the animation. The play(...) method is designed to be called at any time after creating an instance.
         * When the corresponding resources are loaded, the animation frame filling method (set frames) is called, or the instance is displayed on the stage,
         * it will check if it's currently playing, and if so, it will start playing.
         * Combined with the wrapMode property, you can set the animation playback order type.
         * @param start (Optional) Specifies the starting index (int) or frame label (String) for animation playback. Frame labels can be added and removed using addLabel(...) and removeLabel(...).
         * @param loop (Optional) Whether to loop playback.
         * @param name (Optional) Animation name.
         * @zh 开始播放动画。play(...)方法被设计为在创建实例后的任何时候都可以被调用，当相应的资源加载完毕、调用动画帧填充方法(set frames)或者将实例显示在舞台上时，会判断是否正在播放中，如果是，则进行播放。
         * 配合wrapMode属性，可设置动画播放顺序类型。
         * @param start （可选）指定动画播放开始的索引(int)或帧标签(String)。帧标签可以通过addLabel(...)和removeLabel(...)进行添加和删除。
         * @param loop （可选）是否循环播放。
         * @param name （可选）动画名称。
         */
        play(start?: any, loop?: boolean, name?: string): void;
        /**
         * @en Gets or sets the frame interval time (in milliseconds) for animation playback.
         * The default value depends on Config.animationInterval=50, which can be modified through Config.animationInterval.
         * To set an independent frame interval time for a specific animation, you can use set interval.
         * Note: If the animation is currently playing, setting this will reset the frame loop timer's start time to the current time.
         * Frequent setting of interval may cause the animation frame update interval to be slower than expected, or even not update.
         * @zh 动画播放的帧间隔时间(单位：毫秒)。默认值依赖于Config.animationInterval=50，通过Config.animationInterval可以修改默认帧间隔时间。
         * 要想为某动画设置独立的帧间隔时间，可以使用set interval，注意：如果动画正在播放，设置后会重置帧循环定时器的起始时间为当前时间，也就是说，如果频繁设置interval，会导致动画帧更新的时间间隔会比预想的要慢，甚至不更新。
         */
        get interval(): number;
        set interval(value: number);
        protected _getFrameByLabel(label: string): number;
        protected _frameLoop(): void;
        protected _resumePlay(): void;
        /**
         * @en Stop the animation playback.
         * @zh 停止动画播放。
         */
        stop(): void;
        /**
         * @en Whether the animation is currently playing.
         * @zh 是否正在播放中。
         */
        get isPlaying(): boolean;
        /**
         * @en Add a frame label to the specified frame index. When the animation plays to this frame, it will dispatch an Event.LABEL event after updating the current frame.
         * @param label The name of the frame label.
         * @param index The frame index.
         * @zh 增加一个帧标签到指定索引的帧上。当动画播放到此索引的帧时会派发Event.LABEL事件，派发事件是在完成当前帧画面更新之后。
         * @param label 帧标签名称。
         * @param index 帧索引。
         */
        addLabel(label: string, index: number): void;
        /**
         * @en Remove the specified frame label.
         * @param label The name of the frame label. Note: If empty, all frame labels will be deleted!
         * @zh 删除指定的帧标签。
         * @param label 帧标签名称。注意：如果为空，则删除所有帧标签！
         */
        removeLabel(label: string): void;
        private _removeLabelFromList;
        /**
         * @en Switch the animation to the specified frame and stop there.
         * @param position Frame index or frame label.
         * @zh 将动画切换到指定帧并停在那里。
         * @param position 帧索引或帧标签。
         */
        gotoAndStop(position: any): void;
        /**
         * @en The index of the current frame in the animation.
         * @zh 动画当前帧的索引。
         */
        get index(): number;
        set index(value: number);
        /**
         * @en Displays the specified frame.
         * @param value The index of the frame to display.
         * @zh 显示到某帧
         * @param value 帧索引
         */
        protected _displayToIndex(value: number): void;
        /**
         * @en The total number of frames in the current animation.
         * @zh 当前动画中帧的总数。
         */
        get count(): number;
        /**
         * @en Stop the animation playback and clear object properties. After this, the object can be stored in the object pool for reuse.
         * @returns The object itself.
         * @zh 停止动画播放，并清理对象属性。之后可存入对象池，方便对象复用。
         * @returns 返回对象本身。
         */
        clear(): AnimationBase;
    }
    /**
     * @en BitmapFont is a bitmap font class used to define bitmap font information.
     * @zh BitmapFont 是位图字体类，用于定义位图字体信息。
     */
    class BitmapFont extends Resource {
        /**
         * @en Bitmap font texture
         * @zh 位图字体纹理
         */
        texture: Texture;
        /**
         * @en Bitmap font key-value mapping
         * @zh 位图字体键值对映射
         */
        dict: Record<string, BMGlyph>;
        /**
         * @en Font padding
         * @zh 字体边距
         */
        padding: any[];
        /**
         * @en Current bitmap font size. When used, if the font size is different from the setting and autoScaleSize=true, it will be scaled according to the set font size ratio.
         * @zh 当前位图字体字号，使用时，如果字号和设置不同，并且autoScaleSize=true，则按照设置字号比率进行缩放显示。
         */
        fontSize: number;
        /**
         * @en Indicates whether to scale the bitmap font size according to the actual font size used.
         * @zh 表示是否根据实际使用的字体大小缩放位图字体大小。
         */
        autoScaleSize: boolean;
        /**
         * @en Whether it is a font
         * @zh 是否是字体
         */
        tint: boolean;
        /**
         * @en Maximum width
         * @zh 最大宽度
         */
        maxWidth: number;
        /**
         * @en Line height
         * @zh 行高
         */
        lineHeight: number;
        /**
         * @en Letter spacing
         * @zh 字符间隔
         */
        letterSpacing: number;
        /**
         * @en Load the bitmap font file by specifying the file path. After loading, it will be automatically parsed.
         * @param path The path of the bitmap font file.
         * @param complete The callback function after loading and parsing are completed.
         * @zh 通过指定位图字体文件路径，加载位图字体文件，加载完成后会自动解析。
         * @param path 位图字体文件的路径。
         * @param complete 加载并解析完成的回调。
         */
        static loadFont(path: string, complete: Handler): void;
        /**
         * @en BitmapFont constructor.
         * @zh 位图字体构造方法。
         */
        constructor();
        /**
         * @en Parse the font file.
         * @param xml The XML of the font file.
         * @param texture The texture of the font.
         * @zh 解析字体文件。
         * @param xml 字体文件XML。
         * @param texture 字体的纹理。
         */
        parseFont(xml: XML, texture: Texture): void;
        /**
         * @en Destroys the bitmap font. This is called by default when Text.unregisterBitmapFont is invoked.
         * @zh 销毁位图字体，调用 Text.unregisterBitmapFont 时，默认会销毁。
         */
        protected _disposeResource(): void;
        /**
         * @en Get the width of the specified text content.
         * @param text The text content.
         * @param fontSize The font size.
         * @return The width of the text content.
         * @zh 获取指定文本内容的宽度。
         * @param text 文本内容。
         * @param fontSize 字体大小。
         * @return 文本内容的宽度。
         */
        getTextWidth(text: string, fontSize?: number): number;
        /**
         * @en Get the maximum character width.
         * @param fontSize The font size.
         * @zh 获取最大字符宽度。
         * @param fontSize 字体大小。
         */
        getMaxWidth(fontSize?: number): number;
        /**
         * @en Get the maximum character height.
         * @param fontSize The font size.
         * @zh 获取最大字符高度。
         * @param fontSize 字体大小。
         */
        getMaxHeight(fontSize?: number): number;
    }
    interface BMGlyph {
        x?: number;
        y?: number;
        width?: number;
        height?: number;
        advance?: number;
        texture?: Texture;
    }
    /**
     * @en Alpha command.
     * @zh 透明命令
     */
    class AlphaCmd implements IGraphicCMD {
        /**
         * @en Identifier for the AlphaCmd
         * @zh 透明命令的标识符
         */
        static ID: string;
        /**
         * @en The opacity level of the command.
         * @zh 透明度值。
         */
        alpha: number;
        /**
         * @en Creates or retrieves an AlphaCmd instance from the object pool and initializes it with the specified alpha value.
         * @param alpha The alpha value to set for the AlphaCmd instance.
         * @returns An AlphaCmd instance initialized with the given alpha value.
         * @zh 从对象池创建或获取一个 AlphaCmd 实例，并使用指定的 alpha 值进行初始化。
         * @param alpha 用于设置 AlphaCmd 实例的 alpha 值。
         * @returns 一个已用给定 alpha 值初始化的 AlphaCmd 实例。
         */
        static create(alpha: number): AlphaCmd;
        /**
         * @en Recovers the `AlphaCmd` instance to the object pool for reuse.
         * @zh 将 `AlphaCmd` 实例回收到对象池以供重用。
         */
        recover(): void;
        /**
         * @en Execute the alpha command in the given context.
         * @param context The rendering context.
         * @param gx The global x coordinate (unused in this method).
         * @param gy The global y coordinate (unused in this method).
         * @zh 在给定的上下文中执行 alpha 命令。
         * @param context 渲染上下文。
         * @param gx 全局 x 坐标（本方法中未使用）。
         * @param gy 全局 y 坐标（本方法中未使用）。
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en Get the identifier for the AlphaCmd
         * @zh 获得透明命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Clip command
     * @zh 裁剪命令
     */
    class ClipRectCmd implements IGraphicCMD {
        /**
         * @en Identifier for the ClipRectCmd
         * @zh 裁剪命令的标识符
         */
        static ID: string;
        /**
         * @en X-axis offset.
         * @zh X 轴偏移量。
         */
        x: number;
        /**
         * @en Y-axis offset.
         * @zh Y 轴偏移量。
         */
        y: number;
        /**
         * @en Width of the clip rectangle.
         * @zh 裁剪矩形的宽度。
         */
        width: number;
        /**
         * @en Height of the clip rectangle.
         * @zh 裁剪矩形的高度。
         */
        height: number;
        /**
         * @en Creates or retrieves a ClipRectCmd instance from the object pool and initializes it with the specified parameters.
         * @param x The x-coordinate of the top-left corner of the clip rectangle.
         * @param y The y-coordinate of the top-left corner of the clip rectangle.
         * @param width The width of the clip rectangle.
         * @param height The height of the clip rectangle.
         * @returns A ClipRectCmd instance initialized with the given parameters.
         * @zh 从对象池创建或获取一个 ClipRectCmd 实例，并使用指定的参数进行初始化。
         * @param x 裁剪矩形左上角的 x 坐标。
         * @param y 裁剪矩形左上角的 y 坐标。
         * @param width 裁剪矩形的宽度。
         * @param height 裁剪矩形的高度。
         * @returns 一个已用给定参数初始化的 ClipRectCmd 实例。
         */
        static create(x: number, y: number, width: number, height: number): ClipRectCmd;
        /**
         * @en Recycle the instance to the object pool.
         * @zh 将实例回收到对象池。
         */
        recover(): void;
        /**
         * @en Execute the clip rectangle command in the given context.
         * @param context The rendering context.
         * @param gx The global x coordinate.
         * @param gy The global y coordinate.
         * @zh 在给定的上下文中执行裁剪矩形命令。
         * @param context 渲染上下文。
         * @param gx 全局 x 坐标。
         * @param gy 全局 y 坐标。
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en The identifier for the ClipRectCmd
         * @zh 裁剪命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Draw circle command
     * @zh 绘制圆形命令
     */
    class DrawCircleCmd implements IGraphicCMD {
        /**
         * @en Identifier for the DrawCircleCmd
         * @zh 绘制圆形命令的标识符
         */
        static ID: string;
        /**
         * @en X-axis position of the circle center
         * @zh 圆心X轴位置
         */
        x: number;
        /**
         * @en Y-axis position of the circle center
         * @zh 圆心Y轴位置
         */
        y: number;
        /**
         * @en Radius of the circle
         * @zh 圆的半径
         */
        radius: number;
        /**
         * @en Fill color
         * @zh 填充颜色
         */
        fillColor: any;
        /**
         * @en (Optional) Border color
         * @zh （可选）边框颜色
         */
        lineColor: any;
        /**
         * @en (Optional) Border width
         * @zh （可选）边框宽度
         */
        lineWidth: number;
        /**
         * @en Whether the position and size are percentages
         * @zh 位置和大小是否是百分比
         */
        percent: boolean;
        /**
         * @private
         * @en Create a DrawCircleCmd instance
         * @param x X-axis position of the circle center
         * @param y Y-axis position of the circle center
         * @param radius Radius of the circle
         * @param fillColor Fill color
         * @param lineColor Border color
         * @param lineWidth Border width
         * @returns A DrawCircleCmd instance
         * @zh 创建绘制圆形的DrawCircleCmd实例
         * @param x 圆心X轴位置
         * @param y 圆心Y轴位置
         * @param radius 圆的半径
         * @param fillColor 填充颜色
         * @param lineColor 边框颜色
         * @param lineWidth 边框宽度
         * @returns DrawCircleCmd实例
         */
        static create(x: number, y: number, radius: number, fillColor: any, lineColor: any, lineWidth: number): DrawCircleCmd;
        /**
         * @en Recycle the instance to the object pool
         * @zh 将实例回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the draw circle command
         * @param context The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制圆形命令
         * @param context 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawCircleCmd
         * @zh 绘制圆形命令的标识符
         */
        get cmdID(): string;
        /**
         * @en Get the bounding points of the circle
         * @param sp The sprite that draws the cmd
         * @returns An array of bounding points
         * @zh 获取圆形的包围盒顶点数据
         * @param sp 绘制cmd的精灵
         * @returns 包围盒顶点数据数组
         */
        getBoundPoints(sp?: {
            width: number;
            height?: number;
        }): number[];
    }
    /**
     * @en Draw curves command
     * @zh 绘制曲线命令
     */
    class DrawCurvesCmd implements IGraphicCMD {
        /**
         * @en Identifier for the DrawCurvesCmd
         * @zh 绘制曲线命令的标识符
         */
        static ID: string;
        /**
         * @en X-axis position to start drawing
         * @zh 开始绘制的 X 轴位置
         */
        x: number;
        /**
         * @en Y-axis position to start drawing
         * @zh 开始绘制的 Y 轴位置
         */
        y: number;
        /**
         * @en Collection of points for the curve segments, format: [controlX, controlY, anchorX, anchorY...]
         * @zh 线段的点集合，格式：[controlX, controlY, anchorX, anchorY...]
         */
        points: number[] | null;
        /**
         * @en Line color
         * @zh 线段颜色
         */
        lineColor: any;
        /**
         * @en (Optional) Line width
         * @zh （可选）线段宽度
         */
        lineWidth: number;
        /**
         * @private
         * @en Create a DrawCurvesCmd instance
         * @param x X-axis position to start drawing
         * @param y Y-axis position to start drawing
         * @param points Collection of points for the curve segments
         * @param lineColor Line color
         * @param lineWidth Line width
         * @returns A DrawCurvesCmd instance
         * @zh 创建一个DrawCurvesCmd实例
         * @param x 开始绘制的 X 轴位置
         * @param y 开始绘制的 Y 轴位置
         * @param points 线段的点集合
         * @param lineColor 线段颜色
         * @param lineWidth 线段宽度
         * @returns DrawCurvesCmd实例
         */
        static create(x: number, y: number, points: any[], lineColor: any, lineWidth: number): DrawCurvesCmd;
        /**
         * @en Recycle the instance to the object pool
         * @zh 将实例回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the draw curves command
         * @param context The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制曲线命令
         * @param context 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawCurvesCmd
         * @zh 绘制曲线命令的标识符
         */
        get cmdID(): string;
        /**
         * @en Get the bounding points of the curves.
         * @zh 获取贝塞尔曲线上的点数据。
         */
        getBoundPoints(): number[];
    }
    /**
     * @en Draw ellipse command
     * @zh 绘制椭圆命令
     */
    class DrawEllipseCmd implements IGraphicCMD {
        /**
         * @en Identifier for the DrawEllipseCmd
         * @zh 绘制椭圆命令的标识符
         */
        static ID: string;
        /**
         * @en X-axis position of the ellipse center
         * @zh 椭圆中心点X轴位置
         */
        x: number;
        /**
         * @en Y-axis position of the ellipse center
         * @zh 椭圆中心点Y轴位置
         */
        y: number;
        /**
         * @en Horizontal radius of the ellipse
         * @zh 椭圆的横向半径
         */
        width: number;
        /**
         * @en Vertical radius of the ellipse
         * @zh 椭圆的纵向半径
         */
        height: number;
        /**
         * @en Fill color
         * @zh 填充颜色
         */
        fillColor: any;
        /**
         * @en (Optional) Border color
         * @zh （可选）边框颜色
         */
        lineColor: any;
        /**
         * @en (Optional) Border width
         * @zh （可选）边框宽度
         */
        lineWidth: number;
        /**
         * @en Whether the position and size are percentages
         * @zh 位置和大小是否是百分比
         */
        percent: boolean;
        /**
         * @en Create a DrawEllipseCmd instance
         * @param x X-axis position of the ellipse center
         * @param y Y-axis position of the ellipse center
         * @param width Horizontal radius of the ellipse
         * @param height Vertical radius of the ellipse
         * @param fillColor Fill color
         * @param lineColor Border color
         * @param lineWidth Border width
         * @param percent Whether the position and size are percentages
         * @returns A DrawEllipseCmd instance
         * @zh 创建一个绘制椭圆命令的实例
         * @param x 椭圆中心点X轴位置
         * @param y 椭圆中心点Y轴位置
         * @param width 椭圆的横向半径
         * @param height 椭圆的纵向半径
         * @param fillColor 填充颜色
         * @param lineColor 边框颜色
         * @param lineWidth 边框宽度
         * @param percent 位置和大小是否是百分比
         * @returns DrawEllipseCmd实例
         */
        static create(x: number, y: number, width: number, height: number, fillColor: any, lineColor: any, lineWidth: number, percent?: boolean): DrawEllipseCmd;
        /**
         * @en Recycle the instance to the object pool
         * @zh 将实例回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the draw ellipse command
         * @param context The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制椭圆命令
         * @param context 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawEllipseCmd
         * @zh 绘制椭圆命令的标识符
         */
        get cmdID(): string;
        /**
         * @en Get the bounding points of the ellipse
         * @param sp The sprite that draws the cmd
         * @returns An array of bounding points
         * @zh 获取椭圆的包围盒顶点数据
         * @param sp 绘制cmd的精灵
         * @returns 包围盒顶点数据数组
         */
        getBoundPoints(sp?: {
            width: number;
            height?: number;
        }): number[];
    }
    /**
     * @en Draw geometry command
     * @zh 绘制几何体命令
     */
    class DrawGeoCmd implements IGraphicCMD {
        /**
         * @en Identifier for the DrawGeoCmd
         * @zh 绘制几何体命令的标识符
         */
        static ID: string;
        /**
         * @en Geometry element to be rendered
         * @zh 要渲染的几何体元素
         */
        geo: IRenderGeometryElement;
        /**
         * @en Material used for rendering
         * @zh 用于渲染的材质
         */
        material: Material;
        /**
         * @en Create a DrawGeoCmd instance
         * @param geo Geometry element to be rendered
         * @param material Material used for rendering
         * @returns A DrawGeoCmd instance
         * @zh 创建一个绘制几何体命令实例
         * @param geo 要渲染的几何体元素
         * @param material 用于渲染的材质
         * @returns DrawGeoCmd 实例
         */
        static create(geo: IRenderGeometryElement, material: Material): DrawGeoCmd;
        /**
         * @en Create a geometry element
         * @param decl Vertex declaration
         * @param vbArray Vertex buffer array
         * @param vblen Vertex buffer length
         * @param ibArray Index buffer array
         * @param iblen Index buffer length
         * @returns Created geometry element
         * @zh 创建一个几何体元素
         * @param decl 顶点声明
         * @param vbArray 顶点缓冲数组
         * @param vblen 顶点缓冲长度
         * @param ibArray 索引缓冲数组
         * @param iblen 索引缓冲长度
         * @returns 创建的几何体元素
         */
        static creatGEO(decl: VertexDeclaration, vbArray: Float32Array, vblen: number, ibArray: Uint16Array, iblen: number): IRenderGeometryElement;
        /**
         * @en Initialize the DrawGeoCmd
         * @param geo Geometry element to be rendered
         * @param material Material used for rendering
         * @zh 初始化绘制几何体命令
         * @param geo 要渲染的几何体元素
         * @param material 用于渲染的材质
         */
        init(geo: IRenderGeometryElement, material: Material): void;
        /**
         * @en Recycle the instance to the object pool
         * @zh 将实例回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the draw geometry command
         * @param context The rendering context
         * @param gx Global x-coordinate
         * @param gy Global Y-coordinate
         * @zh 执行绘制几何体命令
         * @param context 渲染上下文
         * @param gx 全局X坐标
         * @param gy 全局Y坐标
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawGeoCmd
         * @zh 绘制几何体命令的ID
         */
        get cmdID(): string;
    }
    /**
     * @en Draw multiple geometries command
     * @zh 绘制多个几何体命令
     */
    class DrawGeosCmd implements IGraphicCMD {
        /**
         * @en Identifier for the DrawGeosCmd
         * @zh 绘制多个几何体命令的标识符
         */
        static ID: string;
        /**
         * @en Geometry element to be rendered
         * @zh 要渲染的几何体元素
         */
        geo: IRenderGeometryElement;
        /**
         * @en Array of [Material, startIndex, count] tuples for each geometry
         * @zh 每个几何体的 [材质, 起始索引, 数量] 元组数组
         */
        elements: [
            Material,
            number,
            number
        ][];
        /**
         * @private
         * @en Create a DrawGeosCmd instance
         * @param geo Geometry element to be rendered
         * @param elements Array of [Material, startIndex, count] tuples for each geometry
         * @returns A DrawGeosCmd instance
         * @zh 创建一个 DrawGeosCmd 实例
         * @param geo 要渲染的几何体元素
         * @param elements 每个几何体的 [材质, 起始索引, 数量] 元组数组
         * @returns DrawGeosCmd 实例
         */
        static create(geo: IRenderGeometryElement, elements: [
            Material,
            number,
            number
        ][]): DrawGeosCmd;
        /**
         * @en Initialize the DrawGeosCmd
         * @param geo Geometry element to be rendered
         * @param elements Array of [Material, startIndex, count] tuples for each geometry
         * @zh 初始化绘制多个几何体
         * @param geo 要渲染的几何体元素
         * @param elements 每个几何体的 [材质, 起始索引, 数量] 元组数组
         */
        init(geo: IRenderGeometryElement, elements: [
            Material,
            number,
            number
        ][]): void;
        /**
         * @en Recycle the instance to the object pool
         * @zh 将实例回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the draw geometries command
         * @param context The rendering context
         * @param gx Global x-coordinate
         * @param gy Global Y-coordinate
         * @zh 执行绘制多个几何体命令
         * @param context 渲染上下文
         * @param gx 全局X坐标
         * @param gy 全局Y坐标
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawGeosCmd
         * @zh 绘制多个几何体命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Draw image command
     * @zh 绘制图片命令
     */
    class DrawImageCmd implements IGraphicCMD {
        /**
         * @en Identifier for the DrawImageCmd
         * @zh 绘制图片命令的标识符
         */
        static ID: string;
        /**
         * @en Texture to be drawn
         * @zh 要绘制的纹理
         */
        texture: Texture | null;
        /**
         * @en (Optional) X-axis offset
         * @zh （可选）X轴偏移量
         */
        x: number;
        /**
         * @en (Optional) Y-axis offset
         * @zh （可选）Y轴偏移量
         */
        y: number;
        /**
         * @en (Optional) Width of the drawn image
         * @zh （可选）绘制图片的宽度
         */
        width: number;
        /**
         * @en (Optional) Height of the drawn image
         * @zh （可选）绘制图片的高度
         */
        height: number;
        /**
         * @en (Optional) Drawing color
         * @zh （可选）绘图颜色
         */
        color: number;
        /**
         * @en Create a DrawImageCmd instance
         * @param texture Texture to be drawn
         * @param x X-axis offset
         * @param y Y-axis offset
         * @param width Width of the drawn image
         * @param height Height of the drawn image
         * @param color Drawing color
         * @returns A DrawImageCmd instance
         * @zh 创建一个绘制图片命令实例
         * @param texture 要绘制的纹理
         * @param x X轴偏移量
         * @param y Y轴偏移量
         * @param width 绘制图片的宽度
         * @param height 绘制图片的高度
         * @param color 绘图颜色
         * @returns 绘制图片命令实例
         */
        static create(texture: Texture, x: number, y: number, width: number, height: number, color: string): DrawImageCmd;
        /**
         * @en Recycle the instance to the object pool
         * @zh 将实例回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the draw image command
         * @param context The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制图片命令
         * @param context 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawImageCmd
         * @zh 绘制图片命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Draw bend line command
     * @zh 绘制单条曲线命令
     */
    class DrawLineCmd implements IGraphicCMD {
        /**
         * @en Identifier for the DrawLineCmd
         * @zh 绘制单条曲线命令的标识符
         */
        static ID: string;
        /**
         * @en X-axis start position
         * @zh X轴起始位置
         */
        fromX: number;
        /**
         * @en Y-axis start position
         * @zh Y轴起始位置
         */
        fromY: number;
        /**
         * @en X-axis end position
         * @zh X轴结束位置
         */
        toX: number;
        /**
         * @en Y-axis end position
         * @zh Y轴结束位置
         */
        toY: number;
        /**
         * @en Line color
         * @zh 线条颜色
         */
        lineColor: string;
        /**
         * @en (Optional) Line width
         * @zh （可选）线条宽度
         */
        lineWidth: number;
        /**
         * @en Whether the position is a percentage
         * @zh 位置是否是百分比
         */
        percent: boolean;
        /**
         * @private
         * @en Create a DrawLineCmd instance
         * @param fromX X-axis start position
         * @param fromY Y-axis start position
         * @param toX X-axis end position
         * @param toY Y-axis end position
         * @param lineColor Line color
         * @param lineWidth Line width
         * @returns A DrawLineCmd instance
         * @zh 创建一个绘制单条曲线命令实例
         * @param fromX X轴起始位置
         * @param fromY Y轴起始位置
         * @param toX X轴结束位置
         * @param toY Y轴结束位置
         * @param lineColor 线条颜色
         * @param lineWidth 线条宽度
         * @returns DrawLineCmd 实例
         */
        static create(fromX: number, fromY: number, toX: number, toY: number, lineColor: string, lineWidth: number): DrawLineCmd;
        /**
         * @en Recycle the instance to the object pool
         * @zh 将实例回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the draw bend line command
         * @param context The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制单条曲线命令
         * @param context 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawLineCmd
         * @zh 绘制单条曲线命令的标识符
         */
        get cmdID(): string;
        /**
         * @en Get the bounding points of the line
         * @param sp The sprite that draws the cmd
         * @returns An array of bounding points
         * @zh 获取直线的包围盒顶点数据
         * @param sp 绘制cmd的精灵
         * @returns 包围盒顶点数据数组
         */
        getBoundPoints(sp?: {
            width: number;
            height?: number;
        }): number[];
    }
    /**
     * @en Draw continuous curves command
     * @zh 绘制连续曲线命令
     */
    class DrawLinesCmd implements IGraphicCMD {
        /**
         * @en Identifier for the DrawLinesCmd
         * @zh 绘制连续曲线命令的标识符
         */
        static ID: string;
        /**
         * @en X-axis position to start drawing
         * @zh 开始绘制的X轴位置
         */
        x: number;
        /**
         * @en Y-axis position to start drawing
         * @zh 开始绘制的Y轴位置
         */
        y: number;
        /**
         * @en Collection of points for the line segments. Format: [x1,y1,x2,y2,x3,y3...]
         * @zh 线段的点集合。格式：[x1,y1,x2,y2,x3,y3...]
         */
        points: number[] | null;
        /**
         * @en Line color
         * @zh 线段颜色
         */
        lineColor: any;
        /**
         * @en (Optional) Line width
         * @zh （可选）线段宽度
         */
        lineWidth: number;
        /**
         * @en Create a DrawLinesCmd instance
         * @param x X-axis position to start drawing
         * @param y Y-axis position to start drawing
         * @param points Collection of points for the line segments
         * @param lineColor Line color
         * @param lineWidth Line width
         * @returns A DrawLinesCmd instance
         * @zh 创建一个绘制连续曲线命令实例
         * @param x 开始绘制的X轴位置
         * @param y 开始绘制的Y轴位置
         * @param points 线段的点集合
         * @param lineColor 线段颜色
         * @param lineWidth 线段宽度
         * @returns DrawLinesCmd 实例
         */
        static create(x: number, y: number, points: any[], lineColor: any, lineWidth: number): DrawLinesCmd;
        /**
         * @en Recycle the instance to the object pool
         * @zh 将实例回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the draw continuous lines command
         * @param context The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制连续曲线命令
         * @param context 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawLinesCmd
         * @zh 绘制连续曲线命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Draw vector graphics based on the path
     * @zh 根据路径绘制矢量图形
     */
    class DrawPathCmd {
        /**
         * @en Identifier for the DrawPathCmd
         * @zh 根据路径绘制矢量图形命令的标识符
         */
        static ID: string;
        /**
         * @en The X-axis position to start drawing.
         * @zh 开始绘制的 X 轴位置。
         */
        x: number;
        /**
         * @en The Y-axis position to start drawing.
         * @zh 开始绘制的 Y 轴位置。
         */
        y: number;
        /**
         * @en Path collection. Paths support the following formats: [["moveTo",x,y],["lineTo",x,y],["arcTo",x1,y1,x2,y2,r],["closePath"]].
         * @zh 路径集合，路径支持以下格式：[["moveTo",x,y],["lineTo",x,y],["arcTo",x1,y1,x2,y2,r],["closePath"]]。
         */
        paths: any[] | null;
        /**
         * @en (Optional) Brush definition, supports the following settings: {fillStyle:"#FF0000"}.
         * @zh （可选）刷子定义，支持以下设置：{fillStyle:"#FF0000"}。
         */
        brush: any;
        /**
         * @en (Optional) Pen definition, supports the following settings: {strokeStyle,lineWidth,lineJoin:"bevel|round|miter",lineCap:"butt|round|square",miterLimit}.
         * @zh （可选）画笔定义，支持以下设置：{strokeStyle,lineWidth,lineJoin:"bevel|round|miter",lineCap:"butt|round|square",miterLimit}。
         */
        pen: any;
        /**
         * @en Create a DrawPathCmd instance
         * @param x The X-axis position to start drawing
         * @param y The Y-axis position to start drawing
         * @param paths Path collection
         * @param brush Brush definition
         * @param pen Pen definition
         * @returns DrawPathCmd instance
         * @zh 创建一个根据路径绘制矢量图形命令实例
         * @param x 开始绘制的 X 轴位置
         * @param y 开始绘制的 Y 轴位置
         * @param paths 路径集合
         * @param brush 刷子定义
         * @param pen 画笔定义
         * @return DrawPathCmd 实例
         */
        static create(x: number, y: number, paths: any[], brush: any, pen: any): DrawPathCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the drawing command
         * @param context The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制命令
         * @param context 渲染上下文
         * @param gx 全局 X 偏移
         * @param gy 全局 Y 偏移
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawPathCmd
         * @zh 根据路径绘制矢量图形命令的标识符
         */
        get cmdID(): string;
        /**
         * @en Get the boundary points of the path
         * @zh 获取路径的边界点
         */
        getBoundPoints(): number[];
    }
    /**
     * @en Draw a pie chart
     * @zh 绘制扇形
     */
    class DrawPieCmd {
        /**
         * @en Identifier for the DrawPieCmd
         * @zh 绘制扇形命令的标识符
         */
        static ID: string;
        /**
         * @en The X-axis position to start drawing.
         * @zh 开始绘制的 X 轴位置。
         */
        x: number;
        /**
         * @en The Y-axis position to start drawing.
         * @zh 开始绘制的 Y 轴位置。
         */
        y: number;
        /**
         * @en The radius of the pie chart.
         * @zh 扇形半径。
         */
        radius: number;
        /**
         * @en The fill color
         * @zh 填充颜色
         */
        fillColor: any;
        /**
         * @en (Optional) The border color
         * @zh （可选）边框颜色
         */
        lineColor: any;
        /**
         * @en (Optional) The width of the border.
         * @zh （可选）边框宽度。
         */
        lineWidth: number;
        private _startAngle;
        private _endAngle;
        /**
         * @en Create a DrawPieCmd instance
         * @param x The X-axis position to start drawing
         * @param y The Y-axis position to start drawing
         * @param radius The radius of the pie chart
         * @param startAngle The start angle of the pie chart
         * @param endAngle The end angle of the pie chart
         * @param fillColor The fill color
         * @param lineColor The border color
         * @param lineWidth The width of the border
         * @returns DrawPieCmd instance
         * @zh 创建一个绘制扇形命令实例
         * @param x 开始绘制的 X 轴位置
         * @param y 开始绘制的 Y 轴位置
         * @param radius 扇形半径
         * @param startAngle 扇形起始角度
         * @param endAngle 扇形终止角度
         * @param fillColor 填充颜色
         * @param lineColor 边框颜色
         * @param lineWidth 边框宽度
         * @returns 绘制扇形命令实例
         */
        static create(x: number, y: number, radius: number, startAngle: number, endAngle: number, fillColor: any, lineColor: any, lineWidth: number): DrawPieCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the drawing command
         * @param context The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制命令
         * @param context 渲染上下文
         * @param gx 全局 X 偏移
         * @param gy 全局 Y 偏移
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawPieCmd
         * @zh 绘制扇形命令的标识符
         */
        get cmdID(): string;
        /**
         * @en The start angle of the pie chart in degrees.
         * @zh 开始角度（以度为单位）。
         */
        get startAngle(): number;
        set startAngle(value: number);
        /**
         * @en The end angle of the pie chart in degrees.
         * @zh 结束角度（以度为单位）。
         */
        get endAngle(): number;
        set endAngle(value: number);
        /**
         * @en Get the boundary points of the pie chart
         * @zh 获取扇形的边界点
         */
        getBoundPoints(): number[];
    }
    /**
     * @en Draw a polygon
     * @zh 绘制多边形
     */
    class DrawPolyCmd {
        /**
         * @en Identifier for the DrawPolyCmd
         * @zh 绘制多边形命令的标识符
         */
        static ID: string;
        /**
         * @en The X-axis position to start drawing.
         * @zh 开始绘制的 X 轴位置。
         */
        x: number;
        /**
         * @en The Y-axis position to start drawing.
         * @zh 开始绘制的 Y 轴位置。
         */
        y: number;
        /**
         * @en The collection of points for the polygon.
         * @zh 多边形的点集合。
         */
        points: number[] | null;
        /**
         * @en The fill color
         * @zh 填充颜色
         */
        fillColor: any;
        /**
         * @en (Optional) The border color
         * @zh （可选）边框颜色
         */
        lineColor: any;
        /**
         * @en (Optional) The width of the border.
         * @zh （可选）边框宽度。
         */
        lineWidth: number;
        /**
         * @en Create a DrawPolyCmd instance
         * @param x The X-axis position to start drawing
         * @param y The Y-axis position to start drawing
         * @param points The collection of points for the polygon
         * @param fillColor The fill color
         * @param lineColor The border color
         * @param lineWidth The width of the border
         * @returns DrawPolyCmd instance
         * @zh 创建绘制多边形命令的实例
         * @param x 开始绘制的 X 轴位置
         * @param y 开始绘制的 Y 轴位置
         * @param points 多边形的点集合
         * @param fillColor 填充颜色
         * @param lineColor 边框颜色
         * @param lineWidth 边框宽度
         */
        static create(x: number, y: number, points: any[], fillColor: any, lineColor: any, lineWidth: number): DrawPolyCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the drawing polygon command
         * @param context The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制多边形命令
         * @param context 渲染上下文
         * @param gx 全局 X 偏移
         * @param gy 全局 Y 偏移
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawPolyCmd
         * @zh 绘制多边形命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Draw a rectangle
     * @zh 绘制矩形
     */
    class DrawRectCmd {
        /**
         * @en Identifier for the DrawRectCmd
         * @zh 绘制矩形命令的标识符
         */
        static ID: string;
        /**
         * @en The X-axis position to start drawing.
         * @zh 开始绘制的 X 轴位置。
         */
        x: number;
        /**
         * @en The Y-axis position to start drawing.
         * @zh 开始绘制的 Y 轴位置。
         */
        y: number;
        /**
         * @en The width of the rectangle.
         * @zh 矩形宽度。
         */
        width: number;
        /**
         * @en The height of the rectangle.
         * @zh 矩形高度。
         */
        height: number;
        /**
         * @en The fill color
         * @zh 填充颜色
         */
        fillColor: any;
        /**
         * @en (Optional) The border color
         * @zh （可选）边框颜色
         */
        lineColor: any;
        /**
         * @en (Optional) The width of the border.
         * @zh （可选）边框宽度。
         */
        lineWidth: number;
        /**
         * @en Whether the position and size are percentages.
         * @zh 位置和大小是否是百分比。
         */
        percent: boolean;
        /**
         * @en Create a DrawRectCmd instance
         * @param x The X-axis position to start drawing
         * @param y The Y-axis position to start drawing
         * @param width The width of the rectangle
         * @param height The height of the rectangle
         * @param fillColor The fill color
         * @param lineColor The border color
         * @param lineWidth The width of the border
         * @param percent Whether the position and size are percentages
         * @returns DrawRectCmd instance
         * @zh 创建绘制矩形的命令实例
         * @param x 开始绘制的 X 轴位置
         * @param y 开始绘制的 Y 轴位置
         * @param width 矩形宽度
         * @param height 矩形高度
         * @param fillColor 填充颜色
         * @param lineColor 边框颜色
         * @param lineWidth 边框宽度
         * @param percent 位置和大小是否是百分比
         * @returns DrawRectCmd实例
         */
        static create(x: number, y: number, width: number, height: number, fillColor: any, lineColor: any, lineWidth: number, percent?: boolean): DrawRectCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the drawing rectangle command
         * @param context The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制矩形命令
         * @param context 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawRectCmd
         * @zh 绘制矩形命令的标识符
         */
        get cmdID(): string;
        /**
         * @en Get the vertex data of the bounding box
         * @param sp The sprite that draws the command
         * @returns Array of vertex data
         * @zh 获取包围盒的顶点数据
         * @param sp 绘制命令的精灵对象
         * @returns 顶点数据数组
         */
        getBoundPoints(sp?: {
            width: number;
            height?: number;
        }): number[];
    }
    /**
     * @en Draw a rounded rectangle
     * @zh 绘制圆角矩形
     */
    class DrawRoundRectCmd {
        /**
         * @en Identifier for the DrawRoundRectCmd
         * @zh 绘制圆角矩形命令的标识符
         */
        static ID: string;
        /**
         * @en The X-axis position of the rounded rectangle.
         * @zh 圆角矩形的 X 轴位置。
         */
        x: number;
        /**
         * @en The Y-axis position of the rounded rectangle.
         * @zh 圆角矩形的 Y 轴位置。
         */
        y: number;
        /**
         * @en The width of the rounded rectangle.
         * @zh 圆角矩形的宽度。
         */
        width: number;
        /**
         * @en The height of the rounded rectangle.
         * @zh 圆角矩形的高度。
         */
        height: number;
        /**
         * @en The radius of the top-left corner.
         * @zh 左上圆角的半径。
         */
        lt: number;
        /**
         * @en The radius of the top-right corner.
         * @zh 右上圆角的半径。
         */
        rt: number;
        /**
         * @en The radius of the bottom-left corner.
         * @zh 左下圆角的半径。
         */
        lb: number;
        /**
         * @en The radius of the bottom-right corner.
         * @zh 右下圆角的半径。
         */
        rb: number;
        /**
         * @en The fill color.
         * @zh 填充颜色
         */
        fillColor: any;
        /**
         * @en (Optional) The border color.
         * @zh （可选）边框颜色
         */
        lineColor: any;
        /**
         * @en (Optional) The width of the border.
         * @zh （可选）边框宽度。
         */
        lineWidth: number;
        /**
         * @en Whether the position and size are percentages.
         * @zh 位置和大小是否是百分比。
         */
        percent: boolean;
        /**
         * @en Create a DrawRoundRectCmd instance
         * @param x The X-axis position of the rounded rectangle
         * @param y The Y-axis position of the rounded rectangle
         * @param width The width of the rounded rectangle
         * @param height The height of the rounded rectangle
         * @param lt The radius of the top-left corner
         * @param rt The radius of the top-right corner
         * @param lb The radius of the bottom-left corner
         * @param rb The radius of the bottom-right corner
         * @param fillColor The fill color
         * @param lineColor The border color
         * @param lineWidth The width of the border
         * @param percent Whether the position and size are percentages
         * @returns DrawRoundRectCmd instance
         * @zh 创建绘制圆角矩形命令的实例
         * @param x 圆角矩形的 X 轴位置
         * @param y 圆角矩形的 Y 轴位置
         * @param width 圆角矩形的宽度
         * @param height 圆角矩形的高度
         * @param lt 左上圆角的半径
         * @param rt 右上圆角的半径
         * @param lb 左下圆角的半径
         * @param rb 右下圆角的半径
         * @param fillColor 填充颜色
         * @param lineColor 边框颜色
         * @param lineWidth 边框宽度
         * @param percent 位置和大小是否是百分比
         * @returns DrawRoundRectCmd 实例
         */
        static create(x: number, y: number, width: number, height: number, lt: number, rt: number, lb: number, rb: number, fillColor: any, lineColor: any, lineWidth: number, percent?: boolean): DrawRoundRectCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the drawing rounded rectangle command
         * @param context The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制圆角矩形命令
         * @param context 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawRoundRectCmd
         * @zh 绘制圆角矩形命令的标识符
         */
        get cmdID(): string;
        /**
         * @en Get the vertex data of the bounding box
         * @param sp The sprite that draws the command
         * @returns Array of vertex data
         * @zh 获取包围盒的顶点数据
         * @param sp 绘制命令的精灵对象
         * @returns 顶点数据数组
         */
        getBoundPoints(sp?: {
            width: number;
            height?: number;
        }): number[];
    }
    /**
     * @en Draw a single texture
     * @zh 绘制单个贴图
     */
    class DrawTextureCmd {
        /**
         * @en Identifier for the DrawTextureCmd
         * @zh 绘制单个贴图命令的标识符
         */
        static ID: string;
        /**
         * @en The texture to be drawn.
         * @zh 要绘制的纹理。
         */
        texture: Texture | null;
        /**
         * @en (Optional) X-axis offset.
         * @zh （可选）X轴偏移量。
         */
        x: number;
        /**
         * @en (Optional) Y-axis offset.
         * @zh （可选）Y轴偏移量。
         */
        y: number;
        /**
         * @en (Optional) Width of the texture.
         * @zh （可选）纹理的宽度。
         */
        width: number;
        /**
         * @en (Optional) Height of the texture.
         * @zh （可选）纹理的高度。
         */
        height: number;
        /**
         * @en (Optional) Matrix information for transformation.
         * @zh （可选）矩阵信息，用于变换。
         */
        matrix: Matrix | null;
        /**
         * @en (Optional) Alpha value.
         * @zh （可选）透明度。
         */
        alpha: number;
        /**
         * @en (Optional) Color filter.
         * @zh （可选）颜色滤镜。
         */
        color: number;
        /**
         * @en (Optional) Blend mode.
         * @zh （可选）混合模式。
         */
        blendMode: string | null;
        /**
         * @en (Optional) UV coordinates.
         * @zh （可选）UV坐标。
         */
        uv: number[] | null;
        /**
         * @en Create a DrawTextureCmd instance
         * @param texture The texture to be drawn
         * @param x X-axis offset
         * @param y Y-axis offset
         * @param width Width of the texture
         * @param height Height of the texture
         * @param matrix Matrix information for transformation
         * @param alpha Alpha value
         * @param color Color filter
         * @param blendMode Blend mode
         * @param uv UV coordinates
         * @returns DrawTextureCmd instance
         * @zh 创建一个绘制单个贴图实例
         * @param texture 要绘制的纹理
         * @param x X轴偏移量
         * @param y Y轴偏移量
         * @param width 纹理的宽度
         * @param height 纹理的高度
         * @param matrix 矩阵信息，用于变换
         * @param alpha 透明度
         * @param color 颜色滤镜
         * @param blendMode 混合模式
         * @param uv UV坐标
         * @returns DrawTextureCmd实例
         */
        static create(texture: Texture, x: number, y: number, width: number, height: number, matrix: Matrix | null, alpha: number, color: string | null, blendMode: string | null, uv?: number[]): DrawTextureCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the draw texture command.
         * @param context The rendering context.
         * @param gx Starting X coordinate.
         * @param gy Starting Y coordinate.
         * @zh 执行绘制纹理命令。
         * @param context 渲染上下文。
         * @param gx 起始 X 坐标。
         * @param gy 起始 Y 坐标。
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawTextureCmd
         * @zh 绘制单个贴图命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Draw multiple textures based on coordinate sets
     * @zh 根据坐标集合绘制多个贴图
     */
    class DrawTexturesCmd {
        /**
         * @en Identifier for the DrawTexturesCmd
         * @zh 根据坐标集合绘制多个贴图命令的标识符
         */
        static ID: string;
        /**
         * @en The texture to be drawn.
         * @zh 要绘制的纹理。
         */
        texture: Texture;
        /**
         * @en Drawing times and coordinates.
         * @zh 绘制次数和坐标。
         */
        pos: ArrayLike<number>;
        /**
         * @en Additional vertex colors.
         * @zh 附加顶点色。
         */
        colors: number[];
        /**
         * @en Create a DrawTexturesCmd instance
         * @param texture The texture to be drawn
         * @param pos Drawing times and coordinates
         * @param colors Additional vertex colors
         * @returns DrawTexturesCmd instance
         * @zh 创建一个根据坐标集合绘制多个贴图实例
         * @param texture 要绘制的纹理
         * @param pos 绘制次数和坐标
         * @param colors 附加顶点色
         * @returns DrawTexturesCmd实例
         */
        static create(texture: Texture, pos: any[], colors: number[]): DrawTexturesCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the drawing textures command
         * @param context The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制多个纹理命令
         * @param context 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawTexturesCmd
         * @zh 根据坐标集合绘制多个贴图命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Draw triangles command
     * @zh 绘制三角形命令
     */
    class DrawTrianglesCmd {
        /**
         * @en Identifier for the DrawTrianglesCmd
         * @zh 绘制三角形命令的标识符
         */
        static ID: string;
        /**
         * @en The texture to be drawn.
         * @zh 要绘制的纹理。
         */
        texture: Texture | null;
        /**
         * @en X-axis offset.
         * @zh X轴偏移量。
         */
        x: number;
        /**
         * @en Y-axis offset.
         * @zh Y轴偏移量。
         */
        y: number;
        /**
         * @en Vertex array.
         * @zh 顶点数组。
         */
        vertices: Float32Array;
        /**
         * @en UV data.
         * @zh UV数据。
         */
        uvs: Float32Array;
        /**
         * @en Vertex indices.
         * @zh 顶点索引。
         */
        indices: Uint16Array;
        /**
         * @en Scaling matrix.
         * @zh 缩放矩阵。
         */
        matrix: Matrix | null;
        /**
         * @en Alpha value.
         * @zh 透明度值。
         */
        alpha: number;
        /**
         * @en Blend mode.
         * @zh 混合模式。
         */
        blendMode: string | null;
        /**
         * @en Color transformation.
         * @zh 颜色变换。
         */
        color: number | null;
        /**
         * @en Create a DrawTrianglesCmd instance
         * @param texture The texture to be drawn
         * @param x X-axis offset
         * @param y Y-axis offset
         * @param vertices Vertex array
         * @param uvs UV data
         * @param indices Vertex indices
         * @param matrix Scaling matrix
         * @param alpha Alpha value
         * @param color Color transformation
         * @param blendMode Blend mode
         * @returns DrawTrianglesCmd instance
         * @zh 创建一个绘制三角形命令实例
         * @param texture 要绘制的纹理
         * @param x X轴偏移量
         * @param y Y轴偏移量
         * @param vertices 顶点数组
         * @param uvs UV数据
         * @param indices 顶点索引
         * @param matrix 缩放矩阵
         * @param alpha 透明度值
         * @param color 颜色变换
         * @param blendMode 混合模式
         * @returns 绘制三角形命令实例
         */
        static create(texture: Texture, x: number, y: number, vertices: Float32Array, uvs: Float32Array, indices: Uint16Array, matrix: Matrix | null, alpha: number, color: string | number, blendMode: string | null): DrawTrianglesCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the drawing triangles command
         * @param context The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制三角形命令
         * @param context 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawTrianglesCmd
         * @zh 绘制三角形命令的标识符
         */
        get cmdID(): string;
        /**
         * @en Get the boundary points of the triangles
         * @zh 获取三角形的边界点
         */
        getBoundPoints(): number[];
    }
    /**
     * @en Draw text command
     * @zh 绘制文字命令
     */
    class FillTextCmd {
        /**
         * @en Identifier for the FillTextCmd
         * @zh 绘制文字命令的标识符
         */
        static ID: string;
        /**
         * @en The x position of the start of the text (relative to the canvas).
         * @zh 开始绘制文本的 x 坐标位置（相对于画布）。
         */
        x: number;
        /**
         * @en The y position of the start of the text (relative to the canvas).
         * @zh 开始绘制文本的 y 坐标位置（相对于画布）。
         */
        y: number;
        private _text;
        private _wordText;
        private _font;
        private _color;
        private _strokeColor;
        private _stroke;
        private _align;
        private _fontObj;
        private _loosyBound;
        /**
         * @en Text content
         * @zh 文本内容
         */
        get text(): string;
        set text(value: string);
        /**
         * @en Stroke color
         * @zh 描边颜色
         */
        get strokeColor(): string;
        set strokeColor(value: string);
        /**
         * @en Stroke width
         * @zh 描边宽度
         */
        get stroke(): number;
        set stroke(value: number);
        /**
         * @en Text alignment
         * @zh 对齐方式
         */
        get align(): number;
        set align(value: number);
        /**
         * @en Create a FillTextCmd instance
         * @param text Text content
         * @param x X position
         * @param y Y position
         * @param font Font
         * @param color Text color
         * @param align Alignment
         * @param stroke Stroke width
         * @param strokeColor Stroke color
         * @returns FillTextCmd instance
         * @zh 创建绘制文本的命令的实例
         * @param text 文本内容
         * @param x x位置
         * @param y y位置
         * @param font 字体
         * @param color 文本颜色
         * @param align 对齐方式
         * @param stroke 描边宽度
         * @param strokeColor 描边颜色
         * @returns 绘制文本的命令实例
         */
        static create(text: string | WordText | null, x: number, y: number, font: string, color: string | null, align: string, stroke: number, strokeColor: string | null): FillTextCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @private
         * @en Execute the drawing text command
         * @param context The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制文本命令
         * @param context 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en The identifier for the FillTextCmd
         * @zh 绘制文字命令的标识符
         */
        get cmdID(): string;
        /**
         * @en Define the font size and font, e.g., "20px Arial".
         * @zh 定义字号和字体，比如"20px Arial"。
         */
        get font(): string;
        set font(value: string);
        /**
         * @en Define the text color, e.g., "#ff0000".
         * @zh 定义文本颜色，比如"#ff0000"。
         */
        get color(): string;
        set color(value: string);
        /**
         * @en Gets the bounding points of the text element. Calculates and returns an array of points representing the bounding box of the text.
         * @returns An array of numbers representing the bounding points.
         * @zh 获取文本元素的边界点。计算并返回表示文本边界框的点数组。
         * @returns 表示边界点的数字数组。
         */
        getBoundPoints(): number[];
    }
    /**
     * @en Fill texture command
     * @zh 填充贴图命令
     */
    class FillTextureCmd {
        /**
         * @en Identifier for the FillTextureCmd
         * @zh 填充贴图命令的标识符
         */
        static ID: string;
        /**
         * @en The texture to be filled.
         * @zh 要填充的纹理。
         */
        texture: Texture;
        /**
         * @en X-axis offset.
         * @zh X轴偏移量。
         */
        x: number;
        /**
         * @en Y-axis offset.
         * @zh Y轴偏移量。
         */
        y: number;
        /**
         * @en (Optional) Width of the filled area.
         * @zh （可选）填充区域的宽度。
         */
        width: number;
        /**
         * @en (Optional) Height of the filled area.
         * @zh （可选）填充区域的高度。
         */
        height: number;
        /**
         * @en (Optional) Fill type: repeat|repeat-x|repeat-y|no-repeat
         * @zh （可选）填充类型：repeat|repeat-x|repeat-y|no-repeat
         */
        type?: string;
        /**
         * @en (Optional) Texture offset
         * @zh （可选）贴图纹理偏移
         */
        offset?: Point;
        /**
         * @en Whether the position and size are percentages
         * @zh 位置和大小是否是百分比
         */
        percent: boolean;
        /**
         * @en (Optional) Drawing color
         * @zh （可选）绘图颜色
         */
        color: number;
        /**
         * @zh 创建绘制填充贴图的命令实例
         * @param texture 要填充的纹理
         * @param x X轴偏移量
         * @param y Y轴偏移量
         * @param width 填充区域的宽度
         * @param height 填充区域的高度
         * @param type 填充类型
         * @param offset 贴图纹理偏移
         * @param color 绘图颜色
         * @param percent 宽高是否采用百分比
         * @returns FillTextureCmd实例
         * @en Create a FillTextureCmd instance
         * @param texture The texture to be filled
         * @param x X-axis offset
         * @param y Y-axis offset
         * @param width Width of the filled area
         * @param height Height of the filled area
         * @param type Fill type
         * @param offset Texture offset
         * @param color Drawing color
         * @param percent Whether the width and height are percentages?
         * @returns FillTextureCmd instance
         */
        static create(texture: Texture, x: number, y: number, width: number, height: number, type: string, offset: Point, color: string, percent?: boolean): FillTextureCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the fill texture command
         * @param context The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制填充贴图命令
         * @param context 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en The identifier for the FillTextureCmd
         * @zh 填充贴图命令的标识符
         */
        get cmdID(): string;
        /**
         * @en Get the vertex data of the bounding box
         * @param sp The sprite that draws the command
         * @returns Array of vertex data
         * @zh 获取包围盒的顶点数据
         * @param sp 绘制命令的精灵对象
         * @returns 顶点数据数组
         */
        getBoundPoints(sp?: {
            width: number;
            height?: number;
        }): number[];
    }
    /**
     * @en Restore command, used in conjunction with save
     * @zh 恢复命令，与save配套使用
     */
    class RestoreCmd {
        /**
         * @en Identifier for the RestoreCmd
         * @zh 恢复命令的标识符
         */
        static ID: string;
        /**
         * @en Create a RestoreCmd instance
         * @returns RestoreCmd instance
         * @zh 创建一个恢复命令实例
         * @returns 恢复命令实例
         */
        static create(): RestoreCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the restore command
         * @param context The rendering context
         * @zh 执行恢复命令
         * @param context 渲染上下文
         */
        run(context: Context): void;
        /**
         * @en The identifier for the RestoreCmd
         * @zh 恢复命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Rotate command
     * @zh 旋转命令
     */
    class RotateCmd {
        /**
         * @en Identifier for the RotateCmd
         * @zh 旋转命令的标识符
         */
        static ID: string;
        /**
         * @en Rotation angle in radians.
         * @zh 旋转角度，以弧度计。
         */
        angle: number;
        /**
         * @en (Optional) Horizontal axis point coordinates.
         * @zh （可选）水平方向轴心点坐标。
         */
        pivotX: number;
        /**
         * @en (Optional) Vertical axis point coordinates.
         * @zh （可选）垂直方向轴心点坐标。
         */
        pivotY: number;
        /**
         * @en Create a RotateCmd instance
         * @param angle Rotation angle in radians
         * @param pivotX Horizontal axis point coordinates.
         * @param pivotY Vertical axis point coordinates.
         * @returns RotateCmd instance
         * @zh 创建一个旋转命令实例
         * @param angle 旋转角度，以弧度计。
         * @param pivotX 水平方向轴心点坐标。
         * @param pivotY 垂直方向轴心点坐标。
         * @returns 旋转命令实例
         */
        static create(angle: number, pivotX: number, pivotY: number): RotateCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the rotate command
         * @param context The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行旋转命令
         * @param context 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en The identifier for the RotateCmd
         * @zh 旋转命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Save command, used in conjunction with restore
     * @zh 存储命令，与restore配套使用
     */
    class SaveCmd {
        /**
         * @en Identifier for the SaveCmd
         * @zh 存储命令的标识符
         */
        static ID: string;
        /**
         * @en Create a SaveCmd instance
         * @returns SaveCmd instance
         * @zh 创建一个存储命令实例
         * @returns 存储命令实例
         */
        static create(): SaveCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the save command
         * @param context The rendering context
         * @zh 执行存储命令
         * @param context 渲染上下文
         */
        run(context: Context): void;
        /**
         * @en The identifier for the SaveCmd
         * @zh 存储命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Scale command
     * @zh 缩放命令
     */
    class ScaleCmd {
        /**
         * @en Identifier for the ScaleCmd
         * @zh 缩放命令的标识符
         */
        static ID: string;
        /**
         * @en Horizontal scaling value.
         * @zh 水平方向缩放值。
         */
        scaleX: number;
        /**
         * @en Vertical scaling value.
         * @zh 垂直方向缩放值。
         */
        scaleY: number;
        /**
         * @en (Optional) Horizontal axis point coordinates.
         * @zh （可选）水平方向轴心点坐标。
         */
        pivotX: number;
        /**
         * @en (Optional) Vertical axis point coordinates.
         * @zh （可选）垂直方向轴心点坐标。
         */
        pivotY: number;
        /**
         * @en Create a ScaleCmd instance
         * @param scaleX Horizontal scaling value
         * @param scaleY Vertical scaling value
         * @param pivotX Horizontal axis point coordinates
         * @param pivotY Vertical axis point coordinates
         * @returns ScaleCmd instance
         * @zh 创建一个缩放命令实例
         * @param scaleX 水平方向缩放值
         * @param scaleY 垂直方向缩放值
         * @param pivotX 水平方向轴心点坐标
         * @param pivotY 垂直方向轴心点坐标
         * @returns 缩放命令实例
         */
        static create(scaleX: number, scaleY: number, pivotX: number, pivotY: number): ScaleCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the scale command
         * @param context The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行缩放命令
         * @param context 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en The identifier for the ScaleCmd
         * @zh 缩放命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Transform command
     * @zh 矩阵变换命令
     */
    class TransformCmd {
        /**
         * @en Identifier for the TransformCmd
         * @zh 矩阵变换命令的标识符
         */
        static ID: string;
        /**
         * @en The transformation matrix.
         * @zh 变换矩阵。
         */
        matrix: Matrix;
        /**
         * @en (Optional) Horizontal axis point coordinates.
         * @zh （可选）水平方向轴心点坐标。
         */
        pivotX: number;
        /**
         * @en (Optional) Vertical axis point coordinates.
         * @zh （可选）垂直方向轴心点坐标。
         */
        pivotY: number;
        /**
         * @en Create a TransformCmd instance
         * @param matrix The transformation matrix
         * @param pivotX Horizontal axis point coordinates
         * @param pivotY Vertical axis point coordinates
         * @returns TransformCmd instance
         * @zh 创建一个矩阵变换命令实例
         * @param matrix 变换矩阵
         * @param pivotX 水平方向轴心点坐标
         * @param pivotY 垂直方向轴心点坐标
         * @returns 矩阵变换命令实例
         */
        static create(matrix: Matrix, pivotX: number, pivotY: number): TransformCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the transform command
         * @param context The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行矩阵变换命令
         * @param context 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(context: Context, gx: number, gy: number): void;
        /**
         * @en The identifier for the TransformCmd
         * @zh 矩阵变换命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Translate command
     * @zh 位移命令
     */
    class TranslateCmd {
        /**
         * @en Identifier for the TranslateCmd
         * @zh 位移命令的标识符
         */
        static ID: string;
        /**
         * @en The value to be added to the horizontal coordinate (x).
         * @zh 添加到水平坐标（x）上的值。
         */
        tx: number;
        /**
         * @en The value to be added to the vertical coordinate (y).
         * @zh 添加到垂直坐标（y）上的值。
         */
        ty: number;
        /**
         * @en Create a TranslateCmd instance
         * @param tx The value to be added to the horizontal coordinate
         * @param ty The value to be added to the vertical coordinate
         * @returns TranslateCmd instance
         * @zh 创建一个位移命令实例
         * @param tx 要添加到水平坐标的值
         * @param ty 要添加到垂直坐标的值
         * @returns 位移命令实例
         */
        static create(tx: number, ty: number): TranslateCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the translate command
         * @param context The rendering context
         * @zh 执行位移命令
         * @param context 渲染上下文
         */
        run(context: Context): void;
        /**
         * @en The identifier for the TranslateCmd
         * @zh 位移命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Sprite style
     * @zh 精灵样式
     */
    class SpriteStyle {
        static readonly EMPTY: Readonly<SpriteStyle>;
        /**
         * @en Horizontal scaling
         * @zh 水平缩放
         */
        scaleX: number;
        /**
         * @en Vertical scaling
         * @zh 垂直缩放
         */
        scaleY: number;
        /**
         * @en Horizontal skew angle
         * @zh 水平倾斜角度
         */
        skewX: number;
        /**
         * @en Vertical skew angle
         * @zh 垂直倾斜角度
         */
        skewY: number;
        /**
         * @en X-axis pivot point
         * @zh X轴心点
         */
        pivotX: number;
        /**
         * @en Y-axis pivot point
         * @zh Y轴心点
         */
        pivotY: number;
        /**
         * @en Rotation angle
         * @zh 旋转角度
         */
        rotation: number;
        /**
         * @en Transparency
         * @zh 透明度
         */
        alpha: number;
        /**
         * @en Scroll area
         * @zh 滚动区域
         */
        scrollRect: Rectangle;
        /**
         * @en Viewport
         * @zh 视口
         */
        viewport: Rectangle;
        /**
         * @en Hit area
         * @zh 点击区域
         */
        hitArea: IHitArea;
        /**
         * @en Dragging
         * @zh 滑动
         */
        dragging: Dragging;
        /**
         * @en Blend mode
         * @zh 混合模式
         */
        blendMode: string;
        constructor();
        /**
         * @en Reset for easy reuse next time
         * @zh 重置，方便下次复用
         */
        reset(): SpriteStyle;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Create SpriteStyle object pool instance
         * @zh 创建SpriteStyle对象池实例
         */
        static create(): SpriteStyle;
    }
    /**
     * @en Text style class
     * @zh 文本的样式类
     */
    class TextStyle {
        /**
         * @en Font
         * @zh 字体
         */
        font: string;
        /**
         * @en Font size
         * @zh 字号
         */
        fontSize: number;
        /**
         * @en Text color
         * @zh 文字颜色
         */
        color: string;
        /**
         * @en Whether the text is bold
         * @zh 是否为粗体
         */
        bold: boolean;
        /**
         * @en Whether the text is italic
         * @zh 是否为斜体
         */
        italic: boolean;
        /**
         * @en Whether to show underline
         * @zh 是否显示下划线
         */
        underline: boolean;
        /**
         * @en Underline color
         * @zh 下划线颜色
         */
        underlineColor: string;
        /**
         * @en Whether to display the strikethrough.
         * @zh 是否显示删除线。
         */
        strikethrough: boolean;
        /**
         * @en The color of the strikethrough.
         * @zh 删除线颜色。
         */
        strikethroughColor: string;
        /**
         * @en Indicates the horizontal alignment of text paragraphs using this text format
         * @zh 表示使用此文本格式的文本段落的水平对齐方式
         * @default "left"
         */
        align: string;
        /**
         * @en Indicates the vertical alignment of text paragraphs using this text format
         * @zh 表示使用此文本格式的文本段落的垂直对齐方式
         * @default "top"
         */
        valign: string;
        /**
         * @en Alignment of images and text in mixed content. Possible values are top, middle, bottom
         * @zh 图文混排时图片和文字的对齐方式。可选值是top, middle, bottom
         */
        alignItems: string;
        /**
         * @en Vertical line spacing (in pixels)
         * @zh 垂直行间距（以像素为单位）
         */
        leading: number;
        /**
         * @en Stroke width (in pixels). Default is 0, meaning no stroke
         * @zh 描边宽度（以像素为单位）。默认值0，表示不描边
         * @default 0
         */
        stroke: number;
        /**
         * @en Stroke color, represented as a string
         * @zh 描边颜色，以字符串表示
         * @default "#000000"
         */
        strokeColor: string;
        constructor();
    }
    /**
     * @en Effect template. Used to add animation effects to specified target objects. Each effect has a unique target object, while the same object can add multiple effects. When one effect starts playing, other effects will automatically stop playing.
     * @zh 动效模板。用于为指定目标对象添加动画效果。每个动效有唯一的目标对象，而同一个对象可以添加多个动效。当一个动效开始播放时，其他动效会自动停止播放。
     */
    class EffectAnimation extends FrameAnimation {
        /**
         * 动效开始事件。
         */
        private static EFFECT_BEGIN;
        private _target;
        private _playEvent;
        private _initData;
        private _aniKeys;
        private _effectClass;
        /**
         * @en The target object of this instance. Controls the property changes of the target object through this instance.
         * @zh 本实例的目标对象。通过本实例控制目标对象的属性变化。
         */
        get target(): any;
        set target(v: any);
        private _onOtherBegin;
        /**
         * @en The event name to trigger the animation. This instance will listen for the specified event of the target object and play the corresponding animation effect when triggered.
         * @zh 触发动画的事件名称。本实例会侦听目标对象的指定事件，触发后播放相应动画效果。
         */
        set playEvent(event: string);
        private _addEvent;
        private _onPlayAction;
        /**
         * @en Play the animation effect.
         * @param start The starting position of the animation. Default is 0.
         * @param loop Whether to loop the animation. Default is true.
         * @param name The name of the animation to play. Default is an empty string.
         * @zh 播放动画效果。
         * @param start 动画的起始位置。默认为0。
         * @param loop 是否循环播放动画。默认为true。
         * @param name 要播放的动画名称。默认为空字符串。
         */
        play(start?: any, loop?: boolean, name?: string): void;
        private _recordInitData;
        /**
         * @en Provide the path of the class that provides the data.
         * @zh 提供数据的类的路径。
         */
        set effectClass(classStr: string);
        /**
         * @en The UI data containing animation information.
         * @zh 包含动画信息的UI数据。
         */
        set effectData(uiData: any);
        protected _displayToIndex(value: number): void;
        protected _displayNodeToFrame(node: any, frame: number, targetDic?: any): void;
        protected _calculateKeyFrames(node: any): void;
    }
    /**
     * @en Node keyframe animation playback class. Parses and plays node animations created in the IDE.
     * @zh 节点关键帧动画播放类。解析播放IDE内制作的节点动画。
     */
    class FrameAnimation extends AnimationBase {
        private static _sortIndexFun;
        protected _usedFrames: any[];
        constructor();
        /**
         * @en Clears the animation data and resets the animation to its initial state.
         * @returns The instance of the AnimationBase.
         * @zh 清除动画数据并将动画重置为初始状态。
         * @returns AnimationBase 实例。
         */
        clear(): AnimationBase;
        protected _displayToIndex(value: number): void;
        /**
         * 将节点设置到某一帧的状态
         * @param node 节点ID
         * @param frame
         * @param targetDic 节点表
         */
        protected _displayNodeToFrame(node: any, frame: number, targetDic?: any): void;
        /**
         * @en Calculate frame data
         * @zh 计算帧数据
         */
        private _calculateDatas;
        /**
         * @en Calculate the frame data of a node
         * @zh 计算某个节点的帧数据
         */
        protected _calculateKeyFrames(node: any): void;
        /**
         * @en Reset nodes to restore them to their state before the animation, facilitating control by other animations.
         * This method iterates through all nodes in the animation data, resetting their properties to initial values.
         * @zh 重置节点，使节点恢复到动画之前的状态，方便其他动画控制。
         * 此方法遍历动画数据中的所有节点，将它们的属性重置为初始值。
         */
        resetNodes(): void;
        /**
         * @en Calculate the frame data of a node's property
         * @zh 计算节点某个属性的帧数据
         */
        private _calculateNodePropFrames;
        private _dealKeyFrame;
        /**
         * @en Calculate the frame data between two key frames
         * @zh 计算两个关键帧直接的帧数据
         */
        private _calculateFrameValues;
    }
    /**
     * @ignore
     * @en Graphics animation parser
     * @zh Graphics动画解析器
     */
    class GraphicAnimation extends FrameAnimation {
        /**
         * @en List of animations
         * @zh 动画列表
         */
        animationList: any[];
        /**
         * @en Dictionary of animations
         * @zh 动画字典
         */
        animationDic: any;
        protected _nodeList: any[];
        protected _nodeDefaultProps: any;
        protected _gList: any[];
        protected _nodeIDAniDic: any;
        protected static _drawTextureCmd: any[];
        protected static _temParam: any[];
        private static _I;
        private static _rootMatrix;
        private _rootNode;
        protected _nodeGDic: any;
        private _parseNodeList;
        private _calGraphicData;
        private _createGraphicData;
        protected _createFrameGraphic(frame: number): any;
        protected _updateNodeGraphic(node: any, frame: number, parentTransfrom: Matrix, g: Graphics, alpha?: number): void;
        protected _updateNoChilds(tNodeG: GraphicNode, g: Graphics): void;
        protected _updateNodeGraphic2(node: any, frame: number, g: Graphics): void;
        protected _calculateKeyFrames(node: any): void;
        protected getNodeDataByID(nodeID: number): any;
        protected _getParams(obj: any, params: any[], frame: number, obj2: any): any[];
        private _getObjVar;
        protected _getNodeGraphicData(nodeID: number, frame: number, rst: GraphicNode): GraphicNode;
        private static _tempMt;
        protected _getTextureByUrl(url: string): any;
        /**
         * @en Set animation data
         * @param uiView The UI view containing animation data
         * @param aniName The name of the animation to set
         * @zh 设置动画数据
         * @param uiView 包含动画数据的UI视图
         * @param aniName 要设置的动画名称
         */
        setAniData(uiView: any, aniName?: string): void;
        /**
         * @en Parse animation data
         * @param aniData The animation data to parse
         * @returns Parsed animation frame object
         * @zh 解析动画数据
         * @param aniData 要解析的动画数据
         * @returns 解析后的动画帧对象
         */
        parseByData(aniData: any): any;
        /**
         * @en Set up animation data
         * This method processes the animations in the UI view, creating a list and dictionary of animation frames.
         * @param uiView The UI view containing animation data
         * @zh 设置动画数据
         * 此方法处理UI视图中的动画，创建动画帧的列表和字典。
         * @param uiView 包含动画数据的UI视图
         */
        setUpAniData(uiView: any): void;
        protected _clear(): void;
        /**
         * @en Parse animation by data
         * @param animationObject The animation object to parse
         * @returns Parsed animation data
         * @zh 通过数据解析动画
         * @param animationObject 要解析的动画对象
         * @returns 解析后的动画数据
         */
        static parseAnimationByData(animationObject: any): any;
        /**
         * @en Parse animation data
         * @param aniData The animation data to parse
         * @returns An object containing parsed animation list and dictionary
         * @zh 解析动画数据
         * @param aniData 要解析的动画数据
         * @returns 包含解析后的动画列表和字典的对象
         */
        static parseAnimationData(aniData: any): any;
    }
    /**
     * @en The Graphics class is used to create drawing display objects. Graphics can draw multiple bitmaps or vector graphics simultaneously, and can also combine instructions such as save, restore, transform, scale, rotate, translate, alpha, etc. to change the drawing effect.
     * Graphics is stored as a command stream and can be accessed through the cmds property. Graphics is a lighter object than Sprite, and proper use can improve application performance (for example, changing a large number of node drawings to a collection of Graphics commands of one node can reduce the consumption of creating a large number of nodes).
     * @zh Graphics 类用于创建绘图显示对象。Graphics可以同时绘制多个位图或者矢量图，还可以结合save，restore，transform，scale，rotate，translate，alpha等指令对绘图效果进行变化。
     * Graphics以命令流方式存储，可以通过cmds属性访问所有命令流。Graphics是比Sprite更轻量级的对象，合理使用能提高应用性能(比如把大量的节点绘图改为一个节点的Graphics命令集合，能减少大量节点创建消耗)。
     */
    class Graphics {
        /**
         * @en Add global Uniform Data Map
         * @param propertyID The ID of the property
         * @param propertyKey The key of the property
         * @param uniformtype The type of the uniform
         * @zh 添加全局Uniform数据映射
         * @param propertyID 属性ID
         * @param propertyKey 属性键
         * @param uniformtype Uniform类型
         */
        static add2DGlobalUniformData(propertyID: number, propertyKey: string, uniformtype: ShaderDataType): void;
        /**
         * @deprecated
         * @en Global shaderData,deprecated  use Scene ShaderData replace
         * @zh 全局着色器数据,请使用scene的ShaderData设置全局值
         */
        static get globalShaderData(): ShaderData;
        private _cmds;
        protected _vectorgraphArray: any[] | null;
        private _graphicBounds;
        private _material;
        /**@ignore */
        constructor();
        /**
         * @en Destroy this object.
         * @zh 销毁此对象。
         */
        destroy(): void;
        /**
         * @en Clear drawing commands.
         * @param recoverCmds Whether to recycle the drawing instruction array. If set to true, the instruction array will be recycled to save memory. It is recommended to set it to true for recycling, but if you manually reference the array, recycling is not recommended.
         * @zh 清空绘制命令。
         * @param recoverCmds 是否回收绘图指令数组。设置为true，则对指令数组进行回收以节省内存开销。建议设置为true进行回收，但如果手动引用了数组，不建议回收。
         */
        clear(recoverCmds?: boolean): void;
        /** @ignore */
        _clearBoundsCache(onSizeChanged?: boolean): void;
        /**@private */
        private _initGraphicBounds;
        /**
         * @en Command flow. All drawing commands are stored.
         * @zh 命令流。存储了所有绘制命令。
         */
        get cmds(): IGraphicCMD[];
        set cmds(value: IGraphicCMD[]);
        /**
         * @zh 添加到命令流。
         * @param cmd 要被添加的命令。
         * @param index （可选）插入的索引。
         * @en Save to the command stream.
         * @param cmd Add the command to the command stream.
         * @param index (Optional) The index to be inserted.
         */
        addCmd(cmd: any): any;
        /**
         * @en Remove a specific command from the command list.
         * @param cmd The command to be removed.
         * @zh 从命令列表中移除特定的命令。
         * @param cmd 要移除的命令。
         */
        removeCmd(cmd: any): void;
        /**
         * @en Get the position and size information matrix (CPU-intensive, frequent use may cause lag, use sparingly).
         * @param realSize (Optional) Use the real size of the image, default is false.
         * @returns A Rectangle object composed of position and size.
         * @zh 获取位置及宽高信息矩阵(比较耗CPU，频繁使用会造成卡顿，尽量少用)。
         * @param realSize （可选）使用图片的真实大小，默认为false。
         * @returns 位置与宽高组成的一个 Rectangle 对象。
         */
        getBounds(realSize?: boolean): Rectangle;
        /**
         * @en Get the list of endpoints.
         * @param realSize (Optional) Use the real size of the image, default is false.
         * @returns An array of endpoint coordinates.
         * @zh 获取端点列表。
         * @param realSize （可选）使用图片的真实大小，默认为false。
         * @returns 端点坐标的数组。
         */
        getBoundPoints(realSize?: boolean): any[];
        /**
         * @en The material of the graphics object.
         * @zh 图形对象的材质。
         */
        get material(): Material;
        set material(value: Material);
        /**
         * @en Draw a single image
         * @param texture The texture to draw
         * @param x (Optional) X-axis offset. Default is 0.
         * @param y (Optional) Y-axis offset. Default is 0.
         * @param width (Optional) Width of the image. Default is null.
         * @param height (Optional) Height of the image. Default is null.
         * @param color (Optional) Color of the image. Default is null.
         * @zh 绘制单独图片
         * @param texture 要绘制的纹理
         * @param x （可选）X轴偏移量。默认为0。
         * @param y （可选）Y轴偏移量。默认为0。
         * @param width （可选）图片宽度。默认为null。
         * @param height （可选）图片高度。默认为null。
         * @param color （可选）图片颜色。默认为null。
         */
        drawImage(texture: Texture, x?: number, y?: number, width?: number, height?: number, color?: string): DrawImageCmd | null;
        /**
         * @en Draw a texture. More powerful than drawImage but less performant.
         * @param texture The texture to draw
         * @param x (Optional) X-axis offset. Default is 0.
         * @param y (Optional) Y-axis offset. Default is 0.
         * @param width (Optional) Width of the texture. Default is null.
         * @param height (Optional) Height of the texture. Default is null.
         * @param matrix (Optional) Matrix information. Default is null.
         * @param alpha (Optional) Transparency. Default is 1.
         * @param color (Optional) Color filter. Default is null.
         * @param blendMode (Optional) Blend mode. Default is null.
         * @param uv (Optional) UV coordinates. Default is undefined.
         * @zh 绘制纹理，相比drawImage功能更强大，性能会差一些
         * @param texture 要绘制的纹理
         * @param x （可选）X轴偏移量。默认为0。
         * @param y （可选）Y轴偏移量。默认为0。
         * @param width （可选）纹理宽度。默认为null。
         * @param height （可选）纹理高度。默认为null。
         * @param matrix （可选）矩阵信息。默认为null。
         * @param alpha （可选）透明度。默认为1。
         * @param color （可选）颜色滤镜。默认为null。
         * @param blendMode （可选）混合模式。默认为null。
         * @param uv （可选）UV坐标。默认为undefined。
         */
        drawTexture(texture: Texture | null, x?: number, y?: number, width?: number, height?: number, matrix?: Matrix | null, alpha?: number, color?: string | null, blendMode?: string | null, uv?: number[]): DrawTextureCmd | null;
        /**
         * @en Batch draw the same texture multiple times.
         * @param texture The texture to draw
         * @param pos Array of positions for each draw
         * @param colors (Optional) Array of colors for each draw
         * @zh 批量绘制同样纹理
         * @param texture 要绘制的纹理
         * @param pos 绘制次数和坐标数组
         * @param colors （可选）图片颜色数组
         */
        drawTextures(texture: Texture, pos: any[], colors?: number[]): DrawTexturesCmd | null;
        /**
         * @en Draw geometry
         * @param geo Render geometry element
         * @param material Material to use for rendering
         * @zh 绘制几何体
         * @param geo 渲染几何元素
         * @param material 用于渲染的材质
         */
        drawGeo(geo: IRenderGeometryElement, material: Material): any;
        /**
         * @en Draw multiple geometries
         * @param geo Render geometry element
         * @param elements Array of [Material, startIndex, count] tuples
         * @zh 绘制多个几何体
         * @param geo 渲染几何元素
         * @param elements [材质, 起始索引, 数量] 元组数组
         */
        drawGeos(geo: IRenderGeometryElement, elements: [
            Material,
            number,
            number
        ][]): any;
        /**
         * @en Draw a group of triangles
         * @param texture The texture to use
         * @param x X-axis offset
         * @param y Y-axis offset
         * @param vertices Vertex array
         * @param uvs UV data. Note that the UV coordinates are used directly. If the texture is from an atlas, these UVs are also from the atlas and don't need conversion.
         * @param indices Vertex indices
         * @param matrix (Optional) Scale matrix. Default is null.
         * @param alpha (Optional) Alpha value. Default is 1.
         * @param color (Optional) Color transformation. Default is null.
         * @param blendMode (Optional) Blend mode. Default is null.
         * @zh 绘制一组三角形
         * @param texture 要使用的纹理
         * @param x X轴偏移量
         * @param y Y轴偏移量
         * @param vertices 顶点数组
         * @param uvs UV数据。注意这里的uv是直接使用的，如果texture是图集中的资源，这里的uv也是图集中的，即不需要转换直接用。
         * @param indices 顶点索引
         * @param matrix （可选）缩放矩阵。默认为null。
         * @param alpha （可选）alpha值。默认为1。
         * @param color （可选）颜色变换。默认为null。
         * @param blendMode （可选）混合模式。默认为null。
         */
        drawTriangles(texture: Texture, x: number, y: number, vertices: Float32Array, uvs: Float32Array, indices: Uint16Array, matrix?: Matrix | null, alpha?: number, color?: string | number, blendMode?: string | null): DrawTrianglesCmd;
        /**
         * @zh 用纹理填充
         * @param texture 用于填充的纹理
         * @param x X轴偏移量
         * @param y Y轴偏移量
         * @param width （可选）宽度。默认为0。
         * @param height （可选）高度。默认为0。
         * @param type （可选）填充类型：'repeat'、'repeat-x'、'repeat-y'或'no-repeat'。默认为'repeat'。
         * @param offset （可选）贴图纹理偏移。默认为null。
         * @param color （可选）颜色。默认为null。
         * @param percent （可选）是否采用百分比。默认为false。
         * @en Fill with texture
         * @param texture The texture to use for filling
         * @param x X-axis offset
         * @param y Y-axis offset
         * @param width (Optional) Width. Default is 0.
         * @param height (Optional) Height. Default is 0.
         * @param type (Optional) Fill type: 'repeat', 'repeat-x', 'repeat-y', or 'no-repeat'. Default is 'repeat'.
         * @param offset (Optional) Texture offset. Default is null.
         * @param color (Optional) Color. Default is null.
         * @param percent (Optional) Whether to use percentage. Default is false.
         */
        fillTexture(texture: Texture, x: number, y: number, width?: number, height?: number, type?: string, offset?: Point | null, color?: string, percent?: boolean): FillTextureCmd | null;
        /**
         * @en Set the clipping area. Coordinates outside the clipping area will not be displayed.
         * @param x X-axis offset
         * @param y Y-axis offset
         * @param width Width of the clipping area
         * @param height Height of the clipping area
         * @zh 设置剪裁区域，超出剪裁区域的坐标不显示。
         * @param x X轴偏移量
         * @param y Y轴偏移量
         * @param width 剪裁区域的宽度
         * @param height 剪裁区域的高度
         */
        clipRect(x: number, y: number, width: number, height: number): ClipRectCmd;
        /**
         * @en Draw text on the canvas
         * @param text The text to output on the canvas
         * @param x The x-coordinate where to start drawing the text (relative to the canvas)
         * @param y The y-coordinate where to start drawing the text (relative to the canvas)
         * @param font Defines the font size and family, e.g., "20px Arial"
         * @param color Defines the text color, e.g., "#ff0000"
         * @param textAlign Text alignment. Possible values: "left", "center", "right"
         * @zh 在画布上绘制文本
         * @param text 在画布上输出的文本
         * @param x 开始绘制文本的x坐标位置（相对于画布）
         * @param y 开始绘制文本的y坐标位置（相对于画布）
         * @param font 定义字号和字体，例如"20px Arial"
         * @param color 定义文本颜色，例如"#ff0000"
         * @param textAlign 文本对齐方式。可选值："left"、"center"、"right"
         */
        fillText(text: string | WordText, x: number, y: number, font: string, color: string, textAlign: string): FillTextCmd;
        /**
         * @en Draw filled and stroked text on the canvas.
         * @param text The text to output on the canvas
         * @param x The x-coordinate where to start drawing the text (relative to the canvas)
         * @param y The y-coordinate where to start drawing the text (relative to the canvas)
         * @param font Defines the font and size, e.g., "20px Arial"
         * @param fillColor Defines the text color, e.g., "#ff0000"
         * @param textAlign Text alignment. Possible values: "left", "center", "right"
         * @param lineWidth Width of the stroke line
         * @param borderColor Defines the color of the text stroke
         * @zh 在画布上绘制"被填充且镶边的"文本。
         * @param text 在画布上输出的文本
         * @param x 开始绘制文本的x坐标位置（相对于画布）
         * @param y 开始绘制文本的y坐标位置（相对于画布）
         * @param font 定义字体和字号，例如"20px Arial"
         * @param fillColor 定义文本颜色，例如"#ff0000"
         * @param textAlign 文本对齐方式。可选值："left"、"center"、"right"
         * @param lineWidth 镶边线条宽度
         * @param borderColor 定义镶边文本颜色
         */
        fillBorderText(text: string | WordText, x: number, y: number, font: string, fillColor: string, textAlign: string, lineWidth: number, borderColor: string): FillTextCmd;
        /**
         * @en Draw text on the canvas (without fill). The default color of the text is black.
         * @param text The text to output on the canvas
         * @param x The x-coordinate where to start drawing the text (relative to the canvas)
         * @param y The y-coordinate where to start drawing the text (relative to the canvas)
         * @param font Defines the font and size, e.g., "20px Arial"
         * @param color Defines the text color, e.g., "#ff0000"
         * @param lineWidth Width of the line
         * @param textAlign Text alignment. Possible values: "left", "center", "right"
         * @zh 在画布上绘制文本（没有填色）。文本的默认颜色是黑色。
         * @param text 在画布上输出的文本
         * @param x 开始绘制文本的x坐标位置（相对于画布）
         * @param y 开始绘制文本的y坐标位置（相对于画布）
         * @param font 定义字体和字号，例如"20px Arial"
         * @param color 定义文本颜色，例如"#ff0000"
         * @param lineWidth 线条宽度
         * @param textAlign 文本对齐方式。可选值："left"、"center"、"right"
         */
        strokeText(text: string | WordText, x: number, y: number, font: string, color: string, lineWidth: number, textAlign: string): FillTextCmd;
        /**
         * @en Set the transparency.
         * @param alpha The transparency value
         * @zh 设置透明度。
         * @param alpha 透明度值
         */
        alpha(alpha: number): AlphaCmd;
        /**
         * @en Replace the current transformation matrix for drawing.
         * @param matrix The matrix
         * @param pivotX (Optional) X-coordinate of the pivot point. Default is 0.
         * @param pivotY (Optional) Y-coordinate of the pivot point. Default is 0.
         * @zh 替换绘图的当前转换矩阵。
         * @param matrix 矩阵
         * @param pivotX （可选）水平方向轴心点坐标。默认为0。
         * @param pivotY （可选）垂直方向轴心点坐标。默认为0。
         */
        transform(matrix: Matrix, pivotX?: number, pivotY?: number): TransformCmd;
        /**
         * @en Rotate the current drawing. (It's recommended to use transform for better performance)
         * @param angle The rotation angle in radians
         * @param pivotX (Optional) X-coordinate of the pivot point. Default is 0.
         * @param pivotY (Optional) Y-coordinate of the pivot point. Default is 0.
         * @zh 旋转当前绘图。(推荐使用transform，性能更高)
         * @param angle 旋转角度，以弧度计
         * @param pivotX （可选）水平方向轴心点坐标。默认为0。
         * @param pivotY （可选）垂直方向轴心点坐标。默认为0。
         */
        rotate(angle: number, pivotX?: number, pivotY?: number): RotateCmd;
        /**
         * @en Scale the current drawing to a larger or smaller size. (It's recommended to use transform for better performance)
         * @param scaleX Horizontal scaling value
         * @param scaleY Vertical scaling value
         * @param pivotX (Optional) X-coordinate of the pivot point. Default is 0.
         * @param pivotY (Optional) Y-coordinate of the pivot point. Default is 0.
         * @zh 缩放当前绘图至更大或更小。(推荐使用transform，性能更高)
         * @param scaleX 水平方向缩放值
         * @param scaleY 垂直方向缩放值
         * @param pivotX （可选）水平方向轴心点坐标。默认为0。
         * @param pivotY （可选）垂直方向轴心点坐标。默认为0。
         */
        scale(scaleX: number, scaleY: number, pivotX?: number, pivotY?: number): ScaleCmd;
        /**
         * @en Remap the (0,0) position on the canvas.
         * @param tx The value to add to the horizontal coordinate (x)
         * @param ty The value to add to the vertical coordinate (y)
         * @zh 重新映射画布上的 (0,0) 位置。
         * @param tx 添加到水平坐标（x）上的值
         * @param ty 添加到垂直坐标（y）上的值
         */
        translate(tx: number, ty: number): TranslateCmd;
        /**
         * @en Save the current state of the environment.
         * @zh 保存当前环境的状态。
         */
        save(): SaveCmd;
        /**
         * @en Return the previously saved path state and properties.
         * @zh 返回之前保存过的路径状态和属性。
         */
        restore(): RestoreCmd;
        /**
         * @en Replace text color.
         * @param color The new color
         * @zh 替换文本颜色。
         * @param color 新的颜色
         */
        replaceTextColor(color: string): void;
        /**
         * @en Load and display an image.
         * @param url The URL of the image
         * @param x (Optional) The x-coordinate where the image will be displayed. Default is 0.
         * @param y (Optional) The y-coordinate where the image will be displayed. Default is 0.
         * @param width (Optional) The width to display the image. Set to 0 to use the default image width. Default is null.
         * @param height (Optional) The height to display the image. Set to 0 to use the default image height. Default is null.
         * @param complete (Optional) The callback function to be called when the image is loaded
         * @zh 加载并显示一个图片。
         * @param url 图片地址
         * @param x （可选）显示图片的x位置。默认为0。
         * @param y （可选）显示图片的y位置。默认为0。
         * @param width （可选）显示图片的宽度，设置为0表示使用图片默认宽度。默认为null。
         * @param height （可选）显示图片的高度，设置为0表示使用图片默认高度。默认为null。
         * @param complete （可选）加载完成回调
         */
        loadImage(url: string, x?: number, y?: number, width?: number, height?: number, complete?: Function | null): void;
        /**
         * @en Draw a line.
         * @param fromX X-axis starting position
         * @param fromY Y-axis starting position
         * @param toX X-axis ending position
         * @param toY Y-axis ending position
         * @param lineColor Color of the line
         * @param lineWidth (Optional) Width of the line. Default is 1.
         * @zh 绘制一条线。
         * @param fromX X轴开始位置
         * @param fromY Y轴开始位置
         * @param toX X轴结束位置
         * @param toY Y轴结束位置
         * @param lineColor 线条颜色
         * @param lineWidth （可选）线条宽度。默认为1。
         */
        drawLine(fromX: number, fromY: number, toX: number, toY: number, lineColor: string, lineWidth?: number): DrawLineCmd;
        /**
         * @en Draw a series of line segments.
         * @param x X-axis position to start drawing
         * @param y Y-axis position to start drawing
         * @param points Collection of points for line segments. Format: [x1,y1,x2,y2,x3,y3...]
         * @param lineColor Color of the line segments, or gradient object for filling the drawing
         * @param lineWidth (Optional) Width of the line segments. Default is 1.
         * @zh 绘制一系列线段。
         * @param x 开始绘制的X轴位置
         * @param y 开始绘制的Y轴位置
         * @param points 线段的点集合。格式：[x1,y1,x2,y2,x3,y3...]
         * @param lineColor 线段颜色，或者填充绘图的渐变对象
         * @param lineWidth （可选）线段宽度。默认为1。
         */
        drawLines(x: number, y: number, points: any[], lineColor: any, lineWidth?: number): DrawLinesCmd | null;
        /**
         * @en Draw a series of curves.
         * @param x X-axis position to start drawing
         * @param y Y-axis position to start drawing
         * @param points Collection of points for curves. Format: [controlX, controlY, anchorX, anchorY...]
         * @param lineColor Color of the curves, or gradient object for filling the drawing
         * @param lineWidth (Optional) Width of the curves. Default is 1.
         * @zh 绘制一系列曲线。
         * @param x 开始绘制的X轴位置
         * @param y 开始绘制的Y轴位置
         * @param points 曲线的点集合，格式：[controlX, controlY, anchorX, anchorY...]
         * @param lineColor 曲线颜色，或者填充绘图的渐变对象
         * @param lineWidth （可选）曲线宽度。默认为1。
         */
        drawCurves(x: number, y: number, points: any[], lineColor: any, lineWidth?: number): DrawCurvesCmd;
        /**
         * @en Draw a rectangle.
         * @param x X-axis position to start drawing
         * @param y Y-axis position to start drawing
         * @param width Width of the rectangle
         * @param height Height of the rectangle
         * @param fillColor Fill color, or gradient object for filling the drawing
         * @param lineColor (Optional) Border color, or gradient object for filling the drawing. Default is null.
         * @param lineWidth (Optional) Border width. Default is 1.
         * @param percent Whether the position and size are percentage values
         * @returns DrawRectCmd object
         * @zh 绘制矩形。
         * @param x 开始绘制的X轴位置
         * @param y 开始绘制的Y轴位置
         * @param width 矩形宽度
         * @param height 矩形高度
         * @param fillColor 填充颜色，或者填充绘图的渐变对象
         * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象。默认为null。
         * @param lineWidth （可选）边框宽度。默认为1。
         * @param percent 位置和大小是否是百分比值
         * @returns DrawRectCmd对象
         */
        drawRect(x: number, y: number, width: number, height: number, fillColor: any, lineColor?: any, lineWidth?: number, percent?: boolean): DrawRectCmd;
        /**
         * @en Draw a rounded rectangle.
         * @param x X-axis position to start drawing
         * @param y Y-axis position to start drawing
         * @param width Width of the rounded rectangle
         * @param height Height of the rounded rectangle
         * @param lt Left-top corner radius
         * @param rt Right-top corner radius
         * @param lb Left-bottom corner radius
         * @param rb Right-bottom corner radius
         * @param fillColor Fill color, or gradient object for filling the drawing
         * @param lineColor (Optional) Border color, or gradient object for filling the drawing. Default is null.
         * @param lineWidth (Optional) Border width. Default is 1.
         * @param percent (Optional) Whether the position and size are percentage values
         * @zh 绘制圆角矩形。
         * @param x 开始绘制的X轴位置
         * @param y 开始绘制的Y轴位置
         * @param width 圆角矩形宽度
         * @param height 圆角矩形高度
         * @param lt 左上圆角
         * @param rt 右上圆角
         * @param lb 左下圆角
         * @param rb 右下圆角
         * @param fillColor 填充颜色，或者填充绘图的渐变对象
         * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象。默认为null。
         * @param lineWidth （可选）边框宽度。默认为1。
         * @param percent （可选）位置和大小是否是百分比值
         */
        drawRoundRect(x: number, y: number, width: number, height: number, lt: number, rt: number, lb: number, rb: number, fillColor: any, lineColor?: any, lineWidth?: number, percent?: boolean): any;
        /**
         * @en Draw a circle.
         * @param x X-axis position of the circle center
         * @param y Y-axis position of the circle center
         * @param radius Radius of the circle
         * @param fillColor Fill color, or gradient object for filling the drawing
         * @param lineColor (Optional) Border color, or gradient object for filling the drawing. Default is null.
         * @param lineWidth (Optional) Border width. Default is 1.
         * @zh 绘制圆形。
         * @param x 圆点X轴位置
         * @param y 圆点Y轴位置
         * @param radius 半径
         * @param fillColor 填充颜色，或者填充绘图的渐变对象
         * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象。默认为null。
         * @param lineWidth （可选）边框宽度。默认为1。
         */
        drawCircle(x: number, y: number, radius: number, fillColor: any, lineColor?: any, lineWidth?: number): DrawCircleCmd;
        /**
         * @en Draw an ellipse.
         * @param x X-axis position of the ellipse center
         * @param y Y-axis position of the ellipse center
         * @param width Horizontal radius
         * @param height Vertical radius
         * @param fillColor Fill color, or gradient object for filling the drawing
         * @param lineColor (Optional) Border color, or gradient object for filling the drawing
         * @param lineWidth (Optional) Border width
         * @param percent (Optional) Whether the position and size are percentage values
         * @zh 绘制椭圆形。
         * @param x 圆点X轴位置
         * @param y 圆点Y轴位置
         * @param width 横向半径
         * @param height 纵向半径
         * @param fillColor 填充颜色，或者填充绘图的渐变对象
         * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象
         * @param lineWidth （可选）边框宽度
         * @param percent （可选）位置和大小是否是百分比值
         */
        drawEllipse(x: number, y: number, width: number, height: number, fillColor: any, lineColor: any, lineWidth: number, percent?: boolean): DrawEllipseCmd;
        /**
         * @en Draw a pie.
         * @param x X-axis position to start drawing
         * @param y Y-axis position to start drawing
         * @param radius Radius of the pie
         * @param startAngle Start angle
         * @param endAngle End angle
         * @param fillColor Fill color, or gradient object for filling the drawing
         * @param lineColor (Optional) Border color, or gradient object for filling the drawing. Default is null.
         * @param lineWidth (Optional) Border width. Default is 1.
         * @zh 绘制扇形。
         * @param x 开始绘制的X轴位置
         * @param y 开始绘制的Y轴位置
         * @param radius 扇形半径
         * @param startAngle 开始角度
         * @param endAngle 结束角度
         * @param fillColor 填充颜色，或者填充绘图的渐变对象
         * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象。默认为null。
         * @param lineWidth （可选）边框宽度。默认为1。
         */
        drawPie(x: number, y: number, radius: number, startAngle: number, endAngle: number, fillColor: any, lineColor?: any, lineWidth?: number): DrawPieCmd;
        /**
         * @en Draw a polygon.
         * @param x X-axis position to start drawing
         * @param y Y-axis position to start drawing
         * @param points Collection of points for the polygon
         * @param fillColor Fill color, or gradient object for filling the drawing
         * @param lineColor (Optional) Border color, or gradient object for filling the drawing. Default is null.
         * @param lineWidth (Optional) Border width. Default is 1.
         * @zh 绘制多边形。
         * @param x 开始绘制的X轴位置
         * @param y 开始绘制的Y轴位置
         * @param points 多边形的点集合
         * @param fillColor 填充颜色，或者填充绘图的渐变对象
         * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象。默认为null。
         * @param lineWidth （可选）边框宽度。默认为1。
         */
        drawPoly(x: number, y: number, points: any[], fillColor: any, lineColor?: any, lineWidth?: number): DrawPolyCmd;
        /**
         * @en Draw a path.
         * @param x X-axis position to start drawing
         * @param y Y-axis position to start drawing
         * @param paths Collection of paths. Paths support the following format: [["moveTo",x,y],["lineTo",x,y],["arcTo",x1,y1,x2,y2,r],["closePath"]]
         * @param brush (Optional) Brush definition, supports the following settings: {fillStyle:"#FF0000"}
         * @param pen (Optional) Pen definition, supports the following settings: {strokeStyle,lineWidth,lineJoin:"bevel|round|miter",lineCap:"butt|round|square",miterLimit}
         * @zh 绘制路径。
         * @param x 开始绘制的X轴位置
         * @param y 开始绘制的Y轴位置
         * @param paths 路径集合，路径支持以下格式：[["moveTo",x,y],["lineTo",x,y],["arcTo",x1,y1,x2,y2,r],["closePath"]]
         * @param brush （可选）刷子定义，支持以下设置：{fillStyle:"#FF0000"}
         * @param pen （可选）画笔定义，支持以下设置：{strokeStyle,lineWidth,lineJoin:"bevel|round|miter",lineCap:"butt|round|square",miterLimit}
         */
        drawPath(x: number, y: number, paths: any[], brush?: any, pen?: any): DrawPathCmd;
        /**
         * @en Draw an image with nine-grid
         * @param texture The texture to draw
         * @param x (Optional) X-axis position. Default is 0.
         * @param y (Optional) Y-axis position. Default is 0.
         * @param width (Optional) Width of the image. Default is 0.
         * @param height (Optional) Height of the image. Default is 0.
         * @param sizeGrid Nine-grid information
         * @param color (Optional) Color to tint the image
         * @zh 绘制带九宫格的图片
         * @param texture 要绘制的纹理
         * @param x （可选）X轴位置。默认为0。
         * @param y （可选）Y轴位置。默认为0。
         * @param width （可选）图片宽度。默认为0。
         * @param height （可选）图片高度。默认为0。
         * @param sizeGrid 九宫格信息
         * @param color （可选）图片的着色颜色
         */
        draw9Grid(texture: Texture, x: number, y: number, width: number, height: number, sizeGrid: any[], color?: string): void;
    }
    /**
     * @ignore
     * @en Graphic bounds data class
     * @zh 图形边界数据类
     */
    class GraphicsBounds {
        private _temp;
        private _bounds;
        private _rstBoundPoints;
        private _cacheBounds;
        /**
         * @en Destroy
         * @zh 销毁
         */
        destroy(): void;
        /**
         * @en Create a new GraphicsBounds instance
         * @zh 创建一个新的GraphicsBounds实例
         */
        static create(): GraphicsBounds;
        /**
         * @en Reset data
         * @zh 重置数据
         */
        reset(): void;
        /**
         * @en Get the position and size information matrix (CPU intensive, frequent use may cause lag, use sparingly).
         * @param realSize (Optional) Use the real size of the image. Default is false.
         * @returns A Rectangle object composed of position and size.
         * @zh 获取位置及宽高信息矩阵(比较耗CPU，频繁使用会造成卡顿，尽量少用)。
         * @param realSize （可选）使用图片的真实大小，默认为false。
         * @returns 位置与宽高组成的一个Rectangle对象。
         */
        getBounds(realSize?: boolean): Rectangle;
        /**
         * @en Get the list of boundary points.
         * @param realSize (Optional) Use the real size of the image. Default is false.
         * @returns An array of boundary points.
         * @zh 获取边界点列表。
         * @param realSize （可选）使用图片的真实大小，默认为false。
         * @returns 边界点的数组。
         */
        getBoundPoints(realSize?: boolean): any[];
        private _getCmdPoints;
        private _switchMatrix;
    }
    /**
     * @en The Input class is used to create display objects to display and input text.
     * The Input class encapsulates the native text input box. Due to differences between browsers, there may be slight deviations between the position of the default text of this object and the position of the text when the user clicks to input.
     * - Event.INPUT: Dispatched when one or more text characters are input by the user.
     * - Event.CHANGE: Dispatched after the text has changed.
     * - Event.ENTER: Dispatched when the user presses the Enter key in the input field.
     * - Event.FOCUS: Dispatched when the display object receives focus.
     * - Event.BLUR: Dispatched when the display object loses focus.
     * @zh Input 类用于创建显示对象以显示和输入文本。
     * Input 类封装了原生的文本输入框，由于不同浏览器的差异，会导致此对象的默认文本的位置与用户点击输入时的文本的位置有少许的偏差。
     * - Event.INPUT: 当用户输入一个或多个文本字符时后调度。
     * - Event.CHANGE: 文本发生变化后调度。
     * - Event.ENTER: 用户在输入框内敲回车键后，将会调度 enter 事件。
     * - Event.FOCUS: 显示对象获得焦点后调度。
     * - Event.BLUR: 显示对象失去焦点后调度。
     */
    class Input extends Text {
        /**
         * @en Regular text field.
         * @zh 常规文本域。
         */
        static TYPE_TEXT: string;
        /**
         * @en Password type for password input fields.
         * @zh password 类型用于密码域输入。
         */
        static TYPE_PASSWORD: string;
        /**
         * @en Email type for input fields that should contain an e-mail address.
         * @zh email 类型用于应该包含 e-mail 地址的输入域。
         */
        static TYPE_EMAIL: string;
        /**
         * @en URL type for input fields that should contain a URL address.
         * @zh url 类型用于应该包含 URL 地址的输入域。
         */
        static TYPE_URL: string;
        /**
         * @en Number type for input fields that should contain a numeric value.
         * @zh number 类型用于应该包含数值的输入域。
         */
        static TYPE_NUMBER: string;
        /**
         * @en Range type for input fields that should contain a numeric value within a certain range.
         * The range type is displayed as a slider.
         * You can also set limitations on the accepted numbers.
         * @zh range 类型用于应该包含一定范围内数字值的输入域。
         * range 类型显示为滑动条。
         * 您还能够设定对所接受的数字的限定。
         */
        static TYPE_RANGE: string;
        /**
         * @en Select day, month, and year.
         * @zh 选取日、月、年。
         */
        static TYPE_DATE: string;
        /**
         * @en Select month and year.
         * @zh month - 选取月、年。
         */
        static TYPE_MONTH: string;
        /**
         * @en Select week and year.
         * @zh week - 选取周和年。
         */
        static TYPE_WEEK: string;
        /**
         * @en Select time (hours and minutes).
         * @zh time - 选取时间（小时和分钟）。
         */
        static TYPE_TIME: string;
        /**
         * @en Select time, day, month, year (UTC time).
         * @zh datetime - 选取时间、日、月、年（UTC 时间）。
         */
        static TYPE_DATE_TIME: string;
        /**
         * @en Select time, day, month, year (local time).
         * @zh datetime-local - 选取时间、日、月、年（本地时间）。
         */
        static TYPE_DATE_TIME_LOCAL: string;
        /**
         * @en Search type for search fields, such as site search or Google search.
         * The search field is displayed as a regular text field.
         * @zh search 类型用于搜索域，比如站点搜索或 Google 搜索。
         * search 域显示为常规的文本域。
         */
        static TYPE_SEARCH: string;
        protected static input: HTMLInputElement;
        protected static area: HTMLTextAreaElement;
        protected static inputElement: HTMLInputElement | HTMLTextAreaElement;
        protected static inputContainer: HTMLDivElement;
        protected static confirmButton: any;
        protected static promptStyleDOM: any;
        protected _focus: boolean;
        protected _multiline: boolean;
        protected _editable: boolean;
        protected _restrict: string;
        protected _restrictPattern: any;
        protected _maxChars: number;
        private _type;
        /**
         * @en Indicates whether the application is running in an iframe on iOS.
         * @zh 指示应用程序是否在iOS的iframe中运行。
         */
        static IOS_IFRAME: boolean;
        /**
         * @en Indicates whether the application uses the new input method.
         * @zh 指示应用程序是否使用新的输入方法。
         */
        static isAppUseNewInput: boolean;
        constructor();
        /**
         * @en Pop up the input method on mobile platforms after clicking the event.
         * @zh 移动平台单击事件触发后弹出输入法。
         */
        private static _popupInputMethod;
        private static _createInputElement;
        private static _initInput;
        private static _processInputting;
        private static _stopEvent;
        /**
         * @en Set the cursor position and select characters.
         * @param startIndex The starting position of the cursor.
         * @param endIndex The ending position of the cursor.
         * @zh 设置光标位置和选取字符。
         * @param startIndex 光标起始位置。
         * @param endIndex 光标结束位置。
         */
        setSelection(startIndex: number, endIndex: number): void;
        /**
         * @en Whether it's a multi-line input box.
         * @zh 是否是多行输入框。
         */
        get multiline(): boolean;
        set multiline(value: boolean);
        /**
         * @en Reference instance to input box
         * @zh 对输入框的引用实例。
         */
        get nativeInput(): HTMLInputElement | HTMLTextAreaElement;
        private _onUnDisplay;
        private _onMouseDown;
        /**
         * @en Sync the position of the input box when the Input instance changes during input.
         * @zh 在输入期间，如果 Input 实例的位置改变，调用_syncInputTransform同步输入框的位置。
         */
        private _syncInputTransform;
        /**
         * @en Selects all the text in the current instance.
         * @zh 选中当前实例的所有文本。
         */
        select(): void;
        /**
         * @en Whether the focus is on this instance.
         * Note: On mobile platforms, the keyboard may not immediately pop up when calling the focus interface.
         * On mobile platforms, focus is usually triggered by clicking on the canvas.
         * @zh 焦点是否在此实例上。
         * 注意：在移动平台上，调用 focus 接口可能无法立即弹出键盘。
         * 移动平台上通常是点击画布才会触发焦点。
         */
        get focus(): boolean;
        set focus(value: boolean);
        private _setInputMethod;
        private _focusIn;
        /**
         * @en Set the prompt color of DOM input box.
         * @zh 设置DOM输入框提示符颜色。
         */
        private _setPromptColor;
        private _focusOut;
        private _onKeyDown;
        /**
         * @en Specifically for mini-games (resolves the issue of content inconsistency between keyboard input box and game input box).
         * @param value The text value to be synchronized.
         * @zh 小游戏专用（解决键盘输入框内容和游戏输入框内容不同步的问题）。
         * @param value 需要同步的文本值。
         */
        miniGameTxt(value: string): void;
        /**
         * @en The text content of the input field.
         * @zh 输入框的文本内容。
         */
        get text(): string;
        set text(value: string);
        /**
         * @en Set the color of the input text.
         * @zh 设置输入文本的颜色。
         */
        set_color(value: string): void;
        /**
         * @en The background color of the input text.
         * @zh 输入文本的背景颜色。
         */
        get bgColor(): string;
        set bgColor(value: string);
        /**
         * @en The restriction on input characters.
         * @zh 对输入字符的限制。
         */
        get restrict(): string;
        set restrict(value: string);
        /**
         * @en Whether the input text is editable.
         * @zh 输入框文本是否可编辑。
         */
        get editable(): boolean;
        set editable(value: boolean);
        /**
         * @en The maximum number of characters allowed in the input field. Default is 10000.
         * When setting the character limit, values less than or equal to 0 will set the limit to 10000.
         * @zh 输入框允许的最大字符数量，默认为10000。
         * 设置字符数量限制时，小于等于0的值将会限制字符数量为10000。
         */
        get maxChars(): number;
        set maxChars(value: number);
        /**
         * @en The prompt text for the input field.
         * @zh 输入框的提示文本。
         */
        get prompt(): string;
        set prompt(value: string);
        /**
         * @en Enter the prompt color.
         * @zh 输入提示文本的颜色。
         */
        get promptColor(): string;
        set promptColor(value: string);
        /**
         * @en The input field type, which should be one of the Input static constants.
         * Available types include:
         * - TYPE_TEXT
         * - TYPE_PASSWORD
         * - TYPE_EMAIL
         * - TYPE_URL
         * - TYPE_NUMBER
         * - TYPE_RANGE
         * - TYPE_DATE
         * - TYPE_MONTH
         * - TYPE_WEEK
         * - TYPE_TIME
         * - TYPE_DATE_TIME
         * - TYPE_DATE_TIME_LOCAL
         * For platform compatibility, please refer to: http://www.w3school.com.cn/html5/html_5_form_input_types.asp
         * @zh 输入框类型，应为 Input 静态常量之一。
         * 常用类型包括：
         * - TYPE_TEXT
         * - TYPE_PASSWORD
         * - TYPE_EMAIL
         * - TYPE_URL
         * - TYPE_NUMBER
         * - TYPE_RANGE
         * - TYPE_DATE
         * - TYPE_MONTH
         * - TYPE_WEEK
         * - TYPE_TIME
         * - TYPE_DATE_TIME
         * - TYPE_DATE_TIME_LOCAL
         * @zh 平台兼容性请参考：http://www.w3school.com.cn/html5/html_5_form_input_types.asp
         */
        get type(): string;
        set type(value: string);
    }
    /**
     * @en The `Node` class is the base class for all objects that can be placed in the display list.
     * The display list manages all objects displayed in the runtime of Laya.
     * Use the Node class to arrange the display list. A Node object can have child display objects.
     * @zh `Node` 类是可放在显示列表中的所有对象的基类。
     * 该显示列表管理 LayaAir 运行时中显示的所有对象。使用 Node 类排列显示列表中的显示对象。Node 对象可以有子显示对象。
     */
    class Node extends EventDispatcher {
        private _bits;
        private _hideFlags;
        /**
         * @ignore
         * @en Extra data of the node.
         * @zh 节点的额外数据。IDE内部使用。
         */
        _extra: INodeExtra;
        /**
         * @en Node name.
         * @zh 节点名称。
         */
        name: string;
        /**
         * @en Node tag.
         * @zh 节点标签。
         */
        tag: string;
        /**
         * @en The URL of the resource.
         * @zh 资源的URL。
         */
        get url(): string;
        set url(path: string);
        /**
         * @en Hide flags.
         * @zh 隐藏标志。
         */
        get hideFlags(): number;
        set hideFlags(value: number);
        /**
         * @en Whether it is a 3D node, i.e., Scene3D, Sprite3D and their derived classes.
         * @zh 是否是3D节点，即Scene3D、Sprite3D及其衍生类。
         */
        get is3D(): boolean;
        /**
         * @en Whether it has been destroyed. The object cannot be used after being destroyed.
         * @zh 是否已经销毁。对象销毁后不能再使用。
         */
        get destroyed(): boolean;
        /** @ignore */
        constructor();
        /**
         * @en Set a specific bit of the node.
         * @param type The bit type to set.
         * @param value The value to set, true or false.
         * @zh 设置节点的特定位。
         * @param type 要设置的位类型。
         * @param value 要设置的值,true或false。
         */
        _setBit(type: number, value: boolean): void;
        /**
         * @en Get a specific bit of the node.
         * @param type The bit type to get.
         * @returns The bit value, true or false.
         * @zh 获取节点的特定位。
         * @param type 要获取的位类型。
         * @returns 位的值,true或false。
         */
        _getBit(type: number): boolean;
        /**
         * @en Update the display status of the node in the stage.
         * This method checks the node's hierarchy to determine if it or any of its parents are displayed in the stage, and updates the DISPLAYED_INSTAGE flag accordingly.
         * @zh 更新节点在舞台中的显示状态。
         * 此方法检查节点的层次结构，以确定它或其任何父节点是否显示在舞台中，并相应地更新 DISPLAYED_INSTAGE 标志。
         */
        private _updateDisplayedInstage;
        /**
         * @en Start listening to a specific event type.
         * This method sets the DISPLAY flag if the event type is DISPLAY or UNDISPLAY and the node is not already marked as displayed.
         * @param type The event type to listen to.
         * @zh 开始监听特定事件类型。
         * 如果事件类型是 DISPLAY 或 UNDISPLAY 且节点尚未标记为显示，则此方法设置 DISPLAY 标志。
         * @param type 要监听的事件类型。
         */
        protected onStartListeningToType(type: string): void;
        /**
         * @en Bubble an event up the parent chain.
         * @param type The event type.
         * @param data The event data. If not provided, a new Event object will be created.
         * @zh 事件冒泡到父节点链。
         * @param type 事件类型。
         * @param data 事件数据。如果未提供,将创建一个新的Event对象。
         */
        bubbleEvent(type: string, data?: any): void;
        /**
         * @en Check whether the node has a specific hide flag.
         * @param flag The hide flag to check.
         * @returns Whether the node has the specified hide flag.
         * @zh 检查节点是否具有特定的隐藏标志。
         * @param flag 要检查的隐藏标志。
         * @returns 节点是否具有指定的隐藏标志。
         */
        hasHideFlag(flag: number): boolean;
        /**
         * @en Destroy this node. When a node is destroyed, it will be removed from its parent node and the references will be cleared, waiting for the garbage collector to recycle it.
         * When destroying a node, its own event listeners, timer listeners, child objects will be removed, and it will be removed from its parent node.
         * @param destroyChild Whether to destroy child nodes as well. If true, all child nodes will be destroyed recursively; otherwise, they will only be removed from the parent.
         * @zh 销毁此节点。destroy对象默认会把自己从父节点移除,并且清理自身引用关系,等待js自动垃圾回收机制回收。destroy后不能再使用。
         * destroy时会移除自身的事情监听,自身的timer监听,移除子对象及从父节点移除自己。
         * @param destroyChild 是否同时销毁子节点,若值为true,则销毁子节点,否则不销毁子节点。
         */
        destroy(destroyChild?: boolean): void;
        /**
        * @en The callback function when the node is destroyed. This is a virtual method. You can override it for custom logic when the node is about to be destroyed.
        * @zh 节点被销毁时执行的回调函数。此方法为虚方法，使用时重写覆盖即可。
        */
        onDestroy(): void;
        /**
         * @en Destroy all child nodes, without destroying the node itself.
         * @zh 销毁所有子节点,但不销毁节点本身。
         */
        destroyChildren(): void;
        /**
         * @en Add a child node.
         * @param node The node to be added as a child.
         * @returns The added child node.
         * @zh 添加子节点。
         * @param node 节点对象。
         * @returns 返回添加的节点。
         */
        addChild<T extends Node>(node: T): T;
        /**
         * @en Add multiple child nodes.
         * @param args A variable number of child nodes to be added.
         * @zh 批量增加子节点。
         * @param args 无数子节点。
         */
        addChildren(...args: any[]): void;
        /**
         * @en Insert a child node at a specific index.
         * @param node The child node to be inserted.
         * @param index The index at which the child node will be inserted.
         * @returns The inserted child node.
         * @zh 在指定的索引位置插入子节点。
         * @param node 节点对象。
         * @param index 索引位置。
         * @returns 返回添加的节点。
         */
        addChildAt(node: Node, index: number): Node;
        /**
         * @en Get the index of a child node.
         * @param node The child node to query.
         * @returns The index of the child node.
         * @zh 获取子节点的索引位置。
         * @param node 子节点。
         * @returns 子节点所在的索引位置。
         */
        getChildIndex(node: Node): number;
        /**
        * @en Get a child node by its name.
        * @param name The name of the child node.
        * @returns The child node with the specified name, or null if not found.
        * @zh 根据子节点的名字获取子节点对象。
        * @param name 子节点的名字。
        * @returns 节点对象。
        */
        getChildByName(name: string): Node;
        /**
         * @en Get a child node by its index.
         * @param index The index of the child node.
         * @returns The child node at the specified index, or null if the index is out of range.
         * @zh 根据子节点的索引位置获取子节点对象。
         * @param index 索引位置。
         * @returns 指定索引处的子节点，如果索引超出范围，则为空。
         */
        getChildAt(index: number): Node;
        /**
         * @en Set the index of a child node.
         * @param node The child node to set the index for.
         * @param index The new index of the child node.
         * @returns The child node itself.
         * @zh 设置子节点的索引位置。
         * @param node 子节点。
         * @param index 新的索引。
         * @returns 返回子节点本身。
         */
        setChildIndex(node: Node, index: number): Node;
        /**
         * @en Callback when a child node changes.
         * @param child The child node that has changed.
         * @zh 子节点发生变化时的回调。
         * @param child 发生变化的子节点。
         */
        protected _childChanged(child?: Node): void;
        /**
         * @en Remove a child node.
         * @param node The child node to be removed.
         * @returns The removed node.
         * @zh 删除子节点。
         * @param node 子节点。
         * @returns 被删除的节点。
         */
        removeChild(node: Node): Node;
        /**
         * @en Remove itself from its parent node. If it hasn't been added to any parent node, nothing happens.
         * @returns The node itself.
         * @zh 从父容器删除自己,如果已经被删除不会抛出异常。
         * @returns 当前节点。
         */
        removeSelf(): Node;
        /**
         * @en Remove a child node by its name.
         * @param name The name of the child node.
         * @returns The removed node.
         * @zh 根据子节点名字删除对应的子节点对象,如果找不到不会抛出异常。
         * @param name 对象名字。
         * @returns 查找到的节点。
         */
        removeChildByName(name: string): Node;
        /**
         * @en Remove a child node by its index.
         * @param index The index of the child node.
         * @returns The removed node.
         * @zh 根据子节点索引位置,删除对应的子节点对象。
         * @param index 节点索引位置。
         * @returns 被删除的节点。
         */
        removeChildAt(index: number): Node;
        /**
         * @en Remove all children from this node.
         * @param beginIndex The begin index.
         * @param endIndex The end index.
         * @returns The node itself.
         * @zh 删除指定索引区间的所有子对象。
         * @param beginIndex 开始索引。
         * @param endIndex 结束索引。
         * @returns 当前节点对象。
         */
        removeChildren(beginIndex?: number, endIndex?: number): Node;
        /**
         * @en Replace a child node.
         * @param newNode The new node to replace the old one.
         * @param oldNode The old node to be replaced.
         * @returns The new node.
         * @zh 替换子节点。
         * @param newNode 新节点。
         * @param oldNode 老节点。
         * @returns 返回新节点。
         */
        replaceChild(newNode: Node, oldNode: Node): Node;
        /**
         * @en The number of child nodes.
         * @zh 子对象数量。
         */
        get numChildren(): number;
        /**
         * @en The parent node.
         * @zh 父节点。
         */
        get parent(): Node;
        /**
         * @en Check if this node is an ancestor of the given node.
         * @returns True if this node is an ancestor of the given node, false otherwise.
         * @param node The node to check.
         * @zh 检查本节点是否是某个节点的上层节点。
         * @param node 要检查的节点。
         * @returns 一个布尔值，表示本节点是否是某个节点的上层节点。
         */
        isAncestorOf(node: Node): boolean;
        /**
         * @en Set the parent node of the current node.
         * @param value The new parent node.
         * @zh 设置当前节点的父节点。
         * @param value 新的父节点。
         */
        protected _setParent(value: Node): void;
        /**
         * @en Indicates whether the node is displayed in the scene.
         * @zh 表示是否在显示列表中显示。
         */
        get displayedInStage(): boolean;
        /**
        * @en Set the display state of a node's children.
        * @param node The node whose children's display state needs to change.
        * @param display The display state to set.
        * @zh 设置指定节点对象的子对象是否可见（是否在渲染列表中）。
        * @param node 节点。
        * @param display 是否可见。
        */
        private _displayChild;
        /**
         * @en Checks whether the current node contains the specified node.
         * @returns A Boolean value indicating whether the current node contains the specified node.
         * @param node The specified node.
         * @zh 当前容器是否包含指定的节点对象。
         * @param node 指定的节点对象。
         * @returns 一个布尔值，表示是否包含指定的节点对象。
         */
        contains(node: Node): boolean;
        /**
         * @en Repeatedly execute a callback function at a fixed interval. This is a wrapper of the `loop` method in the timer property of the node.
         * @param delay The interval between executions, in milliseconds.
         * @param caller The execution scope of the callback function (this).
         * @param method The callback function.
         * @param args The parameters passed to the callback function.
         * @param coverBefore Whether to override the previous delayed execution. The default value is true.
         * @param jumpFrame Whether the callback should be executed when the timer jumps frames. The default value is false. If set to true, the callback will be executed multiple times in a single frame if possible, for performance reasons.
         * @zh 定时重复执行某函数。这是对节点 timer 属性的 `loop` 方法的封装。
         * @param delay 执行间隔时间,以毫秒为单位。
         * @param caller 回调函数的执行域(this)。
         * @param method 回调函数。
         * @param args 传递给回调函数的参数。
         * @param coverBefore 是否覆盖之前的延迟执行,默认为 true。
         * @param jumpFrame 时钟是否跳帧。基于时间的循环回调,单位时间间隔内,如能执行多次回调,出于性能考虑,引擎默认只执行一次,设置jumpFrame为true后,则回调会连续执行多次。默认为false。
         */
        timerLoop(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean, jumpFrame?: boolean): void;
        /**
         * @en Executes a callback function once after a specified delay.
         * @param delay The delay time, in milliseconds.
         * @param caller The execution scope of the callback function (this).
         * @param method The callback function.
         * @param args The parameters passed to the callback function.
         * @param coverBefore Whether to override the previous delayed execution. The default value is true.
         * @zh 在指定延迟时间后执行一次回调函数。功能同Laya.timer.once()。
         * @param delay 延迟时间,以毫秒为单位。
         * @param caller 回调函数的执行域(this)。
         * @param method 回调函数。
         * @param args 传递给回调函数的参数。
         * @param coverBefore 是否覆盖之前的延迟执行,默认为 true。
         */
        timerOnce(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean): void;
        /**
         * @en Repeatedly executes a callback function at a fixed interval based on frame rate.
         * @param delay The interval between executions, in frames.
         * @param caller The execution scope of the callback function (this).
         * @param method The callback function.
         * @param args The parameters passed to the callback function.
         * @param coverBefore Whether to override the previous delayed execution. The default value is true.
         * @zh 基于帧率,定时重复执行回调函数。功能同Laya.timer.frameLoop()。
         * @param delay 执行间隔时间,以帧为单位。
         * @param caller 回调函数的执行域(this)。
         * @param method 回调函数。
         * @param args 传递给回调函数的参数。
         * @param coverBefore 是否覆盖之前的延迟执行,默认为 true。
         */
        frameLoop(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean): void;
        /**
         * @en Executes a callback function once after a specified delay based on frame rate.
         * @param delay The delay time, in frames.
         * @param caller The execution scope of the callback function (this).
         * @param method The callback function.
         * @param args The parameters passed to the callback function.
         * @param coverBefore Whether to override the previous delayed execution. The default value is true.
         * @zh 基于帧率,在指定延迟时间后执行一次回调函数。功能同Laya.timer.frameOnce()。
         * @param delay 延迟时间,以帧为单位。
         * @param caller 回调函数的执行域(this)。
         * @param method 回调函数。
         * @param args 传递给回调函数的参数。
         * @param coverBefore 是否覆盖之前的延迟执行,默认为 true。
         */
        frameOnce(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean): void;
        /**
         * @en Clears a timer.
         * @param caller The execution scope of the callback function (this).
         * @param method The callback function.
         * @zh 清除定时器。功能同Laya.timer.clear()。
         * @param caller 回调函数的执行域(this)。
         * @param method 回调函数。
         */
        clearTimer(caller: any, method: Function): void;
        /**
         * @en Delays the execution of a callback function until the next frame after the current execution block is finished.
         * The callback function will only be executed once. It is generally called before the control is displayed on the screen to delay the calculation of data.
         * @param method The callback function.
         * @param args The parameters passed to the callback function.
         * @zh 在当前执行块完成后,延迟执行回调函数到下一帧。
         * 回调函数只会被执行一次。一般在控件被显示在屏幕之前调用，用于延迟计算数据。
         * @param method 回调函数。
         * @param args 传递给回调函数的参数。
         */
        callLater(method: Function, args?: any[]): void;
        /**
         * @en If there are callback functions delayed by `callLater`, they will be executed immediately.
         * @param method The name of the callback function to be executed, such as `functionName`.
         * @zh 如果有通过 `callLater` 延迟执行的回调函数,将立即执行它们。
         * @param method 要执行的回调函数名称,例如 `functionName`。
         */
        runCallLater(method: Function): void;
        /**
         * @en The component list of this node.
         * @zh 节点的组件列表。
         */
        protected _components: Component[];
        /**@private */
        private _activeChangeScripts;
        /**
         * @en Get the scene this node belongs to.
         * @zh 获取该节点所属的场景。
         */
        get scene(): any;
        /**
         * @en Thether this node is active.
         * @zh 该节点自身是否激活。
         */
        get active(): boolean;
        set active(value: boolean);
        /**
         * @en Thether this node is active in the hierarchy.
         * @zh 该节点在层级中是否激活。
         */
        get activeInHierarchy(): boolean;
        /**
         * @en Actions performed when the node becomes active.
         * @zh 节点激活时执行的操作。
         */
        protected _onActive(): void;
        /**
         * @en Actions performed when the node becomes inactive.
         * @zh 节点停用时执行的操作。
         */
        protected _onInActive(): void;
        /**
         * @en Actions performed when the node is added to the scene.
         * @zh 节点被添加到场景时执行的操作。
         */
        protected _onActiveInScene(): void;
        /**
         * @en Actions performed when the node is removed from the scene.
         * @zh 节点从场景中移除时执行的操作。
         */
        protected _onInActiveInScene(): void;
        /**
         * @en The callback function that is executed when the component is activated, at which point all nodes and components have been created.
         * This is a virtual method that needs to be overridden in the subclass.
         * @zh 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次。
         * 此方法为虚方法，使用时重写覆盖即可。
         */
        onAwake(): void;
        /**
        * @en The callback function that is executed when the component is enabled, such as when a node is added to the stage.
        * This is a virtual method that needs to be overridden in the subclass.
        * @zh 组件被启用后执行，比如节点被添加到舞台后。
        * 此方法为虚方法，使用时重写覆盖即可。
        */
        onEnable(): void;
        /**
         * @en The callback function that is executed when the component is disabled, such as when a node is removed from the stage.
         * This is a virtual method that needs to be overridden in the subclass.
         * @zh 组件被禁用时执行，比如从节点从舞台移除后。
         * 此方法为虚方法，使用时重写覆盖即可。
         */
        onDisable(): void;
        /**
         * @en Handle the addition of the node to its parent.
         * This method is called when the node is added to a parent node, updating the active state and scene reference if applicable.
         * @zh 处理节点被添加到父节点时的操作。
         * 当节点被添加到父节点时调用此方法，如果适用，更新激活状态和场景引用。
         */
        protected _onAdded(): void;
        /**
         * @en Handle the removal of the node from its parent.
         * This method is called when the node is removed from its parent node, updating the active state and scene reference if applicable.
         * @zh 处理节点从父节点移除时的操作。
         * 当节点从父节点移除时调用此方法，如果适用，更新激活状态和场景引用。
         */
        protected _onRemoved(): void;
        /**
         * @en Destroy all components on the node.
         * @zh 销毁节点上的所有组件。
         */
        private destroyAllComponent;
        /**
         * @en Handle changes to the node's components.
         * This method is called when a component is added, removed, or all components are destroyed.
         * @param comp The component that was changed.
         * @param action The action performed: 0 for added, 1 for removed, 2 for all destroyed.
         * @zh 处理节点组件的变化。
         * 当组件被添加、移除或所有组件被销毁时调用此方法。
         * @param comp 发生变化的组件。
         * @param action 执行的操作：0 表示添加，1 表示移除，2 表示全部销毁。
         */
        protected _componentsChanged?(comp: Component, action: 0 | 1 | 2): void;
        /**
         * @en Add a component instance to the node.
         * @param component The component instance.
         * @returns The added component instance.
         * @zh 添加组件实例到节点。
         * @param component 组件实例。
         * @returns 添加的组件实例。
         */
        addComponentInstance(component: Component): Component;
        /**
         * @en Add a component to the node.
         * @param componentType The type of the component.
         * @returns The added component instance.
         * @zh 添加组件到节点。
         * @param componentType 组件类型。
         * @returns 添加的组件实例。
         */
        addComponent<T extends Component>(componentType: new () => T): T;
        /**
         * @en Get a component instance by type. Returns null if not found.
         * @param componentType The type of the component.
         * @returns The component instance.
         * @zh 根据类型获取组件实例。如果没有找到则返回null。
         * @param componentType 组件类型。
         * @returns 组件实例。
         */
        getComponent<T extends Component>(componentType: new () => T): T;
        /**
         * @en Get all component instances on the node.
         * @returns An array of component instances.
         * @zh 获取节点上的所有组件实例。
         * @returns 组件实例数组。
         */
        get components(): ReadonlyArray<Component>;
        /**
         * @en Get all component instances by type. Returns an empty array if none are found.
         * @param componentType The type of the component.
         * @returns An array of component instances.
         * @zh 根据类型获取所有组件实例。如果没有找到则返回空数组。
         * @param componentType 组件类型。
         * @returns 组件实例数组。
         */
        getComponents(componentType: typeof Component): Component[];
        /**
         * @en Get the timer associated with the node.
         * @returns The timer.
         * @zh 获取与节点关联的计时器。
         * @returns 计时器。
         */
        get timer(): Timer;
        /**
         * @en Called after deserialization.
         * @zh 反序列化后调用。
         */
        onAfterDeserialize(): void;
    }
    interface INodeExtra {
    }
    /**
     * @en Scene class, responsible for scene creation, loading, destruction and other functions.
     * After the scene is removed from the node, it will not be automatically recycled by the garbage mechanism. If you want to recycle it, please call the destroy interface.
     * You can view the list of scenes that have not been destroyed through the unDestroyedScenes property.
     * @zh 场景类，负责场景创建、加载、销毁等功能。
     * 场景被从节点移除后，并不会被自动垃圾机制回收。如果想回收，请调用 destroy 接口。
     * 可以通过 unDestroyedScenes 属性查看还未被销毁的场景列表。
     */
    class Scene extends Sprite {
        /**
         * @en List of scenes that have been created but not yet destroyed. This property is read-only, please do not modify it directly.
         * @zh 创建后还未被销毁的场景列表。此属性只读，请不要直接修改。用于方便查看未销毁的场景列表，便于内存管理。
         */
        static readonly unDestroyedScenes: Set<Scene>;
        /**
         * @en Get the root node
         * @zh 获取根节点
         * */
        private static _root;
        private static _loadPage;
        /**
         * @en Whether to automatically destroy (destroy nodes and used resources) after the scene is closed, default is false
         * @zh 场景被关闭后，是否自动销毁（销毁节点和使用到的资源），默认为 false
         */
        autoDestroyAtClosed: boolean;
        /**
         * @en relative layout component
         * @zh 相对布局组件
         */
        protected _widget: Widget;
        /**
         * @en The scene clock
         * @zh 场景时钟
         */
        private _timer;
        private _viewCreated;
        private _shaderData;
        /** @ignore */
        constructor(createChildren?: boolean);
        /**
         * @ignore
         * @en Compatible with legacy projects
         * @zh 兼容老项目
         */
        protected createChildren(): void;
        /**
         * @en Compatible loading mode, load mode setting uimap
         * @param url The URL of the uimap JSON file.
         * @zh 兼容加载模式，加载模式设置uimap
         * @param url url uimapJSON 文件的 URL。
         */
        static setUIMap(url: string): void;
        /**
         * @ignore
         * @en Load scene view. Used for loading mode. Compatible with old projects.
         * @param path The scene address.
         * @zh 装载场景视图。用于加载模式。兼容老项目。
         * @param path 场景地址。
         */
        loadScene(path: string): void;
        /**
         * @ignore
         * @en Create view using view data. Compatible with old projects.
         * @param view The view data information.
         * @zh 通过视图数据创建视图。兼容老项目。
         * @param view 视图数据信息。
         */
        createView(view: any): void;
        /**
         * @en Get the node instance based on the node ID in the IDE.
         * @param id The node ID.
         * @zh 根据IDE内的节点id，获得节点实例。
         * @param id 节点ID。
         */
        getNodeByID(id: number): any;
        /**
         * @en Open the scene. Note: If the closed scene has not set autoDestroyAtRemoved=true, resources may not be reclaimed and need to be manually reclaimed.
         * @param closeOther Whether to close other scenes, default is true (optional).
         * @param param Parameters for opening the page, will be passed to the onOpened method (optional).
         * @zh 打开场景。注意：被关闭的场景，如果没有设置autoDestroyAtRemoved=true，则资源可能不能被回收，需要自己手动回收。
         * @param closeOther 是否关闭其他场景，默认为true（可选）。
         * @param param 打开页面的参数，会传递给onOpened方法（可选）。
         */
        open(closeOther?: boolean, param?: any): void;
        /**
         * @en Called after the scene is opened (if there is a pop-up animation, it will be executed after the animation is completed).
         * @param param Parameters.
         * @zh 场景打开完成后调用此方法（如果有弹出动画，则在动画完成后执行）。
         * @param param 参数。
         */
        onOpened(param: any): void;
        /**
         * @en Close the scene. Note: If the closed scene has not set autoDestroyAtRemoved=true, resources may not be reclaimed and need to be manually reclaimed.
         * @param type The reason for closing, which will be passed to the onClosed function.
         * @zh 关闭场景。注意：被关闭的场景，如果没有设置autoDestroyAtRemoved=true，则资源可能不能被回收，需要自己手动回收。
         * @param type 关闭的原因，会传递给onClosed函数。
         */
        close(type?: string): void;
        /**
         * @en Called after the scene is closed (if there is a closing animation, it will be executed after the animation is completed).
         * @param type If triggered by clicking the default close button, pass the name of the close button, otherwise null.
         * @zh 关闭完成后调用此方法（如果有关闭动画，则在动画完成后执行）。
         * @param type 如果是点击默认关闭按钮触发，则传入关闭按钮的名字(name)，否则为null。
         */
        onClosed(type?: string): void;
        /**
         * @en Destroy the scene.
         * @param destroyChild Whether to delete child nodes.
         * @zh 场景销毁。
         * @param destroyChild 是否删除子节点。
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @en Scene clock
         * @zh 场景时钟
         */
        get timer(): Timer;
        set timer(value: Timer);
        /**
         * @en 3D scene instances included in the scene
         * @zh 场景包含的3D场景实例
         */
        get scene3D(): any;
        get sceneShaderData(): ShaderData;
        /**
         * @en The vertical distance (in pixels) between the top edge of the component and the top edge of its content area.
         * @zh 从组件顶边到其内容区域顶边之间的垂直距离（以像素为单位）。
         */
        get top(): number;
        set top(value: number);
        /**
         * @en The vertical distance (in pixels) between the bottom edge of the component and the bottom edge of its content area.
         * @zh 从组件底边到其内容区域底边之间的垂直距离（以像素为单位）。
         */
        get bottom(): number;
        set bottom(value: number);
        /**
         * @en The horizontal distance (in pixels) between the left edge of the component and the left edge of its content area.
         * @zh 从组件左边到其内容区域左边之间的水平距离（以像素为单位）。
         */
        get left(): number;
        set left(value: number);
        /**
         * @en The horizontal distance (in pixels) between the right edge of the component and the right edge of its content area.
         * @zh 从组件右边到其内容区域右边之间的水平距离（以像素为单位）。
         */
        get right(): number;
        set right(value: number);
        /**
         * @en The distance (in pixels) between the horizontal axis of this object and the horizontal center line of its parent container.
         * @zh 在父容器中，此对象的水平方向中轴线与父容器的水平方向中心线的距离（以像素为单位）。
         */
        get centerX(): number;
        set centerX(value: number);
        /**
         * @en The distance (in pixels) between the vertical axis of this object and the vertical center line of its parent container.
         * @zh 在父容器中，此对象的垂直方向中轴线与父容器的垂直方向中心线的距离（以像素为单位）。
         */
        get centerY(): number;
        set centerY(value: number);
        protected _shouldRefreshLayout(): void;
        protected _sizeChanged(): void;
        /**
         * @en Repositioning
         * @zh 重新排版
         */
        freshLayout(): void;
        /**
         * @en Get the layout style of the object. Please do not directly modify this object
         * @zh 获取对象的布局样式。请不要直接修改此对象
         */
        private _getWidget;
        /**
         * @en Get the root container of the scene.
         * @zh 获取场景根容器
         */
        static get root(): Sprite;
        /**
         * @deprecated 请使用Loader.load(url:string, type: ILaya.Loader.HIERARCHY)
         * @en Load the scene and resources used by the scene.
         * @param url The scene address.
         * @param complete Callback function when loading is complete, returns the scene instance (optional).
         * @param progress Callback function for loading progress (optional).
         * @zh 加载场景及场景使用到的资源。
         * @param url 场景地址。
         * @param complete 加载完成回调，返回场景实例（可选）。
         * @param progress 加载进度回调（可选）。
         */
        static load(url: string, complete?: Handler, progress?: Handler): Promise<Scene>;
        /**
         * @en Load and open the scene.
         * @param url The scene address.
         * @param closeOther Whether to close other scenes, default is true (optional). Note: If the closed scene has not set autoDestroyAtRemoved=true, resources may not be reclaimed and need to be manually reclaimed.
         * @param param Parameters for opening the page, will be passed to the onOpened method (optional).
         * @param complete Callback function when opening is complete, returns the scene instance (optional).
         * @param progress Callback function for loading progress (optional).
         * @zh 加载并打开场景。
         * @param url 场景地址。
         * @param closeOther 是否关闭其他场景，默认为true（可选）。注意：被关闭的场景，如果没有设置autoDestroyAtRemoved=true，则资源可能不能被回收，需要自己手动回收。
         * @param param 打开页面的参数，会传递给onOpened方法（可选）。
         * @param complete 打开完成回调，返回场景实例（可选）。
         * @param progress 加载进度回调（可选）。
         */
        static open(url: string, closeOther?: boolean, param?: any, complete?: Handler, progress?: Handler): Promise<Scene>;
        private static _onSceneLoaded;
        /**
         * @en Close the scene (including dialog) based on the address.
         * @param url The scene address.
         * @param name If name is not empty, it must match to close the scene.
         * @returns Returns whether the closure was successful. If the url is not found, it will not be successful.
         * @zh 根据地址，关闭场景（包括对话框）。
         * @param url 场景地址。
         * @param name 如果name不为空，name必须相同才能关闭。
         * @returns 返回是否关闭成功，如果url找不到，则不成功。
         */
        static close(url: string, name?: string): boolean;
        /**
         * @en Close all scenes, not including dialogs. To close dialogs, please use Dialog.closeAll().
         * Note: If the closed scene has not set autoDestroyAtRemoved=true, resources may not be reclaimed and need to be manually reclaimed.
         * @zh 关闭所有场景，不包括对话框。如果要关闭对话框，请使用Dialog.closeAll()。
         * 注意：被关闭的场景，如果没有设置autoDestroyAtRemoved=true，则资源可能不能被回收，需要自己手动回收。
         */
        static closeAll(): void;
        /**
         * @en Destroy the scene (including dialog) based on the address.
         * @param url The scene address.
         * @param name If name is not empty, it must match to destroy the scene.
         * @returns Returns whether the destruction was successful. If the url is not found, it will not be successful.
         * @zh 根据地址，销毁场景（包括对话框）。
         * @param url 场景地址。
         * @param name 如果name不为空，name必须相同才能销毁。
         * @returns 返回是否销毁成功，如果url找不到，则不成功。
         */
        static destroy(url: string, name?: string): boolean;
        /**
         * @en Destroy currently unused resources. This function will ignore resources with lock=true.
         * @zh 销毁当前没有被使用的资源，该函数会忽略lock=true的资源。
         */
        static gc(): void;
        /**
         * @en Set the loading interface. The engine will delay opening the loading interface after calling the open method, and close the loading interface after the page is added to the stage.
         * @param loadPage The loading page instance.
         * @zh 设置loading界面，引擎会在调用open方法后，延迟打开loading界面，在页面添加到舞台之后，关闭loading界面。
         * @param loadPage load界面实例。
         */
        static setLoadingPage(loadPage: Sprite): void;
        /**
         * @en Display the loading interface.
         * @param param Opening parameters. If it's a scene, it will be passed to the onOpened method.
         * @param delay Delay opening time, default is 500 milliseconds.
         * @zh 显示loading界面。
         * @param param 打开参数，如果是scene，则会传递给onOpened方法。
         * @param delay 延迟打开时间，默认500毫秒。
         */
        static showLoadingPage(param?: any, delay?: number): void;
        private static _showLoading;
        private static _hideLoading;
        /**
         * @en Hide the loading interface.
         * @param delay Delay closing time, default is 500 milliseconds.
         * @zh 隐藏loading界面。
         * @param delay 延迟关闭时间，默认500毫秒。
         */
        static hideLoadingPage(delay?: number): void;
    }
    /**
     * @en Sprite is a basic display list node for displaying graphical content. By default, Sprite does not accept mouse events. Through the graphics API, images or vector graphics can be drawn, supporting operations like rotation, scaling, translation, and more. Sprite also functions as a container class, allowing the addition of multiple child nodes.
     * @zh Sprite是基本的显示图形的显示列表节点。Sprite默认不接受鼠标事件。通过graphics可以绘制图片或者矢量图，支持旋转，缩放，位移等操作。Sprite同时也是容器类，可用来添加多个子节点。
     */
    class Sprite extends Node {
        protected _tfChanged: boolean;
        protected _repaint: number;
        private _texture;
        private _sizeFlag;
        private _filterArr;
        /**
         @en For non-UI component display object nodes (container objects or display objects without image resources), specifies whether the mouse events penetrate this object's collision detection. `true` means the object is penetrable, `false` means it is not penetrable.
        * When penetrable, the engine will no longer detect this object and will recursively check its child objects until it finds the target object or misses all objects.
        * When not penetrable, the node's width and height define the mouse collision area (a non-penetrable rectangular area). If the rectangular collision area does not meet the requirements, you can use the drawing area of the hit area as the collision area. The hit area takes precedence over width and height of node as the non-penetrable mouse collision area.
        * Note that for UI object nodes with a set skin property, once a skin texture resource is set, this property becomes ineffective, and the rectangular area drawn by the texture will always be non-penetrable unless it does not accept mouse events or a non-clickable area is set.
        *@zh 用于非UI组件显示对象节点（容器对象或没有设置图像资源的显示对象），鼠标事件与此对象在碰撞检测时，是否穿透。ture为可穿透，false为不可穿透。
         * 可穿透时，引擎不再检测本对象，而会递归检测子对象，直到找到命中的目标对象或者未命中任何对象。
         * 不可穿透时，以节点宽高为鼠标碰撞区（矩形的不可穿透区域）。如果矩形碰撞区不能满足需求，可以将点击区域的绘制图形作为碰撞区，绘制区域优先于宽高作为不可穿透的鼠标碰撞区域。
         * 注意，可以设置skin属性的UI对象节点，当设置了skin纹理资源之后，该属性设置失效，纹理绘制的矩形区域内会始终处于不可穿透状态。除非不接受鼠标事件或设置不可点击区域。
         */
        mouseThrough: boolean;
        /**
         * @en Under the premise that this object is non-penetrable (mouseThrough is false), specify whether the mouse event capture detection prioritizes this object.  When set to true, the object itself is prioritized for detection.  When set to false, the child objects are prioritized.
         * When set to prioritize the object itself, the object is detected first.  If the object itself is not hit, the detection is directly interrupted, indicating that no target was hit.  If the object itself is hit, further recursive detection is performed on its child objects until the final mouse hit target is found or all child nodes have been checked.
         * When set to prioritize child objects, the child objects are recursively detected first.  If a child object is hit, the detection is interrupted and the hit target is obtained.  If all child nodes have been checked and no child object is hit, then the detection checks if the object itself is hit.
         * In most cases, prioritizing the detection of child objects is advisable unless the developer does not care about the mouse event detection results of the current node's child nodes.  For example, when child nodes are certainly within the width and height range of the parent node's container, there is no need for recursive detection layer by layer if the mouse click does not occur within the parent node's area.
         * Using this property appropriately can reduce the nodes for mouse event detection and improve performance.
         * @zh 在本对象为不可穿透（mouseThrough为false）的前提下，指定鼠标事件捕获检测是否优先检测本对象。为`true`时优先检测本对象，为`false`时优先检测子对象。
         * 优先检测本对象时，如果本对象没有被检测命中，会中断检测，表示没有命中目标；如果本对象被检测命中，则进一步递归检测其子对象，直到找到鼠标最终的命中目标或所有子节点都检测完毕。
         * 优先检测子对象时，先递归检测其子对象，如果子对象被检测命中，则中断检测，获得命中目标。如果所有子节点都检测完毕，仍未检测命中任何子对象，最后再检测本对象是否被命中；
         * 大多数情况下需要优先检测子对象，除非开发者并不关心当前节点的子节点的鼠标事件检测结果，也就是以当前节点作为其子节点的鼠标事件检测依据。例如，子节点肯定在父节点的容器宽高范围内，当鼠标点击不发生在父节点范围内的区域时，就不必层层递归检测了。
         * 合理使用本属性，能减少鼠标事件检测的节点，提高性能。
         */
        hitTestPrior: boolean;
        /**
         * @en Whether to automatically calculate the width and height of the node. The default value is `false`, which does not automatically calculate and offers better performance.
         * If you want to get the width and height based on the drawn content, you can set this property to `true`, or use the getBounds method to obtain them, which has some impact on performance.
         * @zh 是否自动计算节点的宽高数据。默认值为 false，不自动计算，性能更佳。
         * 如果想根据绘制内容获取宽高，可以设置本属性为true，或者通过getBounds方法获取，对性能有一定影响。
         */
        autoSize: boolean;
        /**
         * @en Destroy the sprite.
         * @param destroyChild Whether to destroy child nodes. Default is true.
         * @zh 销毁精灵。
         * @param destroyChild 是否删除子节点。默认为 true。
         */
        destroy(destroyChild?: boolean): void;
        /** @ignore */
        constructor();
        /**
         * @en Get the scene the sprite belongs to.
         * @zh 获取所属的场景。
         */
        get scene(): Scene;
        /**
         * @en Re-sort by zOrder.
         * @zh 根据 zOrder 进行重新排序。
         */
        updateZOrder(): void;
        /**
         * @en Enable or disable custom rendering. Custom rendering must be enabled to use the customRender function.
         * @param {boolean} b Whether to enable custom rendering.
         * @zh 设置是否开启自定义渲染，只有开启自定义渲染，才能使用 customRender 函数渲染。
         * @param {boolean} b 是否开启自定义渲染。
         */
        set customRenderEnable(b: boolean);
        /**
         * @en Specifies whether the display object is cached as a static image. When cacheAs is set, changes in child objects will automatically update the cache. You can also manually call the reCache method to update the cache.
         * It is recommended to cache "complex content" that does not change frequently as a static image to greatly improve rendering performance. cacheAs has three values: "none", "normal", and "bitmap".
         * The default is "none," which does not perform any caching.
         * When set to "normal," command caching is used.
         * When set to "bitmap," renderTarget caching is used.
         * Disadvantages of the renderTarget caching mode: it creates additional renderTarget objects, increasing memory overhead, has a maximum cache area limit of 2048, and can increase CPU overhead with constant redrawing. Advantages: it significantly reduces draw calls and provides the highest rendering performance.
         * Disadvantages of the command caching mode: it only reduces node traversal and command organization and does not reduce the number of draw calls, resulting in moderate performance. Advantages: it has no additional memory overhead and does not require renderTarget support.
         * @zh 指定显示对象是否缓存为静态图像，cacheAs 时，子对象发生变化，会自动重新缓存，同时也可以手动调用 reCache 方法更新缓存。
         * 建议把不经常变化的“复杂内容”缓存为静态图像，能极大提高渲染性能。cacheAs 有 "none"，"normal" 和 "bitmap" 三个值可选。
         * 默认为 "none"，不做任何缓存。
         * 当值为 "normal" 时，使用命令缓存。
         * 当值为 "bitmap" 时，使用 renderTarget 缓存。
         * renderTarget 缓存模式缺点：会额外创建 renderTarget 对象，增加内存开销，缓存面积有最大 2048 限制，不断重绘时会增加 CPU 开销。优点：大幅减少 drawcall，渲染性能最高。
         * 命令缓存模式缺点：只会减少节点遍历及命令组织，不会减少 drawcall 数，性能中等。优点：没有额外内存开销，无需 renderTarget 支持。
         */
        get cacheAs(): string;
        set cacheAs(value: string);
        /**
         * @deprecated
         * 设置cacheAs为非空时此值才有效，staticCache=true时，子对象变化时不会自动更新缓存，只能通过调用reCache方法手动刷新。
         */
        get staticCache(): boolean;
        /**@deprecated */
        set staticCache(value: boolean);
        /**
         * @deprecated
         * @en Call this method to refresh the cache when cacheAs is set.
         * @zh 在设置 cacheAs 的情况下，调用此方法会重新刷新缓存。
         */
        reCache(): void;
        /**
         * @en The rendering component node of the sprite.
         * @zh 精灵的渲染组件节点。
         */
        get renderNode2D(): BaseRenderNode2D;
        set renderNode2D(value: BaseRenderNode2D);
        /**
         * @en Get the repaint type.
         * @returns The repaint type.
         * @zh 获取重绘类型。
         * @returns 重绘类型。
         */
        getRepaint(): number;
        /**
         * @en The x coordinate value relative to the parent container.
         * @zh 显示对象相对于父容器的水平方向坐标值。
         */
        get x(): number;
        set x(value: number);
        /**
         * @en The y coordinate value relative to the parent container.
         * @zh 显示对象相对于父容器的垂直方向坐标值。
         */
        get y(): number;
        set y(value: number);
        /**
         * @en The width of the Node, in pixels
         * @zh 节点的宽度，单位为像素。
         */
        get width(): number;
        set width(value: number);
        /**
         * @en Set the width of the Node.
         * @param number value  The width value, in pixels.
         * @zh 设置节点的宽度。
         * @param number value  宽度值，以像素为单位。
         */
        protected set_width(value: number): void;
        /**
         * @en Get the width of the Node, in pixels
         * @zh 获取节点的宽度。以像素为单位。
         */
        protected get_width(): number;
        /**
         * @en The height of the Node, in pixels.
         * @zh 节点的高度，单位为像素。
         */
        get height(): number;
        set height(value: number);
        /**
        * @en Set the height of the Node, in pixels
        * @zh 设置节点的高度，单位为像素。
        */
        protected set_height(value: number): void;
        /**
        * @en Get the height of the Node, in pixels.
        * @zh 获取节点的高度，以像素为单位。
        */
        protected get_height(): number;
        /**
         * @en Check if the width is set.
         * @returns True if the width is set, otherwise false.
         * @zh 检查是否设置了宽度。
         * @returns True 表示宽度已设置，否则为 False。
         */
        get _isWidthSet(): boolean;
        /**
         * @en Check if the height is set.
         * @returns True if the height is set, otherwise false.
         * @zh 检查是否设置了高度。
         * @returns True 表示高度已设置，否则为 False。
         */
        get _isHeightSet(): boolean;
        /**
         * @en Called when the layout should be refreshed.
         * @zh 当需要刷新布局时调用。
         */
        protected _shouldRefreshLayout(): void;
        /**
         * @en The display width of the object, in pixels, including X axis scaling.
         * @returns The display width.
         * @zh 对象的显示宽度（以像素为单位），包含X轴缩放。
         * @returns 显示宽度。
         */
        get displayWidth(): number;
        /**
        * @en The display height of the object, in pixels, including Y axis scaling.
        * @returns The display height.
        * @zh 对象的显示高度（以像素为单位），包含Y轴缩放。
        * @returns 显示高度。
        */
        get displayHeight(): number;
        /**
         * @en Set the bounds of the object. If set, getBounds will not be used to calculate the bounds. Proper use can improve performance.
         * @param bound The bounds rectangle.
         * @zh 设置对象的边界大小，如果设置，则不再通过getBounds计算边界。合理使用能提高性能。
         * @param bound 边界矩形区域
         */
        setSelfBounds(bound: Rectangle): void;
        /**
         * @en Get the rectangle display area of the object in the parent container's coordinate system.
         * Note: This calculation is complex, use sparingly.
         * @return The rectangle area.
         * @zh 获取本对象在父容器坐标系的矩形显示区域。
         * 注意：计算量较大，尽量少用。
         * @returns 矩形区域。
         */
        getBounds(): Rectangle;
        /**
         * @en Get the rectangle display area of the object in its own coordinate system.
         * Note: This calculation is complex, use sparingly.
         * @returns The rectangle area.
         * @zh 获取本对象在自己坐标系的矩形显示区域。
         * 注意：计算量较大，尽量少用。
         * @returns 矩形区域。
         */
        getSelfBounds(): Rectangle;
        /**
         * @en Returns the display area of the drawing object (`Graphics`) in this instance, excluding child objects.
         * @param realSize (Optional) Use the actual size of the image, default is false.
         * @returns A Rectangle object representing the obtained display area.
         * @zh 返回此实例中绘图对象（`Graphics`）的显示区域，不包括子对象。
         * @param realSize （可选）使用图片的真实大小，默认为false。
         * @returns 一个 Rectangle 对象，表示获取到的显示区域。
         */
        getGraphicBounds(realSize?: boolean): Rectangle;
        /**
         * @ignore
         * @en Get the sprite style.
         * @return The sprite style (SpriteStyle).
         * @zh 获取精灵样式。
         * @return 精灵样式 (SpriteStyle)。
         */
        getStyle(): SpriteStyle;
        /**
         * @ignore
         * @en Set the sprite style.
         * @param value The sprite style to set.
         * @zh 设置精灵样式。
         * @param value 要设置的精灵样式。
         */
        setStyle(value: SpriteStyle): void;
        /**
         * @en The scale factor on the X axis, with a default value of 1. Setting a negative value can achieve a horizontal flip effect, e.g., scaleX=-1.
         * @zh X轴缩放值，默认值为1。设置为负数可以实现水平反转效果，例如scaleX=-1。
         */
        get scaleX(): number;
        set scaleX(value: number);
        /**
         * @en The scale factor on the Y axis, with a default value of 1. Setting a negative value can achieve a vertical flip effect, e.g., scaleY=-1.
         * @zh Y轴缩放值，默认值为1。设置为负数可以实现垂直反转效果，例如scaleY=-1。
         */
        get scaleY(): number;
        set scaleY(value: number);
        /**
         * @en The rotation angle, in degrees, with a default value of 0.
         * @zh 旋转角度，默认值为0。以角度为单位。
         */
        get rotation(): number;
        set rotation(value: number);
        /**
         * @en The horizontal skew angle, in degrees, with a default value of 0.
         * @zh 水平倾斜角度，默认值为0。以角度为单位。
         */
        get skewX(): number;
        set skewX(value: number);
        /**
          * @en The vertical skew angle, in degrees, with a default value of 0.
          * @zh 垂直倾斜角度,默认值为0。以角度为单位。
          */
        get skewY(): number;
        set skewY(value: number);
        /**
         * @en Adjust the transform matrix.
         * @return The adjusted transform matrix.
         * @zh 调整变换矩阵。
         * @return 调整后的变换矩阵。
         */
        protected _adjustTransform(): Matrix;
        /**
         * @en The matrix information of the object. By setting the matrix, node rotation, scaling, and displacement effects can be achieved.
         * @zh 对象的矩阵信息。通过设置矩阵可以实现节点旋转，缩放，位移效果。
         */
        get transform(): Matrix;
        set transform(value: Matrix);
        /**
         * @en The x-axis pivot point position, in pixels, with a default value of 0. The pivot point affects the object's position, scaling center, and rotation center.
         * @zh X 轴轴心点的位置，以像素为单位，默认为 0。轴心点会影响对象的位置、缩放中心和旋转中心。
         */
        get pivotX(): number;
        set pivotX(value: number);
        /**
         * @en The y-axis pivot point position, in pixels, with a default value of 0. The pivot point affects the object's position, scaling center, and rotation center.
         * @zh Y 轴轴心点的位置，以像素为单位，默认为 0。轴心点会影响对象的位置、缩放中心和旋转中心。
         */
        get pivotY(): number;
        set pivotY(value: number);
        /**
         * @en The anchor point's x-coordinate, ranging from 0 to 1. Setting anchorX will ultimately change the node's pivot point through the pivotX value.
         * @zh X 轴锚点,值为 0-1。设置 anchorX 值最终会通过 pivotX 值来改变节点的轴心点。
         */
        get anchorX(): number;
        set anchorX(value: number);
        /**
         * @en The anchor point's y-coordinate, ranging from 0 to 1. Setting anchorY will ultimately change the node's pivot point through the pivotY value.
         * @zh Y 轴锚点，值为 0-1。设置 anchorY 值最终会通过 pivotY 值来改变节点的轴心点。
         */
        get anchorY(): number;
        set anchorY(value: number);
        /**
         * @en The transparency value, ranging from 0 to 1, with a default value of 1 (opaque). Changing the alpha value will affect the drawcall.
         * @zh 透明度,值为 0-1,默认值为 1(不透明)。更改 alpha 值会影响 drawcall。
         */
        get alpha(): number;
        set alpha(value: number);
        /**
         * @en Indicates whether the object is visible. The default value is true. If set to false, the node will not be rendered.
         * @zh 表示对象是否可见,默认为 true。如果设置为 false,节点将不会被渲染。
         */
        get visible(): boolean;
        set visible(value: boolean);
        /**
         * @en Specifies the blending mode to be used. Only "lighter" is currently supported.
         * @zh 指定要使用的混合模式，目前只支持 "lighter"。
         */
        get blendMode(): string;
        set blendMode(value: string);
        /**
         * @en The drawing object, which encapsulates the interfaces for drawing bitmaps and vector graphics. All drawing operations of Sprite are implemented through Graphics.
         * @zh 绘图对象。封装了绘制位图和矢量图的接口,Sprite 的所有绘图操作都是通过 Graphics 实现的。
         */
        get graphics(): Graphics;
        set graphics(value: Graphics);
        /**
         * @en Set the Graphics object for drawing.
         * @param value The Graphics object to set.
         * @param transferOwnership Whether to set the Graphics object to the belonging node (i.e., transfer the ownership of the Graphics object to the Sprite). If true, the Sprite will be responsible for destroying the Graphics object when it's no longer needed.
         * @zh 设置用于绘制的 Graphics 对象。
         * @param value 要设置的 Graphics 对象。
         * @param transferOwnership 是否将 Graphics 对象设置到所属节点上(即将 Graphics 对象的所有权转移给 Sprite)。如果为 true,则 Sprite 将负责在不再需要 Graphics 对象时销毁它。
         */
        setGraphics(value: Graphics, transferOwnership: boolean): void;
        /**
         * @en 2D sprite material
         * @zh 2D精灵材质
         */
        get material(): Material;
        set material(value: Material);
        /**
         * @en The scroll rectangle range of the display object, with a clipping effect (if you only want to limit the rendering area of child objects, please use viewport).
         * Differences between srollRect and viewport:
         * 1. srollRect has a clipping effect, viewport only affects whether child objects are rendered, and does not have a clipping effect (higher performance).
         * 2. Setting the x and y properties of the rect can achieve scrolling effect, but scrollRect will keep the position of point 0,0 unchanged.
         * @zh 显示对象的滚动矩形范围，具有裁剪效果(如果只想限制子对象渲染区域，请使用viewport)
         * srollRect和viewport的区别：
         * 1.srollRect自带裁剪效果，viewport只影响子对象渲染是否渲染，不具有裁剪效果（性能更高）。
         * 2.设置rect的x,y属性均能实现区域滚动效果，但scrollRect会保持0,0点位置不变。
         */
        get scrollRect(): Rectangle;
        set scrollRect(value: Rectangle);
        /**
        * @en The viewport size. Child objects outside the viewport will not be rendered (if you want to achieve a clipping effect, please use scrollRect). Proper use can improve rendering performance. For example, map tiles composed of small images will not render small images outside the viewport.
        * The default value is null.
        * The differences between scrollRect and viewport:
        * 1. scrollRect comes with a clipping effect, while viewport only affects whether child objects are rendered without clipping (better performance).
        * 2. Setting the x and y properties of the rect can achieve a scrolling effect in the area, but scrollRect will keep the position of point 0,0 unchanged.
        * @zh 视口大小，视口外的子对象将不被渲染（如果想实现裁剪效果，请使用scrollRect），合理使用能提高渲染性能。例如，由一个个小图片拼成的地图块，viewport外面的小图片将不渲染。
        * 默认值为null。
        * scrollRect和viewport的区别：
        * 1. scrollRect自带裁剪效果，viewport只影响子对象是否渲染，不具有裁剪效果（性能更高）。
        * 2. 设置rect的x,y属性均能实现区域滚动效果，但scrollRect会保持0,0点位置不变。
        */
        get viewport(): Rectangle;
        set viewport(value: Rectangle);
        /**
         * @en Set the position. Equivalent to setting the x and y properties separately.
         * Since the return value is the Sprite object itself, you can use the following syntax: spr.pos(...).scale(...);
         * @param x X-axis coordinate.
         * @param y Y-axis coordinate.
         * @param speedMode (Optional) Whether to use speed mode. Normally, this.x=value is called to assign values. Speed mode directly calls the internal function to handle it. If the x and y properties are not overridden, it is recommended to set to speed mode for higher performance.
         * @returns The object itself.
         * @zh 设置坐标位置。相当于分别设置x和y属性。
         * 因为返回值为Sprite对象本身，所以可以使用如下语法：spr.pos(...).scale(...);
         * @param x X轴坐标。
         * @param y Y轴坐标。
         * @param speedMode （可选）是否极速模式，正常是调用this.x=value进行赋值，极速模式直接调用内部函数处理，如果未重写x,y属性，建议设置为极速模式性能更高。
         * @returns 返回对象本身。
         */
        pos(x: number, y: number, speedMode?: boolean): Sprite;
        /**
         * @en Set the pivot point. Equivalent to setting the pivotX and pivotY properties separately.
         * Since the return value is the Sprite object itself, you can use the following syntax: spr.pivot(...).pos(50, 100);
         * @param x X-axis pivot point.
         * @param y Y-axis pivot point.
         * @returns The object itself.
         * @zh 设置轴心点。相当于分别设置pivotX和pivotY属性。
         * 因为返回值为Sprite对象本身，所以可以使用如下语法：spr.pivot(...).pos(50, 100);
         * @param x X轴心点。
         * @param y Y轴心点。
         * @returns 返回对象本身。
         */
        pivot(x: number, y: number): Sprite;
        /**
         * @en Set the size. Equivalent to setting the width and height properties separately.
         * Since the return value is the Sprite object itself, you can use the following syntax: spr.size(...).pos(50, 100);
         * @param width Width value.
         * @param height Height value.
         * @returns The object itself.
         * @zh 设置宽高。相当于分别设置width和height属性。
         * 因为返回值为Sprite对象本身，所以可以使用如下语法：spr.size(...).pos(50, 100);
         * @param width 宽度值。
         * @param height 高度值。
         * @returns 返回对象本身。
         */
        size(width: number, height: number): Sprite;
        /**
         * @en Set the scale. Equivalent to setting the scaleX and scaleY properties separately.
         * Since the return value is the Sprite object itself, you can use the following syntax: spr.scale(...).pos(50, 100);
         * @param scaleX X-axis scale ratio.
         * @param scaleY Y-axis scale ratio.
         * @param speedMode (Optional) Whether to use speed mode. Normally, this.scaleX=value is called to assign values. Speed mode directly calls the internal function to handle it. If the scaleX and scaleY properties are not overridden, it is recommended to set to speed mode for higher performance.
         * @returns The object itself.
         * @zh 设置缩放。相当于分别设置scaleX和scaleY属性。
         * 因为返回值为Sprite对象本身，所以可以使用如下语法：spr.scale(...).pos(50, 100);
         * @param scaleX X轴缩放比例。
         * @param scaleY Y轴缩放比例。
         * @param speedMode （可选）是否极速模式，正常是调用this.scaleX=value进行赋值，极速模式直接调用内部函数处理，如果未重写scaleX,scaleY属性，建议设置为极速模式性能更高。
         * @returns 返回对象本身。
         */
        scale(scaleX: number, scaleY: number, speedMode?: boolean): Sprite;
        /**
         * @en Set the skew angle. Equivalent to setting the skewX and skewY properties separately.
         * Since the return value is the Sprite object itself, you can use the following syntax: spr.skew(...).pos(50, 100);
         * @param skewX Horizontal skew angle.
         * @param skewY Vertical skew angle.
         * @returns The object itself.
         * @zh 设置倾斜角度。相当于分别设置skewX和skewY属性。
         * 因为返回值为Sprite对象本身，所以可以使用如下语法：spr.skew(...).pos(50, 100);
         * @param skewX 水平倾斜角度。
         * @param skewY 垂直倾斜角度。
         * @returns 返回对象本身。
         */
        skew(skewX: number, skewY: number): Sprite;
        /**
         * @en Update and render the display object. Called by the system.
         * @param ctx The rendering context reference.
         * @param x The X-axis coordinate.
         * @param y The Y-axis coordinate.
         * The meaning of x and y is complex. Without rotation, it is the world position of the current node.
         * If any parent node has rotation, x and y will be reset to [0,0] there and then accumulated again.
         * So, x and y can be considered as the cumulative value from the current node to a node with rotation (or the root node).
         * @zh 更新、呈现显示对象。由系统调用。
         * @param ctx 渲染的上下文引用。
         * @param x X轴坐标。
         * @param y Y轴坐标。
         * 关于上面的x、y的含义比较复杂，在没有旋转的情况下，它就是当前节点的世界坐标的位置。
         * 如果此节点的某个父节点有旋转，x、y会在那里被重置为[0,0]，然后继续累加。
         * 所以可以认为这个x、y是表示当前节点到某个有旋转的节点（或者根节点）的累加值。
         */
        render(ctx: Context, x: number, y: number): void;
        /**
         * @en Draws the current Sprite to a Canvas and returns an HtmlCanvas object.
         * The drawing result can be used as an image source to be drawn into other Sprites.
         * It can also obtain the original image data, send it to the server, or save it as an image to achieve a screenshot effect.
         * @param canvasWidth The width of the canvas.
         * @param canvasHeight The height of the canvas.
         * @param offsetX The X-axis offset for drawing.
         * @param offsetY The Y-axis offset for drawing.
         * @returns The HTMLCanvas object.
         * @zh 绘制当前 Sprite 到 Canvas 上,并返回一个 HtmlCanvas 对象。
         * 绘制的结果可以当作图片源,再次绘制到其他 Sprite 里面。也可以获取原始图片数据,发给服务器或者保存为图片,从而实现截图效果。
         * @param canvasWidth 画布宽度。
         * @param canvasHeight 画布高度。
         * @param offsetX 绘制的 X 轴偏移量。
         * @param offsetY 绘制的 Y 轴偏移量。
         * @returns HTMLCanvas 对象。
         */
        drawToCanvas(canvasWidth: number, canvasHeight: number, offsetX: number, offsetY: number): HTMLCanvas;
        /**
         * @ignore
         * @en Draws the specified Sprite to a Canvas and returns an HtmlCanvas object.
         * @param sprite The Sprite to draw.
         * @param canvasWidth The width of the canvas.
         * @param canvasHeight The height of the canvas.
         * @param offsetX The X-axis offset for drawing.
         * @param offsetY The Y-axis offset for drawing.
         * @returns The HTMLCanvas object.
         * @zh 绘制指定的 Sprite 到 Canvas 上,并返回一个 HtmlCanvas 对象。
         * @param sprite 要绘制的 Sprite。
         * @param canvasWidth 画布宽度。
         * @param canvasHeight 画布高度。
         * @param offsetX 绘制的 X 轴偏移量。
         * @param offsetY 绘制的 Y 轴偏移量。
         * @returns HTMLCanvas 对象。
         */
        static drawToCanvas(sprite: Sprite, canvasWidth: number, canvasHeight: number, offsetX: number, offsetY: number, isDrawRenderRect?: boolean): HTMLCanvas;
        /**
         * @deprecated
         * @en Draws the current object to a Texture object.
         * @param canvasWidth The width of the canvas.
         * @param canvasHeight The height of the canvas.
         * @param offsetX The X-axis offset for drawing.
         * @param offsetY The Y-axis offset for drawing.
         * @param rt The render target.
         * @param isDrawRenderRect A boolean indicating whether to draw the render rectangle. When true, it starts drawing from (0,0) of the render texture and subtracts the offset of the cache rectangle. When false, it keeps the sprite's original relative position for drawing.
         * @returns The drawn Texture or RenderTexture2D object.
         * @zh 绘制当前对象到一个 Texture 对象上。
         * @param canvasWidth 画布宽度。
         * @param canvasHeight 画布高度。
         * @param offsetX 绘制的 X 轴偏移量。
         * @param offsetY 绘制的 Y 轴偏移量。
         * @param rt 渲染目标。
         * @param isDrawRenderRect 表示是否绘制渲染矩形。为 true 时，从渲染纹理的(0,0)点开始绘制，但要减去缓存矩形的偏移；为 false 时，保持精灵的原始相对位置进行绘制。
         * @returns 绘制的 Texture 或 RenderTexture2D 对象。
         */
        drawToTexture(canvasWidth: number, canvasHeight: number, offsetX: number, offsetY: number, rt?: RenderTexture2D | null, isDrawRenderRect?: boolean): Texture | RenderTexture2D;
        /**
         * @deprecated
         * @ignore
         * @en Draws the specified Sprite to a Texture or RenderTexture2D object.
         * @param sprite The Sprite to draw.
         * @param canvasWidth The width of the canvas.
         * @param canvasHeight The height of the canvas.
         * @param offsetX The X-axis offset for drawing.
         * @param offsetY The Y-axis offset for drawing.
         * @param rt The render target. If not provided, a new RenderTexture2D will be created.
         * @param isDrawRenderRect A boolean indicating whether to draw the render rectangle. When true, it starts drawing from (0,0) of the render texture and subtracts the offset of the cache rectangle. When false, it keeps the sprite's original relative position for drawing.
         * @returns The drawn Texture or RenderTexture2D object.
         * @zh 将指定的 Sprite 绘制到 Texture 或 RenderTexture2D 对象上。
         * @param sprite 要绘制的 Sprite。
         * @param canvasWidth 画布宽度。
         * @param canvasHeight 画布高度。
         * @param offsetX 绘制的 X 轴偏移量。
         * @param offsetY 绘制的 Y 轴偏移量。
         * @param rt 渲染目标。如果未提供,将创建一个新的 RenderTexture2D。
         * @param isDrawRenderRect 表示是否绘制渲染矩形。为 true 时，从渲染纹理的(0,0)点开始绘制，但要减去缓存矩形的偏移；为 false 时，保持精灵的原始相对位置进行绘制。
         * @returns 绘制的 Texture 或 RenderTexture2D 对象。
         */
        static drawToTexture(sprite: Sprite, canvasWidth: number, canvasHeight: number, offsetX: number, offsetY: number, rt?: RenderTexture2D | null, isDrawRenderRect?: boolean): Texture | RenderTexture2D;
        /**
         * @en Draws the current object to a RenderTexture2D object.
         * @param canvasWidth The width of the canvas.
         * @param canvasHeight The height of the canvas.
         * @param offsetX The X-axis offset for drawing.
         * @param offsetY The Y-axis offset for drawing.
         * @param rt The render target.
         * @param isDrawRenderRect A boolean indicating whether to draw the render rectangle. When true, it starts drawing from (0,0) of the render texture and subtracts the offset of the cache rectangle. When false, it keeps the sprite's original relative position for drawing.
         * @param flipY Optional. If true, the texture will be flipped vertical. Default is false.
         * @returns The drawn RenderTexture2D object.
         * @zh 绘制当前对象到一个 Texture 对象上。
         * @param canvasWidth 画布宽度。
         * @param canvasHeight 画布高度。
         * @param offsetX 绘制的 X 轴偏移量。
         * @param offsetY 绘制的 Y 轴偏移量。
         * @param rt 渲染目标。
         * @param isDrawRenderRect 表示是否绘制渲染矩形。为 true 时，从渲染纹理的(0,0)点开始绘制，但要减去缓存矩形的偏移；为 false 时，保持精灵的原始相对位置进行绘制。
         * @param flipY 可选。如果为 true，则垂直翻转纹理。默认为 false。
         * @returns 绘制的 RenderTexture2D 对象。
         */
        drawToRenderTexture2D(canvasWidth: number, canvasHeight: number, offsetX: number, offsetY: number, rt?: RenderTexture2D | null, isDrawRenderRect?: boolean, flipY?: boolean): RenderTexture2D;
        /**
         * @ignore
         * @en Draws the specified Sprite to a RenderTexture2D object.
         * @param sprite The Sprite to draw.
         * @param canvasWidth The width of the canvas.
         * @param canvasHeight The height of the canvas.
         * @param offsetX The X-axis offset for drawing.
         * @param offsetY The Y-axis offset for drawing.
         * @param rt The render target. If not provided, a new RenderTexture2D will be created.
         * @param isDrawRenderRect A boolean indicating whether to draw the render rectangle. When true, it starts drawing from (0,0) of the render texture and subtracts the offset of the cache rectangle. When false, it keeps the sprite's original relative position for drawing.
         * @param flipY Optional. If true, the texture will be flipped vertical. Default is false.
         * @returns The drawn RenderTexture2D object.
         * @zh 将指定的 Sprite 绘制到 RenderTexture2D 对象上。
         * @param sprite 要绘制的 Sprite。
         * @param canvasWidth 画布宽度。
         * @param canvasHeight 画布高度。
         * @param offsetX 绘制的 X 轴偏移量。
         * @param offsetY 绘制的 Y 轴偏移量。
         * @param rt 渲染目标。如果未提供,将创建一个新的 RenderTexture2D。
         * @param isDrawRenderRect 表示是否绘制渲染矩形。为 true 时，从渲染纹理的(0,0)点开始绘制，但要减去缓存矩形的偏移；为 false 时，保持精灵的原始相对位置进行绘制。
         * @param flipY 可选。如果为 true，则垂直翻转纹理。默认为 false。
         * @returns 绘制的 RenderTexture2D 对象。
         */
        static drawToRenderTexture2D(sprite: Sprite, canvasWidth: number, canvasHeight: number, offsetX: number, offsetY: number, rt?: RenderTexture2D | null, isDrawRenderRect?: boolean, flipY?: boolean): RenderTexture2D;
        /**
         * 绘制到Canvas的上下文
         */
        static drawtocanvCtx: Context;
        /**
         * @en Custom update and render display objects. Generally used to extend rendering modes. Please use it reasonably as it may cause inability to render on accelerators.
         * Note: Do not add or remove tree nodes in this function, otherwise it will affect the traversal of tree nodes.
         * @param context The rendering context reference.
         * @param x The X-axis coordinate.
         * @param y The Y-axis coordinate.
         * @zh 自定义更新、呈现显示对象。一般用来扩展渲染模式,请合理使用,可能会导致在加速器上无法渲染。
         * 注意: 不要在此函数内增加或删除树节点,否则会对树节点遍历造成影响。
         * @param context 渲染的上下文引用。
         * @param x X轴坐标。
         * @param y Y轴坐标。
         */
        customRender(context: Context, x: number, y: number): void;
        /**
         * @en The filter collection. Multiple filters can be combined.
         * @zh 滤镜集合。可以设置多个滤镜组合。
         */
        get filters(): Filter[];
        set filters(value: Filter[]);
        /**
         * @en Converts the local coordinates to the global coordinates relative to the stage.
         * @param point The local coordinate point.
         * @param createNewPoint (Optional) Whether to create a new Point object as the return value. The default is false, which uses the input point object as the return value to reduce object creation overhead.
         * @param globalNode The global node, default is Laya.stage
         * @return The converted global coordinate point.
         * @zh 把本地坐标转换为相对stage的全局坐标。
         * @param point 本地坐标点。
         * @param createNewPoint （可选）是否创建一个新的Point对象作为返回值，默认为false，使用输入的point对象返回，减少对象创建开销。
         * @param globalNode global节点，默认为Laya.stage
         * @return 转换后的坐标的点。
         */
        localToGlobal(point: Point, createNewPoint?: boolean, globalNode?: Sprite | null): Point;
        /**
         * @en Converts the global coordinates relative to the stage to the local coordinates.
         * @param point The global coordinate point.
         * @param createNewPoint (Optional) Whether to create a new Point object as the return value. The default is false, which uses the input point object as the return value to reduce object creation overhead.
         * @param globalNode The global node, default is Laya.stage.
         * @return The converted local coordinate point.
         * @zh 把stage的全局坐标转换为本地坐标。
         * @param point 全局坐标点。
         * @param createNewPoint （可选）是否创建一个新的Point对象作为返回值，默认为false，使用输入的point对象返回，减少对象创建开销。
         * @param globalNode global节点，默认为Laya.stage。
         * @return 转换后的坐标的点。
         */
        globalToLocal(point: Point, createNewPoint?: boolean, globalNode?: Sprite | null): Point;
        /**
         * @en Converts the coordinates in the local coordinate system to the coordinates in the parent container coordinate system.
         * @param point The local coordinate point.
         * @return The converted point in the parent container coordinate system.
         * @zh 将本地坐标系坐标转换到父容器坐标系。
         * @param point 本地坐标点。
         * @return 转换后的点。
         */
        toParentPoint(point: Point): Point;
        /**
         * @en Converts the coordinates in the parent container coordinate system to the coordinates in the local coordinate system.
         * @param point The point in the parent container coordinate system.
         * @return The converted point in the local coordinate system.
         * @zh 将父容器坐标系坐标转换到本地坐标系。
         * @param point 父容器坐标点。
         * @return 转换后的点。
         */
        fromParentPoint(point: Point): Point;
        /**
         * @en Starts listening to a specific event type. This method is called when a new event listener is added.
         * If it is a mouse event, it sets itself and its parent objects to accept mouse interaction events.
         * @param type The event type.
         * @zh 开始监听特定事件类型。当添加新的事件侦听器时调用此方法。
         * 如果是鼠标事件，则设置自己和父对象为可接受鼠标交互事件。
         * @param type 事件类型。
         */
        protected onStartListeningToType(type: string): void;
        /**
        * @en Ensures that when the node is set to accept mouse interaction events, all parent objects are also set to accept mouse interaction events.
        * @zh 当节点设置为接受鼠标交互事件时，确保所有父对象也被设置为接受鼠标交互事件。
        */
        protected _onDisplay(v?: boolean): void;
        /**
         * @en Set the parent node of the current node.
         * @param value The new parent node.
         * @zh 设置当前节点的父节点。
         * @param value 新的父节点。
         */
        protected _setParent(value: Node): void;
        /**
         * @en Load and display an image. Equivalent to loading the image and then setting the texture property. Note: calling this method multiple times will only display one image.
         * @param url The image URL.
         * @param complete (Optional) The callback function when loading is complete.
         * @returns Returns the Sprite object itself.
         * @zh 加载并显示一个图片。相当于加载图片后，设置texture属性。注意：多次调用，只会显示一个图片。
         * @param url 图片地址。
         * @param complete （可选）加载完成回调。
         * @returns 返回精灵对象本身。
         */
        loadImage(url: string, complete?: Handler): Sprite;
        /**
         * @en Create a new `Sprite` object based on the image URL to load and display the image.
         * @param url The image URL.
         * @returns Returns a new `Sprite` object.
         * @zh 根据图片地址创建一个新的 `Sprite` 对象用于加载并显示此图片。
         * @param url 图片地址。
         * @returns 返回新的 `Sprite`  对象。
         */
        static fromImage(url: string): Sprite;
        /**
        * @en Redraw the Sprite and invalidate its own and parent's cache after setting cacheAs.
        * @param type The redraw type.
        * @zh 重新绘制，cacheAs后，设置自己和父对象缓存失效。
        * @param type 重新绘制类型。
        */
        repaint(type?: number): void;
        /**
        * @en Callback when a child node changes.
        * @param child The child node that has changed.
        * @zh 子节点发生变化时的回调。
        * @param child 发生变化的子节点。
        */
        protected _childChanged(child?: Node): void;
        /**
         * @en Repaint the parent node. When `cacheAs` is enabled, set all parent object caches to invalid.
         * @param type The type of repaint. Default is SpriteConst.REPAINT_CACHE.
         * @zh 重新绘制父节点。启用 `cacheAs` 时，设置所有父对象缓存失效。
         * @param type 重新绘制类型。默认为 SpriteConst.REPAINT_CACHE。
         */
        parentRepaint(type?: number): void;
        /**
         * @en Reference to the stage.
         * @zh 对舞台的引用。
         */
        get stage(): Stage;
        /**
         * @en You can set a rectangular area as the clickable region, or set a HitArea instance as the clickable region. The HitArea can have both clickable and non-clickable areas defined. If the hitArea is not set, the mouse collision detection will be based on the area formed by the width and height of the object.
         * @zh 可以设置一个矩形区域作为点击区域，或者设置一个 `HitArea` 实例作为点击区域，HitArea 内可以设置可点击和不可点击区域。如果不设置 hitArea，则根据宽高形成的区域进行鼠标碰撞检测。
         */
        get hitArea(): IHitArea;
        set hitArea(value: IHitArea);
        /**
         * @en Masking allows setting an object (bitmap or vector graphic) as a mask, displaying content based on the object's shape.
         * @zh 遮罩，可以设置一个对象（支持位图和矢量图），根据对象形状进行遮罩显示。
         */
        get mask(): Sprite;
        set mask(value: Sprite);
        /**
         * @en Indicates whether the object receives mouse events.
         * The default is false. If you listen to mouse events, this value and the value of mouseEnable for parent nodes will be automatically set to true (unless the parent node is manually set to false).
         * @zh 是否接受鼠标事件。
         * 默认为 false，如果监听鼠标事件，则会自动设置本对象及父节点的属性 mouseEnable 的值都为 true（如果父节点手动设置为 false，则不会更改）。
         */
        get mouseEnabled(): boolean;
        set mouseEnabled(value: boolean);
        /**
         * @en Starts dragging this object.
         * @param area (Optional) The drag area, which is the active area of the object's registration point (excluding the object's width and height).
         * @param hasInertia (Optional) Whether the object has inertia when the mouse is released. The default is false.
         * @param elasticDistance (Optional) The distance value of the elastic effect. A value of 0 means no elastic effect. The default is 0.
         * @param elasticBackTime (Optional) The bounce-back time for the elastic effect in milliseconds. The default is 300 milliseconds.
         * @param data (Optional) The data carried by the drag event.
         * @param ratio (Optional) The inertia damping coefficient, which affects the strength and duration of inertia.
         * @zh 开始拖动此对象。
         * @param area				（可选）拖动区域，此区域为当前对象注册点活动区域（不包括对象宽高） 。
         * @param hasInertia		（可选）鼠标松开后，是否还惯性滑动，默认为false。
         * @param elasticDistance	（可选）橡皮筋效果的距离值，0为无橡皮筋效果，默认为0。
         * @param elasticBackTime	（可选）橡皮筋回弹时间，单位为毫秒，默认为300毫秒。
         * @param data				（可选）拖动事件携带的数据。
         * @param ratio				（可选）惯性阻尼系数，影响惯性力度和时长。
         */
        startDrag(area?: Rectangle, hasInertia?: boolean, elasticDistance?: number, elasticBackTime?: number, data?: any, ratio?: number): void;
        /**
         * @en Stops dragging this object.
         * @zh 停止拖动此对象。
         */
        stopDrag(): void;
        /**
         * @en Checks whether a point is within this object.
         * @param x Global x-coordinate.
         * @param y Global y-coordinate.
         * @returns Indicates whether the point is inside the object.
         * @zh 检测某个点是否在此对象内。
         * @param x 全局x坐标。
         * @param y 全局y坐标。
         * @returns 表示是否在对象内。
         */
        hitTestPoint(x: number, y: number): boolean;
        /**
         * @en Get the mouse coordinates relative to this object.
         * @returns The screen point information.
         * @zh 获得相对于本对象上的鼠标坐标信息。
         * @returns 屏幕点信息。
         */
        getMousePoint(): Point;
        /**
         * @en The X-axis coordinate of the mouse in this object's coordinate system.
         * @zh 鼠标在此对象坐标系上的 X 轴坐标信息。
         */
        get mouseX(): number;
        /**
         * @en The Y-axis coordinate of the mouse in this object's coordinate system.
         * @zh 鼠标在此对象坐标系上的 Y 轴坐标信息。
         */
        get mouseY(): number;
        /**
         * @en The z-order. If this value is changed, all objects of the same container will be re-sorted according to the value. The larger the value, the higher it is. The default is 0, which is sorted according to the order of addition.
         * @zh z排序，更改此值，则会按照值的大小对同一容器的所有对象重新排序。值越大，越靠上。默认为0，则根据添加顺序排序。
         */
        get zOrder(): number;
        set zOrder(value: number);
        /**
         * @en Set a Texture instance and display the image (if there are other drawings before, it will be cleared).
         * Equivalent to graphics.clear();graphics.drawImage(), but with better performance.
         * You can also assign an image address, which will automatically load the image and then display it.
         * @zh 设置一个Texture实例，并显示此图片（如果之前有其他绘制，则会被清除掉）。
         * 等同于graphics.clear();graphics.drawImage()，但性能更高。
         * 还可以赋值一个图片地址，则会自动加载图片，然后显示。
         */
        get texture(): Texture;
        set texture(value: Texture);
        /**
         * @en Draw call optimization: when set to true, draw call optimization is enabled. During engine rendering, all text is automatically brought to the top layer to avoid interruptions by text when drawing images from the same atlas, thus reducing the number of draw calls.
         * Enabling this will cause text to be non-obstructable. Use this feature cautiously if your project requires text to be obstructed.
         * @zh 绘制调用优化，为true时，开启drawcall优化。引擎绘制时自动将所有文本提到显示最上层，避免同一个图集内的图像绘制时被文本打断，可以减少drawcall数量。
         * 开启后，会导致文本无法被遮挡，存在文本遮挡需求的项目，请谨慎使用该功能。
         */
        set drawCallOptimize(value: boolean);
        get drawCallOptimize(): boolean;
        set cacheGlobal(value: boolean);
        set globalRotation(value: number);
        /**
         * @en Gets the global X-axis scale relative to the stage (this value includes the scaling of parent nodes).
         * @returns The global X-axis scale.
         * @zh 获得相对于stage的全局X轴缩放值（会叠加父亲节点的缩放值）。
         * @returns 全局X轴缩放值。
         */
        get globalScaleX(): number;
        /**
         * @en Gets the global Y-axis scale relative to the stage (this value includes the scaling of parent nodes).
         * @returns The global Y-axis scale.
         * @zh 获得相对于stage的全局Y轴缩放值（会叠加父亲节点的缩放值）。
         * @returns 全局Y轴缩放值。
         */
        get globalScaleY(): number;
        /**
        * @en Sets a global cache flag for a specific type.
        * @param type The type of cache flag to set.
        * @param value Whether to enable the cache flag.
        * @zh 设置特定类型的全局缓存标志。
        * @param type 要设置的缓存标志类型。
        * @param value 是否启用缓存标志。
        */
        private _setGlobalCacheFlag;
    }
    /**
     * @ignore
     */
    class SpriteConst {
        static ALPHA: number;
        static TRANSFORM: number;
        static BLEND: number;
        static CANVAS: number;
        static FILTERS: number;
        static MASK: number;
        static CLIP: number;
        static TEXTURE: number;
        static GRAPHICS: number;
        static RENDERNODE2D: number;
        static CUSTOM: number;
        static HITAREA: number;
        static CHILDS: number;
        static REPAINT_NONE: number;
        static REPAINT_NODE: number;
        static REPAINT_CACHE: number;
        static REPAINT_ALL: number;
    }
    /**
     * @zh Stage 是舞台类，显示列表的根节点，所有显示对象都在舞台上显示。通过 Laya.stage 单例访问。
     * Stage提供几种适配模式，不同的适配模式会产生不同的画布大小，画布越大，渲染压力越大，所以要选择合适的适配方案。
     * Stage提供不同的帧率模式，帧率越高，渲染压力越大，越费电，合理使用帧率甚至动态更改帧率有利于改进手机耗电。
     * - Event.RESIZE("resize"): 舞台大小经过重新调整时进行调度。
     * - Event.FOCUS("focus"): 舞台获得焦点时调度。比如浏览器或者当前标签处于后台，重新切换回来时进行调度。
     * - Event.BLUR("blur"): 舞台失去焦点时调度。比如浏览器或者当前标签被切换到后台后调度。
     * - Event.FOCUS_CHANGE("focuschange"): 舞台焦点变化时调度，使用Laya.stage.isFocused可以获取当前舞台是否获得焦点。
     * - Event.VISIBILITY_CHANGE("visibilitychange"): 舞台可见性发生变化时调度（比如浏览器或者当前标签被切换到后台后调度），使用Laya.stage.isVisibility可以获取当前是否处于显示状态。
     * - Event.FULL_SCREEN_CHANGE("fullscreenchange"): 浏览器全屏更改时调度，比如进入全屏或者退出全屏。
     * @en Stage is the root node of the display list. All display objects are shown on the stage. It can be accessed through the Laya.stage singleton.
     * Stage provides several adaptation modes. Different adaptation modes will produce different canvas sizes. The larger the canvas, the greater the rendering pressure, so it's important to choose an appropriate adaptation scheme.
     * Stage provides different frame rate modes. The higher the frame rate, the greater the rendering pressure and power consumption. Reasonable use of frame rates or even dynamic changes in frame rates can help improve mobile phone power consumption.
     * - Event.RESIZE("resize"): Discheduled when the stage size is resized.
     * - Event.FOCUS("focus"): Dispatched when the stage gains focus. For example, when the browser or current tab is switched back from the background.
     * - Event.BLUR("blur"): Dispatched when the stage loses focus. For example, when the browser or current tab is switched to the background.
     * - Event.FOCUS_CHANGE("focuschange"): Dispatched when the stage focus changes. Use Laya.stage.isFocused to get whether the current stage has focus.
     * - Event.VISIBILITY_CHANGE("visibilitychange"): Dispatched when the stage visibility changes (e.g., when the browser or current tab is switched to the background). Use Laya.stage.isVisibility to get the current visibility state.
     * - Event.FULL_SCREEN_CHANGE("fullscreenchange"): Discheduled when the browser fullscreen state changes, such as entering or exiting fullscreen mode.
     */
    class Stage extends Sprite {
        /**
        * @zh 不缩放模式：画布宽高等于设计宽高，不进行任何缩放，舞台按照设计尺寸显示，这种模式适合在固定像素大小的嵌入需求，如果出现在与设计宽高不同尺寸的设备上，会出现空白区域或内容超出屏幕（运行窗口）的情况。
        * @en No Scale Mode:The canvas width and height are equal to the design resolution, with no scaling applied. The stage is rendered strictly according to the design dimensions. This mode is suitable for scenarios where a fixed-size pixel canvas is embedded in another interface. If used on devices with screen sizes different from the design resolution, blank margins may appear or content may overflow beyond the screen boundaries.
        */
        static SCALE_NOSCALE: string;
        /**
         * @zh 设计内容全部显示的等比缩放模式：画布宽高等于设计宽高，在确保全部设计内容可见，避免裁切的前提下，将舞台（画布适配后的逻辑宽高）等比缩放至屏幕（运行窗口）最大尺寸，缩放系数取设计宽度与屏幕宽度、设计高度与屏幕高度之间的最小缩放因子。该模式在与设计尺寸比例不同的屏幕上，会出现上下或左右的空白边缘，通常需要配合画布的对齐方式使用。
         * @en Show All Mode: The canvas size equals the design resolution. To ensure that all design content remains visible with no cropping, the stage (i.e., the logical width and height after the canvas is adapted) is uniformly scaled to the largest size that fits inside the screen (runtime window). The scaling factor is the smaller of the two ratios: screen width ÷ design width and screen height ÷ design height. When the screen’s aspect ratio differs from the design’s, blank margins may appear at the top and bottom or the left and right edges, so this mode is typically used together with a canvas-alignment setting.
         */
        static SCALE_SHOWALL: string;
        /**
         * @zh 没底色边的等比缩放模式（全屏适配）：画布宽高等于设计宽高，在确保不会漏出屏幕背景颜色的前提下，将舞台（画布适配后的逻辑宽高）等比缩放至填满屏幕（运行窗口），缩放系数取设计宽度与屏幕宽度、设计高度与屏幕高度之间的最大缩放因子。该模式在与设计尺寸比例不同的屏幕上，会导致部分设计内容被裁切（舞台尺寸超出屏幕），通常用于没有边缘UI，对边缘裁切无所谓的3D场景中。
         * @en No Border Mode: The canvas size equals the design resolution. Under the premise of ensuring that the screen background color is never exposed, the stage (i.e., the logical width and height after the canvas is adapted) is uniformly scaled to fill the entire screen (runtime window). The scaling factor is the larger of the two ratios: screen width ÷ design width and screen height ÷ design height. When the screen’s aspect ratio differs from the design’s, part of the design content may be cropped (since the stage size exceeds the screen). This mode is typically used in 3D scenes without edge UI elements, where edge cropping is not a concern.
         */
        static SCALE_NOBORDER: string;
        /**
         * @zh 画布铺满的不缩放模式：画布和舞台（即画布适配后的逻辑宽高）等于屏幕（运行窗口）的宽高，但不对设计内容本身进行缩放。如果有 UI 元素，开发者需要根据设备的 DPR（设备像素比）自行进行缩放，否则在高 DPR 设备上 UI 会显得较小。该模式通常用于以 3D 内容为主、UI 较少且采用动态相对布局的场景。
         * @en Full Mode: The canvas and the stage (i.e., the logical width and height after adaptation) are set to match the screen (runtime window) dimensions, but the design content itself is not scaled. If there are UI elements, developers need to scale them manually according to the device's DPR (pixelRatio), otherwise the UI may appear too small on high-DPR devices. This mode is commonly used in 3D games with minimal UI that relies on dynamic or relative layout.
         */
        static SCALE_FULL: string;
        /**
         * @zh 画布铺满的缩放模式：与SCALE_FULL类似，画布和舞台（即画布适配后的逻辑宽高）等于屏幕（运行窗口）的宽高，但区别是，设计内容会按 DPR(pixelRatio) 进行缩放，适合于各种高 DPR 的机型应用场景。
         * - 该模式的好处是，不需要开发者对于 UI 根据 DPR 自行在逻辑里进行缩放处理。
         * - 需要注意的是，在这种模式下，设计的宽高不能使用目标机型的物理分辨率，而是要使用目标机型的逻辑分辨率（物理分辨率除以DRP），这与其它适配模式不同，否则，会导致超出逻辑分辨率部分内容被裁切。
         * @en Full Screen Mode: Similar to SCALE_FULL, the canvas and the stage (i.e., the logical width and height after adaptation) are set to match the screen (runtime window) dimensions.  However, unlike SCALE_FULL, the design content is automatically scaled according to the device’s DPR (pixelRatio), making it suitable for applications on high-DPR devices.
         * - One advantage of this mode is that developers do not need to manually scale UI elements based on DPR in their code.
         * - Note: In this mode, the design width and height should be based on the device’s logical resolution (i.e., physical resolution divided by DPR), which differs from other scaling modes. Otherwise, any content exceeding the logical resolution may be clipped.
         **/
        static SCALE_FULLSCREEN: string;
        /**
         * @zh 保宽适配模式（全屏）：画布的宽等于设计宽，高度根据屏幕高度与全屏缩放因子计算得出。舞台（即画布适配后的逻辑宽高）根据画布尺寸等比缩放至填满屏幕（运行窗口）。这种模式可以确保水平方向的UI设计内容始终完全显示在屏幕内，而垂直方向的UI设计内容可能因缩放而部分超出屏幕或露出舞台背景色。但由于舞台始终填满屏幕，开发者可通过相对布局方式，使垂直方向的UI内容适配于各类屏幕，实现完美的全屏效果。
         * @en Fixed width Mode：The canvas width is equal to the design width, while its height is calculated based on the screen height and a full-screen scaling factor. The stage (i.e., the logical width and height after canvas adaptation) is then uniformly scaled according to the canvas size to fill the entire screen (runtime window). This mode ensures that all horizontal design content is always fully visible on the screen, while vertical design content may be partially clipped or expose the stage background due to scaling. However, since the stage always fills the screen, developers can use relative layout in the vertical direction to adapt the content for various screen sizes and achieve a perfect full-screen experience.
         */
        static SCALE_FIXED_WIDTH: string;
        /**
         * @zh 保高适配模式（全屏）：画布的高等于设计高，宽度根据屏幕宽度与全屏缩放因子计算得出。舞台（即画布适配后的逻辑宽高）根据画布尺寸等比缩放至填满屏幕（运行窗口）。这种模式可以确保垂直方向的UI设计内容始终完全显示在屏幕内，而水平方向的UI设计内容可能因缩放而部分超出屏幕或露出舞台背景色。但由于舞台始终填满屏幕，开发者可通过相对布局方式，使水平方向的UI内容适配于各类屏幕，实现完美的全屏效果。
         * @en Fixed height Mode：The canvas height is equal to the design height, while its width is calculated based on the screen width and a full-screen scaling factor. The stage (i.e., the logical width and height after canvas adaptation) is then uniformly scaled according to the canvas size to fill the entire screen (runtime window). This mode ensures that all vertical UI design content is always fully visible on the screen, while horizontal content may be partially clipped or expose the stage background due to scaling. However, since the stage always fills the screen, developers can use relative layout in the horizontal direction to adapt the content for various screen sizes and achieve a perfect full-screen experience.
         */
        static SCALE_FIXED_HEIGHT: string;
        /**
         * @zh 自动保宽高模式（全屏）：这是一种根据屏幕（运行窗口）宽高比动态选择“保宽”或“保高”策略的自适应模式。当屏幕宽高比小于设计宽高比时，采用“保宽”（fixedwidth）模式；反之，则采用“保高”（fixedheight）模式。该模式可确保UI设计内容始终处于舞台范围内，不会被裁切，但可能在水平方向或垂直方向漏出背景颜色。为实现理想的全屏效果，建议通过相对布局方式适配不同屏幕。
         * @en Fixed Auto Mode: This is an adaptive scaling mode that dynamically selects either the "fixedwidth" or "fixedheight" strategy based on the aspect ratio of the screen (runtime window). When the screen’s aspect ratio is less than the design aspect ratio, it uses the **fixedwidth** mode; otherwise, it uses the **fixedheight** mode. This mode ensures that the UI design content always stays within the stage without being cropped, though background color may appear on the horizontal or vertical edges. For an optimal full-screen experience, it is recommended to use relative layout to adapt to various screen sizes.
         */
        static SCALE_FIXED_AUTO: string;
        /**
         * @en Canvas is horizontally aligned to the left.
         * @zh 画布水平居左对齐。
         */
        static ALIGN_LEFT: string;
        /**
         * @en Canvas is horizontally aligned to the right.
         * @zh 画布水平居右对齐。
         */
        static ALIGN_RIGHT: string;
        /**
         * @en Canvas is horizontally centered.
         * @zh 画布水平居中对齐。
         */
        static ALIGN_CENTER: string;
        /**
         * @en Canvas is vertically aligned to the top.
         * @zh 画布垂直居上对齐。
         */
        static ALIGN_TOP: string;
        /**
         * @en Canvas is vertically centered.
         * @zh 画布垂直居中对齐。
         */
        static ALIGN_MIDDLE: string;
        /**
         * @en Canvas is vertically aligned to the bottom.
         * @zh 画布垂直居下对齐。
         */
        static ALIGN_BOTTOM: string;
        /**
         * @en Do not change the screen orientation.
         * @zh 不更改屏幕。
         */
        static SCREEN_NONE: string;
        /**
         * @en Automatically switch to landscape mode.
         * @zh 自动横屏。
         */
        static SCREEN_HORIZONTAL: string;
        /**
         * @en Automatically switch to portrait mode.
         * @zh 自动竖屏。
         */
        static SCREEN_VERTICAL: string;
        /**
         * @en Fast mode, running at the configured maximum frame rate (not exceeding the device's maximum frame rate).
         * @zh 快速模式，以配置的最高帧率运行（不得超过设备最高帧率）。
         */
        static FRAME_FAST: string;
        /**
         * @en Slow mode has a frame rate that is half of the fast mode. The principle is to skip rendering every other frame. For example, if the maximum frame rate in fast mode is 60, the maximum frame rate in slow mode would be 30.
         * @zh 慢速模式的帧率是快速模式的一半，其原理是每隔一帧就会跳过渲染。例如快速模式的满帧为60时，慢速模式的满帧则为30。
         */
        static FRAME_SLOW: string;
        /**
         * @en Mouse mode, In this mode, it checks if the last mouse movement occurred within the last two seconds. If it did, `frameMode` will be set to `FRAME_FAST`; otherwise, it will be set to `FRAME_SLOW`.
         * @zh 鼠标模式，该模式下，会检查上一次鼠标移动的时间，如果是在最近的两秒内，帧率的模式会采用快速模式，否则采用慢速模式。
         */
        static FRAME_MOUSE: string;
        /**
         * @en Sleep mode, running at 1 frame per second.
         * @zh 休眠模式，以每秒1帧的速度运行。
         */
        static FRAME_SLEEP: string;
        /**
         * @en The current focus object, which will affect the dispatch of current keyboard events.
         * @zh 当前焦点对象，此对象会影响当前键盘事件的派发主体。
         */
        focus: Node;
        /**
         * @private
         * @deprecated
         * @en Offset relative to the browser's top-left corner, deprecated, please use _canvasTransform.
         * @zh 相对浏览器左上角的偏移，弃用，请使用_canvasTransform。
         */
        offset: Point;
        /**
         * @en Frame rate types:fast (default, full frame rate),slow (half of the full frame rate),mouse (full frame rate after mouse activity, switches to half frame rate if the mouse is idle for 2 seconds),sleep (1 frame per second)
         * @zh 帧率类型：fast(默认，满帧)，slow（满帧减半），mouse（鼠标活动后满帧，鼠标不动2秒后满帧减半），sleep（每秒1帧）。
         */
        private _frameRate;
        /**
         * @en Design width (the width set during initialization Laya.init(width,height))
         * @zh 设计宽度（初始化时设置的宽度Laya.init(width,height)）
         */
        designWidth: number;
        /**
         * @en Design height (the height set during initialization Laya.init(width,height))
         * @zh 设计高度（初始化时设置的高度Laya.init(width,height)）
         */
        designHeight: number;
        /**
         * @en Whether the canvas has been flipped.
         * @zh 画布是否发生翻转。
         */
        canvasRotation: boolean;
        /**
         * @en The rotation angle of the canvas.
         * @zh 画布的旋转角度。
         */
        canvasDegree: number;
        /**
         * @en Set whether to render. When set to false, rendering can be stopped, the screen will stay on the last render, reducing CPU consumption. This setting does not affect the clock.
         * For example, in an inactive state, you can set renderingEnabled=false to save consumption.
         * @zh 设置是否渲染，设置为false，可以停止渲染，画面会停留到最后一次渲染上，减少cpu消耗，此设置不影响时钟。
         * 比如非激活状态，可以设置renderingEnabled=false以节省消耗。
         */
        renderingEnabled: boolean;
        /**
         * @en Whether to enable screen adaptation. After adaptation, screen adaptation can be turned off at some point to prevent unexpected screen changes caused by certain operations.
         * @zh 是否启用屏幕适配，可以适配后，在某个时候关闭屏幕适配，防止某些操作导致的屏幕意外改变。
         */
        screenAdaptationEnabled: boolean;
        private _screenMode;
        private _scaleMode;
        private _alignV;
        private _alignH;
        private _bgColor;
        private _renderCount;
        private _safariOffsetY;
        private _frameStartTime;
        private _previousOrientation;
        private _isFocused;
        private _isVisibility;
        private _globalRepaintSet;
        private _globalRepaintGet;
        /**
         * @en Using physical resolution as the canvas size will improve rendering effects, but it will reduce performance
         * @zh 使用物理分辨率作为画布大小，会改进渲染效果，但是会降低性能
         */
        useRetinalCanvas: boolean;
        /**
         * @ignore
         * @en Stage class, there is only one stage instance in the engine. This instance can be accessed through Laya.stage.
         * @zh 场景类，引擎中只有一个stage实例，此实例可以通过Laya.stage访问。
         * */
        constructor();
        /**
         * @en Returns whether it is currently in a text input state on mobile devices.
         * Note: Do not reset the canvas size while the input method is displayed during input on mobile devices.
         * @zh 返回是否正处于移动端文本输入的状态。
         * 注意，在移动端输入时，输入法弹出期间不要进行画布尺寸重置。
         */
        private _isInputting;
        /**
         * @en The matrix information of the object. By setting the matrix, node rotation, scaling, and displacement effects can be achieved.
         * @zh 对象的矩阵信息。通过设置矩阵可以实现节点旋转，缩放，位移效果。
         */
        get transform(): Matrix;
        set transform(value: Matrix);
        /**
         * @en Whether the stage has focus.
         * @zh 舞台是否获得焦点。
         */
        get isFocused(): boolean;
        /**
         * @en Indicates whether the stage is in a visible state (whether it has entered the background).
         * @zh 舞台是否处于可见状态(是否进入后台)。
         */
        get isVisibility(): boolean;
        private _needUpdateCanvasSize;
        /**
         * @en Update the canvas size
         * @param delay If true, the change will be executed with a delay
         * @zh 更新canvas大小
         * @param delay 是否延迟执行改动，如果为true，将延迟执行
         */
        updateCanvasSize(delay?: boolean): void;
        /**
         * @en Synchronize the final canvas size
         * @zh 同步最终canvas大小
         */
        needUpdateCanvasSize(): void;
        /**
         * @en Set the screen size. The scene will adapt to the screen size. This method can be called dynamically to change the game display size.
         * @param screenWidth The width of the screen.
         * @param screenHeight The height of the screen.
         * @zh 设置屏幕大小，场景会根据屏幕大小进行适配。可以动态调用此方法，来更改游戏显示的大小。
         * @param screenWidth 屏幕宽度。
         * @param screenHeight 屏幕高度。
         */
        setScreenSize(screenWidth: number, screenHeight: number): void;
        /**
         * @en Set screen size for scene rotation, required by layaverse
         * @param screenWidth The width of the screen
         * @param screenHeight The height of the screen
         * @param screenMode The screen mode. "none" is the default value, "horizontal" for landscape mode, "vertical" for portrait mode
         * @zh 设置场景旋转的屏幕大小，layaverse 需要
         * @param screenWidth 屏幕宽度
         * @param screenHeight 屏幕高度
         * @param screenMode 屏幕模式。"none"为默认值，"horizontal"为横屏，"vertical"为竖屏
         */
        setScreenSizeForScene(screenWidth: number, screenHeight: number, screenMode: string): {
            stageWidth: number;
            stageHeight: number;
            canvasWidth: number;
            canvasHeight: number;
            scaleX: number;
            scaleY: number;
        };
        /**@private */
        private _formatData;
        /**
         * @en The scale mode. Default value is "noscale".
         * Available values:
         * - "noscale": No scaling.
         * - "showall": The canvas matches the design width and height, and the stage is scaled proportionally to the maximum size while ensuring the design content remains fully visible.
         * - "full": No scaling, the stage width and height equal to the screen width and height.
         * - "fixedwidth": Fixed width, height scales according to the screen ratio.
         * - "fixedheight": Fixed height, width scales according to the screen ratio.
         * - "fixedauto": Automatically choose between fixedwidth or fixedheight based on the aspect ratio.
         * @zh 缩放模式。默认值为 "noscale"。
         * 取值范围：
         * - "noscale"：不缩放，舞台与画布采用设计宽高。
         * - "showall"：画布等于设计宽高，在保障设计内容可见的前提下，按设计宽高对舞台等比缩放至最大。
         * - "full"：不缩放，舞台与画布的宽高等于屏幕宽高。
         * - "fixedwidth"：宽度不变，高度根据屏幕比缩放。
         * - "fixedheight"：高度不变，宽度根据屏幕比缩放。
         * - "fixedauto"：根据宽高比，自动选择使用fixedwidth或fixedheight。
         */
        get scaleMode(): string;
        set scaleMode(value: string);
        /**
         * @en Horizontal alignment of canvas. Default value is "left".
         * Available values:
         * - "left": Align to the left.
         * - "center": Align to the center.
         * - "right": Align to the right.
         * @zh 画布水平对齐方式。默认值为"left"。
         * 取值范围：
         * - "left"：居左对齐。
         * - "center"：居中对齐。
         * - "right"：居右对齐。
         */
        get alignH(): string;
        set alignH(value: string);
        /**
         * @en Vertical alignment of canvas. Default value is "top".
         * Available values:
         * - "top": Align to the top.
         * - "middle": Align to the middle.
         * - "bottom": Align to the bottom.
         * @zh 画布垂直对齐方式。默认值为"top"。
         * 取值范围：
         * - "top"：居顶部对齐。
         * - "middle"：居中对齐。
         * - "bottom"：居底部对齐。
         */
        get alignV(): string;
        set alignV(value: string);
        /**
         * @en The background color of the stage. Default is black, null for transparent.
         * @zh 舞台的背景颜色，默认为黑色，null为透明。
         */
        get bgColor(): string;
        set bgColor(value: string);
        /**
         * @en The X coordinate of the mouse on the Stage.
         * @zh 鼠标在 舞台 上的 X 轴坐标。
         */
        get mouseX(): number;
        /**
         * @en The Y coordinate of the mouse on the Stage.
         * @zh 鼠标在 舞台 上的 Y 轴坐标。
         */
        get mouseY(): number;
        /**
         * @en Get the mouse coordinate information on the screen
         * @returns Screen point information
         * @zh 获得屏幕上的鼠标坐标信息
         * @returns 屏幕点信息
         */
        getMousePoint(): Point;
        /**
         * @en The X-axis scaling factor caused by the current viewport scaling mode.
         * @zh 当前视窗由缩放模式导致的 X 轴缩放系数。
         */
        get clientScaleX(): number;
        /**
         * @en The Y-axis scaling factor caused by the current viewport scaling mode.
         * @zh 当前视窗由缩放模式导致的 Y 轴缩放系数。
         */
        get clientScaleY(): number;
        /**
         * @en The scene layout type.
         * Available values:
         * - "none": Do not change the screen
         * - "horizontal": Automatic landscape mode
         * - "vertical": Automatic portrait mode
         * @zh 场景布局类型。
         * 取值范围：
         * - "none"：不更改屏幕
         * - "horizontal"：自动横屏
         * - "vertical"：自动竖屏
         */
        get screenMode(): string;
        set screenMode(value: string);
        /**
         * @en Redraw
         * @param type The type of redraw
         * @zh 重新绘制
         * @param type 重新绘制类型
         */
        repaint(type?: number): void;
        /**
         * @en Redraw the parent node
         * @param type The type of redraw
         * @zh 重新绘制父节点
         * @param type 重新绘制类型
         */
        parentRepaint(type?: number): void;
        /**
         * @en Get frame start time.
         * @zh 获取帧开始时间
         */
        getFrameTm(): number;
        /**
         * @en Get the time elapsed since the current frame started, in milliseconds.
         * This can be used to judge the time consumption within functions, reasonably control the processing time of each frame function, avoid doing too much in one frame, and process complex calculations across frames, which can effectively reduce frame rate fluctuations.
         * @zh 获得距当前帧开始后，过了多少时间，单位为毫秒。
         * 可以用来判断函数内时间消耗，通过合理控制每帧函数处理消耗时长，避免一帧做事情太多，对复杂计算分帧处理，能有效降低帧率波动。
         */
        getTimeFromFrameStart(): number;
        /**
         * @en Indicates whether it is visible, default is true. If set to invisible, the node will not be rendered.
         * @zh 表示是否可见，默认为true。如果设置不可见，节点将不被渲染。
         */
        get visible(): boolean;
        set visible(value: boolean);
        /**
         * @en Render all display objects on the stage
         * @param context2D The rendering context
         * @param x The x-axis coordinate
         * @param y The y-axis coordinate
         * @zh 渲染舞台上的所有显示对象
         * @param context2D 渲染的上下文
         * @param x 横轴坐标
         * @param y 纵轴坐标
         */
        render(context2D: Context, x: number, y: number): void;
        /**
         * @param context2D The rendering context
         * @param x The x-axis coordinate
         * @param y The y-axis coordinate
         * @perfTag PerformanceDefine.T_UIRender
        */
        private _render2d;
        private _runComponents;
        private _updateTimers;
        /**
         * @en Whether to enable fullscreen mode. Users can enter fullscreen mode by clicking.
         * Compatibility note: Some browsers, such as iPhone, do not allow entering fullscreen mode by clicking.
         * @zh 是否开启全屏，用户点击后进入全屏。
         * 兼容性提示：部分浏览器不允许点击进入全屏，比如iPhone等。
         */
        set fullScreenEnabled(value: boolean);
        /**
         * @zh Exit full screen mode
         * @en 退出全屏模式
         */
        exitFullscreen(): void;
        /**
         * @en Frame rate types:fast (default, full frame rate),slow (half of the full frame rate),mouse (full frame rate after mouse activity, switches to half frame rate if the mouse is idle for 2 seconds),sleep (1 frame per second)
         * @zh 当前帧率类型：fast(默认，满帧)，slow（满帧减半），mouse（鼠标活动后满帧，鼠标不动2秒后满帧减半），sleep（每秒1帧）。
         */
        get frameRate(): string;
        set frameRate(value: string);
        /**@ignore */
        isGlobalRepaint(): boolean;
        /**@ignore */
        setGlobalRepaint(): void;
    }
    /**
     * @en The Text class is used to create display objects to show text.
     * Note: If the runtime system cannot find the specified font, it will render the text with the system default font, which may cause display anomalies. (Usually, it displays normally on computers, but may display abnormally on some mobile devices due to the lack of the set font.)
     *  - Event.CHANGE event dispatched after the text content changes.
     * @zh Text类用于创建显示对象以显示文本。
     * 注意：如果运行时系统找不到设定的字体，则用系统默认的字体渲染文字，从而导致显示异常。(通常电脑上显示正常，在一些移动端因缺少设置的字体而显示异常)。
     *  - Event.CHANGE 事件表示文本内容发生改变后调度。
     */
    class Text extends Sprite {
        /**
         * @en Visible without any clipping.
         * @zh visible不进行任何裁切。
         */
        static VISIBLE: string;
        /**
         * @en Scroll does not display character pixels outside the text area and supports the scroll interface.
         * @zh scroll 不显示文本域外的字符像素，并且支持 scroll 接口。
         */
        static SCROLL: string;
        /**
         * @en Hidden does not display characters beyond the text area.
         * @zh hidden 不显示超出文本域的字符。
         */
        static HIDDEN: string;
        /**
         * @en Shrink the entire text to fit the text box when it exceeds the text area.
         * @zh shrink 超出文本域时，文本整体缩小以适应文本框。
         */
        static SHRINK: string;
        /**
         * @en Ellipsis truncates the text and displays an ellipsis at the end when it exceeds the text area.
         * @zh ellipsis 超出文本域时，文本被截断，并且文本最后显示省略号。
         */
        static ELLIPSIS: string;
        /**
         * @en Language pack, a collection of key:value pairs, indexed by key, replaced with target value language.
         * @zh 语言包，是一个包含key:value的集合，用key索引，替换为目标value语言。
         */
        static langPacks: Record<string, string>;
        /**
         * @en Whether the display order is from right to left.
         * @zh 是否是从右向左的显示顺序。
         */
        static RightToLeft: boolean;
        /**
         * @en Predicted length text, used to improve calculation efficiency, find the largest character for different languages.
         * @zh 预测长度的文字，用来提升计算效率，不同语言找一个最大的字符即可。
         */
        static _testWord: string;
        static _passwordChar: string;
        /**
         * @en Dictionary of bitmap fonts.
         * @zh 位图字体字典。
         */
        private static _bitmapFonts;
        /**
         * @en Mark whether this text ignores the language pack.
         * @zh 标记此文本是否忽略语言包。
         */
        ignoreLang: boolean;
        /**
         * @en Represents the text content string.
         * @zh 表示文本内容字符串。
         */
        protected _text: string;
        /**
         * @en Represents the text overflow property.
         * @zh 表示文本的溢出属性。
         */
        protected _overflow: string;
        /**
         * @en Split render.
         * @zh 拆分渲染。
         */
        protected _singleCharRender: boolean;
        protected _textStyle: TextStyle;
        protected _prompt: string;
        /**
         * @en The color of the input prompt.
         * @zh 输入提示符颜色。
         */
        protected _promptColor: string;
        /**
         * @en The background color of the text, represented as a string.
         * @zh 文本背景颜色，以字符串表示。
         */
        protected _bgColor: string;
        /**
         * @en The border color of the text background, represented as a string.
         * @zh 文本边框背景颜色，以字符串表示。
         */
        protected _borderColor: string;
        /**
         * @en The default padding information.
         * [top padding, right padding, bottom padding, left padding] (in pixels).
         * @zh 默认边距信息
         * [上边距，右边距，下边距，左边距]（边距以像素为单位）。
         */
        protected _padding: number[];
        /**
         * @en Indicates whether the text field using this text format automatically wraps.
         * If the value of wordWrap is true, the text field automatically wraps; if the value is false, the text field does not automatically wrap.
         * @zh 表示使用此文本格式的文本字段是否自动换行。
         * 如果 wordWrap 的值为 true，则该文本字段自动换行；如果值为 false，则该文本字段不自动换行。
         */
        protected _wordWrap: boolean;
        protected _htmlParseOptions: HtmlParseOptions;
        protected _templateVars: Record<string, string>;
        /**
         * @en Indicates whether the text content has changed.
         * @zh 表示文本内容是否发生改变。
         */
        protected _isChanged: boolean;
        /**
         * @en Indicates the width of the text in pixels.
         * @zh 表示文本的宽度，以像素为单位。
         */
        protected _textWidth: number;
        /**
         * @en Indicates the height of the text in pixels.
         * @zh 表示文本的高度，以像素为单位。
         */
        protected _textHeight: number;
        protected _realFont: string;
        protected _bitmapFont: BitmapFont;
        protected _scrollPos: Point | null;
        protected _bgDrawCmd: DrawRectCmd;
        protected _html: boolean;
        protected _ubb: boolean;
        protected _lines: Array<ITextLine>;
        protected _elements: Array<HtmlElement>;
        protected _objContainer: Sprite;
        protected _maxWidth: number;
        protected _hideText: boolean;
        private _updatingLayout;
        private _fontSizeScale;
        /**
         * An callback function for wrappers to do something after layout updated.
         */
        _onPostLayout: () => void;
        /**
         * @en Constructor method of Text.
         * @zh 文本的构造方法
         */
        constructor();
        /**
         * @en Register a bitmap font.
         * @param name The name of the bitmap font.
         * @param bitmapFont The bitmap font file.
         * @zh 注册位图字体。
         * @param name 位图字体的名称。
         * @param bitmapFont 位图字体文件。
         */
        static registerBitmapFont(name: string, bitmapFont: BitmapFont): void;
        /**
         * @en Remove a registered bitmap font file.
         * @param name The name of the bitmap font.
         * @param destroy Whether to destroy the specified font file. Default is true.
         * @zh 移除注册的位图字体文件。
         * @param name 位图字体的名称。
         * @param destroy 是否销毁指定的字体文件。默认为 true。
         */
        static unregisterBitmapFont(name: string, destroy?: boolean): void;
        /**
         * @en Destroy the text.
         * @param destroyChild Whether to destroy child nodes. Default is true.
         * @zh 销毁文本。
         * @param destroyChild 是否销毁子节点。默认为 true。
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @en Get the scrollable visible window.
         * @param realSize Whether to use the real size of the image. Default is false.
         * @zh 获取滚动可视视窗。
         * @param realSize 是否使用图片的真实大小。默认为 false。
         */
        getGraphicBounds(realSize?: boolean): Rectangle;
        /**
         * @en The width of the text in pixels.
         * @zh 文本的宽度，以像素为单位。
         */
        get textWidth(): number;
        /**
         * @en The height of the text in pixels.
         * @zh 文本的高度，以像素为单位。
         */
        get textHeight(): number;
        /**
         * @en The current content string of the text.
         * @zh 当前文本的内容字符串。
         */
        get text(): string;
        set text(value: string);
        /**
         * @deprecated
         * @param text 文本
         */
        changeText(text: string): void;
        /**
         * @en The font name of the text, represented as a string.
         * The default value is "Arial", which can be set through Config.defaultFont.
         * If the runtime system cannot find the specified font, it will render the text with the system default font, which may cause display anomalies. (Usually, it displays normally on computers, but may display abnormally on some mobile devices due to the lack of the set font.)
         * @zh 文本的字体名称，以字符串形式表示。
         * 默认值为："Arial"，可以通过Config.defaultFont设置默认字体。
         * 如果运行时系统找不到设定的字体，则用系统默认的字体渲染文字，从而导致显示异常。(通常电脑上显示正常，在一些移动端因缺少设置的字体而显示异常)。
         */
        get font(): string;
        set font(value: string);
        /**
         * @en Specifies the font size of the text in pixels.
         * The default is 20 pixels, which can be set through Config.defaultFontSize.
         * @zh 指定文本的字体大小（以像素为单位）。
         * 默认为20像素，可以通过 Config.defaultFontSize 设置默认大小。
         */
        get fontSize(): number;
        set fontSize(value: number);
        /**
         * @en Represents the color value of the text. The default color can be set through Text.defaultColor.
         * The default value is black.
         * @zh 表示文本的颜色值。可以通过 Text.defaultColor 设置默认颜色。
         * 默认值为黑色。
         */
        get color(): string;
        set color(value: string);
        /**
         * @en Specifies whether the text is bold.
         * The default value is false, which means bold is not used. If the value is true, the text is bold.
         * @zh 指定文本是否为粗体字。
         * 默认值为 false，这意味着不使用粗体字。如果值为 true，则文本为粗体字。
         */
        get bold(): boolean;
        set bold(value: boolean);
        /**
         * @en Indicates whether the text using this text format is italic.
         * The default value is false, which means italic is not used. If the value is true, the text is italic.
         * @zh 表示使用此文本格式的文本是否为斜体。
         * 默认值为 false，这意味着不使用斜体。如果值为 true，则文本为斜体。
         */
        get italic(): boolean;
        set italic(value: boolean);
        /**
         * @en Represents the horizontal alignment of the text.
         * Possible values:
         * - "left": Left-aligned.
         * - "center": Center-aligned.
         * - "right": Right-aligned.
         * @zh 表示文本的水平显示方式。
         * 取值：
         * - "left"： 居左对齐显示。
         * - "center"： 居中对齐显示。
         * - "right"： 居右对齐显示。
         */
        get align(): string;
        set align(value: string);
        /**
         * @en Represents the vertical alignment of the text.
         * Possible values:
         * - "top": Top-aligned.
         * - "middle": Middle-aligned.
         * - "bottom": Bottom-aligned.
         * @zh 表示文本的垂直显示方式。
         * 取值：
         * - "top"： 居顶部对齐显示。
         * - "middle"： 居中对齐显示。
         * - "bottom"： 居底部对齐显示。
         */
        get valign(): string;
        set valign(value: string);
        /**
         * @en Alignment of images and text in mixed content. Possible values are top, middle, bottom.
         * @zh 图文混排时图片和文字的对齐方式。可选值是 top, middle, bottom。
         */
        get alignItems(): string;
        set alignItems(value: string);
        /**
         * @en Indicates whether the text automatically wraps, default is false.
         * If true, the text will automatically wrap; otherwise, it will not.
         * @zh 表示文本是否自动换行，默认为 false。
         * 若值为 true，则自动换行；否则不自动换行。
         */
        get wordWrap(): boolean;
        set wordWrap(value: boolean);
        /**
         * @en Vertical line spacing in pixels.
         * @zh 垂直行间距（以像素为单位）。
         */
        get leading(): number;
        set leading(value: number);
        /**
         * @en Margin information.
         * Data format: [top margin, right margin, bottom margin, left margin] (margins in pixels).
         * @zh 边距信息。
         * 数据格式：[上边距，右边距，下边距，左边距]（边距以像素为单位）。
         */
        get padding(): number[];
        set padding(value: number[] | string);
        /**
         * @en Text background color, represented as a string.
         * @zh 文本背景颜色，以字符串表示。
         */
        get bgColor(): string;
        set bgColor(value: string);
        /**
         * @en Text border background color, represented as a string.
         * @zh 文本边框背景颜色，以字符串表示。
         */
        get borderColor(): string;
        set borderColor(value: string);
        /**
         * @en Stroke width in pixels.
         * The default value is 0, which means no stroke.
         * @zh 描边宽度（以像素为单位）。
         * 默认值0，表示不描边。
         */
        get stroke(): number;
        set stroke(value: number);
        /**
         * @en Stroke color, represented as a string.
         * The default value is "#000000" (black).
         * @zh 描边颜色，以字符串表示。
         * 默认值为 "#000000"（黑色）。
         */
        get strokeColor(): string;
        set strokeColor(value: string);
        /**
         * @en Specifies the behavior when text exceeds the text area.
         * Values: visible, hidden, scroll, shrink, ellipsis.
         * Effects:
         * - visible: All text is visible regardless of text width and height constraints.
         * - hidden: Text exceeding width and height will be clipped, best for performance.
         * - scroll: Parts exceeding width and height are hidden, can be controlled by scrolling.
         * - shrink: Text size automatically adjusts to fit within the width and height.
         * - ellipsis: When text exceeds width and height, last few characters are replaced with ellipsis.
         * @zh 指定文本超出文本域后的行为。
         * 值为：可见visible、隐藏hidden、滚动scroll、自动收缩shrink、显示省略号ellipsis。
         * 作用：
         * - 可见：文本不受文本宽高约束全部可见。
         * - 隐藏：超过文本宽高就会被裁切掉，性能最好。
         * - 滚动：超出宽高的部分被隐藏，可以通过划动控制显示在宽高内区域。
         * - 自动收缩：文本会跟随宽高的大小而自动调整文本的大小，始终全部显示在文本宽高内。
         * - 显示省略号：当文本超出宽高后，未尾的几位字符会替换为省略号，表示当前文本还有未显示的内容。
         */
        get overflow(): string;
        set overflow(value: string);
        /**
         * @en Whether to display underline.
         * @zh 是否显示下划线。
         */
        get underline(): boolean;
        set underline(value: boolean);
        /**
         * @en The color of the underline. If null, it uses the font color.
         * @zh 下划线的颜色。如果为null，则使用字体颜色。
         */
        get underlineColor(): string;
        set underlineColor(value: string);
        get strikethrough(): boolean;
        set strikethrough(value: boolean);
        /**
         * 下划线的颜色，为null则使用字体颜色。
         */
        get strikethroughColor(): string;
        set strikethroughColor(value: string);
        /**
         * @en Whether single character rendering is enabled. Enable this if the text content changes frequently, such as an increasing number, to prevent inefficient use of cache.
         * @zh 是否启用单个字符渲染。如果Textd的内容一直改变，例如是一个增加的数字，就设置这个，防止无效占用缓存
         */
        get singleCharRender(): boolean;
        set singleCharRender(value: boolean);
        /**
         * @en Whether rich text is enabled, supporting HTML syntax.
         * @zh 是否启用富文本，支持HTML语法。
         */
        get html(): boolean;
        set html(value: boolean);
        /**
         * @en Whether UBB syntax parsing is enabled for text.
         * @zh 是否启用UBB语法解析文本。
         */
        get ubb(): boolean;
        set ubb(value: boolean);
        /**
         * @en The maximum width allowed for text. When text reaches this width, it will automatically wrap. Set to 0 to disable this limit.
         * @zh 文本允许的最大宽度。当文本达到这个宽度时，将自动换行。设置为0则此限制不生效。
         */
        get maxWidth(): number;
        set maxWidth(value: number);
        /**
         * @en Rich text HTML mode options.
         * @zh 富文本HTML模式选项。
         */
        get htmlParseOptions(): HtmlParseOptions;
        set htmlParseOptions(value: HtmlParseOptions);
        /**
         * @en Parse the template content.
         * @param template The template content.
         * @returns The template string with placeholders substituted by their corresponding values from _templateVars.
         * @zh 解析模板。
         * @param template 模板内容
         * @returns 模板字符串，其中占位符由_templateVars中的相应值替换。
         */
        protected parseTemplate(template: string): string;
        /**
         * @en Text Template
         * @zh 文本模板
         */
        get templateVars(): Record<string, any>;
        set templateVars(value: Record<string, any> | boolean);
        /**
         * @en Set the value of a template variable.
         * @param name The name of the template variable.
         * @param value The value to set.
         * @returns The current Text instance.
         * @zh 设置模板值。
         * @param name 模板名
         * @param value 值
         * @returns 当前 Text 实例。
         */
        setVar(name: string, value: any): Text;
        /**
         * @en The horizontal scroll amount.
         * Even if a value outside the scroll range is set, it will be automatically limited to the maximum possible value.
         * @zh 横向滚动量。
         * 即使设置超出滚动范围的值，也会被自动限制在可能的最大值处。
         */
        get scrollX(): number;
        set scrollX(value: number);
        /**
         * @en The vertical scroll amount (in pixels).
         * Even if a value outside the scroll range is set, it will be automatically limited to the maximum possible value.
         * @zh 纵向滚动量（以像素为单位）。
         * 即使设置超出滚动范围的值，也会被自动限制在可能的最大值处。
         */
        get scrollY(): number;
        set scrollY(value: number);
        /**
         * @en The maximum horizontal scrollable value.
         * @zh 横向可滚动的最大值。
         */
        get maxScrollX(): number;
        /**
         * @en The maximum vertical scrollable value.
         * @zh 纵向可滚动的最大值。
         */
        get maxScrollY(): number;
        /**
         * @en The text line information.
         * @zh 文字行信息。
         */
        get lines(): ReadonlyArray<ITextLine>;
        /**
         * @en Typeset the text.
         * @zh 排版文本。
         */
        typeset(): void;
        /**
         * @en Refresh the layout with a delay.
         * @zh 延迟刷新排版。
         */
        refreshLayout(): void;
        /**
         * @en The object container.
         * @zh 对象容器。
         */
        get objContainer(): Sprite;
        /**
         * 排版文本。
         * 进行宽高计算，渲染、重绘文本。
         */
        protected _typeset(): void;
        /**
         * @en Analyze text wrapping.
         * @zh 分析文本换行。
         */
        protected doLayout(): void;
        /**
         * @en Render the text.
         * @zh 渲染文字。
         */
        protected renderText(): void;
        /**
         * @en Draw background
         * @zh 绘制背景
         */
        protected drawBg(): void;
    }
    interface ITextCmd {
        x: number;
        y: number;
        width: number;
        height: number;
        style: TextStyle;
        ctxFont: string;
        fontSize: number;
        wt: WordText;
        obj: IHtmlObject;
        linkEnd: boolean;
        next: ITextCmd;
        prev: ITextCmd;
    }
    interface ITextLine {
        x: number;
        y: number;
        height: number;
        width: number;
        cmd: ITextCmd;
    }
    /**
     * @en Effect plugin base class, managed based on the object pool.
     * @zh 效果插件基类，基于对象池管理。
     */
    class EffectBase extends Component {
        /**
         * @en The duration of the animation in milliseconds.
         * @zh 动画持续时间，单位为毫秒。
         */
        duration: number;
        /**
         * @en The delay time of the animation in milliseconds.
         * @zh 动画延迟时间，单位为毫秒。
         */
        delay: number;
        /**
         * @en The repeat count of the animation. Default is to play once.
         * @zh 动画的重复次数。默认为播放一次。
         */
        repeat: number;
        /**
         * @en The type of easing. If empty, it defaults to uniform speed playback.
         * @zh 缓动类型，如果为空，则默认为匀速播放。
         */
        ease: string;
        /**
         * @en The event that triggers the effect. If empty, it triggers upon creation.
         * @zh 触发事件，如果为空，则创建时触发。
         */
        eventName: string;
        /**
         * @en The target object of the effect. If empty, it is the node where the script is located.
         * @zh 效用作用的目标对象，如果为空，则是脚本所在的节点本身。
         */
        target: Sprite;
        /**
         * @en Whether to automatically remove the node when the effect is complete.
         * @zh 效果结束后，是否自动移除节点。
         */
        autoDestroyAtComplete: boolean;
        protected _comlete: Handler;
        protected _tween: Tween;
        protected _onAwake(): void;
        protected _exeTween(): void;
        protected _doTween(): Tween;
        /**
         * @en Reset the effect properties to their default values.
         * @zh 重置效果属性到默认值。
         */
        onReset(): void;
    }
    /**
     * @en Fade in effect
     * @zh 淡入效果
     */
    class FadeIn extends EffectBase {
        /**
         * @override
         */
        protected _doTween(): Tween;
    }
    /**
     * @en Fade out effect
     * @zh 淡出效果
     */
    class FadeOut extends EffectBase {
        /**
         * @override
         */
        protected _doTween(): Tween;
    }
    interface ITouchInfo {
        touchId: number;
        readonly pos: Point;
    }
    /**
     * @en `Event` is a collection of event types. Generally, when an event occurs, the `Event` object is passed as a parameter to the event listener.
     * @zh `Event` 是事件类型的集合。一般当发生事件时,`Event` 对象将作为参数传递给事件侦听器。
     */
    class Event {
        /**
         * @en An empty Event object. Used for event dispatch transfer.
         * @zh 一个空的 Event 对象。用于事件派发中转使用。
         */
        static readonly EMPTY: Readonly<Event>;
        /**
         * @en Defines the value of the `type` property of a `mousedown` event object, triggered when pressed on a display object.
         * @zh 定义 `mousedown` 事件对象的 `type` 属性值，用于在显示对象上按下后触发。
         */
        static MOUSE_DOWN: string;
        /**
         * @en Defines the value of the `type` property of a `mouseup` event object, triggered when released on a display object.
         * @zh 定义 `mouseup` 事件对象的 `type` 属性值，用于在显示对象抬起后触发。
         */
        static MOUSE_UP: string;
        /**
         * @en Defines the value of the `type` property of a `rightmousedown` event object.
         * @zh 定义 `rightmousedown` 事件对象的 `type` 属性值。
         */
        static RIGHT_MOUSE_DOWN: string;
        /**
         * @en Defines the value of the `type` property of a `rightmouseup` event object.
         * @zh 定义 `rightmouseup` 事件对象的 `type` 属性值。
         */
        static RIGHT_MOUSE_UP: string;
        /**
         * @en Defines the value of the `type` property of a `click` event object, triggered when a mouse click completes on a display object.
         * @zh 定义 `click` 事件对象的 `type` 属性值，用于鼠标点击对象后触发。
         */
        static CLICK: string;
        /**
         * @en Defines the value of the `type` property of a `rightclick` event object.
         * @zh 定义 `rightclick` 事件对象的 `type` 属性值。
         */
        static RIGHT_CLICK: string;
        /**
         * @en Defines the value of the `type` property of a `mousemove` event object, triggered when mouse moves over a display object.
         * @zh 定义 `mousemove` 事件对象的 `type` 属性值，用于鼠标在对象身上进行移动后触发。
         */
        static MOUSE_MOVE: string;
        /**
         * @en Defines the value of the `type` property of a `mouseover` event object.
         * @zh 定义 `mouseover` 事件对象的 `type` 属性值。
         */
        static MOUSE_OVER: string;
        /**
         * @en Defines the value of the `type` property of a `mouseout` event object.
         * @zh 定义 `mouseout` 事件对象的 `type` 属性值。
         */
        static MOUSE_OUT: string;
        /**
         * @en Defines the value of the `type` property of a `mousewheel` event object.
         * @zh 定义 `mousewheel` 事件对象的 `type` 属性值。
         */
        static MOUSE_WHEEL: string;
        /**
         * @en Defines the value of the `type` property of a `mouseover` event object.
         * @zh 定义 `mouseover` 事件对象的 `type` 属性值。
         */
        static ROLL_OVER: string;
        /**
         * @en Defines the value of the `type` property of a `mouseout` event object, triggered when mouse leaves a display object.
         * @zh 定义 `mouseout` 事件对象的 `type` 属性值，用于鼠标离开对象后触发。
         */
        static ROLL_OUT: string;
        /**
         * @en Defines the value of the `type` property of a `doubleclick` event object.
         * @zh 定义 `doubleclick` 事件对象的 `type` 属性值。
         */
        static DOUBLE_CLICK: string;
        /**
         * @en Defines the value of the `type` property of a `mousedrag` event object.
         * @zh 定义 `mousedrag` 事件对象的 `type` 属性值。
         */
        static MOUSE_DRAG: string;
        /**
         * @en Defines the value of the `type` property of a `mousedragend` event object.
         * @zh 定义 `mousedragend` 事件对象的 `type` 属性值。
         */
        static MOUSE_DRAG_END: string;
        /**
         * @en Defines the value of the `type` property of a `dragstart` event object, triggered when drag start.
         * @zh 定义 `dragstart` 事件对象的 `type` 属性值，用于开始拖动后触发。
         */
        static DRAG_START: string;
        /**
         * @en Defines the value of the `type` property of a `dragmove` event object, triggered when dragging.
         * @zh 定义 `dragmove` 事件对象的 `type` 属性值，用于拖动中触发。
         */
        static DRAG_MOVE: string;
        /**
         * @en Defines the value of the `type` property of a `dragend` event object, triggered when drag end.
         * @zh 定义 `dragend` 事件对象的 `type` 属性值，用于拖动结束后触发。
         */
        static DRAG_END: string;
        /**
         * @en Defines the value of the `type` property of a `keydown` event object.
         * @zh 定义 `keydown` 事件对象的 `type` 属性值。
         */
        static KEY_DOWN: string;
        /**
         * @en Defines the value of the `type` property of a `keypress` event object.
         * @zh 定义 `keypress` 事件对象的 `type` 属性值。
         */
        static KEY_PRESS: string;
        /**
         * @en Defines the value of the `type` property of a `keyup` event object.
         * @zh 定义 `keyup` 事件对象的 `type` 属性值。
         */
        static KEY_UP: string;
        /**
         * @en Defines the value of the `type` property of a `change` event object.
         * @zh 定义 `change` 事件对象的 `type` 属性值。
         */
        static CHANGE: string;
        /**
         * @en Defines the value of the `type` property of a `changed` event object.
         * @zh 定义 `changed` 事件对象的 `type` 属性值。
         */
        static CHANGED: string;
        /**
         * @en Defines the value of the `type` property of a `willResize` event object.
         * @zh 定义 `willResize` 事件对象的 `type` 属性值。
         */
        static WILL_RESIZE: string;
        /**
         * @en Defines the value of the `type` property of a `resize` event object.
         * @zh 定义 `resize` 事件对象的 `type` 属性值。
         */
        static RESIZE: string;
        /**
         * @en Defines the value of the `type` property of an `added` event object.
         * @zh 定义 `added` 事件对象的 `type` 属性值。
         */
        static ADDED: string;
        /**
         * @en Defines the value of the `type` property of a `removed` event object.
         * @zh 定义 `removed` 事件对象的 `type` 属性值。
         */
        static REMOVED: string;
        /**
         * @en Defines the value of the `type` property of a `display` event object.
         * @zh 定义 `display` 事件对象的 `type` 属性值。
         */
        static DISPLAY: string;
        /**
         * @en Defines the value of the `type` property of an `undisplay` event object.
         * @zh 定义 `undisplay` 事件对象的 `type` 属性值。
         */
        static UNDISPLAY: string;
        /**
         * @en Defines the value of the `type` property of an `error` event object.
         * @zh 定义 `error` 事件对象的 `type` 属性值。
         */
        static ERROR: string;
        /**
         * @en Defines the value of the `type` property of a `complete` event object.
         * @zh 定义 `complete` 事件对象的 `type` 属性值。
         */
        static COMPLETE: string;
        /**
         * @en Defines the value of the `type` property of a `loaded` event object.
         * @zh 定义 `loaded` 事件对象的 `type` 属性值。
         */
        static LOADED: string;
        /**
         * @en Defines the value of the `type` property of a `ready` event object.
         * @zh 定义 `ready` 事件对象的 `type` 属性值。
         */
        static READY: string;
        /**
         * @en Defines the value of the `type` property of a `progress` event object.
         * @zh 定义 `progress` 事件对象的 `type` 属性值。
         */
        static PROGRESS: string;
        /**
         * @en Defines the value of the `type` property of an `input` event object.
         * @zh 定义 `input` 事件对象的 `type` 属性值。
         */
        static INPUT: string;
        /**
         * @en Defines the value of the `type` property of a `render` event object.
         * @zh 定义 `render` 事件对象的 `type` 属性值。
         */
        static RENDER: string;
        /**
         * @en Defines the value of the `type` property of an `open` event object.
         * @zh 定义 `open` 事件对象的 `type` 属性值。
         */
        static OPEN: string;
        /**
         * @en Defines the value of the `type` property of a `message` event object.
         * @zh 定义 `message` 事件对象的 `type` 属性值。
         */
        static MESSAGE: string;
        /**
         * @en Defines the value of the `type` property of a `close` event object.
         * @zh 定义 `close` 事件对象的 `type` 属性值。
         */
        static CLOSE: string;
        /**
         * @en Defines the value of the `type` property of a `enterframe` event object.
         * @zh 定义 `enterframe` 事件对象的 `type` 属性值。
         */
        static FRAME: string;
        /**
         * @en Defines the value of the `type` property of an `enter` event object.
         * @zh 定义 `enter` 事件对象的 `type` 属性值。
         */
        static ENTER: string;
        /**
         * @en Defines the value of the `type` property of a `select` event object.
         * @zh 定义 `select` 事件对象的 `type` 属性值。
         */
        static SELECT: string;
        /**
         * @en Defines the value of the `type` property of a `blur` event object.
         * @zh 定义 `blur` 事件对象的 `type` 属性值。
         */
        static BLUR: string;
        /**
         * @en Defines the value of the `type` property of a `focus` event object.
         * @zh 定义 `focus` 事件对象的 `type` 属性值。
         */
        static FOCUS: string;
        /**
         * @en Defines the value of the `type` property of a `visibilitychange` event object.
         * @zh 定义 `visibilitychange` 事件对象的 `type` 属性值。
         */
        static VISIBILITY_CHANGE: string;
        /**
         * @en Defines the value of the `type` property of a `focuschange` event object.
         * @zh 定义 `focuschange` 事件对象的 `type` 属性值。
         */
        static FOCUS_CHANGE: string;
        /**
         * @en Defines the value of the `type` property of a `played` event object.
         * @zh 定义 `played` 事件对象的 `type` 属性值。
         */
        static PLAYED: string;
        /**
         * @en Defines the value of the `type` property of a `paused` event object.
         * @zh 定义 `paused` 事件对象的 `type` 属性值。
         */
        static PAUSED: string;
        /**
         * @en Defines the value of the `type` property of a `stopped` event object.
         * @zh 定义 `stopped` 事件对象的 `type` 属性值。
         */
        static STOPPED: string;
        /**
         * @en Defines the value of the `type` property of a `start` event object.
         * @zh 定义 `start` 事件对象的 `type` 属性值。
         */
        static START: string;
        /**
         * @en Defines the value of the `type` property of an `end` event object.
         * @zh 定义 `end` 事件对象的 `type` 属性值。
         */
        static END: string;
        /**
         * @en Defines the value of the `type` property of a `link` event object.
         * @zh 定义 `link` 事件对象的 `type` 属性值。
         */
        static LINK: string;
        /**
         * @en Defines the value of the `type` property of a `label` event object.
         * @zh 定义 `label` 事件对象的 `type` 属性值。
         */
        static LABEL: string;
        /**
         * @en Triggered when the full screen state changes in the browser.
         * @zh 浏览器全屏更改时触发
         */
        static FULL_SCREEN_CHANGE: string;
        /**
         * @en Triggered when the GPU device is lost.
         * @zh 显卡设备丢失时触发
         */
        static DEVICE_LOST: string;
        /**
         * @en Triggered when the world matrix is updated.
         * @zh 世界矩阵更新时触发。
         */
        static TRANSFORM_CHANGED: string;
        /**
         * @en Triggered when a 3D layer changes.
         * @zh 3D layer改变时触发。
         */
        static LAYERCHANGE: string;
        /**
        * @en Triggered when 3D Static changes.
        * @zh 3D Static改变时触发。
        */
        static staticMask: string;
        /**
         * @en For 2D physics collision or 3D physics trigger start.
         * @zh 2D物理碰撞或3D物理触发开始。
         */
        static TRIGGER_ENTER: string;
        /**
         * @en For 2D physics collision or 3D physics trigger continues.
         * @zh 2D物理碰撞或3D物理触发持续。
         */
        static TRIGGER_STAY: string;
        /**
         * @en For 2D physics collision or 3D physics trigger end.
         * @zh 2D物理碰撞或3D物理触发结束。
         */
        static TRIGGER_EXIT: string;
        /**
         * @en 3DPhysical collision start.
         * @zh 3D物理碰撞开始。
         */
        static COLLISION_ENTER: string;
        /**
         * @en 3DPhysical collision continues.
         * @zh 3D物理碰撞持续。
         */
        static COLLISION_STAY: string;
        /**
         * @en 3DPhysical collision end.
         * @zh 3D物理碰撞结束。
         */
        static COLLISION_EXIT: string;
        /**
         * @en Joint destruction.
         * @zh 关节破坏。
         */
        static JOINT_BREAK: string;
        /**
         * @en Checks whether the specified event type is a mouse event.
         * @param type The type of the event.
         * @returns True if the specified event type is a mouse event; otherwise, false.
         * @zh 检测指定事件类型是否是鼠标事件。
         * @param type 事件的类型。
         * @returns 如果是鼠标事件，则值为 true;否则，值为 false。
         */
        static isMouseEvent(type: string): boolean;
        /**
         * @en The event type.
         * @zh 事件类型。
         */
        type: string;
        /**
         * @en The triggering object of the event.
         * @zh 事件目标触发对象。
         */
        target: any;
        /**
         * @en The current propagation object of the event.
         * @zh 事件当前冒泡对象。
         */
        currentTarget: any;
        /**
         * @en Unique identifier assigned to the touch point (as an int).
         * @zh 分配给触摸点的唯一标识号（作为 int）。
         */
        touchId: number;
        /**
         * @en The clicked position.
         * @zh 点击坐标。
         */
        readonly touchPos: Point;
        /**
         * @en Specifies whether this is a double-click.
         * @zh 是否双击。
         */
        isDblClick: boolean;
        /**
         * @en The scroll wheel increments.
         * @zh 滚轮滑动增量。
         */
        delta: number;
        /**
         * @en The mouse button.
         * - 0: Main button, usually the left button
         * - 1: Auxiliary button, usually the middle button (wheel button)
         * - 2: Secondary button, usually the right button
         * - 3: Fourth button, typically the browser Back button
         * - 4: Fifth button, typically the browser Forward button
         * @zh 鼠标按键，
         * - 0：主按键，通常指鼠标左键
         * - 1：辅助按键，通常指鼠标滚轮中键
         * - 2：次按键，通常指鼠标右键
         * - 3：第四个按钮，通常指浏览器后退按钮
         * - 4：第五个按钮，通常指浏览器的前进按钮
         */
        button: number;
        /**
         * @en The original browser event.
         * @zh 原生浏览器事件。
         */
        nativeEvent: MouseEvent | TouchEvent | WheelEvent | KeyboardEvent;
        constructor();
        /**
         * @en Sets the event data.
         * @param type The type of the event.
         * @param currentTarget The triggering object of the event.
         * @param target The current propagation object of the event.
         * @returns The current Event object.
         * @zh 设置事件数据。
         * @param type 事件类型。
         * @param currentTarget 事件目标触发对象。
         * @param target 事件当前冒泡对象。
         * @returns 返回当前 Event 对象。
         */
        setTo(type: string, currentTarget: any, target: any): Event;
        /**
         * @en Prevents processing of all event listeners on the current node in the event flow after the current one.
         * This method does not affect any event listeners on the current node (currentTarget).
         * @zh 阻止对事件流中当前节点的后续节点中的所有事件侦听器进行处理。此方法不会影响当前节点 (currentTarget) 中的任何事件侦听器。
         */
        stopPropagation(): void;
        /**
         * @en The list of touch points.
         * @zh 触摸点列表。
         */
        get touches(): ReadonlyArray<Readonly<ITouchInfo>>;
        /**
         * @en Indicates whether the Alt key is active (true) or inactive (false).
         * @zh 表示 Alt 键是处于活动状态 (true) 还是非活动状态 (false)。
         */
        get altKey(): boolean;
        /**
         * @en Indicates whether the Ctrl key is active (true) or inactive (false).
         * @zh 表示 Ctrl 键是处于活动状态 (true) 还是非活动状态 (false)。
         */
        get ctrlKey(): boolean;
        /**
         * @en Indicates whether the Shift key is active (true) or inactive (false).
         * @zh 表示 Shift 键是处于活动状态 (true) 还是非活动状态 (false)。
         */
        get shiftKey(): boolean;
        /**
         * @en Indicates whether the Shift key is active (true) or inactive (false).
         * @zh 表示 Shift 键是处于活动状态 (true) 还是非活动状态 (false)。
         */
        get metaKey(): boolean;
        /**
         * @en The event name.
         * @zh 事件名称。
         */
        get key(): string;
        /**
         * @en The event name index.
         * @zh 事件名称索引。
         */
        get keyCode(): number;
        /**
         * @en Contains the character code value of the key pressed or released. The character code value is for English keyboard.
         * @zh 包含按下或释放的键的字符代码值。字符代码值为英文键盘值。
         */
        get charCode(): string;
        /**
         * @en Indicates the location of the key on the keyboard. This is useful for differentiating keys that appear more than once on the keyboard.
         * For example, you can use this property to distinguish between the left and right Shift keys: the value of KeyLocation.LEFT for the left Shift key and the value of KeyLocation.RIGHT for the right Shift key. Another example is distinguishing between a key pressed on the standard keyboard (KeyLocation.STANDARD) and the same key pressed on the numeric keypad (KeyLocation.NUM_PAD).
         * @zh 表示键在键盘上的位置。这对于区分在键盘上多次出现的键非常有用。
         * 例如，您可以根据此属性的值来区分左 Shift 键和右 Shift 键：左 Shift 键的值为 KeyLocation.LEFT，右 Shift 键的值为 KeyLocation.RIGHT。另一个示例是区分标准键盘 (KeyLocation.STANDARD) 与数字键盘 (KeyLocation.NUM_PAD) 上按下的数字键。
         */
        get keyLocation(): number;
        /**
         * @en The X axis coordinate of the mouse on the Stage.
         * @zh 鼠标在 Stage 上的 X 轴坐标。
         */
        get stageX(): number;
        /**
         * @en The Y axis coordinate of the mouse on the Stage.
         * @zh 鼠标在 Stage 上的 Y 轴坐标。
         */
        get stageY(): number;
    }
    /**
     * @en The `EventDispatcher` class is the base class for all classes that dispatch events.
     * @zh `EventDispatcher` 类是可调度事件的所有类的基类。
     */
    class EventDispatcher {
        /**@private */
        private _events;
        /**
         * @en Check if the EventDispatcher object has any listeners registered for a specific type of event.
         * @param type The type of event.
         * @returns True if a listener of the specified type is registered, false otherwise.
         * @zh 检查 EventDispatcher 对象是否为特定事件类型注册了任何侦听器。
         * @param type 事件的类型。
         * @returns 如果指定类型的侦听器已注册，则值为 true；否则，值为 false。
         */
        hasListener(type: string): boolean;
        /**
         * @en Dispatch an event.
         * @param type The type of event.
         * @param data (Optional) Data to pass to the callback. If multiple parameters p1, p2, p3, ... need to be passed, use an array structure such as [p1, p2, p3, ...]. If a single parameter p needs to be passed and p is an array, use a structure such as [p]. For other single parameters p, you can directly pass parameter p.
         * @returns True if there are listeners for this event type, false otherwise.
         * @zh 派发事件。
         * @param type 事件类型。
         * @param data （可选）回调数据。<b>注意：</b>如果是需要传递多个参数 p1,p2,p3,...可以使用数组结构如：[p1,p2,p3,...] ；如果需要回调单个参数 p ，且 p 是一个数组，则需要使用结构如：[p]，其他的单个参数 p ，可以直接传入参数 p。
         * @returns 此事件类型是否有侦听者，如果有侦听者则值为 true，否则值为 false。
         */
        event(type: string, data?: any): boolean;
        /**
         * @en Register an event listener object with the EventDispatcher object so that the listener receives event notifications.
         * @param type The type of event.
         * @param listener The listener function.
         * @returns This EventDispatcher object.
         * @zh 使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知。
         * @param type 事件的类型。
         * @param listener 事件侦听函数。
         * @returns 此 EventDispatcher 对象。
         */
        on(type: string, listener: Function): EventDispatcher;
        /**
         * @en Register an event listener object with the EventDispatcher object so that the listener receives event notifications.
         * @param type The type of event.
         * @param caller The execution scope of the event listener function.
         * @param listener The listener function.
         * @param args (Optional) The callback parameters of the event listener function.
         * @returns This EventDispatcher object.
         * @zh 使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知。
         * @param type 事件的类型。
         * @param caller 事件侦听函数的执行域。
         * @param listener 事件侦听函数。
         * @param args （可选）事件侦听函数的回调参数。
         * @returns 此 EventDispatcher 对象。
         */
        on(type: string, caller: any, listener: Function, args?: any[]): EventDispatcher;
        /**
         * @en Register an event listener object with the EventDispatcher object so that the listener receives event notifications. This event listener responds once and is automatically removed after the first call.
         * @param type The type of event.
         * @param listener The listener function.
         * @returns This EventDispatcher object.
         * @zh 使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知，此侦听事件响应一次后自动移除。
         * @param type 事件的类型。
         * @param listener 事件侦听函数。
         * @returns 此 EventDispatcher 对象。
         */
        once(type: string, listener: Function): EventDispatcher;
        /**
         * @en Register an event listener object with the EventDispatcher object so that the listener receives event notifications. This event listener responds once and is automatically removed after the first call.
         * @param type The type of event.
         * @param caller The execution scope of the event listener function.
         * @param listener The listener function.
         * @param args (Optional) The callback parameters of the event listener function.
         * @returns This EventDispatcher object.
         * @zh 使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知，此侦听事件响应一次后自动移除。
         * @param type 事件的类型。
         * @param caller 事件侦听函数的执行域。
         * @param listener 事件侦听函数。
         * @param args （可选）事件侦听函数的回调参数。
         * @returns 此 EventDispatcher 对象。
         */
        once(type: string, caller: any, listener: Function, args?: any[]): EventDispatcher;
        /**
         * @en Remove a listener from the EventDispatcher object.
         * @param type The type of event.
         * @param listener The listener function.
         * @returns This EventDispatcher object.
         * @zh 从 EventDispatcher 对象中删除侦听器。
         * @param type 事件的类型。
         * @param listener 事件侦听函数。
         * @returns 此 EventDispatcher 对象。
         */
        off(type: string, listener: Function): EventDispatcher;
        /**
         * @en Remove a listener from the EventDispatcher object.
         * @param type The type of event.
         * @param caller The execution scope of the event listener function.
         * @param listener  (Optional) The listener function.
         * @param args (Optional) The callback parameters of the event listener function.
         * @returns This EventDispatcher object.
         * @zh 从 EventDispatcher 对象中删除侦听器。
         * @param type 事件的类型。
         * @param caller 事件侦听函数的执行域。
         * @param listener （可选）事件侦听函数。
         * @param args （可选）事件侦听函数的回调参数。
         * @returns 此 EventDispatcher 对象。
         */
        off(type: string, caller: any, listener?: Function, args?: any[]): EventDispatcher;
        /**
         * @en Remove all listeners of the specified event type from the EventDispatcher object.
         * @param type (Optional) The type of event. If the value is null, all types of listeners on this object are removed.
         * @returns This EventDispatcher object.
         * @zh 从 EventDispatcher 对象中删除指定事件类型的所有侦听器。
         * @param type （可选）事件类型，如果值为 null，则移除本对象所有类型的侦听器。
         * @returns 此 EventDispatcher 对象。
         */
        offAll(type?: string): EventDispatcher;
        /**
         * @en Remove all event listeners whose caller is the specified target.
         * @param caller The target caller object.
         * @returns This EventDispatcher object.
         * @zh 移除caller为target的所有事件监听。
         * @param caller caller对象
         * @returns 此 EventDispatcher 对象。
         */
        offAllCaller(caller: any): EventDispatcher;
    }
    class InputManager {
        /**
         * @en Whether to enable multi-touch support.
         * @zh 是否开启多点触控支持。
         */
        static multiTouchEnabled: boolean;
        /**
         * @en Whether to enable mouse/touch events. Default is true.
         * @zh 是否开启鼠标/触摸事件。默认为 true。
         */
        static mouseEventsEnabled: boolean;
        /**
         * @en Whether to enable keyboard events. Default is true.
         * @zh 是否开启键盘事件。默认为 true。
         */
        static keyEventsEnabled: boolean;
        /**
         * @en The threshold for considering a mouse press and release as a click. If the distance between the press and release positions exceeds this value, it is not considered a click.
         * @zh 鼠标按下和弹起位置之间的距离阀值，用以判断是否视为一次点击。如果超过这个距离，则不视为点击。
         */
        static clickTestThreshold: number;
        /**
         * @en The X coordinate of the mouse on the canvas.
         * @zh canvas 上鼠标的 X 坐标。
         */
        static mouseX: number;
        /**
         * @en The Y coordinate of the mouse on the canvas.
         * @zh canvas 上鼠标的 Y 坐标。
         */
        static mouseY: number;
        /**
         * @en Indicates whether text input is currently active.
         * @zh 表示当前是否正在输入文字。
         */
        static isTextInputting: boolean;
        /**
         * @en Indicates whether the current platform is iOS's WKWebView.
         * @zh 表示当前是否是 iOS 的 WKWebView 平台。
         */
        static isiOSWKwebView: boolean;
        /**
         * @en Used for IDE processing.
         * @zh 用于IDE处理。
         */
        protected _eventType: number;
        protected _nativeEvent: MouseEvent | WheelEvent | TouchEvent;
        protected _pressKeys: Set<string | number>;
        protected _keyEvent: Event;
        private _lastTouchTime;
        private _lastTouchId;
        /**
         * @ignore
         */
        constructor();
        static get inst(): InputManager;
        /**
         * @en Get the touch position.
         * @param touchId The ID of the touch point. If not provided, the position of the first touch point will be returned.
         * @returns The position of the touch point.
         * @zh 获取触摸位置。
         * @param touchId 触摸点ID。如果不提供，将返回第一个触摸点的位置。
         * @returns 触摸点的位置。
         */
        static getTouchPos(touchId?: number): Readonly<Point>;
        /**
         * @en Get the current touch target node.
         * @zh 获取当前触摸目标节点。
         */
        static get touchTarget(): Node;
        /**
         * @en Get the array of current touch information.
         * @zh 获取当前触摸信息的数组。
         */
        static get touches(): ReadonlyArray<Readonly<ITouchInfo>>;
        /**
         * @en Get the number of current touches.
         * @zh 获取当前触摸数量。
         */
        static get touchCount(): number;
        /**
         * @en Cancel the click event for a touch point.
         * @param touchId The ID of the touch event to cancel.
         * @zh 取消指定触摸点的点击事件。
         * @param touchId 要取消的触摸事件ID。
         */
        static cancelClick(touchId?: number): void;
        /**
         * @en Check if a specific key is pressed.
         * @param key The key value. For more information, see: https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values
         * @return Whether the key is pressed.
         * @zh 返回指定键是否被按下。
         * @param key 键值。更多信息请参考：https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values
         * @return 是否被按下。
         */
        static hasKeyDown(key: string | number): boolean;
        /**
         * @private
         * @en Initialization.
         * @zh 初始化。
         */
        static __init__(stage: Stage, canvas: HTMLCanvasElement): void;
        /**
         * @en Handling mouse events
         * @param ev Mouse events
         * @param type Event types
         * @zh 处理鼠标事件
         * @param ev 鼠标事件
         * @param type 事件类型
         */
        handleMouse(ev: MouseEvent | WheelEvent, type: number): void;
        /**
         * @en Handling touch screen events.
         * @param ev Touch screen events.
         * @param type Event types.
         * @zh 处理触屏事件
         * @param ev 触屏事件
         * @param type 事件类型
         */
        handleTouch(ev: TouchEvent, type: number): void;
        private getTouch;
        private handleFocus;
        /**
         * @en Handle keys events
         * @param ev Keys events
         * @zh 处理按键事件
         * @param ev 按键事件
         */
        handleKeys(ev: KeyboardEvent): void;
        /**
         * @en Obtain nodes under location points
         * @param x The x-coordinate value.
         * @param y The y-coordinate value.
         * @returns The node under the point or the stage if no node is found.
         * @zh 获取位置点下的节点
         * @param x x坐标值。
         * @param y y坐标值。
         * @returns 该点下的对象节点，如果没有找到节点则返回舞台。
         */
        getNodeUnderPoint(x: number, y: number): Node;
        /**
         * @en Get the sprite under the specified coordinates relative to a Sprite. The x/y values are in the local coordinates of the Sprite.
         * @param sp The Sprite relative to which the coordinates are calculated.
         * @param x The x-coordinate relative to the Sprite.
         * @param y The y-coordinate relative to the Sprite.
         * @returns The sprite under the point or null if not found.
         * @zh 获取在相对Sprite指定坐标下的sprite。x/y值是Sprite的本地坐标。
         * @param sp 相对哪个Sprite计算坐标。
         * @param x 相对于Sprite的X坐标。
         * @param y 相对于Sprite的Y坐标。
         * @returns 该点下的sprite，如果没有找到则返回null。
         */
        getSpriteUnderPoint(sp: Sprite, x: number, y: number): Sprite;
        getSprite3DUnderPoint(x: number, y: number): Node;
        /**
         * @en Hit test
         * @param sp Relative Sprite.
         * @param x The x-coordinate relative to the Sprite.
         * @param y The y-coordinate relative to the Sprite.
         * @param editing Whether the test is performed in editing mode.
         * @returns True if the point is within the Sprite's bounds, false otherwise.
         * @zh 点击测试
         * @param sp 相对Sprite
         * @param x 相对于Sprite的X坐标。
         * @param y 相对于Sprite的Y坐标。
         * @param editing 是否在编辑模式下进行测试。
         * @returns 如果点在Sprite的范围内返回true，否则返回false。
         */
        hitTest(sp: Sprite, x: number, y: number, editing?: boolean): boolean;
        private handleRollOver;
    }
    /**
     * @en The `Keyboard` class contains constants representing the most commonly used keys for controlling a game.
     * @zh `Keyboard` 类的属性是一些常数，这些常数表示控制游戏时最常用的键。
     */
    class Keyboard {
        /**
         * @en The constant associated with the key code value (48) for the 0 key.
         * @zh 与 0 的键控代码值(48) 关联的常数。
         */
        static NUMBER_0: number;
        /**
         * @en The constant associated with the key code value (49) for the 1 key.
         * @zh 与 1 的键控代码值 (49) 关联的常数。
         */
        static NUMBER_1: number;
        /**
         * @en The constant associated with the key code value (50) for the 2 key.
         * @zh 与 2 的键控代码值 (50) 关联的常数。
         */
        static NUMBER_2: number;
        /**
         * @en The constant associated with the key code value (51) for the 3 key.
         * @zh 与 3 的键控代码值 (51) 关联的常数。
         */
        static NUMBER_3: number;
        /**
         * @en The constant associated with the key code value (52) for the 4 key.
         * @zh 与 4 的键控代码值 (52) 关联的常数。
         */
        static NUMBER_4: number;
        /**
         * @en The constant associated with the key code value (53) for the 5 key.
         * @zh 与 5 的键控代码值 (53) 关联的常数。
         */
        static NUMBER_5: number;
        /**
         * @en The constant associated with the key code value (54) for the 6 key.
         * @zh 与 6 的键控代码值 (54) 关联的常数。
         */
        static NUMBER_6: number;
        /**
         * @en The constant associated with the key code value (55) for the 7 key.
         * @zh 与 7 的键控代码值 (55) 关联的常数。
         */
        static NUMBER_7: number;
        /**
         * @en The constant associated with the key code value (56) for the 8 key.
         * @zh 与 8 的键控代码值 (56) 关联的常数。
         */
        static NUMBER_8: number;
        /**
         * @en The constant associated with the key code value (57) for the 9 key.
         * @zh 与 9 的键控代码值 (57) 关联的常数。
         */
        static NUMBER_9: number;
        /**
         * @en The constant associated with the key code value (65) for the A key.
         * @zh 与 A 键的键控代码值 (65) 关联的常数。
         */
        static A: number;
        /**
         * @en The constant associated with the key code value (66) for the B key.
         * @zh 与 B 键的键控代码值 (66) 关联的常数。
         */
        static B: number;
        /**
         * @en The constant associated with the key code value (67) for the C key.
         * @zh 与 C 键的键控代码值 (67) 关联的常数。
         */
        static C: number;
        /**
         * @en The constant associated with the key code value (68) for the D key.
         * @zh 与 D 键的键控代码值 (68) 关联的常数。
         */
        static D: number;
        /**
         * @en The constant associated with the key code value (69) for the E key.
         * @zh 与 E 键的键控代码值 (69) 关联的常数。
         */
        static E: number;
        /**
         * @en The constant associated with the key code value (70) for the F key.
         * @zh 与 F 键的键控代码值 (70) 关联的常数。
         */
        static F: number;
        /**
         * @en The constant associated with the key code value (71) for the G key.
         * @zh 与 G 键的键控代码值 (71) 关联的常数。
         */
        static G: number;
        /**
         * @en The constant associated with the key code value (72) for the H key.
         * @zh 与 H 键的键控代码值 (72) 关联的常数。
         */
        static H: number;
        /**
         * @en The constant associated with the key code value (73) for the I key.
         * @zh 与 I 键的键控代码值 (73) 关联的常数。
         */
        static I: number;
        /**
         * @en The constant associated with the key code value (74) for the J key.
         * @zh 与 J 键的键控代码值 (74) 关联的常数。
         */
        static J: number;
        /**
         * @en The constant associated with the key code value (75) for the K key.
         * @zh 与 K 键的键控代码值 (75) 关联的常数。
         */
        static K: number;
        /**
         * @en The constant associated with the key code value (76) for the L key.
         * @zh 与 L 键的键控代码值 (76) 关联的常数。
         */
        static L: number;
        /**
         * @en The constant associated with the key code value (77) for the M key.
         * @zh 与 M 键的键控代码值 (77) 关联的常数。
         */
        static M: number;
        /**
         * @en The constant associated with the key code value (78) for the N key.
         * @zh 与 N 键的键控代码值 (78) 关联的常数。
         */
        static N: number;
        /**
         * @en The constant associated with the key code value (79) for the O key.
         * @zh 与 O 键的键控代码值 (79) 关联的常数。
         */
        static O: number;
        /**
         * @en The constant associated with the key code value (80) for the P key.
         * @zh 与 P 键的键控代码值 (80) 关联的常数。
         */
        static P: number;
        /**
         * @en The constant associated with the key code value (81) for the Q key.
         * @zh 与 Q 键的键控代码值 (81) 关联的常数。
         */
        static Q: number;
        /**
         * @en The constant associated with the key code value (82) for the R key.
         * @zh 与 R 键的键控代码值 (82) 关联的常数。
         */
        static R: number;
        /**
         * @en The constant associated with the key code value (83) for the S key.
         * @zh 与 S 键的键控代码值 (83) 关联的常数。
         */
        static S: number;
        /**
         * @en The constant associated with the key code value (84) for the T key.
         * @zh 与 T 键的键控代码值 (84) 关联的常数。
         */
        static T: number;
        /**
         * @en The constant associated with the key code value (85) for the U key.
         * @zh 与 U 键的键控代码值 (85) 关联的常数。
         */
        static U: number;
        /**
         * @en The constant associated with the key code value (86) for the V key.
         * @zh 与 V 键的键控代码值 (86) 关联的常数。
         */
        static V: number;
        /**
         * @en The constant associated with the key code value (87) for the W key.
         * @zh 与 W 键的键控代码值 (87) 关联的常数。
         */
        static W: number;
        /**
         * @en The constant associated with the key code value (88) for the X key.
         * @zh 与 X 键的键控代码值 (88) 关联的常数。
         */
        static X: number;
        /**
         * @en The constant associated with the key code value (89) for the Y key.
         * @zh 与 Y 键的键控代码值 (89) 关联的常数。
         */
        static Y: number;
        /**
         * @en The constant associated with the key code value (90) for the Z key.
         * @zh 与 Z 键的键控代码值 (90) 关联的常数。
         */
        static Z: number;
        /**
         * @en The constant associated with the key code value (112) for the F1 key.
         * @zh 与 F1 的键控代码值 (112) 关联的常数。
         */
        static F1: number;
        /**
         * @en The constant associated with the key code value (113) for the F2 key.
         * @zh 与 F2 的键控代码值 (113) 关联的常数。
         */
        static F2: number;
        /**
         * @en The constant associated with the key code value (114) for the F3 key.
         * @zh 与 F3 的键控代码值 (114) 关联的常数。
         */
        static F3: number;
        /**
         * @en The constant associated with the key code value (115) for the F4 key.
         * @zh 与 F4 的键控代码值 (115) 关联的常数。
         */
        static F4: number;
        /**
         * @en The constant associated with the key code value (116) for the F5 key.
         * @zh 与 F5 的键控代码值 (116) 关联的常数。
         */
        static F5: number;
        /**
         * @en The constant associated with the key code value (117) for the F6 key.
         * @zh 与 F6 的键控代码值 (117) 关联的常数。
         */
        static F6: number;
        /**
         * @en The constant associated with the key code value (118) for the F7 key.
         * @zh 与 F7 的键控代码值 (118) 关联的常数。
         */
        static F7: number;
        /**
         * @en The constant associated with the key code value (119) for the F8 key.
         * @zh 与 F8 的键控代码值 (119) 关联的常数。
         */
        static F8: number;
        /**
         * @en The constant associated with the key code value (120) for the F9 key.
         * @zh 与 F9 的键控代码值 (120) 关联的常数。
         */
        static F9: number;
        /**
         * @en The constant associated with the key code value (121) for the F10 key.
         * @zh 与 F10 的键控代码值 (121) 关联的常数。
         */
        static F10: number;
        /**
         * @en The constant associated with the key code value (122) for the F11 key.
         * @zh 与 F11 的键控代码值 (122) 关联的常数。
         */
        static F11: number;
        /**
         * @en The constant associated with the key code value (123) for the F12 key.
         * @zh 与 F12 的键控代码值 (123) 关联的常数。
         */
        static F12: number;
        /**
         * @en The constant associated with the key code value (124) for the F13 key.
         * @zh 与 F13 的键控代码值 (124) 关联的常数。
         */
        static F13: number;
        /**
         * @en The constant associated with the key code value (125) for the F14 key.
         * @zh 与 F14 的键控代码值 (125) 关联的常数。
         */
        static F14: number;
        /**
         * @en The constant associated with the key code value (126) for the F15 key.
         * @zh 与 F15 的键控代码值 (126) 关联的常数。
         */
        static F15: number;
        /**
         * @en The constant associated with the pseudo key code (21) for the numeric keypad.
         * @zh 与数字键盘的伪键控代码 (21) 关联的常数。
         */
        static NUMPAD: number;
        /**
         * @en The constant associated with the key code value (96) for the number 0 on the numeric keypad.
         * @zh 与数字键盘上的数字 0 的键控代码值 (96) 关联的常数。
         */
        static NUMPAD_0: number;
        /**
         * @en The constant associated with the key code value (97) for the number 1 on the numeric keypad.
         * @zh 与数字键盘上的数字 1 的键控代码值 (97) 关联的常数。
         */
        static NUMPAD_1: number;
        /**
         * @en The constant associated with the key code value (98) for the number 2 on the numeric keypad.
         * @zh 与数字键盘上的数字 2 的键控代码值 (98) 关联的常数。
         */
        static NUMPAD_2: number;
        /**
         * @en The constant associated with the key code value (99) for the number 3 on the numeric keypad.
         * @zh 与数字键盘上的数字 3 的键控代码值 (99) 关联的常数。
         */
        static NUMPAD_3: number;
        /**
         * @en The constant associated with the key code value (100) for the number 4 on the numeric keypad.
         * @zh 与数字键盘上的数字 4 的键控代码值 (100) 关联的常数。
         */
        static NUMPAD_4: number;
        /**
         * @en The constant associated with the key code value (101) for the number 5 on the numeric keypad.
         * @zh 与数字键盘上的数字 5 的键控代码值 (101) 关联的常数。
         */
        static NUMPAD_5: number;
        /**
         * @en The constant associated with the key code value (102) for the number 6 on the numeric keypad.
         * @zh 与数字键盘上的数字 6 的键控代码值 (102) 关联的常数。
         */
        static NUMPAD_6: number;
        /**
         * @en The constant associated with the key code value (103) for the number 7 on the numeric keypad.
         * @zh 与数字键盘上的数字 7 的键控代码值 (103) 关联的常数。
         */
        static NUMPAD_7: number;
        /**
         * @en The constant associated with the key code value (104) for the number 8 on the numeric keypad.
         * @zh 与数字键盘上的数字 8 的键控代码值 (104) 关联的常数。
         */
        static NUMPAD_8: number;
        /**
         * @en The constant associated with the key code value (105) for the number 9 on the numeric keypad.
         * @zh 与数字键盘上的数字 9 的键控代码值 (105) 关联的常数。
         */
        static NUMPAD_9: number;
        /**
         * @en The constant associated with the key code value (107) for the plus sign (+) on the numeric keypad.
         * @zh 与数字键盘上的加号 (+) 的键控代码值 (107) 关联的常数。
         */
        static NUMPAD_ADD: number;
        /**
         * @en The constant associated with the key code value (110) for the decimal point (.) on the numeric keypad.
         * @zh 与数字键盘上的小数点 (.) 的键控代码值 (110) 关联的常数。
         */
        static NUMPAD_DECIMAL: number;
        /**
         * @en The constant associated with the key code value (111) for the division sign (/) on the numeric keypad.
         * @zh 与数字键盘上的除号 (/) 的键控代码值 (111) 关联的常数。
         */
        static NUMPAD_DIVIDE: number;
        /**
         * @en The constant associated with the key code value (108) for the Enter key on the numeric keypad.
         * @zh 与数字键盘上的 Enter 的键控代码值 (108) 关联的常数。
         */
        static NUMPAD_ENTER: number;
        /**
         * @en The constant associated with the key code value (106) for the multiplication sign (*) on the numeric keypad.
         * @zh 与数字键盘上的乘号 (*) 的键控代码值 (106) 关联的常数。
         */
        static NUMPAD_MULTIPLY: number;
        /**
         * @en The constant associated with the key code value (109) for the minus sign (-) on the numeric keypad.
         * @zh 与数字键盘上的减号 (-) 的键控代码值 (109) 关联的常数。
         */
        static NUMPAD_SUBTRACT: number;
        /**
         * @en The constant associated with the key code value (186) for the semicolon (;) key.
         * @zh 与 ; 键的键控代码值 (186) 关联的常数。
         */
        static SEMICOLON: number;
        /**
         * @en The constant associated with the key code value (187) for the equal sign (=) key.
         * @zh 与 = 键的键控代码值 (187) 关联的常数。
         */
        static EQUAL: number;
        /**
         * @en The constant associated with the key code value (188) for the comma (,) key.
         * @zh 与 F15 的键控代码值 (188) 关联的常数。
         */
        static COMMA: number;
        /**
         * @en The constant associated with the key code value (189) for the minus (-) key.
         * @zh 与 - 键的键控代码值 (189) 关联的常数。
         */
        static MINUS: number;
        /**
         * @en The constant associated with the key code value (190) for the period (.) key.
         * @zh 与 . 键的键控代码值 (190) 关联的常数。
         */
        static PERIOD: number;
        /**
         * @en The constant associated with the key code value (191) for the forward slash (/) key.
         * @zh 与 / 键的键控代码值 (191) 关联的常数。
         */
        static SLASH: number;
        /**
         * @en The constant associated with the key code value (192) for the backquote (`) key.
         * @zh 与 ` 键的键控代码值 (192) 关联的常数。
         */
        static BACKQUOTE: number;
        /**
         * @en The constant associated with the key code value (219) for the left bracket ([) key.
         * @zh 与 [ 键的键控代码值 (219) 关联的常数。
         */
        static LEFTBRACKET: number;
        /**
         * @en The constant associated with the key code value (220) for the backslash (\) key.
         * @zh 与 \ 键的键控代码值 (220) 关联的常数。
         */
        static BACKSLASH: number;
        /**
         * @en The constant associated with the key code value (221) for the right bracket (]) key.
         * @zh 与 ] 键的键控代码值 (221) 关联的常数。
         */
        static RIGHTBRACKET: number;
        /**
         * @en The constant associated with the key code value (222) for the single quote (') key.
         * @zh 与 ' 键的键控代码值 (222) 关联的常数。
         */
        static QUOTE: number;
        /**
         * @en The constant associated with the key code value (18) for the Alternate (Option) key.
         * @zh 与 Alternate (Option) 键的键控代码值 (18) 关联的常数。
         */
        static ALTERNATE: number;
        /**
         * @en The constant associated with the key code value (8) for the Backspace key.
         * @zh 与 Backspace 的键控代码值 (8) 关联的常数。
         */
        static BACKSPACE: number;
        /**
         * @en The constant associated with the key code value (20) for the Caps Lock key.
         * @zh 与 Caps Lock 的键控代码值 (20) 关联的常数。
         */
        static CAPS_LOCK: number;
        /**
         * @en The constant associated with the key code value (15) for the Mac Command key.
         * @zh 与 Mac 命令键 (15) 关联的常数。
         */
        static COMMAND: number;
        /**
         * @en The constant associated with the key code value (17) for the Ctrl key.
         * @zh 与 Ctrl 的键控代码值 (17) 关联的常数。
         */
        static CONTROL: number;
        /**
         * @en The constant associated with the key code value (46) for the Delete key.
         * @zh 与 Delete 的键控代码值 (46) 关联的常数。
         */
        static DELETE: number;
        /**
         * @en The constant associated with the key code value (13) for the Enter key.
         * @zh 与 Enter 的键控代码值 (13) 关联的常数。
         */
        static ENTER: number;
        /**
         * @en The constant associated with the key code value (27) for the Esc key.
         * @zh 与 Esc 的键控代码值 (27) 关联的常数。
         */
        static ESCAPE: number;
        /**
         * @en The constant associated with the key code value (33) for the Page Up key.
         * @zh 与 Page Up 的键控代码值 (33) 关联的常数。
         */
        static PAGE_UP: number;
        /**
         * @en The constant associated with the key code value (34) for the Page Down key.
         * @zh 与 Page Down 的键控代码值 (34) 关联的常数。
         */
        static PAGE_DOWN: number;
        /**
         * @en The constant associated with the key code value (35) for the End key.
         * @zh 与 End 的键控代码值 (35) 关联的常数。
         */
        static END: number;
        /**
         * @en The constant associated with the key code value (36) for the Home key.
         * @zh 与 Home 的键控代码值 (36) 关联的常数。
         */
        static HOME: number;
        /**
         * @en The constant associated with the key code value (37) for the Left Arrow key.
         * @zh 与向左箭头键的键控代码值 (37) 关联的常数。
         */
        static LEFT: number;
        /**
         * @en The constant associated with the key code value (38) for the Up Arrow key.
         * @zh 与向上箭头键的键控代码值 (38) 关联的常数。
         */
        static UP: number;
        /**
         * @en The constant associated with the key code value (39) for the Right Arrow key.
         * @zh 与向右箭头键的键控代码值 (39) 关联的常数。
         */
        static RIGHT: number;
        /**
         * @en The constant associated with the key code value (40) for the Down Arrow key.
         * @zh 与向下箭头键的键控代码值 (40) 关联的常数。
         */
        static DOWN: number;
        /**
         * @en The constant associated with the key code value (16) for the Shift key.
         * @zh 与 Shift 的键控代码值 (16) 关联的常数。
         */
        static SHIFT: number;
        /**
         * @en The constant associated with the key code value (32) for the Spacebar.
         * @zh 与空格键的键控代码值 (32) 关联的常数。
         */
        static SPACE: number;
        /**
         * @en The constant associated with the key code value (9) for the Tab key.
         * @zh 与 Tab 的键控代码值 (9) 关联的常数。
         */
        static TAB: number;
        /**
         * @en The constant associated with the key code value (45) for the Insert key.
         * @zh 与 Insert 的键控代码值 (45) 关联的常数。
         */
        static INSERT: number;
    }
    /**
     * @en The `KeyLocation` class contains constants that indicate the location of a key on a keyboard or keyboard-like input device.
     * The `KeyLocation` constants are used within the `keyLocation` property of keyboard event objects.
     * @zh `KeyLocation` 类包含表示键盘或类似键盘的输入设备上按键位置的常量。
     * `KeyLocation` 常数用在键盘事件对象的 `keyLocation` 属性中。
     */
    class KeyLocation {
        /**
         * @en Indicates that the active key does not distinguish between the left or right position,
         * nor does it distinguish whether it is located on the numeric keypad (or activated by a virtual key corresponding to the numeric keypad).
         * @zh 表示激活的键不区分位于左侧还是右侧，也不区分是否位于数字键盘（或者是使用对应于数字键盘的虚拟键激活的）。
         */
        static STANDARD: number;
        /**
         * @en Indicates that the active key is in the left key location (a key may have multiple possible locations).
         * @zh 表示激活的键在左侧键位置（此键可能有多个可能的位置）。
         */
        static LEFT: number;
        /**
         * @en Indicates that the active key is in the right key location (a key may have multiple possible locations).
         * @zh 表示激活的键在右侧键位置（此键可能有多个可能的位置）。
         */
        static RIGHT: number;
        /**
         * @en Indicates that the active key is on the numeric keypad or activated by a virtual key corresponding to the numeric keypad.
         * <Note: This property is only valid in Flash mode.
         * @zh 表示激活的键位于数字键盘或者是使用对应于数字键盘的虚拟键激活的。
         * <注意：此属性只在flash模式下有效。
         */
        static NUM_PAD: number;
    }
    /**
     * @en Blur filter
     * @zh 模糊滤镜
     */
    class BlurFilter extends Filter {
        /**
         * @en The intensity of the blur filter. The higher the value, the more indistinct the image becomes.
         * @zh 模糊滤镜的强度。值越大，图像越不清晰。
         */
        private _strength;
        private _shaderV1;
        /**
         * @en Constructs a new BlurFilter instance with the specified strength.
         * The strength of the blur filter, with a default value of 4. Higher values result in a more indistinct image.
         * @param strength The strength of the blur filter. The default value is 4.
         * @zh 创建一个新的模糊滤镜实例，并设置指定的强度值。
         * 模糊滤镜的强度，默认值为4。值越大，图像越不清晰。
         * @param strength 模糊滤镜的强度。默认值为4。
         */
        constructor(strength?: number);
        /**
         * @en The strength of the blur filter.
         * @zh 模糊滤镜的强度。
         */
        get strength(): number;
        set strength(v: number);
        /**
         * @en Renders the blur filter effect on the given source texture.
         * @param srctexture The source texture to apply the blur filter to.
         * @param width The width of the rendering area.
         * @param height The height of the rendering area.
         * @zh 将模糊滤镜效果渲染到给定的源纹理上。
         * @param srctexture 要应用模糊滤镜的源纹理。
         * @param width 渲染区域的宽度。
         * @param height 渲染区域的高度。
         */
        render(srctexture: RenderTexture2D, width: number, height: number): void;
    }
    /**
     * @en The `ColorFilter` class represents a color filter that applies a 4x5 matrix transformation to the RGBA color and Alpha values of each pixel of the input image to produce a result with a new set of RGBA colors and Alpha values. This class allows for saturation adjustments, hue rotation, brightness to Alpha, and various other effects. You can apply the filter to any display object (i.e., an object that inherits from the `Sprite` class).
     * For RGBA values, the most significant byte represents the red channel value, followed by the green, blue, and Alpha channel values respectively.
     * @zh `ColorFilter` 类是一个颜色滤镜，它将 4x5 矩阵转换应用于输入图像上的每个像素的 RGBA 颜色和 Alpha 值，以生成具有一组新的 RGBA 颜色和 Alpha 值的结果。此类允许饱和度更改、色相旋转、亮度转 Alpha 以及各种其他效果。您可以将滤镜应用于任何显示对象（即从 `Sprite` 类继承的对象）。
     * 注意：对于 RGBA 值，最高有效字节代表红色通道值，其后的有效字节分别代表绿色、蓝色和 Alpha 通道值。
     */
    class ColorFilter extends Filter implements IFilter {
        /**
         * @en Creates an instance of the ColorFilter class with an optional 4x5 matrix for color transformation.
         * @param mat An array with 20 elements arranged in a 4x5 matrix for color transformation.
         * @zh 创建 `ColorFilter` 类的实例，可选择传入用于颜色转换的 4x5 矩阵。
         * @param mat 用于颜色转换的由 20 个元素组成的数组（排列成 4x5 矩阵）。
         */
        constructor(mat?: any[]);
        /** @ignore */
        render(srctexture: RenderTexture2D, width: number, height: number): void;
        /**
         * @en Sets the filter to a grayscale filter.
         * @zh 将滤镜设置为灰度滤镜。
         */
        gray(): ColorFilter;
        /**
         * @en Sets the filter to a color transformation filter with the specified red, green, blue, and alpha coefficients.
         * @param red The red coefficient, range: 0 to 1.
         * @param green The green coefficient, range: 0 to 1.
         * @param blue The blue coefficient, range: 0 to 1.
         * @param alpha The alpha coefficient, range: 0 to 1.
         * @zh 将滤镜设置为具有指定红色、绿色、蓝色和 Alpha 系数的颜色转换滤镜。
         * @param red 红色系数,范围:0~1
         * @param green 绿色系数,范围:0~1
         * @param blue 蓝色系数,范围:0~1
         * @param alpha alpha系数,范围:0~1
         */
        color(red?: number, green?: number, blue?: number, alpha?: number): ColorFilter;
        /**
         * @en Sets the filter color using a color value.
         * @param color The color value in string format.
         * @zh 使用颜色值设置滤镜颜色。
         * @param  color 颜色值
         */
        setColor(color: string): ColorFilter;
        /**
         * @en Sets the matrix data.
         * @param matrix An array with 20 elements arranged in a 4x5 matrix.
         * @zh 设置矩阵数据
         * @param matrix 由 20 个项目（排列成 4 x 5 矩阵）组成的数组
         */
        setByMatrix(matrix: any[]): ColorFilter;
        /**
         * @private
         * @override
         * @en Gets the type of the filter.
         * @zh 获取滤镜类型。
         */
        get type(): number;
        /**
         * @en Adjusts color properties including brightness, contrast, saturation, and hue.
         * @param brightness Brightness value, range: -100 to 100.
         * @param contrast Contrast value, range: -100 to 100.
         * @param saturation Saturation value, range: -100 to 100.
         * @param hue Hue value, range: -180 to 180.
         * @zh 调整颜色属性，包括亮度、对比度、饱和度和色调。
         * @param brightness 亮度,范围:-100~100
         * @param contrast 对比度,范围:-100~100
         * @param saturation 饱和度,范围:-100~100
         * @param hue 色调,范围:-180~180
         */
        adjustColor(brightness: number, contrast: number, saturation: number, hue: number): ColorFilter;
        /**
         * @en Adjusts the brightness of the filter.
         * @param brightness Brightness value, range: -100 to 100.
         * @zh 调整滤镜的亮度。
         * @param brightness 亮度,范围:-100~100
         */
        adjustBrightness(brightness: number): ColorFilter;
        /**
         * @en Adjusts the contrast of the image.
         * @param contrast The contrast value. The contrast value should be between -100 and 100.
         * @zh 调整图像的对比度。
         * @param contrast 对比度值。对比度值应在 -100 到 100 之间。
         */
        adjustContrast(contrast: number): ColorFilter;
        /**
         * @en Adjusts the saturation of the image.
         * @param saturation The saturation value. The saturation value should be between -100 and 100.
         * @zh 调整图像的饱和度。
         * @param saturation 饱和度值。饱和度值应在 -100 到 100 之间。
         */
        adjustSaturation(saturation: number): ColorFilter;
        /**
         * @en Adjusts the hue of the image.
         * @param hue The hue value.The hue value should be between -180 and 180.
         * @zh 调整图像的色调。
         * @param hue 色调值。色调值应在 -180 到 180 之间。
         */
        adjustHue(hue: number): ColorFilter;
        /**
         * @en Resets the filter to the identity matrix, removing any filter effects.
         * @zh 将滤镜重置为单位矩阵，移除所有滤镜效果。
         */
        reset(): ColorFilter;
        /**
         * @en Multiplication.
         * @param matrix The matrix to multiply with the current one.
         * @zh 矩阵乘法
         * @param matrix 要与当前矩阵相乘的矩阵。
         */
        private _multiplyMatrix;
        /**
         * @en Clamps the value to a specified range.
         * @param val The current value to be clamped.
         * @param limit The limit range for the value.
         * @zh 规范值的范围。
         * @param val 当前值。
         * @param limit 值的范围限制。
         */
        private _clampValue;
        /**
         * @en Adjusts the matrix to the correct size.
         * @param matrix The matrix to be adjusted.
         * @zh 规范矩阵，确保矩阵大小正确。
         * @param matrix 需要调整的矩阵。
         */
        private _fixMatrix;
        /**
         * @en Copies the matrix
         * @zh 复制矩阵
         */
        private _copyMatrix;
        /**
         * @en Called after deserialization.
         * @zh 反序列化后调用。
         */
        onAfterDeserialize(): void;
    }
    /**
     * @en The `Filter` class is the base class for filters. Filters are post-processing operations on nodes, so they inevitably operate on a renderTexture.
     * @zh Filter 是滤镜基类。滤镜是针对节点的后处理过程，所以必然操作一个rendertexture
     */
    abstract class Filter extends EventDispatcher implements IFilter {
        /**
         * @private
         * @en color filter
         * @zh 颜色滤镜。
         */
        static COLOR: number;
        /**
         * @en The coordinate of the result origin, relative to the original origin of the sprite. If extended, left and top may be negative.
         * @zh 结果原点的坐标，相对于sprite的原始原点。如果进行了扩展，left 和 top 可能是负值。
         */
        protected left: number;
        protected top: number;
        /**
         * @en The size of the rendering result.
         * @zh 渲染结果的大小。
         */
        protected width: number;
        protected height: number;
        protected texture: RenderTexture2D;
        protected _render2D: Render2D;
        /**
         * @en event：some parameter changed
         * @zh 参数改变事件
         */
        static EVENT_CHANGE: string;
        /**
         * @en Current usage
         * @zh 当前使用的
         */
        protected _rectMesh: MeshQuadTexture;
        protected _rectMeshVB: Float32Array;
        /**
         * @en Version with normal UV coordinates
         * @zh uv坐标正常的版本
         */
        private _rectMeshNormY;
        private _rectMeshVBNormY;
        /**
         * @en Version of UV coordinate flipping
         * @zh uv坐标翻转的版本
         */
        private _rectMeshInvY;
        private _rectMeshVBInvY;
        /**
         * @ignore
         */
        constructor();
        protected onChange(): void;
        /**
         * @en Sets the mesh and vertex buffer to use based on whether Y-flip is needed.
         * @zh 根据是否需要翻转 Y 坐标来设置使用的网格和顶点缓冲区。
         */
        useFlipY(b: boolean): void;
        /**
         * @en The setter for the Render2D object used for rendering.
         * @zh 用于设置渲染用的 Render2D 对象。
         */
        set render2D(r: Render2D);
        /**
         * @en No location required
         * @zh 不需要位置
         * @param texture
         * @param width
         * @param height
         */
        abstract render(texture: RenderTexture2D, width: number, height: number): void;
        /**
         * @private
         * @en Gets the type of the filter.
         * @zh 获取滤镜类型。
         */
        get type(): number;
        /**
         * @en Applies multiple filters to a sprite within the given context.
         * @param this The context in which this function is executed, typically a RenderSprite instance.
         * @param sprite The sprite to which the filters are applied.
         * @param context The current rendering context.
         * @param x The x-coordinate at which the sprite is being rendered.
         * @param y The y-coordinate at which the sprite is being rendered.
         * @zh 在给定的上下文中为精灵应用多个滤镜。
         * @param this 执行此函数的上下文，通常是 RenderSprite 实例。
         * @param sprite 应用滤镜的精灵。
         * @param context 当前的渲染上下文。
         * @param x 精灵正在渲染的 x 坐标。
         * @param y 精灵正在渲染的 y 坐标。
         */
        static _filter: (this: RenderSprite, sprite: Sprite, context: Context, x: number, y: number) => void;
    }
    /**
     * @en Luminous filter (can also be used as shadow filter)
     * @zh 发光滤镜(也可以当成阴影滤使用）
     */
    class GlowFilter extends Filter {
        /**滤镜的颜色*/
        private _color;
        private shaderDataBlur;
        private shaderDataCopy;
        private textureExtend;
        private shaderDataCopy1;
        private _flipY;
        /**
         * @en Creates an instance of a glow filter.
         * @param color The color of the glow filter.
         * @param blur The size of blurred edges
         * @param offX The horizontal offset for the glow effect.
         * @param offY The vertical offset for the glow effect.
         * @zh 创建一个发光滤镜实例。
         * @param color 发光滤镜的颜色。
         * @param blur 边缘模糊的大小。
         * @param offX 发光效果的水平偏移。
         * @param offY 发光效果的垂直偏移。
         */
        constructor(color: string, blur?: number, offX?: number, offY?: number);
        private _fillQuad;
        useFlipY(b: boolean): void;
        /**
         * @en Renders the glow effect based on the source texture.
         * @param srctexture The source RenderTexture2D to apply the glow effect on.
         * @param width The width of the rendering area.
         * @param height The height of the rendering area.
         * @zh 根据源纹理渲染发光效果。
         * @param srctexture 应用发光效果的源 RenderTexture2D。
         * @param width 渲染区域的宽度。
         * @param height 渲染区域的高度。
         */
        render(srctexture: RenderTexture2D, width: number, height: number): void;
        /**
         * @private
         * @en Gets Y offset value
         * @zh 获取Y偏移值
         */
        get offY(): number;
        /**
         * @private
         * @en Sets Y offset value
         * @zh 设置Y偏移值
         */
        set offY(value: number);
        /**
         * @private
         * @en Gets X offset value
         * @zh 获取X偏移值
         */
        get offX(): number;
        /**
         * @private
         * @en Sets X offset value
         * @zh 设置X偏移值
         */
        set offX(value: number);
        /**
         * @private
         * @en Gets X color value
         * @zh 获取颜色值
         */
        get color(): string;
        /**
         * @private
         * @en Sets X color value
         * @zh 设置颜色值
         */
        set color(value: string);
        /**
         * @private
         * @en Get the color array from the color utility.
         * @zh 从颜色工具获取颜色数组。
         */
        getColor(): any[];
        /**
         * @private
         * @en Gest fuzzy value
         * @zh 获取模糊值
         */
        get blur(): number;
        /**
         * @private
         * @en Sets fuzzy value
         * @zh 设置模糊值
         */
        set blur(value: number);
    }
    /**
     * @en Filter mount
     * @zh 滤镜接口。
     */
    interface IFilter {
        type: number;
    }
    /**
     * @en Enum representing the types of HTML elements.
     * @zh 枚举，表示 HTML 元素的类型。
     */
    enum HtmlElementType {
        /**
         * @en Text element, typically used for raw text content.
         * @zh 文本元素，通常用于纯文本内容。
         */
        Text = 0,
        /**
         * @en Link element, used for creating hyperlinks.
         * @zh 链接元素，用于创建超链接。
         */
        Link = 1,
        /**
         * @en Image element, used for embedding images.
         * @zh 图像元素，用于嵌入图像。
         */
        Image = 2,
        /**
         * @en Input element, used for creating input fields.
         * @zh 输入元素，用于创建输入字段。
         */
        Input = 3,
        /**
         * @en Select element, used for creating dropdown selects.
         * @zh 选择元素，用于创建下拉选择框。
         */
        Select = 4,
        /**
         * @en Object element, used for embedding objects like images, videos, or other media.
         * @zh 对象元素，用于嵌入对象，如图像、视频或其他媒体。
         */
        Object = 5
    }
    /**
     * @en The `HtmlElement` class represents HTML element.
     * @zh `HtmlElement` 类表示 HTML 元素。
     */
    class HtmlElement {
        /**
         * @en The type of the HTML element.
         * @zh HTML 元素的类型。
         */
        type: HtmlElementType;
        /**
         * @en The name of the HTML element.
         * @zh HTML 元素的名称。
         */
        name: string;
        /**
         * @en The text content of the HTML element.
         * @zh HTML 元素的文本内容。
         */
        text: string;
        /**
         * @en The style of the HTML element.
         * @zh HTML 元素的样式。
         */
        style: TextStyle;
        /**
         * @en The object associated with the HTML element.
         * @zh 与 HTML 元素关联的对象。
         */
        obj: IHtmlObject;
        /**
         * @en The space associated with the element, used for layout purposes.
         * @zh 与元素关联的空间，用于布局目的。
         */
        space: number;
        _attrs: Record<string, any>;
        /**
         * @en Creates a new instance of the `HtmlElement` class.
         * @zh 创建 `HtmlElement` 类的新实例。
         */
        constructor();
        /**
         * @en Gets the value of an attribute from the element.
         * @param attrName The name of the attribute to retrieve.
         * @returns The value of the attribute.
         * @zh 从元素中获取属性的值。
         * @param attrName 属性名称。
         * @returns 属性值。
         */
        getAttr(attrName: string): any;
        /**
         * @en Sets an attribute on the element with the given value.
         * @param attrName The name of the attribute to set.
         * @param attrValue The value to set for the attribute.
         * @zh 使用给定的值在元素上设置属性。
         * @param attrName 属性名称。
         * @param attrValue 属性值。
         */
        setAttr(attrName: string, attrValue: any): void;
        /**
         * @en Gets a string attribute value, with an optional default.
         * @param attrName The name of the attribute.
         * @param defValue The default value to use if the attribute is not found or is not a string.
         * @returns The string value of the attribute or the default value.
         * @zh 获取字符串属性值，可设置默认值。
         * @param attrName 属性名称。
         * @param defValue 默认值，如果属性不存在或不是字符串。
         * @returns 属性值或默认值。
         */
        getAttrString(attrName: string, defValue?: string): string;
        /**
         * @en Gets an integer attribute value, with an optional default.
         * @param attrName The name of the attribute.
         * @param defValue The default value to use if the attribute is not found or is not an integer.
         * @returns The integer value of the attribute or the default value.
         * @zh 获取整数属性值，可设置默认值。
         * @param attrName 属性名称。
         * @param defValue 默认值，如果属性不存在或不是整数。
         * @returns 属性值或默认值。
         */
        getAttrInt(attrName: string, defValue?: number): number;
        /**
         * @en Gets a float attribute value, with an optional default.
         * @param attrName The name of the attribute.
         * @param defValue The default value to use if the attribute is not found or is not a float.
         * @returns The float value of the attribute or the default value.
         * @zh 获取浮点属性值，可设置默认值。
         * @param attrName 属性名称。
         * @param defValue 默认值，如果属性不存在或不是浮点数。
         * @returns 属性值或默认值。
         */
        getAttrFloat(attrName: string, defValue?: number): number;
        /**
         * @en Gets a boolean attribute value, with an optional default.
         * @param attrName The name of the attribute.
         * @param defValue The default value to use if the attribute is not found or is not a boolean.
         * @returns The boolean value of the attribute or the default value.
         * @zh 获取布尔属性值，可设置默认值。
         * @param attrName 属性名称。
         * @param defValue 默认值，如果属性不存在或不是布尔值。
         * @returns 属性值或默认值。
         */
        getAttrBool(attrName: string, defValue?: boolean): boolean;
        /**
         * @en Fetches attributes from an external source and assigns them to the element.
         * @zh 从外部源获取属性，并将它们分配给元素。
         */
        fetchAttributes(): void;
        /**
         * @en Resets the properties of the element to their default state, preparing it for reuse from the pool.
         * @zh 将元素的属性重置为默认状态，准备从池中重用。
         */
        reset(): void;
        /**
         * @en A static pool of HtmlElement objects for reuse.
         * @zh HtmlElement 对象的静态池。
         */
        static pool: Array<HtmlElement>;
        /**
         * @en Retrieves an HtmlElement from the pool with a specified type, initializing it if necessary.
         * @zh 从池中检索具有指定类型的 HtmlElement，如有必要则进行初始化。
         */
        static getFromPool(type: HtmlElementType): HtmlElement;
        /**
         * @en Returns an HtmlElement or an array of HtmlElements back to the pool for reuse.
         * @zh 将 HtmlElement 或 HtmlElement 数组返回到池中以供重用。
         */
        static returnToPool(ele: HtmlElement | Array<HtmlElement>): void;
    }
    /**
     * @en The `HtmlImage` class represents an image object within an HTML element.
     * @zh `HtmlImage` 类表示 HTML 元素中的图像对象。
     */
    class HtmlImage implements IHtmlObject {
        /**
         * @en The sprite object representing the image.
         * @zh 表示图像的精灵对象。
         */
        readonly obj: Sprite;
        private _owner;
        private _element;
        private _v;
        /**
         * @en Creates a new HtmlImage object.
         * @zh 创建一个 HtmlImage 对象。
         */
        constructor();
        /**
         * @en The associated HTML element.
         * @zh 关联的 HTML 元素。
         */
        get element(): HtmlElement;
        /**
         * @en The width of the image.
         * @zh 图像的宽度。
         */
        get width(): number;
        /**
         * @en The height of the image.
         * @zh 图像的高度。
         */
        get height(): number;
        /**
         * @en Creates and loads the image with the specified owner text and HTML element.
         * @param owner The owner text object.
         * @param element The HTML element associated with the image.
         * @zh 使用指定的文本所有者和 HTML 元素创建并加载图像。
         * @param owner 文本对象的所有者。
         * @param element 与图像关联的 HTML 元素。
         */
        create(owner: Text, element: HtmlElement): void;
        protected loadTexture(src: string): void;
        /**
         * @en Positions the image at the specified coordinates.
         * @param x The x-coordinate.
         * @param y The y-coordinate.
         * @zh 将图像定位到指定的坐标。
         * @param x x 坐标。
         * @param y y 坐标。
         */
        pos(x: number, y: number): void;
        /**
         * @en Releases resources and removes the image object from its parent container.
         * @zh 释放资源并从父容器中移除图像对象。
         */
        release(): void;
        /**
         * @en Destroys the image object.
         * @zh 销毁图像对象。
         */
        destroy(): void;
    }
    /**
     * @en The `HtmlLink` class represents a clickable link area within an HTML element.
     * @zh `HtmlLink` 类表示 HTML 元素内可点击的链接区域。
     */
    class HtmlLink implements IHtmlObject, IHitArea {
        private _owner;
        private _element;
        private _shape;
        private _rects;
        private _rectCnt;
        /**
         * @en Creates a new instance of the `HtmlLink` class.
         * @zh 创建  HtmlLink 类的新实例
         */
        constructor();
        /**
         * @en The associated HTML element.
         * @zh 关联的 HTML 元素。
         */
        get element(): HtmlElement;
        /**
         * @en The width of the link area.
         * @zh 链接区域的宽度。
         */
        get width(): number;
        /**
         * @en The height of the link area.
         * @zh 链接区域的高度。
         */
        get height(): number;
        /**
         * @en Creates the link with the specified owner text and HTML element.
         * @param owner The owner text object.
         * @param element The HTML element associated with the link.
         * @zh 使用指定的文本所有者和 HTML 元素创建链接。
         * @param owner 所有者文本对象。
         * @param element 与链接关联的 HTML 元素。
         */
        create(owner: Text, element: HtmlElement): void;
        /**
         * @en Resets the link area.
         * @zh 重置链接区域。
         */
        resetArea(): void;
        /**
         * @en Adds a rectangle to the hit area.
         * @param x The x-coordinate of the rectangle.
         * @param y The y-coordinate of the rectangle.
         * @param width The width of the rectangle.
         * @param height The height of the rectangle.
         * @zh 向点击区域添加一个矩形。
         * @param x 矩形的 x 坐标。
         * @param y 矩形的 y 坐标。
         * @param width 矩形的宽度。
         * @param height 矩形的高度。
         */
        addRect(x: number, y: number, width: number, height: number): void;
        /**
         * @en Checks if the specified point is within the hit area.
         * @param x The x-coordinate of the point.
         * @param y The y-coordinate of the point.
         * @returns `true` if the point is within the hit area, otherwise `false`.
         * @zh 检查指定的点是否在点击区域内。
         * @param x 点的 x 坐标。
         * @param y 点的 y 坐标。
         * @returns 如果点在点击区域内，则返回 `true`，否则返回 `false`。
         */
        contains(x: number, y: number): boolean;
        /**
         * @en Positions the link area at the specified coordinates. This method does nothing.
         * @param x The x-coordinate.
         * @param y The y-coordinate.
         * @zh 将链接区域定位到指定的坐标。此方法不执行任何操作。
         * @param x x 坐标。
         * @param y y 坐标。
         */
        pos(x: number, y: number): void;
        /**
         * @en Releases resources and removes the link area from its parent container.
         * @zh 释放资源并从父容器中移除链接区域。
         */
        release(): void;
        /**
         * @en Destroys the link area and its associated sprite.
         * @zh 销毁链接区域及其关联的精灵。
         */
        destroy(): void;
    }
    /**
     * @en The `HtmlParseOptions` class defines a set of options used for parsing HTML content.
     * @zh `HtmlParseOptions` 类定义了一组用于解析 HTML 内容的选项。
     */
    class HtmlParseOptions {
        /**
         * @en Indicates whether links should be displayed with an underline.
         * @zh 指示链接是否应该显示下划线。
         */
        linkUnderline: boolean;
        /**
         * @en The default color for links.
         * @zh 链接的默认颜色。
         */
        linkColor: string;
        /**
         * @en Indicates whether to ignore white spaces in the HTML content.
         * @zh 指示是否忽略 HTML 内容中的空白。
         */
        ignoreWhiteSpace: boolean;
        /**
         * @en The default value for the `linkUnderline` option.
         * @zh `linkUnderline` 选项的默认值。
         */
        static defaultLinkUnderline: boolean;
        /**
         * @en The default value for the `linkColor` option.
         * @zh `linkColor` 选项的默认值。
         */
        static defaultLinkColor: string;
        /**
         * @ignore
         * @en Creates a new instance of the `HtmlParseOptions` class.
         * @zh 创建 HtmlParseOptions 类的新实例。
         */
        constructor();
    }
    /**
     * @en The `HtmlParser` class is responsible for parsing HTML content and converting it into a series of HTML elements with styles.
     * @zh `HtmlParser` 类负责解析 HTML 内容，将其转换为一系列具有样式的 HTML 元素。
     */
    class HtmlParser {
        /**
         * @en The default instance of the HtmlParser class.
         * @zh HtmlParser 类的默认实例。
         */
        static defaultParser: HtmlParser;
        /**
         * @en A mapping of HTML element types to their corresponding classes.
         * @zh 将 HTML 元素类型映射到它们对应的类。
         */
        static classMap: Record<number, new () => IHtmlObject>;
        protected _styleStack: Array<TextStyle>;
        protected _styleStackTop: number;
        protected _style: TextStyle;
        protected _elements: Array<HtmlElement>;
        protected _options: HtmlParseOptions;
        /** @ignore */
        constructor();
        /**
         * @en Parses the given HTML source and populates the output array with HTML elements.
         * @param aSource The HTML source to parse.
         * @param style The default text style to apply.
         * @param out The array to populate with parsed HTML elements.
         * @param options The options for parsing the HTML.
         * @zh 解析给定的 HTML 源代码，并将输出数组填充为 HTML 元素。
         * @param aSource 要解析的 HTML 源代码。
         * @param style 要应用的默认文本样式。
         * @param out 要填充解析后的 HTML 元素的数组。
         * @param options 解析 HTML 的选项。
         */
        parse(aSource: string, style: TextStyle, out: Array<HtmlElement>, options?: HtmlParseOptions): void;
        protected pushStyle(): void;
        protected popStyle(): void;
        protected isNewLine(): boolean;
        protected appendText(text: string): void;
    }
    /**
     * @en The `IHtmlObject` interface defines the structure and behavior of objects that can be embedded within HTML content.
     * @zh `IHtmlObject` 接口定义了可以嵌入在 HTML 内容中的对象的结构和行为。
     */
    interface IHtmlObject {
        /**
         * @en The width of the HTML object.
         * @zh HTML 对象的宽度。
         */
        width: number;
        /**
         * @en The height of the HTML object.
         * @zh HTML 对象的高度。
         */
        height: number;
        /**
         * @en The HTML element associated with this object.
         * @zh 与此对象关联的 HTML 元素。
         */
        element: HtmlElement;
        /**
         * @en Indicates whether the HTML object is currently loading.
         * @zh 表示 HTML 对象当前是否正在加载。
         */
        loading?: boolean;
        /**
         * @en Creates the HTML object with the given owner and element.
         * @param owner The owner of the HTML object.
         * @param element The HTML element to create the object from.
         * @zh 使用给定的所有者和元素创建 HTML 对象。
         * @param owner HTML 对象的所有者。
         * @param element 用于创建对象的 HTML 元素。
         */
        create(owner: Text, element: HtmlElement): void;
        /**
         * @en Positions the HTML object at the specified coordinates.
         * @param x The x-coordinate.
         * @param y The y-coordinate.
         * @zh 将 HTML 对象定位到指定的坐标。
         * @param x x 坐标。
         * @param y y 坐标。
         */
        pos(x: number, y: number): void;
        /**
         * @en Releases resources associated with the HTML object.
         * @zh 释放与 HTML 对象关联的资源。
         */
        release(): void;
        /**
         * @en Destroys the HTML object and frees up all associated resources.
         * @zh 销毁 HTML 对象并释放所有关联的资源。
         */
        destroy(): void;
    }
    /**
     * @en The `IHtmlPageContext` interface represents the context in which HTML content is parsed and rendered, providing methods to create and manage HTML objects.
     * @zh `IHtmlPageContext` 接口表示解析和渲染 HTML 内容的上下文环境，提供创建和管理 HTML 对象的方法。
     */
    interface IHtmlPageContext {
        /**
         * @en Creates an HTML object based on the provided owner and element, which can be embedded within the HTML content.
         * @param owner The owner of the HTML object, typically a text container.
         * @param element The HTML element from which to create the object.
         * @returns An instance of `IHtmlObject` that represents the created HTML object.
         * @zh 基于提供的拥有者和元素创建一个 HTML 对象，该对象可以嵌入在 HTML 内容中。
         * @param owner HTML 对象的拥有者，通常是一个文本容器。
         * @param element 用于创建对象的 HTML 元素。
         * @returns `IHtmlObject` 的一个实例，代表创建的 HTML 对象。
         */
        createObject(owner: Text, element: HtmlElement): IHtmlObject;
        /**
         * @en Frees an HTML object, releasing any resources associated with it. This method is typically called when an object is no longer needed.
         * @param obj The HTML object to be freed.
         * @zh 释放一个 HTML 对象，释放与其关联的所有资源。通常在不再需要对象时调用此方法。
         * @param obj 要释放的 HTML 对象。
         */
        freeObject(obj: IHtmlObject): void;
    }
    interface ITagHandler {
        (tagName: string, end: boolean, attr: string): string;
    }
    /**
     * @en The `UBBParser` class is responsible for parsing UBB formatted text and converting it to HTML.
     * @zh `UBBParser` 类负责解析 UBB 格式的文本，并将其转换为 HTML。
     */
    class UBBParser {
        /**
         * @en The default instance of the UBBParser class.
         * @zh UBBParser 类的默认实例。
         */
        static defaultParser: UBBParser;
        private _text;
        private _readPos;
        protected _handlers: Record<string, ITagHandler>;
        /**
         * @en The default width for image tags.
         * @zh 图像标签的默认宽度。
         */
        defaultImgWidth: number;
        /**
         * @en The default height for image tags.
         * @zh 图像标签的默认高度。
         */
        defaultImgHeight: number;
        /**
         * @en The last color parsed in the text.
         * @zh 文本中解析的最后颜色。
         */
        lastColor: string;
        /**
         * @en The last size parsed in the text.
         * @zh 文本中解析的最后大小。
         */
        lastSize: string;
        /**
         * @ignore
         * @en Creates an instance of the `UBBParser` class.
         * @zh 创建 `UBBParser` 类的实例。
         */
        constructor();
        protected onTag_URL(tagName: string, end: boolean, attr: string): string;
        protected onTag_IMG(tagName: string, end: boolean, attr: string): string;
        protected onTag_B(tagName: string, end: boolean, attr: string): string;
        protected onTag_I(tagName: string, end: boolean, attr: string): string;
        protected onTag_U(tagName: string, end: boolean, attr: string): string;
        protected onTag_Simple(tagName: string, end: boolean, attr: string): string;
        protected onTag_COLOR(tagName: string, end: boolean, attr: string): string;
        protected onTag_FONT(tagName: string, end: boolean, attr: string): string;
        protected onTag_SIZE(tagName: string, end: boolean, attr: string): string;
        protected getTagText(remove?: boolean): string;
        /**
         * @en Parses the UBB formatted text and returns the corresponding HTML string.
         * @param text The UBB formatted text to parse.
         * @param remove Whether to remove UBB tags or convert them to HTML.
         * @returns The resulting HTML string.
         * @zh 解析 UBB 格式的文本，并返回相应的 HTML 字符串。
         * @param text 要解析的 UBB 格式文本。
         * @param remove 是否移除 UBB 标签或将其转换为 HTML。
         * @returns 生成的 HTML 字符串。
         */
        parse(text: string, remove?: boolean): string;
    }
    /**
     * @en The `XML` class represents an XML node with methods to manipulate and parse XML data.
     * @zh `XML` 类表示一个 XML 节点，具有操作和解析 XML 数据的方法。
     */
    class XML {
        /**
         * @en The name of the XML node.
         * @zh XML 节点的名称。
         */
        name: string;
        /**
         * @en The text content of the XML node.
         * @zh XML 节点的文本内容。
         */
        text: string;
        private _attrs;
        private _children;
        /**
         * @ignore
         * @en Creates a new instance of the `XML` class.
         * @param XmlString Optional. The XML source string to parse.
         * @zh 创建 `XML` 类的新实例。
         * @param XmlString 可选。要解析的 XML 源字符串。
         */
        constructor(XmlString?: string);
        /**
         * @en The attributes of the XML node.
         * @zh XML 节点的属性。
         */
        get attributes(): Record<string, string>;
        /**
         * @en Retrieves the value of an attribute as a string. If the attribute is not found, the default value is returned.
         * @param attrName The name of the attribute to retrieve.
         * @param defValue The default value to return if the attribute is not found.
         * @returns The attribute value as a string, or the default value if the attribute is not present.
         * @zh 根据属性名称获取对应的字符串。如果未找到属性，则返回默认值。
         * @param attrName 要检索的属性名称。
         * @param defValue 如果未找到属性，则返回的默认值。
         * @returns 属性的字符串，如果属性不存在，则为默认值。
         */
        getAttrString(attrName: string, defValue?: string): string;
        /**
         * @en Retrieve the attribute value from the XML node's attributes based on the attribute name, convert it to an integer, and return the default value if the attribute is not found.
         * @param attrName The name of the attribute to retrieve.
         * @param defValue The default value to return if the attribute is not found or not a number.
         * @returns The integer value of an XML node attribute, or the default value if the attribute value does not exist.
         * @zh 根据属性名称从 XML 节点的属性中检索属性值，将其转换为整数，如果未找到属性，则返回默认值。
         * @param attrName 要检索的属性名称。
         * @param defValue 如果属性未找到或无法转换为整数，则返回的默认整数值。
         * @returns XML 节点属性的整数值，如果属性值不存在，则为默认值。
         */
        getAttrInt(attrName: string, defValue?: number): number;
        /**
         * @en Retrieve the attribute value from the XML node's attributes based on the attribute name, convert it to a floating-point number, and return the default value if the attribute is not found.
         * @param attrName The name of the attribute to retrieve.
         * @param defValue The default value to return if the attribute is not found.
         * @returns The floating-point value of an XML node attribute, which is the default value if the attribute value does not exist.
         * @zh 根据属性名称从 XML 节点的属性中检索属性值，将其转换为浮点数，如果未找到属性，则返回默认值。
         * @param attrName 要检索的属性名称。
         * @param defValue 如果属性未找到，则返回的默认浮点数。
         * @returns XML 节点属性的浮点数值，如果属性值不存在，则为默认值。
         */
        getAttrFloat(attrName: string, defValue?: number): number;
        /**
         * @en Retrieve the attribute value from the XML node's attributes based on the attribute name, convert it to a floating-point number, and return the default value if the attribute is not found.
         * @param attrName The name of the attribute to retrieve.
         * @param defValue The default value to return if the attribute is not found or not a number.
         * @returns The floating-point value of an XML node attribute, which is the default value if the attribute value does not exist.
         * @zh 根据属性名称从 XML 节点的属性中检索属性值，将其转换为布尔值，如果未找到属性，则返回默认值。
         * @param attrName 要检索的属性名称。
         * @param defValue 如果属性未找到，则返回的默认布尔值。
         * @returns XML 节点属性的布尔值，如果属性值不存在，则为默认值。
         */
        getAttrBool(attrName: string, defValue?: boolean): boolean;
        /**
         * @en Sets an attribute on the XML node to the specified value.
         * @param attrName The name of the attribute to set.
         * @param attrValue The value of the attribute to set.
         * @zh 设置 XML 节点的属性为指定的值。
         * @param attrName 要设置的属性名称。
         * @param attrValue 要设置的属性值。
         */
        setAttribute(attrName: string, attrValue: string): void;
        /**
         * @en Retrieves the first child node with the specified name.
         * @param selector The name of the child node to find.
         * @returns The first child node with the specified name, or null if not found.
         * @zh 检索具有指定名称的第一个子节点。
         * @param selector 要查找的子节点名称。
         * @returns 如果找到具有指定名称的第一个子节点，则返回该节点；如果没有找到，则返回 null。
         */
        getNode(selector: string): XML;
        /**
         * @en Get child elements of the XML node.
         * @param selector Optional. A string to filter child elements by name.
         * @returns An array of XML objects representing the child elements.
         * @zh 获取XML节点的子元素。
         * @param selector 可选。用于按名称筛选子元素的字符串。
         * @returns 表示子元素的XML对象数组。
         */
        elements(selector?: string): Array<XML>;
        /**
         * @en Parses the given XML source string and populates the node and its children according to the XML structure.
         * @param aSource The XML source string to parse.
         * @zh 解析给定的 XML 源字符串，并根据 XML 结构填充节点及其子节点。
         * @param aSource 要解析的 XML 源字符串。
         */
        parse(aSource: string): void;
        /**
         * @en Resets the attributes and child nodes of the XML node.
         * @zh 重置 XML 节点的属性和子节点。
         */
        reset(): void;
    }
    /**
     * @en The tag type of XML.
     * @zh XML 的标签类型
     */
    enum XMLTagType {
        /**
         * @en Represents the start of an XML element.
         * @zh 表示XML元素的开始。
         */
        Start = 0,
        /**
         * @en Represents the end of an XML element.
         * @zh 表示XML元素的结束。
         */
        End = 1,
        /**
         * @en Represents a void XML element (self-closing tag).
         * @zh 表示空的XML元素（自闭合标签）。
         */
        Void = 2,
        /**
         * @en Represents a CDATA section in XML.
         * @zh 表示XML中的CDATA部分。
         */
        CDATA = 3,
        /**
         * @en Represents an XML comment.
         * @zh 表示XML注释。
         */
        Comment = 4,
        /**
         * @en Represents an XML processing instruction.
         * @zh 表示XML处理指令。
         */
        Instruction = 5
    }
    /**
     * @en XMLIterator class for parsing XML strings.
     * @zh XML迭代器类，用于解析XML字符串。
     */
    class XMLIterator {
        /**
         * @en The name of the current XML tag.
         * @zh 当前XML标签的名称。
         */
        static tagName: string;
        /**
         * @en The type of the current XML tag.
         * @zh 当前XML标签的类型。
         */
        static tagType: XMLTagType;
        /**
         * @en The name of the last processed XML tag.
         * @zh 上一个处理的XML标签的名称。
         */
        static lastTagName: string;
        /**
         * @en The source XML string being parsed.
         * @zh 正在解析的源XML字符串。
         */
        static source: string;
        /**
         * @en The length of the source XML string.
         * @zh 源XML字符串的长度。
         */
        static sourceLen: number;
        /**
         * @en The current parsing position in the source string.
         * @zh 源字符串中的当前解析位置。
         */
        static parsePos: number;
        /**
         * @en The starting position of the current tag in the source string.
         * @zh 当前标签在源字符串中的起始位置。
         */
        static tagPos: number;
        /**
         * @en The length of the current tag.
         * @zh 当前标签的长度。
         */
        static tagLength: number;
        /**
         * @en The ending position of the last processed tag.
         * @zh 上一个处理的标签的结束位置。
         */
        static lastTagEnd: number;
        /**
         * @en Indicates whether attributes have been parsed.
         * @zh 指示是否已解析属性。
         */
        static attrParsed: boolean;
        /**
         * @en Indicates whether tag names should be converted to lowercase.
         * @zh 指示是否应将标签名称转换为小写。
         */
        static lowerCaseName: boolean;
        private static _attrs;
        /**
         * @en Initialize the XMLIterator with a source string.
         * @param source The XML string to parse.
         * @param lowerCaseName Optional. Whether to convert tag names to lowercase.
         * @zh 使用源字符串初始化XMLIterator。
         * @param source 要解析的XML字符串。
         * @param lowerCaseName 可选。是否将标签名称转换为小写。
         */
        static begin(source: string, lowerCaseName?: boolean): void;
        /**
         * @en Parses through the XML source to find the next tag and updates the iterator's state accordingly.
         * @returns Returns true if a new tag is found; otherwise, false if the end of the source is reached.
         * @zh 解析XML源，查找下一个标签并相应地更新迭代器的状态。
         * @returns 如果找到新标签则返回true；如果到达源的末尾则返回false。
         */
        static nextTag(): boolean;
        /**
         * @en Get the source of the current XML tag.
         * @returns The source of the current XML tag.
         * @zh 获取当前XML标签的源代码。
         * @returns 当前XML标签的源代码。
         */
        static getTagSource(): string;
        /**
         * @en Gets the raw text between the last tag end and the current tag position.
         * @param trim Whether to trim the whitespace characters at the beginning and end of the text.
         * @returns The raw text, trimmed if specified.
         * @zh 获取上一个标签结束和当前标签位置之间的原始文本。
         * @param trim 是否去除文本首尾的空白字符。
         * @returns 返回的原始文本，如果指定则去除首尾空白。
         */
        static getRawText(trim?: boolean): string;
        /**
         * @en Get the decoded text between XML tags, optionally trimmed.
         * @param trim Whether to trim the whitespace at the beginning and end of the text. Default is false.
         * @returns The decoded text between XML tags.
         * @zh 获取XML标签之间的解码文本，可选择是否去除首尾空白字符。
         * @param trim 是否去除文本开头和结尾的空白字符。默认为false。
         * @returns XML标签之间的解码文本。
         */
        static getText(trim?: boolean): string;
        /**
         * @en The parsed attributes of the current tag.
         * @zh 当前标签解析后的属性。
         */
        static get attributes(): any;
        /**
         * @en Gets the value of the specified attribute from the current tag.
         * @param attrName The name of the attribute to get.
         * @returns The value of the attribute.
         * @zh 从当前标签获取指定属性的值。
         * @param attrName 要获取的属性名称。
         * @returns 返回属性的值。
         */
        static getAttribute(attrName: string): string;
        /**
         * @en Parses the attributes from the source text.
         * @param attrs The object to store the parsed attributes.
         * @zh 从源文本解析属性。
         * @param attrs 存储解析后属性的对象。
         */
        static parseAttributes(attrs: any): void;
    }
    /**
     * @en Utility class for XML operations.
     * @zh XML操作的工具类。
     */
    class XMLUtils {
        /**
         * @en Decodes a string that contains HTML entities into a displayable form.
         * @param aSource The string to decode.
         * @returns The decoded string.
         * @zh 对包含HTML实体的字符串进行解码，转换为可显示的格式。
         * @param aSource 需要解码的字符串。
         * @returns 返回解码后的字符串。
         */
        static decodeString(aSource: string): string;
        /**
         * @en Encodes special characters in a string to their corresponding HTML entities.
         * @param str The string that contains special characters to be encoded.
         * @returns The encoded string with HTML entities.
         * @zh 将字符串中的特殊字符转换为对应的HTML实体。
         * @param str 包含待编码特殊字符的字符串。
         * @returns 包含HTML实体的编码后的字符串。
         */
        static encodeString(str: string): string;
        /**
         * @en Retrieves an attribute value from an object, and converts it to a string. If the attribute or object does not exist, the default value is used.
         * @param attrs The object that contains the attribute.
         * @param attrName The name of the attribute to retrieve.
         * @param defValue The default value if the attribute is not found or is null.
         * @returns The retrieved attribute value, or the default if the attribute is not present.
         * @zh 从一个对象中检索一个属性值，并将此属性转化为字符串，如果属性不存在或对象不存在，则使用默认值。
         * @param attrs 包含待检索属性的对象。
         * @param attrName 需要检索的属性名称。
         * @param defValue 如果属性不存在或为null时的默认值。
         * @returns 检索到的属性值的字符串，如果属性不存在或对象不存在，则返回默认值。
         */
        static getString(attrs: any, attrName: string, defValue?: string): string;
        /**
         * @en Retrieve the attribute values in the object based on the attribute name and convert them to integers. If the attribute does not exist, use the default value.
         * @param attrs The object containing the attribute.
         * @param attrName The name of the attribute.
         * @param defValue The default value if the attribute is not found.
         * @returns If the attribute is a valid integer, return the parsed integer value; otherwise, return the default value.
         * @zh 根据属性名检索对象中的属性值，并将其转换为整数，如果属性不存在，则使用默认值。
         * @param attrs 包含属性的对象。
         * @param attrName 属性的名称。
         * @param defValue 如果属性未找到，则使用的默认值。
         * @returns 如果属性是有效的整数，则返回解析后的整数值，否则返回默认值。
         */
        static getInt(attrs: any, attrName: string, defValue?: number): number;
        /**
         * @en Retrieve the attribute value from the object based on the attribute name and convert it to a floating-point number. If the attribute does not exist, use the default value.
         * @param attrs The object containing the attribute.
         * @param attrName The name of the attribute.
         * @param defValue The default value if the attribute is not found.
         * @returns If the attribute is a valid floating-point number, return the parsed floating-point number; otherwise, return the default value.
         * @zh 根据属性名检索对象中的属性值，并将其转换为浮点数，如果属性不存在，则使用默认值。
         * @param attrs 包含属性的对象。
         * @param attrName 属性的名称。
         * @param defValue 如果属性未找到，则使用的默认值。
         * @returns 如果属性是有效的浮点数，则返回解析后的浮点数，否则返回默认值。
         */
        static getFloat(attrs: any, attrName: string, defValue?: number): number;
        /**
         * @en Retrieve the attribute values in the object based on the attribute name and convert them to Boolean values. If the attribute does not exist, use the default value.
         * @param attrs The object containing the attribute.
         * @param attrName The name of the attribute.
         * @param defValue The default value if the attribute is not found.
         * @returns If the attribute is a valid Boolean values, return the parsed Boolean values; otherwise, return the default value.
         * @zh 根据属性名检索对象中的属性值，并将其转换为布尔值，如果属性不存在，则使用默认值。
         * @param attrs 包含属性的对象。
         * @param attrName 属性的名称。
         * @param defValue 如果属性未找到，则使用的默认值。
         * @returns 如果属性是有效的布尔值，则返回解析后的布尔值，否则返回默认值。
         */
        static getBool(attrs: any, attrName: string, defValue?: boolean): boolean;
    }
    /**
     * @private
     * @en CommandEncoder Shader variable collection
     * @zh CommandEncoder Shader变量集合
     */
    class CommandEncoder {
        /**
         * @en Constructor method, initialize CommandEncoder object
         * @zh 构造方法，初始化CommandEncoder对象
         */
        constructor();
    }
    /**
     * @en Package GL commands
     * @zh 封装GL命令
     */
    class LayaGL {
        static textureContext: ITextureContext;
        static renderEngine: IRenderEngine;
        static renderOBJCreate: IRenderEngineFactory;
        static render2DRenderPassFactory: I2DRenderPassFactory;
        static renderDeviceFactory: IRenderDeviceFactory;
        static unitRenderModuleDataFactory: IUnitRenderModuleDataFactory;
    }
    /**
     * @en QuickTestTool class for rendering and performance testing.
     * @zh 用于渲染和性能测试的 QuickTestTool 类。
     */
    class QuickTestTool {
        private static showedDic;
        private static _rendertypeToStrDic;
        private static _typeToNameDic;
        /**
         * @en Get the name of a specific render command type.
         * @param type The render command type.
         * @returns The name of the render command type.
         * @zh 获取特定渲染命令类型的名称。
         * @param type 渲染命令类型。
         * @returns 渲染命令类型的名称。
         */
        static getMCDName(type: number): string;
        /**
         * @en Show render type information.
         * @param type The render type.
         * @param force Whether to force display even if it has been shown before.
         * @zh 显示渲染类型信息。
         * @param type 渲染类型。
         * @param force 是否强制显示，即使之前已经显示过。
         */
        static showRenderTypeInfo(type: any, force?: boolean): void;
        static __init__(): void;
        _renderType: number;
        _repaint: number;
        _x: number;
        _y: number;
        constructor();
        /**
         * @en Update and render the display object. Called by the system.
         * @param context The rendering context reference.
         * @param x The X-axis coordinate.
         * @param y The Y-axis coordinate.
         * @zh 更新、呈现显示对象。由系统调用。
         * @param context 渲染的上下文引用。
         * @param x X轴坐标。
         * @param y Y轴坐标。
         */
        render(context: Context, x: number, y: number): void;
        private static _PreStageRender;
        private static _countDic;
        private static _countStart;
        private static _i;
        private static _countEnd;
        /**
         * @en Show count information for render types.
         * @zh 显示渲染类型的计数信息。
         */
        static showCountInfo(): void;
        /**
         * @en Enable quick test mode.
         * @zh 启用快速测试模式。
         */
        static enableQuickTest(): void;
    }
    /**
     * @private 场景辅助类
     */
    class LegacyUIParser {
        /**@private */
        private static _funMap;
        /**@private */
        private static _parseWatchData;
        /**@private */
        private static _parseKeyWord;
        static parse(data: any, options: any): Sprite;
        /**
         * @private 根据字符串，返回函数表达式
         */
        static getBindFun(value: string): Function;
        /**
         * @private
         * 通过视图数据创建视图。
         * @param uiView 视图数据信息。
         */
        static createByData(root: Sprite, uiView: any): Sprite;
        static createInitTool(): InitTool;
        /**
         * 根据UI数据实例化组件。
         * @param uiView UI数据。
         * @param comp 组件本体，如果为空，会新创建一个。
         * @param view 组件所在的视图实例，用来注册var全局变量，如果值为空则不注册。
         * @return 一个 Component 对象。
         */
        static createComp(uiView: any, comp?: Sprite, view?: Sprite, dataMap?: any[], initTool?: InitTool): any;
        /**
         * @private
         * 设置组件的属性值。
         * @param comp 组件实例。
         * @param prop 属性名称。
         * @param value 属性值。
         * @param view 组件所在的视图实例，用来注册var全局变量，如果值为空则不注册。
         */
        private static setCompValue;
        /**
         * @private
         * 通过组建UI数据，获取组件实例。
         * @param json UI数据。
         * @return Component 对象。
         */
        static getCompInstance(json: any): any;
        static collectResourceLinks(uiView: any): string[];
        /**
         * 根据指定的 json 数据创建节点对象。
         * 比如:
         * {
         * 	"type":"Sprite",
         * 	"props":{
         * 		"x":100,
         * 		"y":50,
         * 		"name":"item1",
         * 		"scale":[2,2]
         * 	},
         * 	"customProps":{
         * 		"x":100,
         * 		"y":50,
         * 		"name":"item1",
         * 		"scale":[2,2]
         * 	},
         * 	"child":[
         * 		{
         * 			"type":"Text",
         * 			"props":{
         * 				"text":"this is a test",
         * 				"var":"label",
         * 				"rumtime":""
         * 			}
         * 		}
         * 	]
         * }
         * @param	json json字符串或者Object对象。
         * @param	node node节点，如果为空，则新创建一个。
         * @param	root 根节点，用来设置var定义。
         * @return	生成的节点。
         */
        static createByJson(json: any, node?: any, root?: Node, customHandler?: Handler, instanceHandler?: Handler): any;
        /**
         * @private
         */
        private static _getGraphicsFromSprite;
        /**
         * @private
         */
        private static _getTransformData;
        /**
         * @private
         */
        private static _addGraphicToGraphics;
        /**
         * @private
         */
        private static _adptLineData;
        /**
         * @private
         */
        private static _adptTextureData;
        /**
         * @private
         */
        private static _adptLinesData;
        /**
         * @private
         */
        private static _getParams;
        /**@private */
        private static DrawTypeDic;
        /**@private */
        private static _temParam;
        /**@private */
        private static _tM;
        /**@private */
        private static _alpha;
        /**
         * @private
         */
        private static _getObjVar;
    }
    class InitTool {
        /**@private */
        private _nodeRefList;
        /**@private */
        private _initList;
        reset(): void;
        recover(): void;
        static create(): InitTool;
        /**@private */
        addNodeRef(node: any, prop: string, referStr: string): void;
        /**@private */
        setNodeRef(): void;
        /**@private */
        getReferData(referStr: string): any;
        /**@private */
        addInitItem(item: any): void;
        /**@private */
        doInits(): void;
        /**@private */
        finish(): void;
    }
    class HierarchyLoader implements IResourceLoader {
        static v3: IHierarchyParserAPI;
        static v2: IHierarchyParserAPI;
        static legacySceneOrPrefab: IHierarchyParserAPI & {
            createByData(root: Sprite, uiView: any): Sprite;
            createComp(uiView: any, comp: Sprite, view: Sprite, dataMap: any[], initTool?: any): any;
        };
        load(task: ILoadTask): Promise<Prefab>;
        protected _load(api: IHierarchyParserAPI, task: ILoadTask, data: any, version: number, fromDCC: boolean): Promise<Prefab>;
    }
    class HierarchyParser {
        static parse(data: any, options?: Record<string, any>, errors?: Array<any>): Array<Node>;
        static collectResourceLinks(data: any, basePath: string): (string | ILoadURL)[];
    }
    class MaterialLoader implements IResourceLoader {
        load(task: ILoadTask): Promise<any>;
        private load2;
        private move;
    }
    class MaterialParser {
        static parse(data: any): Material;
        static collectLinks(data: any, basePath: string): ILoadURL[];
        /**
         * @deprecated
         * @inheritDoc
         */
        static parseLegacy(data: any): Material;
        /**
            * @deprecated
            * 兼容Blend数据
            */
        private static _getRenderStateParams;
    }
    class NullLoader implements IResourceLoader {
        load(task: ILoadTask): Promise<any>;
    }
    const TypedArrayClasses: Record<string, any>;
    interface IDecodeObjOptions {
        outErrors?: Array<string>;
        getNodeByRef?: (id: string | string[]) => Node;
        getNodeData?: (node: Node) => any;
    }
    class SerializeUtil {
        static isDeserializing: boolean;
        static decodeObj(data: any, obj?: any, options?: IDecodeObjOptions): any;
        private static _decodeObj;
        static getLoadTypeByEngineType(type: string): string;
        static bakeOverrideData(overrideData: any): Record<string, any[]>;
        static applyOverrideData(nodeData: any, overrideDataMap: Record<string, Array<any>>): any;
    }
    class ShaderParser {
        static parse(data: string, basePath?: string): Shader3D;
        static compileToTree(sliceFlag: string[], data: string, sliceIndex: number): string[];
        static getMapKey(value: string): string;
        /**
         * get Shader Data
         */
        static getShaderBlock(source: string): IShaderObjStructor;
        /**
         * get CG data for map
         * @param source
         * @returns
         */
        static getCGBlock(source: string): {
            [key: string]: string;
        };
        static bindCG(shaderObj: IShaderObjStructor, cgmap: {
            [key: string]: string;
        }): void;
        /**
         * trans string to ShaderDataType
         * @param value
         * @returns
         */
        static getShaderDataType(value: string): ShaderDataType;
        /**
         * set ShaderData Value
         * @param type
         * @param data
         * @returns
         */
        static getDefaultData(type: ShaderDataType, data: any): any;
    }
    class Texture2DLoader implements IResourceLoader {
        constructor();
        load(task: ILoadTask): Promise<BaseTexture>;
        protected load2(task: ILoadTask, meta: any): Promise<BaseTexture>;
        protected move(obsoluteInst: BaseTexture, tex: BaseTexture): BaseTexture;
    }
    class RenderTextureLoader implements IResourceLoader {
        load(task: ILoadTask): Promise<RenderTexture>;
    }
    class VideoTextureLoader implements IResourceLoader {
        load(task: ILoadTask): Promise<VideoTexture>;
    }
    class TextureLoader implements IResourceLoader {
        wrapTex2D(task: ILoadTask, tex2D: Texture2D): Texture;
        load(task: ILoadTask): Promise<Texture>;
    }
    /**
     * @en Each layer of the map is rendered in chunks. This class represents the chunk data of the map.
     * @zh 地图的每层都会分块渲染处理，本类就是地图的块数据。
     */
    class GridSprite extends Sprite {
        /**
         * @en The coordinate relative to the X-axis of the map.
         * @zh 相对于地图X轴的坐标。
         */
        relativeX: number;
        /**
         * @en The coordinate relative to the Y-axis of the map.
         * @zh 相对于地图Y轴的坐标。
         */
        relativeY: number;
        /**
         * @en Indicates whether the object is an independent entity within the object layer.
         * @zh 是否用于对象层的独立物件。
         */
        isAloneObject: boolean;
        /**
         * @en Indicates whether there is an animation in the current GRID.
         * @zh 当前GRID中是否有动画。
         */
        isHaveAnimation: boolean;
        /**
         * @en The array containing animations within the current GRID.
         * @zh 当前GRID包含的动画数组。
         */
        aniSpriteArray: any[];
        /**
         * @en The number of TILEs (including animations) included in the current GRID.
         * @zh 当前GRID包含多少个TILE(包含动画)。
         */
        drawImageNum: number;
        /**
         * @en Reference to the current map object.
         * @zh 当前地图对象的引用。
         */
        private _map;
        /**
         * @en Initialize the data with necessary parameters for clipping and confirming the type of this object.
         * @param map The reference to the map, used for some clipping calculations.
         * @param objectKey If true, indicates that the current GridSprite is an active object that can be controlled; if false, it is a block of the map layer.
         * @zh 传入必要的参数，用于裁剪，跟确认此对象类型。
         * @param map 把地图的引用传进来，参与一些裁剪计算。
         * @param objectKey true:表示当前GridSprite是个活动对象，可以控制，false:地图层的组成块。
         */
        initData(map: TiledMap, objectKey?: boolean): void;
        /**
         * @en Bind an animation object to the current GridSprite.
         * @param sprite The display object of the animation.
         * @zh 把一个动画对象绑定到当前GridSprite。
         * @param sprite 动画的显示对象。
         */
        addAniSprite(sprite: TileAniSprite): void;
        /**
         * @en Display the current GridSprite and show all animations on it.
         * @zh 显示当前GridSprite，并把上面的动画全部显示。
         */
        show(): void;
        /**
         * @en Hide the current GridSprite and remove all animations bound to it.
         * @zh 隐藏当前GridSprite，并把上面绑定的动画全部移除。
         */
        hide(): void;
        /**
         * @en Refresh the position coordinates. Call this function manually to refresh when you control the movement of a GridSprite.
         * @zh 当我们自己控制一个GridSprite移动时，需要调用此函数，手动刷新坐标。
         */
        updatePos(): void;
        /**
         * @en Reset all properties of the current object.
         * @zh 重置当前对象的所有属性。
         */
        clearAll(): void;
    }
    /**
     * @en The `MapLayer` class represents layer within a map that supports multi-layer rendering, such as terrain, vegetation, and building layers. This class is a hierarchical class
     * @zh `MapLayer` 类代表地图中的层级，支持多层渲染，例如地表层、植被层、建筑层等。本类就是层级类。
     */
    class MapLayer extends Sprite {
        private _map;
        private _tileWidthHalf;
        private _tileHeightHalf;
        private _mapWidthHalf;
        private _mapHeightHalf;
        private _objDic;
        private _dataDic;
        private _tempMapPos;
        private _properties;
        /**
         * @en The target layer that this layer is merged with.
         * @zh 被合并到的目标层。
         */
        tarLayer: MapLayer;
        /**
         * @en The name of the current layer.
         * @zh 当前层的名称。
         */
        layerName: string;
        /**
         * @en Parse the LAYER data and initialize some data.
         * @param layerData Reference to the layer data within the map data.
         * @param map Reference to the map.
         * @zh 解析LAYER数据，以及初始化一些数据。
         * @param layerData 地图数据中，layer数据的引用。
         * @param map 地图的引用。
         */
        init(layerData: any, map: TiledMap): void;
        /******************************************对外接口*********************************************/
        /**
         * @en Retrieve a control object by name; returns null if not found.
         * @param objName The name of the object to retrieve.
         * @zh 通过名字获取控制对象，如果找不到返回null。
         * @param objName 所要获取对象的名字。。
         */
        getObjectByName(objName: string): GridSprite;
        /**
         * @en Retrieve data by name; returns null if not found.
         * @param objName The name of the object whose data is to be retrieved.
         * @zh 通过名字获取数据，如果找不到返回null。
         * @param objName 所要获取数据的对象名。
         */
        getObjectDataByName(objName: string): any;
        /**
         * @en Get the custom properties of the map layer.
         * @param name The property name.
         * @zh 获取地图层的自定义属性。
         * @param name 属性名。
         */
        getLayerProperties(name: string): any;
        /**
         * @en Get the data of the specified tile.
         * @param tileX The X coordinate of the tile.
         * @param tileY The Y coordinate of the tile.
         * @returns The data of the tile or 0 if out of bounds.
         * @zh 获取指定格子的数据。
         * @param tileX 格子坐标X
         * @param tileY 格子坐标Y
         * @returns 格子数据，如果越界，返回0
         */
        getTileData(tileX: number, tileY: number): number;
        /**
         * @en Convert map coordinates to screen coordinates.
         * @param tileX The X coordinate on the map grid.
         * @param tileY The Y coordinate on the map grid.
         * @param screenPos The Point object to store the calculated screen coordinates.
         * @zh 通过地图坐标得到屏幕坐标。
         * @param	tileX 格子坐标X
         * @param	tileY 格子坐标Y
         * @param	screenPos 把计算好的屏幕坐标数据，放到此对象中
         */
        getScreenPositionByTilePos(tileX: number, tileY: number, screenPos?: Point): void;
        /**
         * @en Retrieve the data of the tile selected by screen coordinates.
         * @param screenX The x-coordinate on the screen.
         * @param screenY The y-coordinate on the screen.
         * @zh 通过屏幕坐标来获取选中格子的数据。
         * @param screenX 屏幕坐标x
         * @param screenY 屏幕坐标y
         */
        getTileDataByScreenPos(screenX: number, screenY: number): number;
        /**
         * @en Get the index of the tile selected by screen coordinates.
         * @param screenX The x-coordinate on the screen.
         * @param screenY The y-coordinate on the screen.
         * @param result The Point object to store the calculated tile coordinates.
         * @zh 通过屏幕坐标来获取选中格子的索引。
         * @param screenX 屏幕坐标x
         * @param screenY 屏幕坐标y
         * @param result 计算好的格子坐标，放到此对象中
         */
        getTilePositionByScreenPos(screenX: number, screenY: number, result?: Point): boolean;
        /***********************************************************************************************/
        /**
         * @en Retrieve a GridSprite based on grid indices.
         * @param gridX The X-axis index of the current Grid.
         * @param gridY The Y-axis index of the current Grid.
         * @returns A GridSprite object.
         * @zh 根据网格的X轴和Y轴索引获取一个GridSprite对象。
         * @param gridX 当前网格的X轴索引
         * @param gridY 当前网格的Y轴索引
         * @returns  一个GridSprite对象
         */
        getDrawSprite(gridX: number, gridY: number): GridSprite;
        /**
         * @en Update the coordinates of the blocks in this layer. The purpose of manual refresh is to keep the width and height of the hierarchy to a minimum and accelerate rendering.
         * @zh 更新此层中块的坐标。手动刷新的目的是，保持层级的宽和高保持最小，加快渲染。
         */
        updateGridPos(): void;
        /**
         * @private
         * @en Draw a tile onto a specified display object.
         * @param gridSprite The target display object to draw on.
         * @param tileX The X-coordinate of the tile.
         * @param tileY The Y-coordinate of the tile.
         * @returns A boolean indicating whether the tile was successfully drawn.
         * @zh 把tile画到指定的显示对象上。
         * @param gridSprite 要绘制的目标显示对象
         * @param tileX 格子的X轴坐标
         * @param tileY 格子的Y轴坐标
         * @returns 一个布尔值，表示是否成功绘制了tile
         */
        drawTileTexture(gridSprite: GridSprite, tileX: number, tileY: number): boolean;
        /**
         * @private
         * @en Clear all properties and references of the current object to free up resources.
         * @zh 清理当前对象，释放资源。
         */
        clearAll(): void;
    }
    /**
     * @en The `TileAniSprite` class represents an animation display object within a `TiledMap`. An animation set (represented by `TileTexSet`) can be associated with multiple animation display objects (`TileAniSprite`).
     * @zh `TileAniSprite` 类是 `TiledMap` 的动画显示对象。一个动画集合（由 `TileTexSet` 表示）可以绑定多个动画显示对象（`TileAniSprite`）。
     */
    class TileAniSprite extends Sprite {
        /**
         * @en Reference to the animation set.
         * @zh 动画的引用。
         */
        private _tileTextureSet;
        /**
         * @en The unique name of the current animation display object.
         * @zh 当前动画显示对象的唯一名称。
         */
        private _aniName;
        /**
         * @en Set the name of the current display object and which animation set it belongs to.
         * @param aniName The unique name of the current animation display object.
         * @param tileTextureSet The animation set that the current display object belongs to.
         * @zh 确定当前显示对象的名称以及属于哪个动画。
         * @param	aniName	当前动画显示对象的名字，名字唯一
         * @param	tileTextureSet 当前显示对象属于哪个动画（一个动画，可以绑定多个同类显示对象）
         */
        setTileTextureSet(aniName: string, tileTextureSet: TileTexSet): void;
        /**
         * @en Add the current animation to the corresponding animation refresh list.
         * @zh 把当前动画加入到对应的动画刷新列表中。
         */
        show(): void;
        /**
         * @en Remove the current animation from the corresponding animation refresh list.
         * @zh 把当前动画从对应的动画刷新列表中移除。
         */
        hide(): void;
        /**
         * @en Clear all properties and references of the current object to free up resources.
         * @zh 清理当前对象的所有属性和引用，释放资源。
         */
        clearAll(): void;
    }
    /**
     * @en The `TiledMap` class is the core of the entire map system.
     * - The map is divided into layers (e.g., terrain layer, vegetation layer, building layer), and each layer is further divided into grid sprites for display object management, showing only the areas within the viewport. Each grid sprite contains an N*N grid of tiles, which can be either animated tiles or image tiles.
     * @zh `TiledMap` 类是整个地图系统的核心。
     * - 地图以层级划分（例如：地表层、植被层、建筑层），
     * - 每层进一步划分为网格精灵来管理显示对象，只显示视口区域内的部分。
     * - 每个网格精灵包含 N*N 个格子，格子类型分为动画格子和图片格子两种。
     */
    class TiledMap {
        /**
         * @en Orthogonal map.
         * @zh 四边形地图。
         */
        static ORIENTATION_ORTHOGONAL: string;
        /**
         * @en Diamond map.
         * @zh 菱形地图。
         */
        static ORIENTATION_ISOMETRIC: string;
        /**
         * @en 45 degree interleaved map.
         * @zh 45度交错地图。
         */
        static ORIENTATION_STAGGERED: string;
        /**
         * @en Hexagonal map.
         * @zh 六边形地图。
         */
        static ORIENTATION_HEXAGONAL: string;
        /**
         * @en The map grid is rendered starting from the top left corner.
         * @zh 地图格子从左上角开始渲染。
         */
        static RENDERORDER_RIGHTDOWN: string;
        /**
         * @en The map grid is rendered starting from the bottom left corner.
         * @zh 地图格子从左下角开始渲染。
         */
        static RENDERORDER_RIGHTUP: string;
        /**
         * @en The map grid is rendered starting from the top right corner.
         * @zh 地图格子从右上角开始渲染。
         */
        static RENDERORDER_LEFTDOWN: string;
        /**
         * @en The map grid is rendered starting from the bottom right corner.
         * @zh 地图格子从右下角开始渲染。
         */
        static RENDERORDER_LEFTUP: string;
        /**
         * @en The internal JSON data used by the map.
         * @zh 地图使用的内部JSON数据。
         */
        private _jsonData;
        /**
         * @en An array to store all the sub-texture data used in the map.
         * @zh 存放地图中用到的所有子纹理数据的数组。
         */
        private _tileTexSetArr;
        /**
         * @en The main texture data, primarily used when releasing texture resources.
         * @zh 主纹理数据，主要在释放纹理资源时使用。
         */
        private _texArray;
        private _x;
        private _y;
        private _width;
        private _height;
        private _mapW;
        private _mapH;
        private _mapTileW;
        private _mapTileH;
        private _rect;
        private _paddingRect;
        private _mapSprite;
        private _layerArray;
        private _renderLayerArray;
        private _gridArray;
        private _showGridKey;
        private _totalGridNum;
        private _gridW;
        private _gridH;
        private _gridWidth;
        private _gridHeight;
        private _tileSetArray;
        private _currTileSet;
        private _completeHandler;
        private _mapRect;
        private _mapLastRect;
        private _index;
        private _animationDic;
        private _properties;
        private _tileProperties;
        private _tileProperties2;
        private _orientation;
        private _renderOrder;
        private _colorArray;
        private _scale;
        private _pivotScaleX;
        private _pivotScaleY;
        private _centerX;
        private _centerY;
        private _viewPortWidth;
        private _viewPortHeight;
        private _enableLinear;
        private _resPath;
        private _pathArray;
        private _limitRange;
        /**
         * @en Whether to automatically cache tiles that do not have animations.
         * @zh 是否自动缓存没有动画的地块。
         */
        autoCache: boolean;
        /**
         * @en The type of automatic caching. For larger maps, "normal" is recommended.
         * @zh 自动缓存类型，地图较大时建议使用 "normal"。
         */
        autoCacheType: string;
        /**
         * @en Whether to enable layer merging. When layer merging is enabled, you can add a "layer" property in the layer attributes. At runtime, layers with the same "layer" attribute will be merged to improve performance.
         * @zh 是否合并图层。开启合并图层时，图层属性内可添加 "layer" 属性，运行时将会将相邻的 "layer" 属性相同的图层进行合并以提高性能。
         */
        enableMergeLayer: boolean;
        /**
         * @en Whether to remove covered tiles. Tiles can have a "type" property; a "type" other than 0 indicates opacity. Tiles that are covered by opaque tiles will be culled to improve performance.
         * @zh 是否移除被覆盖的格子。地块可添加 "type" 属性，"type" 不为 0 时表示不透明，被不透明地块遮挡的地块将会被剔除以提高性能。
         */
        removeCoveredTile: boolean;
        /**
         * @en Whether to display the number of textures shown in large grids.
         * @zh 是否在大格子里显示显示的贴图数量。
         */
        showGridTextureCount: boolean;
        /**
         * @en Whether to adjust tile edges to eliminate gaps caused by scaling.
         * @zh 是否调整地块边缘消除缩放导致的缝隙。
         */
        antiCrack: boolean;
        /**
         * @en Whether to cache all large grids after initialization is complete.
         * @zh 是否在加载完成之后 cache 所有大格子。
         */
        cacheAllAfterInit: boolean;
        /** @ignore */
        constructor();
        /**
         * @en Create a map with the specified parameters.
         * @param mapName The name of the JSON file.
         * @param viewRect The viewport area.
         * @param completeHandler The callback function when the map is created.
         * @param viewRectPadding The expanded viewport area to prevent exposure when the viewport moves.
         * @param gridSize The size of the grid.
         * @param enableLinear Whether to enable linear sampling to improve texture quality.
         * @param limitRange Whether to restrict the map to the display area.
         * @zh 使用指定参数创建地图。
         * @param	mapName 		JSON文件名字
         * @param	viewRect 		视口区域
         * @param	completeHandler 地图创建完成的回调函数
         * @param	viewRectPadding 视口扩充区域，把视口区域上、下、左、右扩充一下，防止视口移动时的穿帮
         * @param	gridSize 		grid大小
         * @param	enableLinear 	是否开启线性取样（为false时，可以解决地图黑线的问题，但画质会锐化）
         * @param	limitRange		把地图限制在显示区域
         */
        createMap(mapName: string, viewRect: Rectangle, completeHandler: Handler, viewRectPadding?: Rectangle, gridSize?: Point, enableLinear?: boolean, limitRange?: boolean): void;
        /**
         * @en Parse the texture data inside the JSON file after successful reading, and start loading.
         * @param tJsonData The JSON data.
         * @zh JSON文件读取成功后，解析里面的纹理数据，进行加载。
         * @param	tJsonData JSON数据
         */
        private onJsonComplete;
        /**
         * @en Merge resource paths.
         * @param resPath The base resource path.
         * @param relativePath The relative path to merge with the base path.
         * @returns The resolved path.
         * @zh 合并路径。
         * @param	resPath 基础资源路径
         * @param	relativePath 相对路径
         * @return 解析后的路径
         */
        private mergePath;
        private _texutreStartDic;
        /**
         * @en Handle the completion of texture loading. If all textures are loaded, begin initializing the map.
         * @param tTexture The loaded texture.
         * @zh 纹理加载完成的处理。如果所有纹理都加载完成，开始初始化地图。
         * @param	tTexture 纹理数据
         */
        private onTextureComplete;
        private adptTexture;
        /**
         * @en Initialize map
         * @zh 初始化地图
         */
        private initMap;
        private addTileProperties;
        /**
         * @en Retrieve user data associated with a specific tile by its ID and a sign, with an option for a default value.
         * @param id The unique ID of the tile.
         * @param sign The key for the user data within the tile's data.
         * @param defaultV The default value to return if the specified user data does not exist.
         * @returns The retrieved user data or the default value if not found.
         * @zh 根据地块的ID和标识符检索与之关联的用户数据，并可选择提供默认值。
         * @param	id 地块的唯一ID
         * @param	sign 用户数据在地块数据中的标识符
         * @param	defaultV 默认值，如果指定的用户数据不存在则返回
         * @return 得到的用户数据或默认值
         */
        getTileUserData(id: number, sign: string, defaultV?: any): any;
        private adptTiledMapData;
        private removeCoverd;
        private collectCovers;
        /**
         * @en Retrieve a map texture by its index.
         * @param index The index of the texture. Default to starting from 1.
         * @returns The TileTexSet object at the specified index, or null if not found.
         * @zh 通过索引值获取一块指定的地图纹理，默认索引从1开始。
         * @param	index 纹理的索引值。
         * @return 索引处的TileTexSet对象，如果没有找到则返回null
         */
        getTexture(index: number): TileTexSet;
        /**
         * @en Get the custom properties of the map.
         * @param name The name of the property to retrieve.
         * @returns The value of the specified property, or null if not found.
         * @zh 获取地图的自定义属性。
         * @param	name	属性名称
         * @return 得到的属性值，如果没有找到则返回null
         */
        getMapProperties(name: string): any;
        /**
         * @en Get custom properties of a tile.
         * @param index The index of the tile data.
         * @param id The specific TileSetID of the tile.
         * @param name The name of the property to retrieve.
         * @returns The value of the specified property for the given tile, or null if not found.
         * @zh 获取tile的自定义属性。
         * @param	index	地图块索引
         * @param	id		具体的TileSetID
         * @param	name	属性名称
         * @returns 给定tile的指定属性值，如果没有找到则返回null
         */
        getTileProperties(index: number, id: number, name: string): any;
        /**
         * @en Generate a controllable sprite using the texture index.
         * @param index The index of the texture. Starting from 1 by default.
         * @param width The width of the sprite.
         * @param height The height of the sprite.
         * @returns The created GridSprite object, or null if not created.
         * @zh 通过纹理索引生成一个可控制物件。
         * @param	index	纹理索引，默认从1开始
         * @param	width		精灵的宽
         * @param	height		精灵的高
         * @returns 生成的GridSprite对象，如果没有生成则返回null
         */
        getSprite(index: number, width: number, height: number): GridSprite;
        /**
         * @en Set the viewport pivot point based on scale, useful for centering the scaling origin.
         * @param scaleX The horizontal scale value for the pivot point.
         * @param scaleY The vertical scale value for the pivot point.
         * @zh 根据缩放值设置视口的缩放中心点，例如：scaleX= scaleY= 0.5 表示以视口中心缩放。
         * @param	scaleX	水平缩放值
         * @param	scaleY	垂直缩放值
         */
        setViewPortPivotByScale(scaleX: number, scaleY: number): void;
        /**
         * @en Set the map's scale, which affects the size of the map within the viewport.
         * @param scale The new scale value. Scale less than or equal to zero will be ignored.
         * @zh 设置地图缩放，影响地图在视口中的大小。
         * @param	scale	新的缩放值，小于等于0的缩放值将被忽略
         */
        set scale(scale: number);
        /**
         * @en Get the current scale of the map.
         * @zh 获取当前地图的缩放比例。
         */
        get scale(): number;
        /**
         * @en Move the viewport to a new position.
         * @param moveX The new x-coordinate for the viewport.
         * @param moveY The new y-coordinate for the viewport.
         * @zh 移动视口到新的位置。
         * @param	moveX	视口的新x坐标
         * @param	moveY	视口的新y坐标
         */
        moveViewPort(moveX: number, moveY: number): void;
        /**
         * @en Change the size and/or position of the viewport.
         * @zh 改变视口的大小和/或位置。
         * @param moveX The new x-coordinate for the viewport.
         * @param moveY The new y-coordinate for the viewport.
         * @param width The new width of the viewport.
         * @param height The new height of the viewport.
         * @zh 改变视口的大小和/或位置。
         * @param	moveX	视口的坐标x
         * @param	moveY	视口的坐标y
         * @param	width	视口的宽
         * @param	height	视口的高
         */
        changeViewPort(moveX: number, moveY: number, width: number, height: number): void;
        /**
         * @en Change the viewport based on width and height, calculated from the anchor point.
         * @param width The new width for the viewport.
         * @param height The new height for the viewport.
         * @param rect The Rectangle object to store the result (optional).
         * @returns The resulting Rectangle with the new viewport dimensions and position.
         * @zh 基于锚点计算，通过宽和高来重新计算视口。
         * @param	width		新视口宽
         * @param	height		新视口高
         * @param	rect		返回的结果
         * @returns	返回的Rectangle对象，包含新的视口的宽高和位置
         */
        changeViewPortBySize(width: number, height: number, rect?: Rectangle): Rectangle;
        /**
         * @en Refresh Viewport
         * @zh 刷新视口
         */
        private updateViewPort;
        /**
         * @en GRID cropping
         * @zh GRID裁剪
         */
        private clipViewPort;
        /**
         * @en Display the specified grid on the map.
         * @param gridX The X-coordinate of the grid.
         * @param gridY The Y-coordinate of the grid.
         * @zh 显示地图中指定的网格。
         * @param	gridX	网格的X坐标
         * @param	gridY	网格的Y坐标
         */
        private showGrid;
        /**
         * @en Cache all grids in the map to improve rendering performance.
         * @zh 缓存地图中的所有网格以提高渲染性能。
         */
        private cacheAllGrid;
        private static _tempCanvas;
        /**
         * @en Cache an array of grids by rendering them to an off-screen canvas.
         * @param arr An array of GridSprite objects to cache.
         * @zh 通过将网格渲染到离屏画布上来缓存网格数组。
         * @param	arr	要缓存的GridSprite数组。
         */
        private cacheGridsArray;
        /**
         * @en Retrieve or initialize the array of grid sprites for a specific grid position on the map.
         * @param gridX The X-coordinate of the grid position.
         * @param gridY The Y-coordinate of the grid position.
         * @returns An array of grid sprites for the specified grid position.
         * @zh 检索或初始化地图中特定网格位置的网格精灵数组。
         * @param	gridX	网格位置的X坐标
         * @param	gridY	网格位置的Y坐标
         * @return	指定网格位置的网格精灵数组
         */
        private getGridArray;
        /**
         * @en Hide the specified grid on the map.
         * @param gridX The X-coordinate of the grid to hide.
         * @param gridY The Y-coordinate of the grid to hide.
         * @zh 隐藏地图中指定的网格。
         * @param	gridX	要隐藏的网格的X坐标
         * @param	gridY	要隐藏的网格的Y坐标
         */
        private hideGrid;
        /**
         * @en Retrieve an object from a specific layer by its name.
         * @param layerName The name of the layer where the object resides.
         * @param objectName The name of the object to find.
         * @returns The GridSprite object if found, or null if not found.
         * @zh 根据名称从特定层中获取一个对象。
         * @param	layerName	物体所在层的名称
         * @param	objectName	要查找的物体的名称
         * @return	找到的GridSprite对象，如果没找到则返回null
         */
        getLayerObject(layerName: string, objectName: string): GridSprite;
        /**
         * @en Destroy and cleanup the map, releasing all resources.
         * @zh 销毁地图并清理资源。
         */
        destroy(): void;
        /****************************地图的基本数据***************************/
        /**
         * @en Gets the width of a tile.
         * @zh 获取格子的宽度。
         */
        get tileWidth(): number;
        /**
         * @en Gets the height of a tile.
         * @zh 获取格子的高度。
         */
        get tileHeight(): number;
        /**
         * @en Gets the width of the map.
         * @zh 获取地图的宽度。
         */
        get width(): number;
        /**
         * @en Gets the height of the map.
         * @zh 获取地图的高度。
         */
        get height(): number;
        /**
         * @en Gets the number of horizontal tiles in the map.
         * @zh 获取地图横向的格子数。
         */
        get numColumnsTile(): number;
        /**
         * @en Gets the number of vertical tiles in the map.
         * @zh 获取地图竖向的格子数。
         */
        get numRowsTile(): number;
        /**
         * @private
         * @en Gets the viewport's x-coordinate.
         * @zh 获取视口的x坐标。
         */
        get viewPortX(): number;
        /**
         * @private
         * @en Gets the viewport's y-coordinate.
         * @zh 获取视口的y坐标。
         */
        get viewPortY(): number;
        /**
         * @private
         * @en Gets the width of the viewport.
         * @zh 获取视口的宽度。
         */
        get viewPortWidth(): number;
        /**
         * @private
         * @en Gets the height of the viewport.
         * @zh 获取视口的高度。
         */
        get viewPortHeight(): number;
        /**
         * @en Gets the x-coordinate of the map.
         * @zh 获取地图的x坐标。
         */
        get x(): number;
        /**
         * @en Gets the y-coordinate of the map.
         * @zh 获取地图的y坐标。
         */
        get y(): number;
        /**
         * @en Gets the width of a grid block.
         * @zh 获取块的宽度。
         */
        get gridWidth(): number;
        /**
         * @en Gets the height of a grid block.
         * @zh 获取块的高度。
         */
        get gridHeight(): number;
        /**
         * @en Gets the number of horizontal grid blocks in the map.
         * @zh 获取地图的横向块数。
         */
        get numColumnsGrid(): number;
        /**
         * @en Gets the number of vertical grid blocks in the map.
         * @zh 获取地图的坚向块数。
         */
        get numRowsGrid(): number;
        /**
         * @en Gets the current map orientation type.
         * @zh 获取当前地图类型。
         */
        get orientation(): string;
        /**
         * @en Gets the tile rendering order.
         * @zh 获取tile渲染顺序。
         */
        get renderOrder(): string;
        /*****************************************对外接口**********************************************/
        /**
         * @en Gets the display container for the entire map.
         * @zh 获取整个地图的显示容器。
         */
        mapSprite(): Sprite;
        /**
         * @en Retrieves a `MapLayer` by its name.
         * @param layerName The name of the layer to find.
         * @returns The found `MapLayer` or null if not found.
         * @zh 通过名称获取指定的`MapLayer`。
         * @param layerName 要查找的层的名称。
         * @returns 找到的`MapLayer`对象，如果没找到则返回null。
         */
        getLayerByName(layerName: string): MapLayer;
        /**
         * @en Retrieves a `MapLayer` by its index.
         * @param index The index of the layer to retrieve.
         * @zh 通过索引获取`MapLayer`。
         * @param index 要检索的层的索引。
         */
        getLayerByIndex(index: number): MapLayer;
    }
    /**
     * @en The `TileTexSet` class is a sub-texture class that also manages animations of the same type.
     * TiledMap divides textures into numerous sub-textures and can replace a specific sub-texture with an animation sequence.
     * The implementation of this class sets the `animationKey` to true if a sub-texture is replaced with an animation sequence.
     * That is, if `animationKey` is true, use `TileAniSprite` for display, and draw the animation sequence onto `TileAniSprite` according to time.
     * @zh `TileTexSet` 类是一个子纹理类，同时管理同类型动画。
     * TiledMap 将纹理分割成许多子纹理，并且可以将其中的某个子纹理替换为动画序列。
     * 如果发现子纹理被替换为动画序列，本类的实现会将 `animationKey` 设置为 true。
     * 即如果 `animationKey` 为 true，则使用 `TileAniSprite` 来显示，并将动画序列根据时间绘制到 `TileAniSprite` 上。
     */
    class TileTexSet {
        /**
         * @en The unique identifier for the tile texture set.
         * @zh 子纹理集的唯一标识。
         */
        gid: number;
        /**
         * @en The reference to the sub-texture.
         * @zh 子纹理的引用。
         */
        texture: Texture;
        /**
         * @en The X coordinate offset when displaying the texture.
         * @zh 纹理显示时的X坐标偏移。
         */
        offX: number;
        /**
         * @en The Y coordinate offset when displaying the texture.
         * @zh 纹理显示时的Y坐标偏移。
         */
        offY: number;
        /**
         * @en The array of textures to be displayed for the current animation.
         * @zh 当前要播放的动画纹理序列。
         */
        textureArray: any[];
        /**
         * @en The duration of each frame in the current animation.
         * @zh 当前动画每帧的时间间隔。
         */
        durationTimeArray: any[];
        /**
         * @en The total duration of the animation.
         * @zh 动画播放的总时间。
         */
        animationTotalTime: number;
        /**
         * @en Indicates whether the current texture is an animation sequence (true) or a single texture (false).
         * @zh 表示当前纹理是一组动画(true)还是单个纹理(false)。
         */
        isAnimation: boolean;
        /**
         * @en The number of display objects in the current animation.
         * @zh 当前动画的显示对象数量。
         */
        private _spriteNum;
        /**
         * @en A dictionary to save display objects by their unique name.
         * @zh 通过显示对象的唯一名字保存显示对象的字典。
         */
        private _aniDic;
        /**
         * @en The current frame index in the animation sequence.
         * @zh 当前动画播放到的帧索引。
         */
        private _frameIndex;
        /**
         * @en The elapsed time since the last animation refresh.
         * @zh 距离上次动画刷新过了多少时间。
         */
        private _time;
        /**
         * @en The interval time for refreshing each frame.
         * @zh 每帧刷新的时间间隔。
         */
        private _interval;
        /**
         * @en The timestamp of the last frame refresh.
         * @zh 上一帧刷新的时间戳。
         */
        private _preFrameTime;
        /**
         * @en Adds an animation display object to this animation.
         * @param aniName The name of the display object.
         * @param sprite The display object.
         * @zh 将一个动画显示对象加入到此动画中。
         * @param aniName 显示对象的名字。
         * @param sprite 显示对象。
         */
        addAniSprite(aniName: string, sprite: TileAniSprite): void;
        /**
         * @en Draws the animation to all registered sprites.
         * @zh 把动画画到所有注册的显示对象上。
         */
        private animate;
        /**
         * @en Draws the texture to the specified sprite.
         * @param sprite The sprite to draw the texture on.
         * @param tileTextSet The tile texture set to draw.
         * @zh 将纹理绘制到指定的显示对象上。
         * @param sprite 要绘制纹理的显示对象。
         * @param tileTextSet 要绘制的子纹理集。
         */
        private drawTexture;
        /**
         * @en Removes the sprite that no longer needs to be updated.
         * @param _name The name of the sprite to remove.
         * @zh 移除不再需要更新的显示对象。
         * @param _name 要移除的显示对象的名字。
         */
        removeAniSprite(_name: string): void;
        /**
         * @en Displays the current usage of the animation.
         * @returns A string containing the debug information.
         * @zh 显示当前动画的使用情况。
         * @returns 包含调试信息的字符串。
         */
        showDebugInfo(): string;
        /**
         * @en Clears all properties of the tile texture set.
         * @zh 清理子纹理集的所有属性。
         */
        clearAll(): void;
    }
    /**
     * @private
     * @en Utility class for calculating Bezier curves.
     * @zh 计算贝塞尔曲线的工具类。
     */
    class Bezier {
        /**
         * @en Singleton instance of the utility class
         * @zh 工具类单例
         */
        static I: Bezier;
        /** @private */
        private _controlPoints;
        /** @private */
        private _calFun;
        /** @private */
        private _switchPoint;
        /**
         * @en Calculate quadratic Bezier point.
         * @param t The parameter in the range [0, 1]
         * @param rst The array to store the result
         * @zh 计算二次贝塞尔点。
         * @param t 用于计算的参数，范围[0, 1]
         * @param rst 用于存结果的数组
         */
        getPoint2(t: number, rst: any[]): void;
        /**
         * @en Calculate cubic Bezier point
         * @param t The parameter in the range [0, 1]
         * @param rst The array to store the result
         * @zh 计算三次贝塞尔点
         * @param t 用于计算的参数，范围[0, 1]
         * @param rst 用于存结果的数组
         */
        getPoint3(t: number, rst: any[]): void;
        /**
         * @en Calculate a sequence of Bezier points
         * @param count The number of points to insert
         * @param rst The array to store the result
         * @zh 计算贝塞尔点序列
         * @param count 输入的点的数量
         * @param rst 用于存结果的数组
         */
        insertPoints(count: number, rst: any[]): void;
        /**
         * @en Get points on the Bezier curve.
         * @param pList Control points [x0,y0,x1,y1...]
         * @param inSertCount The number of interpolation points for each curve segment
         * @param count The order of the Bezier curve (2 for quadratic, 3 for cubic)
         * @returns An array of points on the Bezier curve
         * @zh 获取贝塞尔曲线上的点。
         * @param pList 控制点[x0,y0,x1,y1...]
         * @param inSertCount 每次曲线的插值数量
         * @param count 贝塞尔曲线的阶数（2表示二次曲线，3表示三次曲线）
         * @returns 贝塞尔曲线上的点组成的数组
         */
        getBezierPoints(pList: any[], inSertCount?: number, count?: number): any[];
    }
    /**
     * @en The Color class is used to create color instances.
     * @zh Color类用于创建颜色实例。
     */
    class Color implements IClone {
        /**
         * @en Red color
         * @zh 红色
         */
        static RED: Color;
        /**
         * @en Green color
         * @zh 绿色
         */
        static GREEN: Color;
        /**
         * @en Blue color
         * @zh 蓝色
         */
        static BLUE: Color;
        /**
         * @en Cyan color
         * @zh 蓝绿色
         */
        static CYAN: Color;
        /**
         * @en Yellow color
         * @zh 黄色
         */
        static YELLOW: Color;
        /**
         * @en Magenta color
         * @zh 品红色
         */
        static MAGENTA: Color;
        /**
         * @en Gray color
         * @zh 灰色
         */
        static GRAY: Color;
        /**
         * @en White color
         * @zh 白色
         */
        static WHITE: Color;
        /**
         * @en Black color
         * @zh 黑色
         */
        static BLACK: Color;
        /**
         * @en Fully transparent
         * @zh 全透明
         */
        static CLEAR: Color;
        /**
         * @en Convert gamma space value to linear space.
         * @param value The value in gamma space.
         * @returns The value in linear space.
         * @zh 将 Gamma 空间值转换为线性空间值。
         * @param value Gamma 空间值。
         * @returns 线性空间值。
         */
        static gammaToLinearSpace(value: number): number;
        /**
         * @en Convert linear space value to gamma space.
         * @param value The value in linear space.
         * @returns The value in gamma space.
         * @zh 将线性空间值转换为 Gamma 空间值。
         * @param value 线性空间值。
         * @returns Gamma 空间值。
         */
        static linearToGammaSpace(value: number): number;
        /**
         * @en Red component
         * @zh 红色分量
         */
        r: number;
        /**
         * @en Green component
         * @zh 绿色分量
         */
        g: number;
        /**
         * @en Blue component
         * @zh 蓝色分量
         */
        b: number;
        /**
         * @en Alpha component
         * @zh 透明度分量
         */
        a: number;
        /**
         * @en Constructor method Color.
         * @param r Red component (0-1).
         * @param g Green component (0-1).
         * @param b Blue component (0-1).
         * @param a Alpha component (0-1).
         * @zh 构造函数,初始化颜色实例。
         * @param r 红色分量（0-1）。
         * @param g 绿色分量（0-1）。
         * @param b 蓝色分量（0-1）。
         * @param a 透明度分量（0-1）。
         */
        constructor(r?: number, g?: number, b?: number, a?: number);
        /**
         * @en Check if two colors are equal.
         * @param c The color to compare with.
         * @returns True if the colors are equal, false otherwise.
         * @zh 判断两个颜色是否相等。
         * @param c 要比较的颜色。
         * @returns 如果颜色相等则返回 true，否则返回 false。
         */
        equal(c: Color): boolean;
        /**
         * @en Convert from gamma space to linear space.
         * @param out The output color in linear space.
         * @zh 从 Gamma 空间转换到线性空间。
         * @param out 输出的线性空间颜色。
         */
        toLinear(out: Color): void;
        /**
         * @en Convert from linear space to gamma space.
         * @param out The output color in gamma space.
         * @zh 从线性空间转换到 Gamma 空间。
         * @param out 输出的 Gamma 空间颜色。
         */
        toGamma(out: Color): void;
        /**
         * @en Clone the color to another object.
         * @param destObject The target object to clone to.
         * @zh 克隆颜色到目标对象。
         * @param destObject 目标克隆对象。
         */
        cloneTo(destObject: Color): void;
        /**
         * @en Scale the color.
         * @param value The scale value.
         * @returns The scaled color.
         * @zh 缩放颜色。
         * @param value 缩放值。
         * @returns 缩放后的颜色。
         */
        scale(value: number): Color;
        /**
         * @en Set the color components (0-1).
         * @param r Red component.
         * @param g Green component.
         * @param b Blue component.
         * @param a Alpha component.
         * @zh 设置颜色分量（0-1）。
         * @param r 红色分量。
         * @param g 绿色分量。
         * @param b 蓝色分量。
         * @param a 透明度分量。
         */
        setValue(r: number, g: number, b: number, a: number): void;
        /**
         * @en Convert from Array to color.
         * @param array The source array.
         * @param offset The offset of the array.
         * @zh 从Array数组拷贝值。
         * @param array 数组。
         * @param offset 数组偏移。
         */
        fromArray(array: any[], offset?: number): void;
        /**
         * @en Convert to Array.
         * @returns An array representing the color [r, g, b, a].
         * @zh 转换为Array数组
         * @returns 表示颜色的数组 [r, g, b, a]。
         */
        toArray(): Array<number>;
        /**
         * @en Clone the color.
         * @returns The cloned color.
         * @zh 克隆颜色。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @private
     * @en Graham Scan algorithm for convex hull calculation.
     * @zh 凸包算法。
     */
    class GrahamScan {
        private static _mPointList;
        private static _tempPointList;
        private static _temPList;
        private static _temArr;
        /**
         * @en Calculate the cross product of two two-dimensional vectors.
         * @param p1 End point 1.
         * @param p2 End point 2.
         * @param p0 Start point.
         * @returns The cross product value.
         * @zh 计算两个二维向量的叉积。
         * @param p1 终点1。
         * @param p2 终点2。
         * @param p0 起点。
         * @returns 叉积的值。
         */
        static multiply(p1: Point, p2: Point, p0: Point): number;
        /**
         * @en Calculate the squared distance between two points.
         * @param p1 The Start point.
         * @param p2 The End point.
         * @returns The squared distance.
         * @zh 计算两个点距离的平方。
         * @param p1 起点
         * @param p2 终点
         * @returns 距离的平方。
         */
        static dis(p1: Point, p2: Point): number;
        private static _getPoints;
        /**
         * @en Take cout items from the src array at index 0 and add them to the tail of the tst array.
         * @param rst The original array is used to add new child elements.
         * @param src An array used to retrieve child elements.
         * @param count The number of child elements to add.
         * @returns Add the RST object of the child elements.
         * @zh 将数组src从索引0位置，依次取cout个项添加至tst数组的尾部。
         * @param rst 原始数组，用于添加新的子元素。
         * @param src 用于取子元素的数组。
         * @param count 需要取得子元素个数。
         * @returns 添加完子元素的 rst 对象。
         */
        static getFrom(rst: any[], src: any[], count: number): any[];
        /**
         * @en Take cout items from the end index position to the head index position of the src array and add them to the tail of the tst array.
         * @param rst The original array is used to add new child elements.
         * @param src An array used to retrieve child elements.
         * @param count The number of child elements to add.
         * @returns Add the RST object of the child elements.
         * @zh 将数组src从末尾索引位置往头部索引位置方向，依次取cout个项添加至tst数组的尾部。
         * @param rst 原始数组，用于添加新的子元素。
         * @param src 用于取子元素的数组。
         * @param count 需要取得子元素个数。
         * @returns 添加完子元素的 rst 对象。
         */
        static getFromR(rst: any[], src: any[], count: number): any[];
        /**
         * @en Convert a list of [x,y...] to a list of Points.
         * @param pList The Point list.
         * @param tempUse Whether to use temporary storage.
         * @returns A list of [x,y...].
         * @zh 将 [x,y...] 列表转换为 Point 列表。
         * @param pList Point列表。
         * @param tempUse 是否使用临时存储。
         * @returns [x,y...]列表
         */
        static pListToPointList(pList: any[], tempUse?: boolean): any[];
        /**
         * @en Convert a list of Points to a [x,y...] list.
         * @param pointList The list of Points.
         * @returns The [x,y...] list.
         * @zh 将 Point 列表转换为 [x,y...] 列表。
         * @param pointList Point列表
         * @returns [x,y...]列表
         */
        static pointListToPlist(pointList: any[]): any[];
        /**
         * @en Find the minimum polygon vertex set that includes all points.
         * @param pList The [x,y...] list.
         * @returns The minimum polygon vertex set.
         * @zh 寻找包括所有点的最小多边形顶点集合。
         * @param pList 形如[x0,y0,x1,y1...]的点列表。
         * @returns  最小多边形顶点集合。
         */
        static scanPList(pList: any[]): any[];
        /**
         * @en Find the minimum polygon vertex set that includes all points.
         * @param PointSet The Point list.
         * @returns The minimum polygon vertex set.
         * @zh 寻找包括所有点的最小多边形顶点集合。
         * @param PointSet Point列表
         * @return 最小多边形顶点集合
         */
        static scan(PointSet: any[]): any[];
    }
    /**
     * @private
     * @en The MathUtil class is a utility class for data processing.
     * @zh MathUtil 是一个数据处理工具类。
     */
    class MathUtil {
        /**
         * @en Subtracts two 3D vectors.
         * @param l The left vector.
         * @param r The right vector.
         * @param o The output vector to store the result.
         * @zh 计算两个三维向量的差。
         * @param l 左向量。
         * @param r 右向量。
         * @param o 用于存储结果的输出向量。
         */
        static subtractVector3(l: Float32Array, r: Float32Array, o: Float32Array): void;
        /**
         * @en Performs linear interpolation between two values.
         * @param left The start value.
         * @param right The end value.
         * @param amount The interpolation amount (0-1).
         * @returns The interpolated value.
         * @zh 在两个值之间进行线性插值。
         * @param left 起始值。
         * @param right 终止值。
         * @param amount 插值比率（0-1）。
         * @returns 插值结果。
         */
        static lerp(left: number, right: number, amount: number): number;
        /**
         * @en Scales a 3D vector by a scalar value.
         * @param f The input vector.
         * @param b The scalar value.
         * @param e The output vector to store the result.
         * @zh 将三维向量乘以一个标量值。
         * @param f 输入向量。
         * @param b 标量值。
         * @param e 用于存储结果的输出向量。
         */
        static scaleVector3(f: Float32Array, b: number, e: Float32Array): void;
        /**
         * @en Performs linear interpolation between two 3D vectors.
         * @param l The start vector.
         * @param r The end vector.
         * @param t The interpolation amount (0-1).
         * @param o The output vector to store the result.
         * @zh 在两个三维向量之间进行线性插值。
         * @param l 起始向量。
         * @param r 终止向量。
         * @param t 插值比率（0-1）。
         * @param o 用于存储结果的输出向量。
         */
        static lerpVector3(l: Float32Array, r: Float32Array, t: number, o: Float32Array): void;
        /**
         * @en Performs linear interpolation between two 4D vectors.
         * @param l The start vector.
         * @param r The end vector.
         * @param t The interpolation amount (0-1).
         * @param o The output vector to store the result.
         * @zh 在两个四维向量之间进行线性插值。
         * @param l 起始向量。
         * @param r 终止向量。
         * @param t 插值比率（0-1）。
         * @param o 用于存储结果的输出向量。
         */
        static lerpVector4(l: Float32Array, r: Float32Array, t: number, o: Float32Array): void;
        /**
         * @en Performs spherical linear interpolation (slerp) between two quaternions.
         * @param a The start quaternion array.
         * @param Offset1 The offset in the start quaternion array.
         * @param b The end quaternion array.
         * @param Offset2 The offset in the end quaternion array.
         * @param t The interpolation amount (0-1).
         * @param out The output quaternion array to store the result.
         * @param Offset3 The offset in the output quaternion array.
         * @returns The output quaternion array.
         * @zh 在两个四元数之间进行球面线性插值（slerp）。
         * @param a 起始四元数数组。
         * @param Offset1 起始四元数数组的偏移量。
         * @param b 终止四元数数组。
         * @param Offset2 终止四元数数组的偏移量。
         * @param t 插值比率（0-1）。
         * @param out 用于存储结果的输出四元数数组。
         * @param Offset3 输出四元数数组的偏移量。
         * @returns 输出四元数数组。
         */
        static slerpQuaternionArray(a: Float32Array, Offset1: number, b: Float32Array, Offset2: number, t: number, out: Float32Array, Offset3: number): Float32Array;
        /**
         * @en Gets the angle value of the line segment formed by two specified points.
         * @param x0 The X coordinate of the first point.
         * @param y0 The Y coordinate of the first point.
         * @param x1 The X coordinate of the second point.
         * @param y1 The Y coordinate of the second point.
         * @returns The angle value in degrees.
         * @zh 获取由两个指定点组成的线段的角度值。
         * @param x0 第一个点的 X 坐标。
         * @param y0 第一个点的 Y 坐标。
         * @param x1 第二个点的 X 坐标。
         * @param y1 第二个点的 Y 坐标。
         * @returns 角度值，单位为度。
         */
        static getRotation(x0: number, y0: number, x1: number, y1: number): number;
        /**
         * @en A comparison function to determine the sorting order of array elements.
         * @param a The first number to compare.
         * @param b The second number to compare.
         * @returns 0 if a equals b, 1 if b > a, -1 if b < a.
         * @zh 一个用来确定数组元素排序顺序的比较函数。
         * @param a 待比较数字。
         * @param b 待比较数字。
         * @returns 如果a等于b 则值为0；如果b>a则值为1；如果b<则值为-1。
         */
        static sortBigFirst(a: number, b: number): number;
        /**
         * @en A comparison function to determine the sorting order of array elements.
         * @param a The first number to compare.
         * @param b The second number to compare.
         * @returns 0 if a equals b, -1 if b > a, 1 if b < a.
         * @zh 一个用来确定数组元素排序顺序的比较函数。
         * @param	a 待比较数字。
         * @param	b 待比较数字。
         * @returns 如果a等于b 则值为0；如果b>a则值为-1；如果b<则值为1。
         */
        static sortSmallFirst(a: number, b: number): number;
        /**
         * @en Compares the specified elements by converting them to numbers.
         * @param a The first element to compare.
         * @param b The second element to compare.
         * @returns The difference between b and a as numbers (b-a).
         * @zh 将指定的元素转为数字进行比较。
         * @param a 待比较元素。
         * @param b 待比较元素。
         * @returns b、a转化成数字的差值 (b-a)。
         */
        static sortNumBigFirst(a: any, b: any): number;
        /**
         * @en Compares the specified elements by converting them to numbers.
         * @param a The first element to compare.
         * @param b The second element to compare.
         * @returns The difference between a and b as numbers (a-b).
         * @zh 将指定的元素转为数字进行比较。
         * @param a 待比较元素。
         * @param b 待比较元素。
         * @returns a、b转化成数字的差值 (a-b)。
         */
        static sortNumSmallFirst(a: any, b: any): number;
        /**
         * @en Returns a comparison function for sorting objects based on a specified property.
         * @param key The name of the object property to sort by.
         * @param bigFirst If true, sort from big to small; otherwise, sort from small to big.
         * @param forceNum If true, convert the sorting elements to numbers for comparison.
         * @returns The sorting function.
         * @zh 返回根据对象指定的属性进行排序的比较函数。
         * @param key 排序要依据的元素属性名。
         * @param bigFirst 如果值为true，则按照由大到小的顺序进行排序，否则按照由小到大的顺序进行排序。
         * @param forceNum 如果值为true，则将排序的元素转为数字进行比较。
         * @return 排序函数。
         */
        static sortByKey(key: string, bigFirst?: boolean, forceNum?: boolean): (a: any, b: any) => number;
    }
    /**
     * @en The MathUtils3D class is used to create mathematical utilities.
     * @zh MathUtils3D 类用于创建数学工具。
     */
    class MathUtils3D {
        /**
         * @en Tolerance for single-precision floating-point (float) zero.
         * @zh 单精度浮点(float)零的容差。
         */
        static zeroTolerance: number;
        /**
         * @en Default maximum value for floating-point numbers.
         * @zh 浮点数默认最大值。
         */
        static MaxValue: number;
        /**
         * @en Default minimum value for floating-point numbers.
         * @zh 浮点数默认最小值。
         */
        static MinValue: number;
        /**
         * @en Coefficient for converting degrees to radians.
         * @zh 角度转弧度系数。
         */
        static Deg2Rad: number;
        /**
         * @en Constructor of MathUtils3D.
         * @zh MathUtils3D 的构造函数。
         */
        constructor();
        /**
         * @en Determines if a value is approximately zero within the tolerance range.
         * @param v The value to be checked.
         * @returns Whether the value is approximately zero.
         * @zh 是否在容差的范围内近似于0。
         * @param v 要判断的值。
         * @returns 是否近似于0。
         */
        static isZero(v: number): boolean;
        /**
         * @en Determines if two values are approximately equal within the tolerance range.
         * @param n1 The first value to compare.
         * @param n2 The second value to compare.
         * @returns Whether the two values are approximately equal.
         * @zh 两个值是否在容差的范围内近似相等Sqr Magnitude。
         * @param n1 要比较的第一个值。
         * @param n2 要比较的第二个值。
         * @returns 两个值是否近似相等。
         */
        static nearEqual(n1: number, n2: number): boolean;
        /**
         * @en Calculate the reciprocal of the square root of a non-zero number.
         * @param value The input value.
         * @returns The reciprocal of the square root of the input value.
         * @zh 计算一个非0数的平方根的倒数。
         * @param value 输入值。
         * @returns 输入值的平方根倒数。
         */
        static fastInvSqrt(value: number): number;
    }
    /**
     * @en Represents a transformation matrix that determines how to map points from one coordinate space to another.
     * You can perform various graphical transformations on a display object by setting the properties of a Matrix object, applying it to the matrix property of a Transform object, and then applying that Transform object as the transform property of the display object.
     * These transformation functions include translation (x and y repositioning), rotation, scaling, and skewing.
     * @zh 表示一个转换矩阵，它确定如何将点从一个坐标空间映射到另一个坐标空间。
     * 您可以对一个显示对象执行不同的图形转换，方法是设置 Matrix 对象的属性，将该 Matrix 对象应用于 Transform 对象的 matrix 属性，
     * 然后应用该 Transform 对象作为显示对象的 transform 属性。这些转换函数包括平移（x 和 y 重新定位）、旋转、缩放和倾斜。
     */
    class Matrix {
        /**
         * @private
         * @en An initialized Matrix object. The content of this object is not allowed to be modified.
         * @zh 一个初始化的 Matrix 对象，不允许修改此对象内容。
         */
        static EMPTY: Matrix;
        /**
         * @en A Matrix object used for temporary operations.
         * @zh 用于中转使用的 Matrix 对象。
         */
        static TEMP: Matrix;
        /**
         * @en The value that affects the positioning of pixels along the x axis when scaling or rotating an image.
         * @zh 缩放或旋转图像时影响像素沿 x 轴定位的值。
         */
        a: number;
        /**
         * @en The value that affects the positioning of pixels along the y axis when rotating or skewing an image.
         * @zh 旋转或倾斜图像时影响像素沿 y 轴定位的值。
         */
        b: number;
        /**
         * @en The value that affects the positioning of pixels along the x axis when rotating or skewing an image.
         * @zh 旋转或倾斜图像时影响像素沿 x 轴定位的值。
         */
        c: number;
        /**
         * @en The value that affects the positioning of pixels along the y axis when scaling or rotating an image.
         * @zh 缩放或旋转图像时影响像素沿 y 轴定位的值。
         */
        d: number;
        /**
         * @en The distance by which to translate each point along the x axis.
         * @zh 沿 x 轴平移每个点的距离。
         */
        tx: number;
        /**
         * @en The distance by which to translate each point along the y axis.
         * @zh 沿 y 轴平移每个点的距离。
         */
        ty: number;
        /**
         * @en Constructs method, initialize matrix.
         * @param a (Optional) The value that affects the positioning of pixels along the x axis when scaling or rotating an image.
         * @param b (Optional) The value that affects the positioning of pixels along the y axis when rotating or skewing an image.
         * @param c (Optional) The value that affects the positioning of pixels along the x axis when rotating or skewing an image.
         * @param d (Optional) The value that affects the positioning of pixels along the y axis when scaling or rotating an image.
         * @param tx (Optional) The distance by which to translate each point along the x axis.
         * @param ty (Optional) The distance by which to translate each point along the y axis.
         * @param nums (Optional) Additional parameter.
         * @zh 构造方法，初始化矩阵。
         * @param a		（可选）缩放或旋转图像时影响像素沿 x 轴定位的值。
         * @param b		（可选）旋转或倾斜图像时影响像素沿 y 轴定位的值。
         * @param c		（可选）旋转或倾斜图像时影响像素沿 x 轴定位的值。
         * @param d		（可选）缩放或旋转图像时影响像素沿 y 轴定位的值。
         * @param tx	（可选）沿 x 轴平移每个点的距离。
         * @param ty	（可选）沿 y 轴平移每个点的距离。
         * @param nums   (可选) 附加参数。
         */
        constructor(a?: number, b?: number, c?: number, d?: number, tx?: number, ty?: number, nums?: number);
        /**
         * @en Sets this matrix to an identity matrix.
         * @returns The current matrix.
         * @zh 将本矩阵设置为单位矩阵。
         * @return 返回当前矩形。
         */
        identity(): Matrix;
        /**
         * @en Sets the translation along the x and y axes.
         * @param x The distance to translate along the x axis.
         * @param y The distance to translate along the y axis.
         * @returns The current matrix object.
         * @zh 设置沿 x 、y 轴平移每个点的距离。
         * @param	x 沿 x 轴平移每个点的距离。
         * @param	y 沿 y 轴平移每个点的距离。
         * @return	返回对象本身
         */
        setTranslate(x: number, y: number): Matrix;
        /**
         * @en Translates the matrix along the x and y axes, as specified by the x and y parameters.
         * @param x The amount to move along the x axis (in pixels).
         * @param y The amount to move along the y axis (in pixels).
         * @returns The current matrix object.
         * @zh 沿 x 和 y 轴平移矩阵，平移的变化量由 x 和 y 参数指定。
         * @param	x 沿 x 轴向右移动的量（以像素为单位）。
         * @param	y 沿 y 轴向下移动的量（以像素为单位）。
         * @return 返回此矩形对象。
         */
        translate(x: number, y: number): Matrix;
        /**
         * @en Applies a scaling transformation to the matrix.
         * @param x The multiplier used to scale the object along the x axis.
         * @param y The multiplier used to scale the object along the y axis.
         * @returns The current matrix object.
         * @zh 对矩阵应用缩放转换。
         * @param	x 用于沿 x 轴缩放对象的乘数。
         * @param	y 用于沿 y 轴缩放对象的乘数。
         * @return	返回矩阵对象本身
         */
        scale(x: number, y: number): Matrix;
        /**
         * @en Applies a rotation transformation to the Matrix object.
         * @param angle The rotation angle in radians.
         * @returns The current matrix objec.
         * @zh 对 Matrix 对象应用旋转转换。
         * @param	angle 以弧度为单位的旋转角度。
         * @return	返回矩阵对象本身
         */
        rotate(angle: number): Matrix;
        /**
         * @en Applies a skew transformation to the Matrix object.
         * @param x The 2D skew angle along the X axis in radians.
         * @param y The 2D skew angle along the Y axis in radians.
         * @returns The current Matrix object.
         * @zh 对 Matrix 对象应用倾斜转换。
         * @param	x 沿着 X 轴的 2D 倾斜弧度。
         * @param	y 沿着 Y 轴的 2D 倾斜弧度。
         * @returns 当前 Matrix 对象。
         */
        skew(x: number, y: number): Matrix;
        /**
         * @en Applies the inverse transformation of the current matrix to the specified point and returns this point.
         * @param out The Point object to be transformed.
         * @returns The transformed out Point object.
         * @zh 对指定的点应用当前矩阵的逆转化并返回此点。
         * @param	out 待转化的点 Point 对象。
         * @returns	返回out
         */
        invertTransformPoint(out: Point): Point;
        /**
         * @en Applies the geometric transformation represented by the Matrix object to the specified point.
         * @param out The point used to set the output result.
         * @returns The transformed out Point object.
         * @zh 将 Matrix 对象表示的几何转换应用于指定点。
         * @param	out 用来设定输出结果的点。
         * @returns	返回out
         */
        transformPoint(out: Point): Point;
        /**
         * @en Applies the geometric transformation represented by the Matrix object to the specified point, ignoring tx and ty.
         * @param out The point used to set the output result.
         * @returns The transformed out Point object.
         * @zh 将 Matrix 对象表示的几何转换应用于指定点，忽略tx、ty。
         * @param	out 用来设定输出结果的点。
         * @returns	返回out
         */
        transformPointN(out: Point): Point;
        /**
         * @en Gets the X-axis scaling value.
         * @zh 获取 X 轴缩放值。
         */
        getScaleX(): number;
        /**
         * @en Gets the Y-axis scaling value.
         * @zh 获取 Y 轴缩放值。
         */
        getScaleY(): number;
        /**
         * @en Perform the inverse transformation of the original matrix.
         * @returns The current matrix object.
         * @zh 执行原始矩阵的逆转换。
         * @returns 当前矩阵对象。
         */
        invert(): Matrix;
        /**
         * @en Sets the members of Matrix to the specified values.
         * @param a The value that affects the positioning of pixels along the x axis when scaling or rotating an image.
         * @param b The value that affects the positioning of pixels along the y axis when rotating or skewing an image.
         * @param c The value that affects the positioning of pixels along the x axis when rotating or skewing an image.
         * @param d The value that affects the positioning of pixels along the y axis when scaling or rotating an image.
         * @param tx The distance by which to translate each point along the x axis.
         * @param ty The distance by which to translate each point along the y axis.
         * @returns The current matrix object.
         * @zh 将 Matrix 的成员设置为指定值。
         * @param	a 缩放或旋转图像时影响像素沿 x 轴定位的值。
         * @param	b 旋转或倾斜图像时影响像素沿 y 轴定位的值。
         * @param	c 旋转或倾斜图像时影响像素沿 x 轴定位的值。
         * @param	d 缩放或旋转图像时影响像素沿 y 轴定位的值。
         * @param	tx 沿 x 轴平移每个点的距离。
         * @param	ty 沿 y 轴平移每个点的距离。
         * @return 当前矩阵对象。
         */
        setTo(a: number, b: number, c: number, d: number, tx: number, ty: number): Matrix;
        /**
         * @en Concatenates the specified matrix with the current matrix, effectively combining the geometric effects of the two.
         * @param matrix The matrix to be concatenated to the source matrix.
         * @returns The current matrix.
         * @zh 将指定矩阵与当前矩阵连接，从而将这两个矩阵的几何效果有效地结合在一起。
         * @param	matrix 要连接到源矩阵的矩阵。
         * @return	当前矩阵。
         */
        concat(matrix: Matrix): Matrix;
        /**
         * @en Multiplies the specified two matrices and assigns the result to the specified output object.
         * @param m1 The first matrix.
         * @param m2 The second matrix.
         * @param out The output object.
         * @returns The result output object out.
         * @zh 将指定的两个矩阵相乘后的结果赋值给指定的输出对象。
         * @param	m1 矩阵一。
         * @param	m2 矩阵二。
         * @param	out 输出对象。
         * @return	结果输出对象 out。
         */
        static mul(m1: Matrix, m2: Matrix, out: Matrix): Matrix;
        /**
         * @en Multiplies the specified two matrices and assigns the result to the specified output array of length 16.
         * @param m1 The first matrix.
         * @param m2 The second matrix.
         * @param out The output Array object.
         * @returns The result output object out.
         * @zh 将指定的两个矩阵相乘，结果赋值给指定的输出数组，长度为16。
         * @param m1	矩阵一。
         * @param m2	矩阵二。
         * @param out	输出对象Array。
         * @returns 结果输出对象 out。
         */
        static mul16(m1: Matrix, m2: Matrix, out: any[]): any[];
        /**
         * @private
         * @en Applies a scaling transformation to the matrix. Reverse multiplication.
         * @param x The multiplier used to scale the object along the x axis.
         * @param y The multiplier used to scale the object along the y axis.
         * @zh 对矩阵应用缩放转换。反向相乘
         * @param	x 用于沿 x 轴缩放对象的乘数。
         * @param	y 用于沿 y 轴缩放对象的乘数。
         */
        scaleEx(x: number, y: number): void;
        /**
         * @private
         * @en Applies a rotation transformation to the Matrix object. Reverse multiplication.
         * @param angle The rotation angle in radians.
         * @zh 对 Matrix 对象应用旋转转换。反向相乘
         * @param angle 以弧度为单位的旋转角度。
         */
        rotateEx(angle: number): void;
        /**
         * @en Returns a copy of this Matrix object.
         * @returns A new Matrix instance with exactly the same properties as the original instance.
         * @zh 返回此 Matrix 对象的副本。
         * @returns 与原始实例具有完全相同的属性的新 Matrix 实例。
         */
        clone(): Matrix;
        /**
         * @en Copy all matrix data from the current Matrix object to the specified Matrix object.
         * @param dec The Matrix object to copy the current matrix data to.
         * @returns The Matrix object with the copied matrix data.
         * @zh 将当前 Matrix 对象中的所有矩阵数据复制到指定的 Matrix 对象中。
         * @param dec 要复制当前矩阵数据的 Matrix 对象。
         * @returns 已复制当前矩阵数据的 Matrix 对象。
         */
        copyTo(dec: Matrix): Matrix;
        /**
         * @en Return a string that lists the properties of this Matrix object.
         * @returns A string containing the property values of the Matrix object: a, b, c, d, tx, and ty.
         * @zh 返回列出该 Matrix 对象属性的文本值。
         * @returns 一个字符串，它包含 Matrix 对象的属性值：a、b、c、d、tx 和 ty。
         */
        toString(): string;
        /**
         * @en Destroy this object.
         * @zh 销毁此对象。
         */
        destroy(): void;
        /**
         * @en Recycle to the object pool for reuse.
         * @zh 回收到对象池，方便复用。
         */
        recover(): void;
        /**
         * @en Create a Matrix object from the object pool.
         * @returns A Matrix object.
         * @zh 从对象池中创建一个 Matrix 对象。
         * @returns 返回一个 Matrix 对象。
         */
        static create(): Matrix;
    }
    /**
     * @en The Matrix3x3 class is used to create a 3x3 matrix.
     * @zh Matrix3x3 类用于创建 3x3 矩阵。
     */
    class Matrix3x3 implements IClone {
        /**
         * @en Default value
         * @zh 默认值
         */
        static readonly DEFAULT: Readonly<Matrix3x3>;
        /**
         * @en Temporary variable
         * @zh 临时变量
         */
        static Temp: Matrix3x3;
        /**
         * @en Create a rotation matrix from a quaternion.
         * @param rotation The rotation quaternion.
         * @param out The output rotation matrix.
         * @zh 通过四元数创建旋转矩阵。
         * @param rotation 旋转四元数。
         * @param out 输出的旋转矩阵。
         */
        static createRotationQuaternion(rotation: Quaternion, out: Matrix3x3): void;
        /**
         * @en Generate a 3x3 matrix based on the specified translation.
         * @param trans The translation vector.
         * @param out The output matrix.
         * @zh 根据指定平移生成 3x3 矩阵。
         * @param trans 平移向量。
         * @param out 输出矩阵。
         */
        static createFromTranslation(trans: Vector2, out: Matrix3x3): void;
        /**
         * @en Generate a 3x3 matrix based on the specified rotation.
         * @param rad The rotation value.
         * @param out The output matrix.
         * @zh 根据指定旋转生成 3x3 矩阵。
         * @param rad 旋转值。
         * @param out 输出矩阵。
         */
        static createFromRotation(rad: number, out: Matrix3x3): void;
        /**
         * @en Generate a 3x3 matrix based on the specified scaling.
         * @param scale The scaling vector.
         * @param out The output matrix.
         * @zh 根据指定缩放生成 3x3 矩阵。
         * @param scale 缩放向量。
         * @param out 输出矩阵。
         */
        static createFromScaling(scale: Vector3, out: Matrix3x3): void;
        /**
         * @en Convert a 4x4 matrix to a 3x3 matrix (upper-left principle, ignoring the fourth row and column).
         * @param sou The source 4x4 matrix.
         * @param out The output 3x3 matrix.
         * @zh 从 4x4 矩阵转换为一个 3x3 的矩阵（原则为 upper-left，忽略第四行四列）。
         * @param sou 4x4 源矩阵。
         * @param out 3x3 输出矩阵。
         */
        static createFromMatrix4x4(sou: Matrix4x4, out: Matrix3x3): void;
        /**
         * @en Multiply two 3x3 matrices.
         * @param left The left matrix.
         * @param right The right matrix.
         * @param out The output matrix.
         * @zh 两个 3x3 矩阵的相乘。
         * @param left 左矩阵。
         * @param right 右矩阵。
         * @param out 输出矩阵。
         */
        static multiply(left: Matrix3x3, right: Matrix3x3, out: Matrix3x3): void;
        /**
         * @en Matrix element array
         * @zh 矩阵元素数组
         */
        elements: Float32Array;
        constructor(createElement?: boolean);
        /**
         * @en Clone the matrix by array.
         * @param destObject The target array to clone to.
         * @zh 通过数组克隆矩阵。
         * @param destObject 克隆目标数组。
         */
        cloneByArray(destObject: Float32Array): void;
        /**
         * @en Calculate the determinant of the 3x3 matrix.
         * @returns The determinant of the matrix.
         * @zh 计算 3x3 矩阵的行列式。
         * @returns 返回矩阵的行列式。
         */
        determinant(): number;
        /**
         * @en Transform the 3x3 matrix by a two-dimensional vector.
         * @param trans The translation vector.
         * @param out The output matrix.
         * @zh 通过一个二维向量转换 3x3 矩阵。
         * @param trans 转换向量。
         * @param out 输出矩阵。
         */
        translate(trans: Vector2, out: Matrix3x3): void;
        /**
         * @en Rotate the 3x3 matrix by a specified angle.
         * @param rad The rotation angle in radians.
         * @param out The output matrix.
         * @zh 根据指定角度旋转 3x3 矩阵。
         * @param rad 旋转角度（弧度）。
         * @param out 输出矩阵。
         */
        rotate(rad: number, out: Matrix3x3): void;
        /**
         * @en Scale the 3x3 matrix by a specified value.
         * @param scale The scaling vector.
         * @param out The output matrix.
         * @zh 根据指定缩放值缩放 3x3 矩阵。
         * @param scale 缩放向量。
         * @param out 输出矩阵。
         */
        scale(scale: Vector2, out: Matrix3x3): void;
        /**
         * @en Calculate the inverse of the 3x3 matrix.
         * @param out The output inverse matrix.
         * @zh 计算 3x3 矩阵的逆矩阵。
         * @param out 输出的逆矩阵。
         */
        invert(out: Matrix3x3): void;
        /**
         * @en Calculate the transpose of the 3x3 matrix.
         * @param out The output matrix.
         * @zh 计算 3x3 矩阵的转置矩阵。
         * @param  out 输出矩阵。
         */
        transpose(out: Matrix3x3): void;
        /**
         * @en Set the existing matrix to an identity matrix.
         * @zh 设置已有的矩阵为单位矩阵。
         */
        identity(): void;
        /**
         * @en Clone the matrix.
         * @param destObject The clone target.
         * @zh 克隆矩阵。
         * @param destObject 克隆目标。
         */
        cloneTo(destObject: Matrix3x3): void;
        /**
         * @en Clone the matrix.
         * @returns A clone of the matrix.
         * @zh 克隆矩阵。
         * @returns 矩阵的克隆副本。
         */
        clone(): any;
        /**
         * @en Calculate the 3x3 view matrix.
         * @param eye The position of the observer.
         * @param target The position of the target.
         * @param up The up vector.
         * @param out The output 3x3 matrix.
         * @zh 计算观察3x3矩阵。
         * @param eye 观察者位置。
         * @param target 目标位置。
         * @param up 上向量。
         * @param out 输出3x3矩阵。
         */
        static lookAt(eye: Vector3, target: Vector3, up: Vector3, out: Matrix3x3): void;
        /**
         * @en Calculate the 3x3 view matrix with forward direction looking at target. Forward is defined as the z-axis here.
         * @param eye The starting point.
         * @param target The target point.
         * @param up The up vector.
         * @param out The output matrix.
         * @zh 计算前向看向目标的3x3观察矩阵。这里规定前向为z轴。
         * @param eye 起始点。
         * @param target 目标点。
         * @param up 向上轴。
         * @param out 输出矩阵。
         */
        static forwardLookAt(eye: Vector3, target: Vector3, up: Vector3, out: Matrix3x3): void;
    }
    /**
     * @en The `Matrix4x4` class is used to create 4x4 matrices.
     * @zh `Matrix4x4` 类用于创建4x4矩阵。
     */
    class Matrix4x4 implements IClone {
        /**
         * @en Default matrix. Do not modify.
         * @zh 默认矩阵，禁止修改。
         */
        static readonly DEFAULT: Readonly<Matrix4x4>;
        /**
         * @en Inverse of the default matrix. Do not modify.
         * @zh 默认值的逆矩阵，禁止修改。
         */
        static readonly DEFAULTINVERT: Readonly<Matrix4x4>;
        /**
         * @en Default matrix. Do not modify.
         * @zh 默认矩阵，禁止修改。
         */
        static readonly ZERO: Readonly<Matrix4x4>;
        /**
         * @en Create a rotation matrix around the X axis.
         * @param rad The rotation angle.
         * @param out The output matrix.
         * @zh 创建绕X轴旋转的矩阵。
         * @param rad 旋转角度。
         * @param out 输出矩阵。
         */
        static createRotationX(rad: number, out: Matrix4x4): void;
        /**
         * @en Create a rotation matrix around the Y axis.
         * @param rad The rotation angle.
         * @param out The output matrix.
         * @zh 创建绕Y轴旋转的矩阵。
         * @param rad 旋转角度。
         * @param out 输出矩阵。
         */
        static createRotationY(rad: number, out: Matrix4x4): void;
        /**
         * @en Create a rotation matrix around the Z axis.
         * @param rad The rotation angle.
         * @param out The output matrix.
         * @zh 创建绕Z轴旋转的矩阵。
         * @param rad 旋转角度。
         * @param out 输出矩阵。
         */
        static createRotationZ(rad: number, out: Matrix4x4): void;
        /**
         * @en Create a rotation matrix from yaw, pitch, and roll angles.
         * @param yaw The rotation angle around the vertical axis (Y-axis).
         * @param pitch The rotation angle around the transverse axis (X-axis).
         * @param roll The rotation angle around the longitudinal axis (Z-axis).
         * @param result The output result matrix.
         * @zh 通过yaw、pitch、roll角度创建旋转矩阵。
         * @param yaw 绕垂直轴（Y轴）的旋转角度。
         * @param pitch 绕横向轴（X轴）的旋转角度。
         * @param roll 绕纵向轴（Z轴）的旋转角度。
         * @param result 输出结果矩阵。
         */
        static createRotationYawPitchRoll(yaw: number, pitch: number, roll: number, result: Matrix4x4): void;
        /**
         * @en Create a rotation matrix from an axis and an angle.
         * @param axis The rotation axis, assumed to be normalized.
         * @param angle The rotation angle.
         * @param result The output result matrix.
         * @zh 通过旋转轴和旋转角度计算旋转矩阵。
         * @param axis 旋转轴，假定已经归一化。
         * @param angle 旋转角度。
         * @param result 输出结果矩阵。
         */
        static createRotationAxis(axis: Vector3, angle: number, result: Matrix4x4): void;
        /**
         * @en Create a rotation matrix from a quaternion.
         * @param rotation The rotation quaternion.
         * @param result The output rotation matrix.
         * @zh 通过四元数创建旋转矩阵。
         * @param rotation 旋转四元数。
         * @param result 输出旋转矩阵。
         */
        static createRotationQuaternion(rotation: Quaternion, result: Matrix4x4): void;
        /**
         * @en Create a translation matrix.
         * @param trans The translation vector.
         * @param out The output matrix.
         * @zh 根据平移向量创建平移矩阵。
         * @param trans 平移向量。
         * @param out 输出矩阵。
         */
        static createTranslate(trans: Vector3, out: Matrix4x4): void;
        /**
         * @en Create a scaling matrix.
         * @param scale The scaling values.
         * @param out The output matrix.
         * @zh 根据缩放值创建缩放矩阵。
         * @param scale 缩放值。
         * @param out 输出矩阵。
         */
        static createScaling(scale: Vector3, out: Matrix4x4): void;
        /**
         * @en Multiply two matrices.
         * @param left The left matrix.
         * @param right The right matrix.
         * @param out The output matrix.
         * @zh 计算两个矩阵的乘法。
         * @param left 左矩阵。
         * @param right 右矩阵。
         * @param out 输出矩阵。
         */
        static multiply(left: Matrix4x4, right: Matrix4x4, out: Matrix4x4): void;
        /**
         * @en Calculate the rotation matrix from a quaternion.
         * @param rotation The input quaternion.
         * @param out The output matrix.
         * @zh 从四元数计算旋转矩阵。
         * @param rotation 输入的四元数。
         * @param out 输出矩阵。
         */
        static createFromQuaternion(rotation: Quaternion, out: Matrix4x4): void;
        /**
         * @en Calculate the affine transformation matrix.
         * @param trans The translation vector.
         * @param rot The rotation quaternion.
         * @param scale The scale vector.
         * @param out The output matrix.
         * @zh 计算仿射变换矩阵。
         * @param trans 平移向量。
         * @param rot 旋转四元数。
         * @param scale 缩放向量。
         * @param out 输出矩阵。
         */
        static createAffineTransformation(trans: Vector3, rot: Quaternion, scale: Vector3, out: Matrix4x4): void;
        /**
         * @en Calculate the view matrix.
         * @param eye The position of the viewer's eye.
         * @param target The position of the target point.
         * @param up The up vector.
         * @param out The output matrix.
         * @zh 计算观察矩阵。
         * @param eye 视点位置。
         * @param target 视点目标。
         * @param up 向上向量。
         * @param out 输出矩阵。
         */
        static createLookAt(eye: Vector3, target: Vector3, up: Vector3, out: Matrix4x4): void;
        /**
         * @en Create a perspective projection matrix using FOV.
         * @param fov The field of view in radians.
         * @param aspect The aspect ratio (width / height).
         * @param znear The near clipping plane.
         * @param zfar The far clipping plane.
         * @param out The output matrix.
         * @zh 通过FOV创建透视投影矩阵。
         * @param fov 视角（以弧度为单位）。
         * @param aspect 横纵比（宽/高）。
         * @param znear 近裁面。
         * @param zfar 远裁面。
         * @param out 输出矩阵。
         */
        static createPerspective(fov: number, aspect: number, znear: number, zfar: number, out: Matrix4x4): void;
        /**
         * @en Create a perspective projection matrix.
         * @param left The left boundary of the frustum.
         * @param right The right boundary of the frustum.
         * @param bottom The bottom boundary of the frustum.
         * @param top The top boundary of the frustum.
         * @param znear The near boundary of the frustum.
         * @param zfar The far boundary of the frustum.
         * @param out The output matrix.
         * @zh 创建透视投影矩阵。
         * @param left 视椎左边界。
         * @param right 视椎右边界。
         * @param bottom 视椎底边界。
         * @param top 视椎顶边界。
         * @param znear 视椎近边界。
         * @param zfar 视椎远边界。
         * @param out 输出矩阵。
         */
        static createPerspectiveOffCenter(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, out: Matrix4x4): void;
        /**
         * @en Calculate the orthographic projection matrix.
         * @param left The left boundary of the frustum.
         * @param right The right boundary of the frustum.
         * @param bottom The bottom boundary of the frustum.
         * @param top The top boundary of the frustum.
         * @param znear The near boundary of the frustum.
         * @param zfar The far boundary of the frustum.
         * @param out The output matrix.
         * @zh 计算正交投影矩阵。
         * @param left 视椎左边界。
         * @param right 视椎右边界。
         * @param bottom 视椎底边界。
         * @param top 视椎顶边界。
         * @param znear 视椎近边界。
         * @param zfar 视椎远边界。
         * @param out 输出矩阵。
         */
        static createOrthoOffCenter(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, out: Matrix4x4): void;
        /**
         * @en Matrix elements array.
         * @zh 矩阵元素数组。
         */
        elements: Float32Array;
        /**
         * @en Constructor method.
         * @zh 构造方法
         */
        constructor(m11?: number, m12?: number, m13?: number, m14?: number, m21?: number, m22?: number, m23?: number, m24?: number, m31?: number, m32?: number, m33?: number, m34?: number, m41?: number, m42?: number, m43?: number, m44?: number, elements?: Float32Array);
        /**
         * @en Generate matrix from quaternion.
         * @param rotation The rotation quaternion.
         * @zh 从四元数生成矩阵。
         * @param rotation 旋转四元数。
         */
        setRotation(rotation: Quaternion): void;
        /**
         * @en Set the position of the matrix.
         * @param position The position vector.
         * @zh 设置矩阵的位置。
         * @param position 位置向量。
         */
        setPosition(position: Vector3): void;
        /**
         * @en Determine if two 4x4 matrices have equal values.
         * @param other The other 4x4 matrix to compare.
         * @returns True if the matrices are equal, false otherwise.
         * @zh 判断两个4x4矩阵的值是否相等。
         * @param other 要比较的另一个4x4矩阵。
         * @returns 如果矩阵相等则返回true，否则返回false。
         */
        equalsOtherMatrix(other: Matrix4x4): boolean;
        /**
         * @en Decompose the matrix into translation vector, rotation quaternion, and scale vector.
         * @param translation The translation vector.
         * @param rotation The rotation quaternion.
         * @param scale The scale vector.
         * @returns Whether the decomposition was successful.
         * @zh 分解矩阵为平移向量、旋转四元数、缩放向量。
         * @param translation 平移向量。
         * @param rotation 旋转四元数。
         * @param scale 缩放向量。
         * @returns 是否分解成功。
         */
        decomposeTransRotScale(translation: Vector3, rotation: Quaternion, scale: Vector3): boolean;
        /**
         * @en Decompose the matrix into translation vector, rotation matrix, and scale vector.
         * @param translation The translation vector.
         * @param rotationMatrix The rotation matrix.
         * @param scale The scale vector.
         * @returns Whether the decomposition was successful.
         * @zh 分解矩阵为平移向量、旋转矩阵、缩放向量。
         * @param translation 平移向量。
         * @param rotationMatrix 旋转矩阵。
         * @param scale 缩放向量。
         * @returns 是否分解成功。
         */
        decomposeTransRotMatScale(translation: Vector3, rotationMatrix: Matrix4x4, scale: Vector3): boolean;
        /**
         * @en Decompose the rotation matrix into Yaw-Pitch-Roll Euler angles.
         * @param yawPitchRoll Vector3 to store the resulting Euler angles (in radians).
         * @zh 分解旋转矩阵为Yaw-Pitch-Roll欧拉角。
         * @param yawPitchRoll 用于存储结果欧拉角的Vector3（单位为弧度）。
         */
        decomposeYawPitchRoll(yawPitchRoll: Vector3): void;
        /**
         * @en Normalize the matrix.
         * @zh 归一化矩阵。
         */
        normalize(): void;
        /**
         * @en Calculate the transpose of the matrix.
         * @returns The transposed matrix.
         * @zh 计算矩阵的转置矩阵。
         * @returns 转置后的矩阵。
         */
        transpose(): Matrix4x4;
        /**
         * @en Calculate the inverse of a matrix.
         * @param out The output matrix to store the result.
         * @zh 计算矩阵的逆矩阵。
         * @param out 用于存储结果的输出矩阵。
         */
        invert(out: Matrix4x4): void;
        /**
         * @en Calculate the Billboard matrix
         * @param objectPosition The position of the object
         * @param cameraPosition The position of the camera
         * @param cameraUp The up vector of the camera
         * @param cameraForward The forward vector of the camera
         * @param mat The transformation matrix to store the result
         * @zh 计算Billboard矩阵
         * @param objectPosition 物体位置
         * @param cameraPosition 相机位置
         * @param cameraUp 相机上向量
         * @param cameraForward 相机前向量
         * @param mat 用于存储结果的变换矩阵
         */
        static billboard(objectPosition: Vector3, cameraPosition: Vector3, cameraUp: Vector3, cameraForward: Vector3, mat: Matrix4x4): void;
        /**
         * @en Normalization
         * @zh 归一化
         */
        identity(): void;
        /**
         * @en Check if the matrix is an identity matrix
         * @zh 判断是否是单位矩阵
         */
        isIdentity(): boolean;
        /**
         * @en Clone the matrix to another object
         * @param destObject Clone Source
         * @zh 克隆矩阵到另一个对象
         * @param destObject 克隆源。
         */
        cloneTo(destObject: Matrix4x4): void;
        /**
         * @en Clone the matrix from a Float32Array
         * @param destObject The Float32Array to clone from
         * @zh 从Float32Array克隆矩阵
         * @param destObject 要克隆的Float32Array
         */
        cloneByArray(destObject: Float32Array): void;
        /**
         * @en Clone the matrix
         * @returns A new Matrix4x4 object with the same values
         * @zh 克隆矩阵
         * @returns 一个具有相同值的新Matrix4x4对象
         */
        clone(): any;
        /**
         * @en Convert a coordinate matrix
         * @param v3 Coordinate points
         * @param out The output matrix
         * @zh 转换一个坐标位矩阵
         * @param v3 坐标点
         * @param out 输出矩阵
         */
        static translation(v3: Vector3, out: Matrix4x4): void;
        /**
         * @en Get the translation vector from the matrix
         * @param out The output vector to store the translation
         * @zh 获取矩阵中的平移向量
         * @param out 用于存储平移向量的输出向量
         */
        getTranslationVector(out: Vector3): void;
        /**
         * @en Set the translation vector of the matrix
         * @param translate The vector representing the translation
         * @zh 设置矩阵的平移向量
         * @param translate 表示平移的向量
         */
        setTranslationVector(translate: Vector3): void;
        /**
         * @en Get the forward vector from the matrix
         * @param out The output vector to store the forward vector
         * @zh 获取矩阵的前向量
         * @param out 用于存储前向量的输出向量
         */
        getForward(out: Vector3): void;
        /**
         * @en Set the forward vector of the matrix
         * @param forward The vector representing the forward direction
         * @zh 设置矩阵的前向量
         * @param forward 表示前向方向的向量
         */
        setForward(forward: Vector3): void;
        /**
         * @en Determine if this matrix is an inverted matrix
         * @returns True if the matrix is inverted, false otherwise
         * @zh 判断此矩阵是否是反向矩阵
         * @returns 如果矩阵是反向的返回true，否则返回false
         */
        getInvertFront(): boolean;
    }
    /**
     * @en The `Point` object represents a location in a two-dimensional coordinate system, where x represents the horizontal axis and y represents the vertical axis.
     * @zh `Point` 对象表示二维坐标系统中的某个位置，其中 x 表示水平轴，y 表示垂直轴。
     */
    class Point {
        /**
         * @en Temporary public object for reuse.
         * @zh 临时使用的公用对象。
         */
        static TEMP: Point;
        /**
         * @private
         * @en Global empty point object (x=0, y=0), the content of this object is not allowed to be modified.
         * @zh 全局空的point对象(x=0，y=0)，不允许修改此对象内容。
         */
        static EMPTY: Point;
        /**
         * @en The horizontal coordinate of this point.
         * @zh 该点的水平坐标。
         */
        x: number;
        /**
         * @en The vertical coordinate of this point.
         * @zh 该点的垂直坐标。
         */
        y: number;
        /**
         * @en Creates a new Point object based on the specified coordinates.
         * @param x The horizontal coordinate. Default is 0.
         * @param y The vertical coordinate. Default is 0.
         * @zh 根据指定坐标，创建一个新的 Point 对象。
         * @param x 水平坐标。默认值为0。
         * @param y 垂直坐标。默认值为0。
         */
        constructor(x?: number, y?: number);
        /**
         * @en Create from object pool
         * @returns A Point object from the pool
         * @zh 从对象池创建
         * @returns 从对象池中获取的Point对象
         */
        static create(): Point;
        /**
         * @en Sets the members of Point to the specified values.
         * @param x The horizontal coordinate.
         * @param y The vertical coordinate.
         * @returns The current Point object.
         * @zh 将 Point 的成员设置为指定值。
         * @param x 水平坐标。
         * @param y 垂直坐标。
         * @returns 当前 Point 对象。
         */
        setTo(x: number, y: number): Point;
        /**
         * @en Reset the point to (0, 0)
         * @returns The current Point object.
         * @zh 重置点为(0, 0)
         * @returns 当前 Point 对象。
         */
        reset(): Point;
        /**
         * @en Recycle to the object pool for reuse
         * @zh 回收到对象池，方便复用
         */
        recover(): void;
        /**
         * @en Calculate the distance between the current point and the target point (x, y).
         * @param x The horizontal coordinate of the target point.
         * @param y The vertical coordinate of the target point.
         * @returns The distance between the current point and the target point.
         * @zh 计算当前点和目标点(x，y)的距离。
         * @param x 目标点的水平坐标。
         * @param y 目标点的垂直坐标。
         * @returns 返回当前点和目标点之间的距离。
         */
        distance(x: number, y: number): number;
        /**
         * @en Returns a string that contains the values of the x and y coordinates.
         * @zh 返回包含 x 和 y 坐标的值的字符串。
         */
        toString(): string;
        /**
         * @en Normalize the vector.
         * @zh 标准化向量。
         */
        normalize(): void;
        /**
         * @en Copy coordinates from another point
         * @param point The point to be copied from
         * @returns The current Point object.
         * @zh 复制另一个点的坐标
         * @param point 需要被复制的点
         * @returns 当前 Point 对象。
         */
        copy(point: Point): Point;
    }
    /**
     * @en The `Quaternion` class is used to create quaternions.
     * @zh `Quaternion` 类用于创建四元数。
     */
    class Quaternion implements IClone {
        /**
         * @en Default quaternion, read-only.
         * @zh 默认四元数，只读。
         */
        static readonly DEFAULT: Readonly<Quaternion>;
        /**
         * @en Invalid quaternion, read-only.
         * @zh 无效四元数，只读。
         */
        static readonly NAN: Readonly<Quaternion>;
        /**
         * @en Generate a quaternion from Euler angles (order is Yaw, Pitch, Roll)
         * @param yaw The yaw value
         * @param pitch The pitch value
         * @param roll The roll value
         * @param out The output quaternion
         * @zh 从欧拉角生成四元数（顺序为Yaw、Pitch、Roll）
         * @param yaw yaw值
         * @param pitch pitch值
         * @param roll roll值
         * @param out 输出四元数
         */
        static createFromYawPitchRoll(yaw: number, pitch: number, roll: number, out: Quaternion): void;
        /**
         * @en Multiply two quaternions
         * @param left The left quaternion
         * @param right The right quaternion
         * @param out The output quaternion
         * @zh 计算两个四元数相乘
         * @param left left四元数
         * @param right right四元数
         * @param out 输出四元数
         */
        static multiply(left: Quaternion, right: Quaternion, out: Quaternion): void;
        /**
         * @en Calculate a quaternion that rotates around an arbitrary axis.
         * @param axis The rotation axis
         * @param rad The rotation angle in radians
         * @param out The output quaternion after rotation
         * @zh 计算绕任意轴旋转的四元数。
         * @param axis 旋转轴
         * @param rad 旋转角度（以弧度为单位）
         * @param out 旋转后的输出四元数
         */
        static rotationAxisAngle(axis: Vector3, rad: number, out: Quaternion): void;
        private static arcTanAngle;
        private static angleTo;
        /**
         * @en Calculate a quaternion from the specified axis and angle.
         * @param axis The axis vector.
         * @param rad The angle in radians.
         * @param out The output quaternion.
         * @zh 从指定的轴和角度计算四元数。
         * @param axis 轴向量。
         * @param rad 角度（以弧度为单位）。
         * @param out 输出的四元数。
         */
        static createFromAxisAngle(axis: Vector3, rad: number, out: Quaternion): void;
        /**
         * @en Calculate a quaternion from a rotation matrix.
         * @param mat The rotation matrix.
         * @param out The output quaternion.
         * @zh 从旋转矩阵计算四元数。
         * @param mat 旋转矩阵。
         * @param out 输出的四元数。
         */
        static createFromMatrix4x4(mat: Matrix4x4, out: Quaternion): void;
        /**
         * @en Spherical linear interpolation between two quaternions.
         * @param left The left quaternion.
         * @param right The right quaternion.
         * @param t The interpolation factor, ranging from 0 to 1.
         * @param out The output quaternion.
         * @returns The output quaternion.
         * @zh 两个四元数之间的球面线性插值。
         * @param left 左侧四元数。
         * @param right 右侧四元数。
         * @param t 插值因子，范围从0到1。
         * @param out 输出的四元数。
         * @returns 输出的四元数。
         */
        static slerp(left: Quaternion, right: Quaternion, t: number, out: Quaternion): Quaternion;
        /**
         * @en Calculate the linear interpolation between two quaternions.
         * @param left The left quaternion.
         * @param right The right quaternion.
         * @param amount The interpolation factor, ranging from 0 to 1.
         * @param out The output quaternion.
         * @zh 计算两个四元数的线性插值。
         * @param left 左侧四元数。
         * @param right 右侧四元数。
         * @param amount 插值因子，范围从0到1。
         * @param out 输出的四元数。
         */
        static lerp(left: Quaternion, right: Quaternion, amount: number, out: Quaternion): void;
        /**
         * @en Calculate the sum of two quaternions.
         * @param left The left quaternion.
         * @param right The right quaternion.
         * @param out The output quaternion.
         * @zh 计算两个四元数的和。
         * @param left 左侧四元数。
         * @param right 右侧四元数。
         * @param out 输出的四元数。
         */
        static add(left: Quaternion, right: Quaternion, out: Quaternion): void;
        /**
         * @en Calculate the dot product of two quaternions.
         * @param left The left quaternion.
         * @param right The right quaternion.
         * @returns The dot product.
         * @zh 计算两个四元数的点积。
         * @param left 左侧四元数。
         * @param right 右侧四元数。
         * @returns 点积结果。
         */
        static dot(left: Quaternion, right: Quaternion): number;
        /**
         * @en X-axis coordinate.
         * @zh X轴坐标。
         */
        x: number;
        /**
         * @en Y-axis coordinate.
         * @zh Y轴坐标。
         */
        y: number;
        /**
         * @en Z-axis coordinate.
         * @zh Z轴坐标。
         */
        z: number;
        /**
         * @en W-axis coordinate.
         * @zh W轴坐标。
         */
        w: number;
        /**
         * @en Constructor method, initializes the default value.
         * @param x The x value of the quaternion. Default is 0.
         * @param y The y value of the quaternion. Default is 0.
         * @param z The z value of the quaternion. Default is 0.
         * @param w The w value of the quaternion. Default is 1.
         * @zh 构造方法,初始化为默认值。
         * @param x 四元数的x值。默认为0。
         * @param y 四元数的y值。默认为0。
         * @param z 四元数的z值。默认为0。
         * @param w 四元数的w值。默认为1。
         */
        constructor(x?: number, y?: number, z?: number, w?: number);
        /**
         * @en Set the values of the quaternion.
         * @param x The X value.
         * @param y The Y value.
         * @param z The Z value.
         * @param w The W value.
         * @zh 设置四元数的值。
         * @param x X值。
         * @param y Y值。
         * @param z Z值。
         * @param w W值。
         */
        setValue(x: number, y: number, z: number, w: number): void;
        /**
         * @en Set the values of the quaternion and return itself.
         * @param x The X value.
         * @param y The Y value.
         * @param z The Z value.
         * @param w The W value.
         * @returns The quaternion itself.
         * @zh 设置四元数的值并返回自身。
         * @param x X值。
         * @param y Y值。
         * @param z Z值。
         * @param w W值。
         * @returns 四元数自身。
         */
        set(x: number, y: number, z: number, w: number): this;
        /**
         * @en Scale the quaternion by a scalar value.
         * @param scaling The scalar value to scale by.
         * @param out The output quaternion.
         * @zh 根据缩放值缩放四元数。
         * @param scaling 缩放值。
         * @param out 输出的四元数。
         */
        scaling(scaling: number, out: Quaternion): void;
        /**
         * @en Normalize the quaternion.
         * @param out The output normalized quaternion.
         * @zh 归一化四元数。
         * @param out 输出的归一化四元数。
         */
        normalize(out: Quaternion): void;
        /**
         * @en Calculate the length of the quaternion.
         * @returns The length of the quaternion.
         * @zh 计算四元数的长度。
         * @returns 四元数的长度。
         */
        length(): number;
        /**
         * @en Rotate the quaternion around the X axis.
         * @param rad The angle of rotation.
         * @param out The output rotated quaternion.
         * @zh 根据绕X轴的角度旋转四元数。
         * @param rad 旋转角度。
         * @param out 输出的旋转后的四元数。
         */
        rotateX(rad: number, out: Quaternion): void;
        /**
         * @en Rotate the quaternion around the Y axis by a specified angle.
         * @param rad The angle of rotation.
         * @param out The output rotated quaternion.
         * @zh 根据绕Y轴的指定角度旋转四元数。
         * @param rad 旋转角度。
         * @param out 输出的旋转后的四元数。
         */
        rotateY(rad: number, out: Quaternion): void;
        /**
         * @en Rotate the quaternion around the Z axis by a specified angle.
         * @param rad The angle of rotation.
         * @param out The output rotated quaternion.
         * @zh 根据绕Z轴的指定角度旋转四元数。
         * @param rad 旋转角度。
         * @param out 输出的旋转后的四元数。
         */
        rotateZ(rad: number, out: Quaternion): void;
        /**
         * @en Decompose the quaternion into Euler angles (in the order of Yaw, Pitch, Roll).
         * Note: This method may produce sudden flips when rotating around the X axis beyond ±90 degrees.
         * @param out The output Vector3 to store the Euler angles.
         * @zh 将四元数分解为欧拉角（按Yaw、Pitch、Roll的顺序）。
         * 注意：当绕X轴旋转超过±90度时，此方法可能会产生突然的翻转。
         * @param out 用于存储欧拉角的输出Vector3。
         */
        getYawPitchRoll(out: Vector3): void;
        /**
         * @en Calculate the inverse of the quaternion.
         * @param out The output inverted quaternion.
         * @zh 计算四元数的逆。
         * @param out 输出的逆四元数。
         */
        invert(out: Quaternion): void;
        /**
         * @en Set the quaternion to identity quaternion.
         * @zh 将四元数设置为单位四元数。
         */
        identity(): void;
        /**
         * @en Copy values from an array.
         * @param array The source array.
         * @param offset The start offset in the array. Default is 0.
         * @zh 从数组中拷贝值。
         * @param array 源数组。
         * @param offset 数组中的起始偏移量。默认为0。
         */
        fromArray(array: any[], offset?: number): void;
        /**
         * @en Clone the quaternion to a destination object.
         * @param destObject The destination object.
         * @zh 克隆四元数到目标对象。
         * @param destObject 目标对象。
         */
        cloneTo(destObject: Quaternion): void;
        /**
         * @en Clone the quaternion.
         * @returns A new quaternion with the same values as this one.
         * @zh 克隆四元数。
         * @returns 一个与当前四元数值相同的新四元数。
         */
        clone(): any;
        /**
         * @en Determines if two quaternions are equal.
         * @param b The quaternion to compare with.
         * @zh 如果四元数相等则返回true，否则返回false。
         * @param b 对比四元数
         */
        equals(b: Quaternion): boolean;
        /**
         * @en Calculates a rotation quaternion to look at a direction.
         * @param forward The forward direction.
         * @param up The up vector.
         * @param out The output quaternion.
         * @zh 计算旋转观察四元数。
         * @param	forward 方向
         * @param	up     上向量
         * @param	out    输出四元数
         */
        static rotationLookAt(forward: Vector3, up: Vector3, out: Quaternion): void;
        /**
         * @en Calculates a look-at quaternion (suitable for Camera and Light).
         * @param eye The position of the observer.
         * @param target The target position to look at.
         * @param up The up vector.
         * @param out The output quaternion.
         * @zh 计算观察四元数（适用于相机和灯光）。
         * @param	eye    观察者位置
         * @param	target 目标位置
         * @param	up     上向量
         * @param	out    输出四元数
         */
        static lookAt(eye: Vector3, target: Vector3, up: Vector3, out: Quaternion): void;
        /**
         * @en Calculates a look-at quaternion (suitable for GameObject).
         * @param eye The position of the observer.
         * @param target The target position to look at.
         * @param up The up vector.
         * @param out The output quaternion.
         * @zh 计算观察四元数（适用于游戏对象）。
         * @param eye 观察者位置
         * @param target 目标位置
         * @param up 上向量
         * @param out 输出四元数
         */
        static forwardLookAt(eye: Vector3, target: Vector3, up: Vector3, out: Quaternion): void;
        /**
         * @en Calculates the squared length of the quaternion.
         * @returns The squared length of the quaternion.
         * @zh 计算四元数长度的平方。
         * @returns 四元数长度的平方。
         */
        lengthSquared(): number;
        /**
         * @en Calculates the inverse of a quaternion.
         * @param value The input quaternion.
         * @param out The output inverse quaternion.
         * @zh 计算四元数的逆四元数。
         * @param	value 四元数。
         * @param	out 逆四元数。
         */
        static invert(value: Quaternion, out: Quaternion): void;
        /**
         * @en Creates a quaternion from a 3x3 rotation matrix.
         * @param matrix3x3 The 3x3 rotation matrix.
         * @param out The output quaternion.
         * @zh 通过一个3x3旋转矩阵创建一个四元数。
         * @param	matrix3x3  3x3矩阵
         * @param	out        四元数
         */
        static rotationMatrix(matrix3x3: Matrix3x3, out: Quaternion): void;
    }
    /**
     * @en The `Rectangle` object is an area defined by its position, as indicated by its top-left corner point (x, y), and by its width and height.
     * The x, y, width, and height properties of the Rectangle class are independent of each other; changing the value of one property has no effect on the others.
     * @zh `Rectangle` 对象是按其位置（由它左上角的点 (x, y) 确定）以及宽度和高度定义的区域。
     * Rectangle 类的 x、y、width 和 height 属性相互独立；更改一个属性的值不会影响其他属性。
     */
    class Rectangle implements IClone {
        /**
         * @private
         * @en Global empty rectangle area with x=0, y=0, width=0, height=0. The content of this object is not allowed to be modified.
         * @zh 全局空的矩形区域，x=0, y=0, width=0, height=0。不允许修改此对象内容。
         */
        static EMPTY: Rectangle;
        /**
         * @en Global temporary rectangle area. This object is used for global reuse to reduce object creation.
         * @zh 全局临时的矩形区域，此对象用于全局复用，以减少对象创建。
         */
        static TEMP: Rectangle;
        /**
         * @en The x coordinate of the top-left corner of the rectangle.
         * @zh 矩形左上角的 X 轴坐标。
         */
        x: number;
        /**
         * @en The y coordinate of the top-left corner of the rectangle.
         * @zh 矩形左上角的 Y 轴坐标。
         */
        y: number;
        /**
         * @en The width of the rectangle.
         * @zh 矩形的宽度。
         */
        width: number;
        /**
         * @en The height of the rectangle.
         * @zh 矩形的高度。
         */
        height: number;
        /**
         * @en Constructor method.
         * @param x The x coordinate of the top-left corner of the rectangle.
         * @param y The y coordinate of the top-left corner of the rectangle.
         * @param width The width of the rectangle.
         * @param height The height of the rectangle.
         * @zh 构造方法
         * @param	x 矩形左上角的 X 轴坐标。
         * @param	y 矩形左上角的 Y 轴坐标。
         * @param	width 矩形的宽度。
         * @param	height 矩形的高度。
         */
        constructor(x?: number, y?: number, width?: number, height?: number);
        /**
         * @en The x-coordinate of the right side of this rectangle. It is equal to the sum of the x and width properties.
         * @zh 此矩形右侧的 X 轴坐标。等于 x 和 width 属性的和。
         */
        get right(): number;
        /**
         * @en The y-coordinate of the bottom side of this rectangle. It is equal to the sum of the y and height properties.
         * @zh 此矩形底端的 Y 轴坐标。等于 y 和 height 属性的和。
         */
        get bottom(): number;
        /**
         * @en Sets the properties of the Rectangle to the specified values.
         * @param x The x-coordinate of the top-left corner of the rectangle.
         * @param y The y-coordinate of the top-left corner of the rectangle.
         * @param width The width of the rectangle.
         * @param height The height of the rectangle.
         * @return The rectangle object itself after the property values have been modified.
         * @zh 将 Rectangle 的属性设置为指定值。
         * @param	x	x 矩形左上角的 X 轴坐标。
         * @param	y	x 矩形左上角的 Y 轴坐标。
         * @param	width	矩形的宽度。
         * @param	height	矩形的高。
         * @return	返回属性值修改后的矩形对象本身。
         */
        setTo(x: number, y: number, width: number, height: number): Rectangle;
        /**
         * @en Resets the rectangle to default values (x=0, y=0, width=0, height=0).
         * @zh 重置矩形为默认值（x=0, y=0, width=0, height=0）。
         */
        reset(): Rectangle;
        /**
         * @en Recycles the rectangle object.
         * @zh 回收矩形对象。
         */
        recover(): void;
        /**
         * @en Creates a new Rectangle object from the object pool.
         * @zh 从对象池中创建一个新的 Rectangle 对象。
         */
        static create(): Rectangle;
        /**
         * @en Copies the property values from the source Rectangle object to this rectangle object.
         * @param source The source Rectangle object.
         * @returns The rectangle object itself after the property values have been modified.
         * @zh 复制源 Rectangle 对象的属性值到此矩形对象中。
         * @param source 源 Rectangle 对象。
         * @return 返回属性值修改后的矩形对象本身。
         */
        copyFrom(source: Rectangle): Rectangle;
        /**
         * @en Determines whether the specified point is contained within the rectangular region defined by this Rectangle object.
         * @param x The x-coordinate of the point (horizontal position).
         * @param y The y-coordinate of the point (vertical position).
         * @return True if the Rectangle object contains the specified point; false otherwise.
         * @zh 确定由此 Rectangle 对象定义的矩形区域内是否包含指定的点。
         * @param x	点的 X 轴坐标值（水平位置）。
         * @param y	点的 Y 轴坐标值（垂直位置）。
         * @return	如果 Rectangle 对象包含指定的点，则值为 true；否则为 false。
         */
        contains(x: number, y: number): boolean;
        /**
         * @en Determines whether the object specified in the rect parameter intersects with this Rectangle object. This method checks the x, y, width, and height properties of the specified Rectangle object to see if it intersects with this Rectangle object.
         * @param rect The Rectangle object to compare.
         * @returns True if the specified rectangle intersects with this one, false otherwise.
         * @zh 确定在 rect 参数中指定的对象是否与此 Rectangle 对象相交。此方法检查指定的 Rectangle 对象的 x、y、width 和 height 属性，以查看它是否与此 Rectangle 对象相交。
         * @param	rect Rectangle 对象。
         * @return	如果传入的矩形对象与此对象相交，则返回 true 值，否则返回 false。
         */
        intersects(rect: Readonly<Rectangle>): boolean;
        /**
         * @en If the Rectangle object specified in the rect parameter intersects with this Rectangle object, returns the area of intersection as a Rectangle object. If the rectangles do not intersect, this method returns null.
         * @param rect The rectangle to compare against.
         * @param out (Optional) The rectangle object for storing the output. If null, a new one will be created. It is allowed to be the same as rect or this.
         * @returns The intersection area as a Rectangle object, or null if there's no intersection.
         * @zh 如果在 rect 参数中指定的 Rectangle 对象与此 Rectangle 对象相交，则返回交集区域作为 Rectangle 对象。如果矩形不相交，则此方法返回null。
         * @param rect 待比较的矩形区域。
         * @param out （可选）待输出的矩形区域。如果为空则创建一个新的。允许out与rect或者this相同。
         * @return	返回相交的矩形区域对象。
         */
        intersection(rect: Rectangle, out?: Rectangle): Rectangle;
        /**
         * @en Adds two rectangles together to create a new Rectangle object, by filling in the horizontal and vertical space between the two rectangles.
         * Note: The union() method ignores rectangles with a height or width of 0, such as: var rect2:Rectangle = new Rectangle(300,300,50,0);
         * @param source The Rectangle object to add to this Rectangle object.
         * @param out The Rectangle object to store the output. If null, a new one will be created. It is allowed to be the same as rect or this.
         * @returns A new Rectangle object that is the union of the two rectangles.
         * @zh 矩形联合，通过填充两个矩形之间的水平和垂直空间，将这两个矩形组合在一起以创建一个新的 Rectangle 对象。
         * 注意：union() 方法忽略高度或宽度值为 0 的矩形，如：var rect2:Rectangle = new Rectangle(300,300,50,0);
         * @param source 要添加到此 Rectangle 对象的 Rectangle 对象。
         * @param out	用于存储输出结果的矩形对象。如果为空，则创建一个新的。允许out与rect或者this相同。
         * @return	充当两个矩形的联合的新 Rectangle 对象。
         */
        union(source: Rectangle, out?: Rectangle): Rectangle;
        /**
         * @zh 缩放矩形
         * @param scaleX X缩放值
         * @param scaleY Y缩放值
         * @returns 本对象
         * @en Scales the rectangle.
         * @param scaleX The scaling factor in the x-direction.
         * @param scaleY The scaling factor in the y-direction.
         * @returns This object.
         */
        scale(scaleX: number, scaleY: number): this;
        /**
         * @en Returns a string representation of this Rectangle object, with the x, y, width, and height values joined by commas.
         * @zh 返回当前 Rectangle 对象的字符串表示，其中水平位置 x、垂直位置 y、宽度 width 和高度 height 以逗号连接。
         */
        toString(): string;
        /**
         * @en Checks if the properties of the input Rectangle object are equal to the properties of the current Rectangle object (x, y, width, height).
         * @param rect The Rectangle object to compare.
         * @returns True if all properties are equal, false otherwise.
         * @zh 检测传入的 Rectangle 对象的属性是否与当前 Rectangle 对象的属性 x、y、width、height 属性值都相等。
         * @param	rect	待比较的 Rectangle 对象。
         * @return	如果判断的属性都相等，则返回 true 值，否则返回 false。
         */
        equals(rect: Rectangle): boolean;
        /**
         * @en Adds a point to the current rectangle object, expanding it to the smallest rectangle that contains both the current rectangle and the given point.
         * This method modifies the current object.
         * @param x The x-coordinate of the point.
         * @param y The y-coordinate of the point.
         * @return This Rectangle object.
         * @zh 为当前矩形对象加一个点，以使当前矩形扩展为包含当前矩形和此点的最小矩形。
         * 此方法会修改本对象。
         * @param x	点的 X 坐标。
         * @param y	点的 Y 坐标。
         * @return 返回此 Rectangle 对象。
         */
        addPoint(x: number, y: number): Rectangle;
        /**
         * @en Determines whether this Rectangle object is empty.
         * @returns True if the width or height of the Rectangle object is less than or equal to 0, false otherwise.
         * @zh 确定此 Rectangle 对象是否为空。
         * @return 如果 Rectangle 对象的宽度或高度小于等于 0，则返回 true 值，否则返回 false。
         */
        isEmpty(): boolean;
        /**
         * @en Returns a new Rectangle object with the same values for the x, y, width, and height properties as the original Rectangle object.
         * @param out (Optional) The rectangle object used to store the result. If null, a new one is created. Recommendation: Reuse objects as much as possible to reduce object creation overhead. The Rectangle.TEMP object can be used for object reuse.
         * @returns A Rectangle object with the same values for x, y, width, and height properties as the current Rectangle object.
         * @zh 返回一个新的 Rectangle 对象，其 x、y、width 和 height 属性的值与当前 Rectangle 对象的对应值相同。
         * @param out （可选）用于存储结果的矩形对象。如果为空，则创建一个新的。建议：尽量复用对象，减少对象创建消耗。Rectangle.TEMP对象用于对象复用。
         * @return 一个 Rectangle 对象，其 x、y、width 和 height 属性的值与当前 Rectangle 对象的对应值相同。
         */
        clone(out?: Rectangle | null): Rectangle;
        /**
         * @en Copies the properties of this Rectangle to the destination object.
         * @param destObject The destination object to copy to.
         * @zh 将此 Rectangle 的属性复制到目标对象。
         * @param destObject 目标对象。
         */
        cloneTo(destObject: Rectangle): void;
    }
    interface IV2 {
        x: number;
        y: number;
    }
    /**
     * @en The `Vector2` class is used to create two-dimensional vectors.
     * @zh `Vector2` 类用于创建二维向量。
     */
    class Vector2 implements IClone {
        /**
         * @en Zero vector, read-only.
         * @zh 零向量，只读。
         */
        static readonly ZERO: Readonly<Vector2>;
        /**
         * @en One vector, read-only.
         * @zh 单位向量，只读。
         */
        static readonly ONE: Readonly<Vector2>;
        /**
         * @en Temporary Vector2 for calculations.
         * @zh 用于计算的临时 Vector2。
         */
        static TempVector2: Vector2;
        /**
         * @en X-axis coordinate.
         * @zh X 轴坐标。
         */
        x: number;
        /**
         * @en Y-axis coordinate.
         * @zh Y 轴坐标。
         */
        y: number;
        /**
         * @en Constructor method.
         * @param x X-axis coordinate.
         * @param y Y-axis coordinate.
         * @zh 构造方法
         * @param x X 轴坐标。
         * @param y Y 轴坐标。
         */
        constructor(x?: number, y?: number);
        /**
         * @en Sets the x and y values of the vector.
         * @param x The x value to set.
         * @param y The y value to set.
         * @zh 设置向量的 x 和 y 值。
         * @param x 要设置的 X 值。
         * @param y 要设置的 Y 值。
         */
        setValue(x: number, y: number): void;
        /**
         * @en Scales a two-dimensional vector.
         * @param a Source two-dimensional vector.
         * @param b Scale value.
         * @param out Output two-dimensional vector.
         * @zh 缩放二维向量。
         * @param a 源二维向量。
         * @param b 缩放值。
         * @param out 输出二维向量。
         */
        static scale(a: Vector2, b: number, out: Vector2): void;
        /**
         * @en Determines whether two two-dimensional vectors are equal.
         * @param a First two-dimensional vector.
         * @param b Second two-dimensional vector.
         * @returns Whether the vectors are equal.
         * @zh 判断两个二维向量是否相等。
         * @param a 第一个二维向量。
         * @param b 第二个二维向量。
         * @returns 是否相等。
         */
        static equals(a: Vector2, b: Vector2): boolean;
        /**
         * @en Copies values from an array.
         * @param array The source array.
         * @param offset The offset in the array. Default is 0.
         * @zh 从数组中拷贝值。
         * @param array 源数组。
         * @param offset 数组偏移。默认值为 0。
         */
        fromArray(array: ArrayLike<number>, offset?: number): void;
        /**
         * @en Converts the vector to an array.
         * @returns An array representation of the vector.
         * @zh 将向量转换为数组。
         * @returns 表示向量的数组。
         */
        toArray(): Array<number>;
        /**
         * @en Writes the vector to a Float32Array.
         * @param array The target Float32Array.
         * @param offset The offset in the array. Default is 0.
         * @zh 将向量写入 Float32Array 数组。
         * @param array 目标 Float32Array 数组。
         * @param offset 数组偏移。默认值为 0。
         */
        writeTo(array: Float32Array, offset?: number): void;
        /**
         * @en Clones the vector to another object.
         * @param destObject The destination object to clone to.
         * @zh 将向量克隆到另一个对象。
         * @param destObject 克隆的目标对象。
         */
        cloneTo(destObject: Vector2): void;
        /**
         * @en Calculates the dot product of two 2D vectors.
         * @param a The left vector.
         * @param b The right vector.
         * @returns The dot product.
         * @zh 计算两个二维向量的点积。
         * @param a 左向量。
         * @param b 右向量。
         * @returns 点积。
         */
        static dot(a: Vector2, b: Vector2): number;
        /**
         * @en Normalizes a 2D vector.
         * @param s The source 2D vector.
         * @param out The output normalized 2D vector.
         * @zh 归一化二维向量。
         * @param s 源二维向量。
         * @param out 输出的归一化二维向量。
         */
        static normalize(s: Vector2, out: Vector2): void;
        /**
         * @en Calculates the scalar length of a 2D vector.
         * @param a The source 2D vector.
         * @returns The scalar length.
         * @zh 计算二维向量的标量长度。
         * @param a 源二维向量。
         * @returns 标量长度。
         */
        static scalarLength(a: Vector2): number;
        /**
         * @en Creates a clone of this Vector2.
         * @returns Cloned copy of Vector2.
         * @zh 创建此Vector2的克隆。
         * @returns 克隆副本。
         */
        clone(): any;
    }
    /**
     * @en The `Vector3` class is used to create three-dimensional vectors.
     * @zh `Vector3` 类用于创建三维向量。
     */
    class Vector3 implements IClone {
        /**
         * @en Zero vector (0, 0, 0).
         * @zh 零向量 (0, 0, 0)。
         */
        static readonly ZERO: Readonly<Vector3>;
        /**
         * @en One vector (1, 1, 1).
         * @zh 单位向量 (1, 1, 1)。
         */
        static readonly ONE: Readonly<Vector3>;
        /**
         * @en Negative X axis (-1, 0, 0).
         * @zh 负X轴 (-1, 0, 0)。
         */
        static readonly NegativeUnitX: Readonly<Vector3>;
        /**
         * @en Positive X axis (1, 0, 0).
         * @zh 正X轴 (1, 0, 0)。
         */
        static readonly UnitX: Readonly<Vector3>;
        /**
         * @en Positive Y axis (0, 1, 0).
         * @zh 正Y轴 (0, 1, 0)。
         */
        static readonly UnitY: Readonly<Vector3>;
        /**
         * @en Positive Z axis (0, 0, 1).
         * @zh 正Z轴 (0, 0, 1)。
         */
        static readonly UnitZ: Readonly<Vector3>;
        /**
         * @en Forward vector in right-handed coordinate system (0, 0, -1).
         * @zh 右手坐标系中的前向量 (0, 0, -1)。
         */
        static readonly ForwardRH: Readonly<Vector3>;
        /**
         * @en Forward vector in left-handed coordinate system (0, 0, 1).
         * @zh 左手坐标系中的前向量 (0, 0, 1)。
         */
        static readonly ForwardLH: Readonly<Vector3>;
        /**
         * @en Up vector (0, 1, 0).
         * @zh 上向量 (0, 1, 0)。
         */
        static readonly Up: Readonly<Vector3>;
        /**
         * @en Calculates the squared distance between two three-dimensional vectors.
         * @param value1 The first vector.
         * @param value2 The second vector.
         * @returns The squared distance.
         * @zh 计算两个三维向量之间距离的平方。
         * @param value1 第一个向量。
         * @param value2 第二个向量。
         * @returns 距离的平方。
         */
        static distanceSquared(value1: Vector3, value2: Vector3): number;
        /**
         * @en Calculates the distance between two three-dimensional vectors.
         * @param value1 The first vector.
         * @param value2 The second vector.
         * @returns The distance.
         * @zh 计算两个三维向量之间的距离。
         * @param value1 第一个向量。
         * @param value2 第二个向量。
         * @returns 距离。
         */
        static distance(value1: Vector3, value2: Vector3): number;
        /**
         * @en Calculates a new three-dimensional vector by taking the minimum of x, y, and z from two vectors.
         * @param a The first Vector3.
         * @param b The second Vector3.
         * @param out The resulting Vector3.
         * @zh 通过取两个三维向量的 x、y、z 的最小值计算新的三维向量。
         * @param a 第一个三维向量。
         * @param b 第二个三维向量。
         * @param out 结果三维向量。
         */
        static min(a: Vector3, b: Vector3, out: Vector3): void;
        /**
         * @en Calculates a new three-dimensional vector by taking the maximum of x, y, and z from two vectors.
         * @param a The first Vector3.
         * @param b The second Vector3.
         * @param out The resulting Vector3.
         * @zh 通过取两个三维向量的 x、y、z 的最大值计算新的三维向量。
         * @param a 第一个三维向量。
         * @param b 第二个三维向量。
         * @param out 结果三维向量。
         */
        static max(a: Vector3, b: Vector3, out: Vector3): void;
        /**
         * @en Rotates a three-dimensional vector by a quaternion.
         * @param source The source vector3 to be rotated.
         * @param rotation The rotation quaternion.
         * @param out The output vector3.
         * @zh 根据四元数旋转三维向量。
         * @param source 要旋转的源三维向量。
         * @param rotation 旋转四元数。
         * @param out 输出三维向量。
         */
        static transformQuat(source: Vector3, rotation: Quaternion, out: Vector3): void;
        /**
         * @en Calculates the scalar length of a vector.
         * @param a The source vector.
         * @returns The scalar length.
         * @zh 计算向量的标量长度。
         * @param a 源向量。
         * @returns 标量长度。
         */
        static scalarLength(a: Vector3): number;
        /**
         * @en Calculates the squared scalar length of a vector.
         * @param a The source three-dimensional vector.
         * @returns The squared scalar length.
         * @zh 计算标量长度的平方。
         * @param a 源三维向量。
         * @returns 标量长度的平方。
         */
        static scalarLengthSquared(a: Vector3): number;
        /**
         * @en Normalizes a three-dimensional vector.
         * @param s The source vector to be normalized.
         * @param out The output normalized vector.
         * @zh 归一化三维向量。
         * @param s 要归一化的源向量。
         * @param out 输出的归一化向量。
         */
        static normalize(s: Vector3, out: Vector3): void;
        /**
         * @en Calculates the product of two three-dimensional vectors.
         * @param a The left vector3.
         * @param b The right vector3.
         * @param out The output vector3.
         * @zh 计算两个三维向量的乘积。
         * @param a 左侧三维向量。
         * @param b 右侧三维向量。
         * @param out 输出三维向量。
         */
        static multiply(a: Vector3, b: Vector3, out: Vector3): void;
        /**
         * @en Scales a three-dimensional vector.
         * @param a The source vector3 to be scaled.
         * @param b The scaling factor.
         * @param out The output scaled vector3.
         * @zh 缩放三维向量。
         * @param a 要缩放的源三维向量。
         * @param b 缩放因子。
         * @param out 输出的缩放后的三维向量。
         */
        static scale(a: Vector3, b: number, out: Vector3): void;
        /**
         * @en Performs a linear interpolation between two three-dimensional vectors.
         * @param a The starting vector.
         * @param b The ending vector.
         * @param t The interpolation coefficient in the range [0, 1].
         * @param out The output interpolated vector.
         * @zh 在两个三维向量之间进行线性插值。
         * @param a 起始向量。
         * @param b 结束向量。
         * @param t 插值系数，范围为 [0, 1]。
         * @param out 输出的插值向量。
         */
        static lerp(a: Vector3, b: Vector3, t: number, out: Vector3): void;
        /**
         * @en Transforms a three-dimensional vector to another three-dimensional vector using a matrix.
         * @param vector The source vector3.
         * @param transform The transformation matrix.
         * @param result The output transformed vector3.
         * @zh 使用矩阵将一个三维向量转换为另一个三维向量。
         * @param vector 源三维向量。
         * @param transform 变换矩阵。
         * @param result 输出的转换后的三维向量。
         */
        static transformV3ToV3(vector: Vector3, transform: Matrix4x4, result: Vector3): void;
        /**
         * @en Transforms a three-dimensional vector to a four-dimensional vector using a matrix.
         * @param vector The source vector3.
         * @param transform The transformation matrix.
         * @param result The output vector4.
         * @zh 使用矩阵将三维向量转换为四维向量。
         * @param vector 源三维向量。
         * @param transform 变换矩阵。
         * @param result 输出的四维向量。
         */
        static transformV3ToV4(vector: Vector3, transform: Matrix4x4, result: Vector4): void;
        /**
         * @en Transforms a normal three-dimensional vector to another three-dimensional vector using a normal transformation matrix.
         * @param normal The source normal vector3.
         * @param transform The normal transformation matrix.
         * @param result The output transformed normal vector3.
         * @zh 使用法线变换矩阵将法线三维向量转换为另一个三维向量。
         * @param normal 源法线三维向量。
         * @param transform 法线变换矩阵。
         * @param result 输出转换后的法线三维向量。
         */
        static TransformNormal(normal: Vector3, transform: Matrix4x4, result: Vector3): void;
        /**
         * @en Transforms a three-dimensional vector to another normalized three-dimensional vector using a matrix.
         * @param coordinate The source three-dimensional vector.
         * @param transform The transformation matrix.
         * @param result The output normalized three-dimensional vector.
         * @zh 使用矩阵将三维向量转换为另一个归一化的三维向量。
         * @param coordinate 源三维向量。
         * @param transform 变换矩阵。
         * @param result 输出的归一化三维向量。
         */
        static transformCoordinate(coordinate: Vector3, transform: Matrix4x4, result: Vector3): void;
        /**
         * @en Clamps a vector within a specified range.
         * @param value The vector to be clamped.
         * @param min The minimum values for each component.
         * @param max The maximum values for each component.
         * @param out The output clamped vector.
         * @zh 将向量限制在指定范围内。
         * @param value 要限制的向量。
         * @param min 每个分量的最小值。
         * @param max 每个分量的最大值。
         * @param out 输出的限制后的向量。
         */
        static Clamp(value: Vector3, min: Vector3, max: Vector3, out: Vector3): void;
        /**
         * @en Calculates the sum of two three-dimensional vectors.
         * @param a The left vector3.
         * @param b The right vector3.
         * @param out The output vector3.
         * @zh 计算两个三维向量的和。
         * @param a 左侧三维向量。
         * @param b 右侧三维向量。
         * @param out 输出向量。
         */
        static add(a: Vector3, b: Vector3, out: Vector3): void;
        /**
         * @en Calculates the difference between two three-dimensional vectors.
         * @param a The left vector3.
         * @param b The right vector3.
         * @param o The output vector3.
         * @zh 计算两个三维向量的差。
         * @param a 左侧三维向量。
         * @param b 右侧三维向量。
         * @param o 输出向量。
         */
        static subtract(a: Vector3, b: Vector3, o: Vector3): void;
        /**
         * @en Calculates the cross product of two three-dimensional vectors.
         * @param a The left vector3.
         * @param b The right vector3.
         * @param o The output vector3.
         * @zh 计算两个三维向量的叉乘。
         * @param a 左侧三维向量。
         * @param b 右侧三维向量。
         * @param o 输出三维向量。
         */
        static cross(a: Vector3, b: Vector3, o: Vector3): void;
        /**
         * @en Calculates the dot product of two three-dimensional vectors.
         * @param a The left vector3.
         * @param b The right vector3.
         * @returns The dot product.
         * @zh 计算两个三维向量的点积。
         * @param a 左侧向量。
         * @param b 右侧向量。
         * @returns 点积。
         */
        static dot(a: Vector3, b: Vector3): number;
        /**
         * @en Determines whether two three-dimensional vectors are equal.
         * @param a The first vector3.
         * @param b The second vector3.
         * @returns Whether the vectors are equal.
         * @zh 判断两个三维向量是否相等。
         * @param a 第一个三维向量。
         * @param b 第二个三维向量。
         * @returns 是否相等。
         */
        static equals(a: Vector3, b: Vector3): boolean;
        /**
         * @en X-axis coordinate
         * @zh X轴坐标
         */
        x: number;
        /**
         * @en Y-axis coordinate
         * @zh Y轴坐标
         */
        y: number;
        /**
         * @en Z-axis coordinate
         * @zh Z轴坐标
         */
        z: number;
        /**
         * @en Constructor method, 3D vector initialization.
         * @param x X-axis coordinate.
         * @param y Y-axis coordinate.
         * @param z Z-axis coordinate.
         * @zh 构造方法，初始化三维向量。
         * @param x X轴坐标。
         * @param y Y轴坐标。
         * @param z Z轴坐标。
         */
        constructor(x?: number, y?: number, z?: number);
        /**
         * @en Determines whether the three-dimensional vector is equal to another vector.
         * @param value The vector to compare with.
         * @returns Returns true if the vectors are equal, false otherwise.
         * @zh 判断三维向量是否与另一个向量相等。
         * @param value 对比值
         * @returns 如果向量相等则返回 true，否则返回 false。
         */
        equal(value: Vector3): boolean;
        /**
         * @en Sets the x, y, and z values of the vector.
         * @param x The x value.
         * @param y The y value.
         * @param z The z value.
         * @zh 设置向量的 x、y 和 z 值。
         * @param x X值。
         * @param y Y值。
         * @param z Z值。
         */
        setValue(x: number, y: number, z: number): Vector3;
        /**
         * @en Sets the x, y, and z values of the vector.
         * @param x The x value.
         * @param y The y value.
         * @param z The z value.
         * @zh 设置向量的 x、y 和 z 值。
         * @param x X值。
         * @param y Y值。
         * @param z Z值。
         */
        set(x: number, y: number, z: number): this;
        /**
         * @en Copies values from an array.
         * @param arr The source array.
         * @param offset The offset in the array. Default is 0.
         * @zh 从数组中拷贝值。
         * @param arr 源数组。
         * @param offset 数组偏移。默认值为 0。
         */
        fromArray(arr: ArrayLike<number>, offset?: number): void;
        /**
         * @en Converts the vector to an array.
         * @zh 将向量转换为数组。
         */
        toArray(): Array<number>;
        /**
         * @en Writes the vector values to an array.
         * @param arr The target array.
         * @param offset The offset in the array. Default is 0.
         * @zh 将向量值写入数组。
         * @param arr 目标数组。
         * @param offset 数组偏移。默认值为 0。
         */
        writeTo(arr: Float32Array, offset?: number): void;
        /**
         * @en Calculates the length of the vector.
         * @zh 计算向量的长度。
         */
        length(): number;
        /**
         * @en Calculates the squared length of the vector.
         * @zh 计算向量长度的平方。
         */
        lengthSquared(): number;
        /**
         * @en Subtracts a vector from this vector.
         * @param b The vector to subtract.
         * @param out The output vector.
         * @returns The resulting vector.
         * @zh 向量相减
         * @param b 被减向量。
         * @param out 输出向量。
         * @returns 相减后的结果向量。
         */
        vsub(b: Vector3, out: Vector3): Vector3;
        /**
         * @en Adds a vector to this vector.
         * @param b The vector to add.
         * @param out The output vector.
         * @returns The resulting vector.
         * @zh 向量相加。
         * @param b 加向量。
         * @param out 输出向量。
         * @returns returns 相加后的结果向量。
         */
        vadd(b: Vector3, out: Vector3): Vector3;
        /**
         * @en Scales this vector by a scalar value.
         * @param s The scalar value.
         * @param out The output vector.
         * @returns The scaled vector.
         * @zh 缩放向量。
         * @param s 缩放值。
         * @param out 输出向量。
         * @returns 缩放后的向量。
         */
        scale(s: number, out: Vector3): Vector3;
        /**
         * @en Normalizes this vector.
         * @returns The normalized vector.
         * @zh 归一化向量。
         * @returns 归一化后的向量。
         */
        normalize(): this;
        /**
         * @en Calculates the dot product of this vector with another vector.
         * @param b The vector to dot product with.
         * @returns The dot product.
         * @zh 计算向量点乘。
         * @param b 点乘向量。
         * @returns 点乘结果。
         */
        dot(b: Vector3): number;
        /**
         * @en Calculates the cross product of this vector with another vector.
         * @param b The vector to cross product with.
         * @param o The output vector.
         * @returns The resulting cross product vector.
         * @zh 计算向量叉乘。
         * @param b 叉乘向量。
         * @param o 输出向量。
         * @returns 叉乘结果向量。
         */
        cross(b: Vector3, o: Vector3): Vector3;
        /**
         * @en Clones this vector to another object.
         * @param destObject The destination object to clone to.
         * @zh 将当前向量克隆到目标对象。
         * @param destObject 克隆的目标对象。
         */
        cloneTo(destObject: Vector3): void;
        /**
         * @en Creates a clone of this vector.
         * @returns A new Vector3 object with the same values as this vector.
         * @zh 创建当前向量的克隆。
         * @returns 返回一个新的 Vector3 对象，其值与当前向量相同。
         */
        clone(): any;
        /**
         * @en Sets this vector to its default value (0, 0, 0).
         * @zh 将当前向量设置为默认值 (0, 0, 0)。
         */
        toDefault(): void;
    }
    /**
     * @en The `Vector4` class is used to create four-dimensional vectors.
     * @zh `Vector4` 类用于创建四维向量。
     */
    class Vector4 implements IClone {
        /**
         * @en Zero vector (0, 0, 0, 0).
         * @zh 零向量 (0, 0, 0, 0)。
         */
        static readonly ZERO: Readonly<Vector4>;
        /**
         * @en One vector (1, 1, 1, 1).
         * @zh 一向量 (1, 1, 1, 1)。
         */
        static readonly ONE: Readonly<Vector4>;
        /**
         * @en Unit X vector (1, 0, 0, 0).
         * @zh X 单位向量 (1, 0, 0, 0)。
         */
        static readonly UnitX: Readonly<Vector4>;
        /**
         * @en Unit Y vector (0, 1, 0, 0).
         * @zh Y 单位向量 (0, 1, 0, 0)。
         */
        static readonly UnitY: Readonly<Vector4>;
        /**
         * @en Unit Z vector (0, 0, 1, 0).
         * @zh Z 单位向量 (0, 0, 1, 0)。
         */
        static readonly UnitZ: Readonly<Vector4>;
        /**
         * @en Unit W vector (0, 0, 0, 1).
         * @zh W 单位向量 (0, 0, 0, 1)。
         */
        static readonly UnitW: Readonly<Vector4>;
        /**
         * @en X coordinate.
         * @zh X 轴坐标。
         */
        x: number;
        /**
         * @en Y coordinate.
         * @zh Y 轴坐标。
         */
        y: number;
        /**
         * @en Z coordinate.
         * @zh Z 轴坐标。
         */
        z: number;
        /**
         * @en W coordinate.
         * @zh W 轴坐标。
         */
        w: number;
        /**
         * @en Constructor method, initializes the vector4.
         * @param x X coordinate. Default is 0.
         * @param y Y coordinate. Default is 0.
         * @param z Z coordinate. Default is 0.
         * @param w W coordinate. Default is 0.
         * @zh 构造方法，初始化四维向量。
         * @param x X 轴坐标。默认为 0。
         * @param y Y 轴坐标。默认为 0。
         * @param z Z 轴坐标。默认为 0。
         * @param w W 轴坐标。默认为 0。
         */
        constructor(x?: number, y?: number, z?: number, w?: number);
        /**
         * @en Sets the x, y, z, and w values of the vector.
         * @param x The x value.
         * @param y The y value.
         * @param z The z value.
         * @param w The w value.
         * @zh 设置向量的 x、y、z 和 w 值。
         * @param x X值。
         * @param y Y值。
         * @param z Z值。
         * @param w W值。
         */
        setValue(x: number, y: number, z: number, w: number): void;
        /**
         * @en Copies values from an array.
         * @param arr The source array.
         * @param offset The offset in the array. Default is 0.
         * @zh 从数组中拷贝值。
         * @param arr 源数组。
         * @param offset 数组偏移。默认值为 0。
         */
        fromArray(arr: ArrayLike<number>, offset?: number): void;
        /**
         * @en Converts the vector to an array.
         * @returns An array containing the vector components [x, y, z, w].
         * @zh 将向量转换为数组。
         * @returns 包含向量分量的数组 [x, y, z, w]。
         */
        toArray(): Array<number>;
        /**
         * @en Writes the vector values to a Float32Array.
         * @param arr The target Float32Array.
         * @param offset The offset in the array. Default is 0.
         * @zh 将向量值写入 Float32Array 数组。
         * @zh arr 目标 Float32Array 数组。
         * @zh offset 数组偏移。默认值为 0。
         */
        writeTo(arr: Float32Array, offset?: number): void;
        /**
         * @en Clones this vector to another object.
         * @param destObject The destination object to clone to.
         * @zh 将当前向量克隆到目标对象。
         * @param destObject 克隆的目标对象。
         */
        cloneTo(destObject: Vector4): void;
        /**
         * @en Creates a clone of this vector.
         * @returns A new Vector4 object with the same values as this vector.
         * @zh 创建当前向量的克隆。
         * @returns 返回一个新的 Vector4 对象，其值与当前向量相同。
         */
        clone(): any;
        /**
         * @en Performs a linear interpolation between two vectors.
         * @param a The first vector.
         * @param b The second vector.
         * @param t The interpolation coefficient.
         * @param out The output vector.
         * @zh 在两个向量之间进行线性插值。
         * @param a 起始向量。
         * @param b 目标向量。
         * @param t 插值系数。
         * @param out 输出向量。
         */
        static lerp(a: Vector4, b: Vector4, t: number, out: Vector4): void;
        /**
         * @en Transforms a Vector4 by a 4x4 matrix.
         * @param vector4 The vector to transform.
         * @param m4x4 The transformation matrix.
         * @param out The output vector.
         * @zh 通过 4x4 矩阵转换一个四维向量。
         * @param vector4 待转换的四维向量。
         * @param m4x4 4x4 变换矩阵。
         * @param out 转换后的四维向量。
         */
        static transformByM4x4(vector4: Vector4, m4x4: Matrix4x4, out: Vector4): void;
        /**
         * @en Determines whether two Vector4 objects are equal.
         * @param a The first Vector4.
         * @param b The second Vector4.
         * @returns True if the vectors are equal, false otherwise.
         * @zh 判断两个四维向量是否相等。
         * @param a 第一个四维向量。
         * @param b 第二个四维向量。
         * @returns 如果向量相等则返回 true，否则返回 false。
         */
        static equals(a: Vector4, b: Vector4): boolean;
        /**
         * @en Determines whether this vector is equal to another vector.
         * @param value The vector to compare with.
         * @returns True if the vectors are equal, false otherwise.
         * @zh 判断当前向量是否与另一个向量相等。
         * @param value 用于比较的向量。
         * @returns 如果向量相等则返回 true，否则返回 false。
         */
        equal(value: Vector4): boolean;
        /**
         * @en Calculates the length of the vector4.
         * @returns The length of the vector4.
         * @zh 计算四维向量的长度。
         * @return  四维向量的长度。
         */
        length(): number;
        /**
         * @en Calculates the squared length of the vector4.
         * @returns The squared length of the vector4.
         * @zh 计算四维向量长度的平方。
         * @returns 返回四维向量长度的平方。
         */
        lengthSquared(): number;
        /**
         * @en Normalize a vector4.
         * @param s Source vector4.
         * @param out Output vector4.
         * @zh 归一化四维向量。
         * @param s 源四维向量。
         * @param out 输出四维向量。
         */
        static normalize(s: Vector4, out: Vector4): void;
        /**
         * @en Calculate the sum of two four-dimensional vectors.
         * @param a First vector4.
         * @param b Second vector4.
         * @param out Output vector.
         * @zh 求两个四维向量的和。
         * @param a 第一个四维向量。
         * @param b 第二个四维向量。
         * @param out 输出向量。
         */
        static add(a: Vector4, b: Vector4, out: Vector4): void;
        /**
         * @en Calculate the difference between two four-dimensional vectors.
         * @param a First vector4.
         * @param b Second vector4.
         * @param out Output vector.
         * @zh 求两个四维向量的差。
         * @param a 第一个四维向量。
         * @param b 第二个四维向量。
         * @param out 输出向量。
         */
        static subtract(a: Vector4, b: Vector4, out: Vector4): void;
        /**
         * @en Calculate the product of two four-dimensional vectors.
         * @param a First vector4.
         * @param b Second vector4.
         * @param out Output vector.
         * @zh 计算两个四维向量的乘积。
         * @param a 第一个四维向量。
         * @param b 第二个四维向量。
         * @param out 输出向量。
         */
        static multiply(a: Vector4, b: Vector4, out: Vector4): void;
        /**
         * @en Scale a four-dimensional vector.
         * @param a Source vector4.
         * @param b Scale value.
         * @param out Output vector4.
         * @zh 缩放四维向量。
         * @param a 源四维向量。
         * @param b 缩放值。
         * @param out 输出四维向量。
         */
        static scale(a: Vector4, b: number, out: Vector4): void;
        /**
         * @en Clamp a four-dimensional vector within a specified range.
         * @param value Vector to be clamped.
         * @param min Minimum values.
         * @param max Maximum values.
         * @param out Output vector.
         * @zh 将四维向量限制在指定的范围内。
         * @param value 要限制的向量。
         * @param min 最小值。
         * @param max 最大值。
         * @param out 输出向量。
         */
        static Clamp(value: Vector4, min: Vector4, max: Vector4, out: Vector4): void;
        /**
         * @en Calculate the squared distance between two four-dimensional vectors.
         * @param value1 The first vector4.
         * @param value2 The second vector4.
         * @returns The squared distance.
         * @zh 计算两个四维向量之间距离的平方。
         * @param value1 第一个四维向量。
         * @param value2 第二个四维向量。
         * @returns 距离的平方。
         */
        static distanceSquared(value1: Vector4, value2: Vector4): number;
        /**
         * @en Calculate the distance between two four-dimensional vectors.
         * @param value1 The first vector.
         * @param value2 The second vector.
         * @returns The distance.
         * @zh 计算两个四维向量之间的距离。
         * @param value1 第一个向量。
         * @param value2 第二个向量。
         * @returns 距离。
         */
        static distance(value1: Vector4, value2: Vector4): number;
        /**
         * @en Calculate the dot product of two four-dimensional vectors.
         * @param a The first vector.
         * @param b The second vector.
         * @returns The dot product.
         * @zh 计算两个四维向量的点积。
         * @param a 第一个向量。
         * @param b 第二个向量。
         * @returns 点积。
         */
        static dot(a: Vector4, b: Vector4): number;
        /**
         * @en Calculate a new four-dimensional vector using the minimum values of x, y, z, and w from two vectors.
         * @param a The first vector4.
         * @param b The second vector4.
         * @param out The resulting vector4.
         * @zh 分别取两个四维向量x、y、z、w的最小值计算新的四维向量。
         * @param a 第一个四维向量。
         * @param b 第二个四维向量。
         * @param out 结果四维向量。
         */
        static min(a: Vector4, b: Vector4, out: Vector4): void;
        /**
         * @en Calculate a new four-dimensional vector using the maximum values of x, y, z, and w from two vectors.
         * @param a The first vector4.
         * @param b The second vector4.
         * @param out The resulting vector4.
         * @zh 分别取两个四维向量x、y、z、w的最大值计算新的四维向量。
         * @param a 第一个四维向量。
         * @param b 第二个四维向量。
         * @param out 结果四维向量。
         */
        static max(a: Vector4, b: Vector4, out: Vector4): void;
    }
    /**
     * @en The `Viewport` class is used to create a viewport.
     * @zh `Viewport` 类用于创建视口。
     */
    class Viewport {
        /**
         * @en X-axis coordinate
         * @zh X轴坐标
         */
        x: number;
        /**
         * @en Y-axis coordinate
         * @zh Y轴坐标
         */
        y: number;
        /**
         * @en Width
         * @zh 宽度
         */
        width: number;
        /**
         * @en Height
         * @zh 高度
         */
        height: number;
        /**
         * @en Minimum depth
         * @zh 最小深度
         */
        minDepth: number;
        /**
         * @en Maximum depth
         * @zh 最大深度
         */
        maxDepth: number;
        /**
         * @en Constructor method, initialize viewport.
         * @param x X-axis coordinate.
         * @param y Y-axis coordinate.
         * @param width Width.
         * @param height Height.
         * @zh 构造方法，初始化视口。
         * @param x X轴坐标。
         * @param y Y轴坐标。
         * @param width 宽度。
         * @param height 高度。
         */
        constructor(x?: number, y?: number, width?: number, height?: number);
        /**
         * @en Project a three-dimensional vector to viewport space.
         * @param source vector3.
         * @param matrix Transformation matrix.
         * @param out x, y, z are viewport space coordinates; in perspective projection, w is the z-axis coordinate relative to the transformation matrix.
         * @zh 投影一个三维向量到视口空间。
         * @param source 三维向量。
         * @param matrix 变换矩阵。
         * @param out x、y、z为视口空间坐标，透视投影下w为相对于变换矩阵的z轴坐标。
         */
        project(source: Vector3, matrix: Matrix4x4, out: Vector4): void;
        /**
         * @en Unproject a three-dimensional vector.
         * @param source Source vector3.
         * @param matrix Transformation matrix.
         * @param out Output vector3.
         * @zh 反变换一个三维向量。
         * @param source 源三维向量。
         * @param matrix 变换矩阵。
         * @param out 输出三维向量。
         */
        unprojectFromMat(source: Vector3, matrix: Matrix4x4, out: Vector3): void;
        /**
         * @en Unproject a three-dimensional vector using World-View-Projection matrices.
         * @param source Source vector3.
         * @param projection Perspective projection matrix.
         * @param view View matrix.
         * @param world World matrix, can be set to null.
         * @param out Output vector.
         * @zh 使用世界-视图-投影矩阵反变换一个三维向量。
         * @param source 源三维向量。
         * @param projection 透视投影矩阵。
         * @param view 视图矩阵。
         * @param world 世界矩阵，可设置为null。
         * @param out 输出向量。
         */
        unprojectFromWVP(source: Vector3, projection: Matrix4x4, view: Matrix4x4, world: Matrix4x4, out: Vector3): void;
        /**
         * @en Set viewport values.
         * @param x X-axis coordinate.
         * @param y Y-axis coordinate.
         * @param width Width.
         * @param height Height.
         * @zh 设置视口值。
         * @param x X轴坐标。
         * @param y Y轴坐标。
         * @param width 宽度。
         * @param height 高度。
         */
        set(x: number, y: number, width: number, height: number): void;
        /**
         * @en Clone the viewport.
         * @param out Output viewport.
         * @zh 克隆视口。
         * @param out 输出视口。
         */
        cloneTo(out: Viewport): void;
    }
    /**
     * @en Use Audio tag to play sound
     * @zh 使用Audio标签播放声音
     */
    class AudioSound extends EventDispatcher {
        private static _audioCache;
        /**
         * @en Sound URL
         * @zh 声音URL
         */
        url: string;
        /**
         * @en Audio tag used for playback
         * @zh 播放用的audio标签
         */
        audio: HTMLAudioElement;
        /**
         * @en Whether it has been loaded
         * @zh 是否已加载完成
         */
        loaded: boolean;
        /**
         * @en Release the sound
         * @zh 释放声音
         */
        dispose(): void;
        private static _makeMusicOK;
        /**
         * @en Load the sound
         * @param url The URL of the sound to load
         * @zh 加载声音
         * @param url 要加载的声音的URL
         */
        load(url: string): void;
        /**
         * @en Play the sound
         * @param startTime The start time of playback
         * @param loops The number of times to loop the sound
         * @returns The sound channel
         * @zh 播放声音
         * @param startTime 播放的起始时间
         * @param loops 循环播放次数
         * @returns 声音通道
         */
        play(startTime?: number, loops?: number): SoundChannel;
        /**
         * @en Total time
         * @zh 总时间。
         */
        get duration(): number;
    }
    /**
     * @en Audio tag sound track control for playing sounds
     * @zh audio标签播放声音的音轨控制
     */
    class AudioSoundChannel extends SoundChannel {
        /**
         * 播放用的audio标签
         */
        private _audio;
        private _onEnd;
        private _resumePlay;
        private _src;
        /** @ignore */
        constructor(audio: HTMLAudioElement);
        private __onEnd;
        private __resumePlay;
        /**
         * @en Play the sound
         * @zh 播放声音
         */
        play(): void;
        /**
         * @en The current playback position, in seconds.
         * @zh 当前播放到的位置,单位为秒
         */
        get position(): number;
        /**
         * @en The total duration of the sound, in seconds.
         * @zh 声音的总时长,单位为秒。
         */
        get duration(): number;
        /**
         * @en Stop playing
         * @zh 停止播放
         */
        stop(): void;
        /**
         * @en Pause the sound playback
         * @zh 暂停声音播放
         */
        pause(): void;
        /**
         * @en Resume the sound playback
         * @zh 恢复声音播放
         */
        resume(): void;
        /**
         * @en The volume of the sound
         * @zh 声音的音量
         */
        get volume(): number;
        set volume(v: number);
    }
    /**
     * @en `Sound` is an abstract base class for controlling sound.
     * @zh `Sound`是播放控制声音的抽象基类。
     */
    class Sound extends EventDispatcher {
        /**
         * @en Load the sound.
         * @param url The URL of the sound file.
         * @zh 加载声音。
         * @param url 声音文件的地址。
         */
        load(url: string): void;
        /**
         * @en Play the sound.
         * @param startTime The start time in seconds.
         * @param loops The number of times to loop the sound. 0 means loop indefinitely.
         * @returns A SoundChannel object representing the sound channel.
         * @zh 播放声音。
         * @param startTime 开始时间，单位为秒。
         * @param loops 循环次数，0表示一直循环。
         * @returns 声道 SoundChannel 对象。
         */
        play(startTime?: number, loops?: number): SoundChannel;
        /**
         * @en The total duration of the sound in seconds.
         * @zh 声音的总时间，以秒为单位。
         */
        get duration(): number;
        /**
         * @en Release the sound resources.
         * @zh 释放声音资源。
         */
        dispose(): void;
    }
    /**
     * @en The `SoundChannel` class is used to control sounds in the program. Each sound is assigned to a channel, and an application can have multiple channels mixed together.
     * The `SoundChannel` class contains methods for controlling sound playback, pause, stop, volume, as well as methods for getting information about the sound's playback status, total time, current playback time, total loop count, and playback address.
     * @zh `SoundChannel` 用来控制程序中的声音。每个声音均分配给一个声道，而且应用程序可以具有混合在一起的多个声道。
     * `SoundChannel` 类包含控制声音的播放、暂停、停止、音量的方法，以及获取声音的播放状态、总时间、当前播放时间、总循环次数、播放地址等信息的方法。
     */
    class SoundChannel extends EventDispatcher {
        /**
         * @en The URL of the sound.
         * @zh 声音地址。
         */
        url: string;
        /**
         * @en The number of loops.
         * @zh 循环次数。
         */
        loops: number;
        /**
         * @en The start time of sound playback.
         * @zh 播放声音开始时间。
         */
        startTime: number;
        /**
         * @en Indicates whether the sound is paused.
         * @zh 表示声音是否已暂停。
         */
        isStopped: boolean;
        /**
         * @en The handler for playback completion.
         * @zh 播放完成处理器。
         */
        completeHandler: Handler;
        /**
         * @en The volume. The volume range is from 0 (mute) to 1 (maximum volume).
         * @zh 音量。音量范围从 0（静音）至 1（最大音量）。
         */
        get volume(): number;
        set volume(v: number);
        /**
         * @en The current playback time in seconds.
         * @zh 当前播放时间，单位是秒。
         */
        get position(): number;
        /**
         * @en The total duration in seconds.
         * @zh 总时间，单位是秒。
         */
        get duration(): number;
        /**
         * @en Play the sound.
         * @zh 播放声音。
         */
        play(): void;
        /**
         * @en Stop playing the sound.
         * @zh 停止播放。
         */
        stop(): void;
        /**
         * @en Pause the sound playback.
         * @zh 暂停播放。
         */
        pause(): void;
        /**
         * @en Resume the sound playback.
         * @zh 继续播放。
         */
        resume(): void;
        protected __runComplete(handler: Handler): void;
    }
    /**
     * @en The `SoundManager` is a sound management class. It provides control methods for playing background music and sound effects.
     * - The engine has two default sound schemes: WebAudio and H5Audio.
     * - For playing sound effects, WebAudio is prioritized. If WebAudio is not available, H5Audio is used. H5Audio may have compatibility issues on some devices (such as inability to mix sounds or playback delays).
     * - For playing background music, H5Audio is used (using WebAudio would significantly increase memory usage and cause a delay as it needs to wait for the sound to load completely before playing).
     * - It is recommended to use mp3 format for background music and wav or mp3 format for sound effects (if packaging as an app, only wav format can be used for sound effects).
     * @zh `SoundManager` 是一个声音管理类。提供了对背景音乐、音效的播放控制方法。
     * - 引擎默认有两套声音方案：WebAudio和H5Audio。
     * - 播放音效时，优先使用WebAudio播放声音，如果WebAudio不可用，则用H5Audio播放。H5Audio在部分机器上有兼容问题（比如不能混音，播放有延迟等）。
     * - 播放背景音乐时，则使用H5Audio播放（使用WebAudio会增加特别大的内存，并且要等加载完毕后才能播放，有延迟）。
     * - 建议背景音乐用mp3类型，音效用wav或者mp3类型（如果打包为app，音效只能用wav格式）。
     */
    class SoundManager {
        /**
         * @en Background music volume. default value is 1.
         * @zh 背景音乐音量。默认值为1。
         */
        static musicVolume: number;
        /**
         * @en Sound effect volume. default value is 1.
         * @zh 音效音量。默认值为1。
         */
        static soundVolume: number;
        /**
         * @en Sound playback rate. default value is 1.
         * @zh 声音播放速率。默认值为1。
         */
        static playbackRate: number;
        /**
         * @en Background music uses the Audio tag for playback. The default is true.
         * @zh 背景音乐使用 Audio 标签播放。 默认值为true。
         */
        private static _useAudioMusic;
        /**
         * @en Indicates whether the audio is muted. The default is false.
         * @zh 是否静音，默认为 false。
         */
        private static _muted;
        /**
         * @en Indicates whether sound effects are muted. The default is false.
         * @zh 是否音效静音，默认为 false。
         */
        private static _soundMuted;
        /**
         * @en Indicates whether background music is muted. The default is false.
         * @zh 是否背景音乐静音，默认为 false。
         */
        private static _musicMuted;
        /**
         * @en The current background music URL.
         * @zh 当前背景音乐 URL。
         */
        static _bgMusic: string;
        /**
         * @en The current background music channel.
         * @zh 当前背景音乐声道。
         */
        static _musicChannel: SoundChannel;
        /**
         * @en The list of currently playing channels.
         * @zh 当前播放的 Channel 列表。
         */
        private static _channels;
        private static _autoStopMusic;
        private static _blurPaused;
        private static _isActive;
        private static _lastSoundUsedTimeDic;
        private static _isCheckingDispose;
        private static _soundCache;
        /**
         * @en Automatically delete sound effects after playing.default value is true.
         * @zh 音效播放后自动删除。默认值是 true。
         */
        static autoReleaseSound: boolean;
        /**
         * @en Add a playing sound instance.
         * @param channel The `SoundChannel` object.
         * @zh 添加播放的声音实例。
         * @param channel `SoundChannel` 对象。
         */
        static addChannel(channel: SoundChannel): void;
        /**
         * @en Remove a playing sound instance.
         * @param channel The `SoundChannel` object.
         * @zh 移除播放的声音实例。
         * @param channel `SoundChannel` 对象。
         */
        static removeChannel(channel: SoundChannel): void;
        static disposeSoundLater(url: string): void;
        private static _checkDisposeSound;
        static disposeSoundIfNotUsed(url: string): void;
        /**
         * @en Whether to automatically stop background music when losing focus.
         * @zh 失去焦点后是否自动停止背景音乐。
         */
        static get autoStopMusic(): boolean;
        static set autoStopMusic(v: boolean);
        private static _visibilityChange;
        private static _stageOnBlur;
        private static _recoverWebAudio;
        private static _stageOnFocus;
        /**
         * @en Whether background music and all sound effects are muted.
         * @zh 背景音乐和所有音效是否静音。
         */
        static get muted(): boolean;
        static set muted(value: boolean);
        /**
         * @en Whether all sound effects (excluding background music) are muted.
         * @zh 所有音效（不包括背景音乐）是否静音。
         */
        static get soundMuted(): boolean;
        static set soundMuted(value: boolean);
        /**
         * @en Whether background music (excluding sound effects) is muted.
         * @zh 背景音乐（不包括音效）是否静音。
         */
        static get musicMuted(): boolean;
        static set musicMuted(value: boolean);
        /**
         * @en Determines whether background music is played using the Audio tag.
         * @zh 背景音乐是否使用Audio标签播放。
         */
        static get useAudioMusic(): boolean;
        static set useAudioMusic(value: boolean);
        /**
         * @en Play a sound effect. Multiple sound effects can be played simultaneously.
         * @param url The URL of the sound file.
         * @param loops The number of times to loop the sound. 0 means infinite loop.
         * @param complete The callback function when the sound playback is complete. It should be a Handler object.
         * @param soundClass The sound class to use for playback. If null, it will be automatically selected.
         * @param startTime The start time of the sound playback.
         * @returns A SoundChannel object, through which you can control the sound and get sound information.
         * @zh 播放音效。音效可以同时播放多个。
         * @param url 声音文件地址。
         * @param loops 循环次数，0表示无限循环。
         * @param complete 声音播放完成回调，应为Handler对象。
         * @param soundClass 使用哪个声音类进行播放，null表示自动选择。
         * @param startTime 声音播放起始时间。
         * @returns SoundChannel对象，通过此对象可以对声音进行控制，以及获取声音信息。
         */
        static playSound(url: string, loops?: number, complete?: Handler, soundClass?: new () => any, startTime?: number): SoundChannel;
        /**
         * @en Release sound resources.
         * @param url The URL of the sound file to be released.
         * @zh 释放声音资源。
         * @param url 要释放的声音文件地址。
         */
        static destroySound(url: string): void;
        /**
         * @en Play background music. Only one background music can be played at a time. If this method is called while background music is already playing, the previous music will be stopped before playing the current one.
         * @param url The URL of the sound file.
         * @param loops The number of times to loop the music. 0 means infinite loop.
         * @param complete The callback function when the music playback is complete. The result parameter is true if playback is completed, false/undefined if triggered by stop.
         * @param startTime The start time of the music playback.
         * @returns A SoundChannel object, through which you can control the sound and get sound information.
         * @zh 播放背景音乐。背景音乐同时只能播放一个，如果在播放背景音乐时再次调用本方法，会先停止之前的背景音乐，再播放当前的背景音乐。
         * @param url 声音文件地址。
         * @param loops 循环次数，0表示无限循环。
         * @param complete 声音播放完成回调，complete 结果参数 true: 播放完成, false/undefined：stop触发的complete。
         * @param startTime 声音播放起始时间。
         * @returns SoundChannel对象，通过此对象可以对声音进行控制，以及获取声音信息。
         */
        static playMusic(url: string, loops?: number, complete?: Handler, startTime?: number): SoundChannel;
        /**
         * @en Stop playing a specific sound. This method can stop the playback of any sound (including background music and sound effects) by providing the corresponding sound file address.
         * @param url The URL of the sound file.
         * @zh 停止声音播放。此方法能够停止任意声音的播放（包括背景音乐和音效），只需传入对应的声音播放地址。
         * @param url 声音文件地址。
         */
        static stopSound(url: string): void;
        /**
         * @en Stop playing all sounds (including background music and sound effects).
         * @zh 停止播放所有声音（包括背景音乐和音效）。
         */
        static stopAll(): void;
        /**
         * @en Stop playing all sound effects (excluding background music).
         * @zh 停止播放所有音效（不包括背景音乐）。
         */
        static stopAllSound(): void;
        /**
         * @en Stop playing background music (excluding sound effects).
         * @zh 停止播放背景音乐（不包括音效）。
         */
        static stopMusic(): void;
        /**
         * @en Set the volume of sounds. Depending on the parameters, it can set the volume for a specific sound (background music or sound effect) or all sound effects (excluding background music).
         * @param volume The volume. Initial value is 1. Volume range is from 0 (mute) to 1 (maximum volume).
         * @param url (default = null) The URL of the sound file. If null, it sets the volume for all sound effects (excluding background music). If not null, it sets the volume for the specified sound (background music or sound effect).
         * @zh 设置声音音量。根据参数不同，可以分别设置指定声音（背景音乐或音效）音量或者所有音效（不包括背景音乐）音量。
         * @param volume 音量。初始值为1。音量范围从 0（静音）至 1（最大音量）。
         * @param url (默认为 null) 声音播放地址。为空表示设置所有音效（不包括背景音乐）的音量，不为空表示设置指定声音（背景音乐或音效）的音量。
         */
        static setSoundVolume(volume: number, url?: string): void;
        /**
         * @en Set the volume of background music. Volume range is from 0 (mute) to 1 (maximum volume).
         * @param volume The volume. Initial value is 1. Volume range is from 0 (mute) to 1 (maximum volume).
         * @zh 设置背景音乐音量。音量范围从 0（静音）至 1（最大音量）。
         * @param volume 音量。初始值为1。音量范围从 0（静音）至 1（最大音量）。
         */
        static setMusicVolume(volume: number): void;
        /**
         * @en Set the volume for a specified sound.
         * @param url The URL of the sound file.
         * @param volume The volume level, with an initial value of 1.
         * @zh 设置指定声音的音量。
         * @param url 声音文件 URL。
         * @param volume 音量。初始值为 1。
         */
        private static _setVolume;
    }
    /**
     * @en Nodes used for playing background music or sound effects
     * @zh 用于播放背景音乐或者音效的节点
     */
    class SoundNode extends Sprite {
        private _channel;
        private _tar;
        private _playEvents;
        private _stopEvents;
        private _source;
        private _isMusic;
        private _autoPlay;
        private _loop;
        constructor();
        /**
         * @en Audio source
         * @zh 音频源
         */
        get source(): string;
        set source(value: string);
        /**
         * @en Determines if the audio type is background music. If true, it's background music; otherwise, it's a sound effect.
         * @zh 确定音频类型是否为背景音乐。如果为true，音乐类型为背景音乐，否则为音效
         */
        get isMusic(): boolean;
        set isMusic(value: boolean);
        /**
         * @en The number of times the audio should loop
         * @zh 循环次数
         */
        get loop(): number;
        set loop(value: number);
        /**
         * @en Determines if the audio should auto-play
         * @zh 是否自动播放
         */
        get autoPlay(): boolean;
        set autoPlay(value: boolean);
        private _onParentChange;
        /**
         * @en Play the audio
         * @param loops The number of times to loop the audio
         * @param complete The callback function to be called when playback is complete
         * @zh 播放音频
         * @param loops 循环次数
         * @param complete 完成回调函数
         */
        play(loops?: number, complete?: Handler): void;
        /**
         * @en Stop playing the audio
         * @zh 停止播放音频
         */
        stop(): void;
        private _setPlayAction;
        private _setPlayActions;
        /**
         * @en The events string that trigger audio playback
         * @zh 触发播放的事件字符串
         */
        set playEvent(events: string);
        /**
         * @en The target sprite object that controls audio playback
         * @zh 控制播放的精灵对象
         */
        set target(tar: Sprite);
        /**
         * @en Set the events string that trigger audio stop
         * @zh 设置触发停止的事件字符串
         */
        set stopEvent(events: string);
    }
    /**
     * @en VideoNode displays video on Canvas. Video may not be effective in all browsers.
     * For all events supported by Video, see: https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement
     * Note:
     * On PC, you can call play() at any time, so the Video can start playing as soon as the program starts running.
     * However, on mobile devices, play() can only be called after the user's first touch on the screen, so it's not possible to automatically start playing Video when the program starts running on mobile devices.
     * MDN Video link: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video
     * @zh VideoNode将视频显示到Canvas上。Video可能不会在所有浏览器有效。
     * 关于Video支持的所有事件，请参见：https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement
     * 注意：
     * 在PC端可以在任何时机调用play()，因此可以在程序开始运行时就使Video开始播放。
     * 但是在移动端，只有在用户第一次触碰屏幕后才可以调用play()，所以移动端不可能在程序开始运行时就自动开始播放Video。
     * MDN Video链接：https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video
     */
    class VideoNode extends Sprite {
        private _videoTexture;
        private _internalTex;
        /** @ignore */
        constructor();
        /**
         * @en Video texture
         * @zh 视频纹理
         */
        get videoTexture(): VideoTexture;
        set videoTexture(value: VideoTexture);
        /**
         * @en Video source
         * @zh 视频源
         */
        get source(): string;
        set source(value: string);
        private _checkCachAs;
        private _repaintCachAs;
        /**
         * @en Set playback source
         * @param url Play source path.
         * @zh 设置播放源。
         * @param url 播放源路径。
         */
        load(url: string): void;
        /**
         * @en Start playing the video
         * @zh 开始播放视频
         */
        play(): void;
        /**
         * @en Pause video playback
         * @zh 暂停视频播放
         */
        pause(): void;
        /**
         * @en Reload the video
         * @zh 重新加载视频
         */
        reload(): void;
        /**
         * @en Check if the specified video format is supported for playback.
         * @param type The video format type, such as "mp4", "ogg", "webm", "m3u8", etc.
         * @returns The level of support. Possible values:
         * - "probably": The browser most likely supports this audio/video type
         * - "maybe": The browser might support this audio/video type
         * - "": (empty string) The browser does not support this audio/video type
         * @zh 检测是否支持播放指定格式视频。
         * @param type	视频格式类型，如 "mp4"、"ogg"、"webm"、"m3u8" 等。
         * @returns 表示支持的级别。可能的值：
         * - "probably"：浏览器最可能支持该音频/视频类型
         * - "maybe"：浏览器也许支持该音频/视频类型
         * - ""：（空字符串）浏览器不支持该音频/视频类型
         */
        canPlayType(type: string): CanPlayTypeResult;
        private onVideoMetaLoaded;
        /**
         * @en Get the TimeRanges object representing the buffered parts of the video.
         * The TimeRanges object represents the time ranges of the buffered audio/video. If the user jumps to different parts of the audio/video, multiple buffer ranges may be created.
         * buffered.length returns the number of buffer ranges.
         * To get the first buffer range, use buffered.start(0) and buffered.end(0). Values are in seconds.
         * @returns TimeRanges object
         * @zh 获取表示视频已缓冲部分的 TimeRanges 对象。
         * TimeRanges 对象表示用户的音视频缓冲范围。缓冲范围指的是已缓冲音视频的时间范围。如果用户在音视频中跳跃播放，会得到多个缓冲范围。
         * buffered.length 返回缓冲范围个数。
         * 如获取第一个缓冲范围则是 buffered.start(0) 和 buffered.end(0)。以秒计。
         * @returns TimeRanges 对象
         */
        get buffered(): any;
        /**
         * @en The current video source path.
         * @zh 当前播放源路径。
         */
        get currentSrc(): string;
        /**
         * @en The current playback position in seconds.
         * @zh 当前播放头位置（以秒为单位）。
         */
        get currentTime(): number;
        set currentTime(value: number);
        /**
         * @en The current volume level.
         * @zh 当前音量。
         */
        get volume(): number;
        set volume(value: number);
        /**
         * @en The ready state of the video element:
         * - 0 = HAVE_NOTHING - No information is available about the audio/video readiness
         * - 1 = HAVE_METADATA - Metadata about the audio/video is ready
         * - 2 = HAVE_CURRENT_DATA - Data for the current playback position is available, but not enough to play the next frame/millisecond
         * - 3 = HAVE_FUTURE_DATA - Data for the current and at least the next frame is available
         * - 4 = HAVE_ENOUGH_DATA - Enough data is available to begin playback
         * @zh 视频元素的就绪状态：
         * - 0 = HAVE_NOTHING - 没有关于音频/视频是否就绪的信息
         * - 1 = HAVE_METADATA - 关于音频/视频就绪的元数据
         * - 2 = HAVE_CURRENT_DATA - 关于当前播放位置的数据是可用的，但没有足够的数据来播放下一帧/毫秒
         * - 3 = HAVE_FUTURE_DATA - 当前及至少下一帧的数据是可用的
         * - 4 = HAVE_ENOUGH_DATA - 可用数据足以开始播放
         */
        get readyState(): any;
        /**
         * @en The video source width. Available after the ready event is triggered.
         * @zh 视频源宽度。ready 事件触发后可用。
         */
        get videoWidth(): number;
        /**
         * @en The video source height. Available after the ready event is triggered.
         * @zh 视频源高度。ready 事件触发后可用。
         */
        get videoHeight(): number;
        /**
         * @en The video duration in seconds. Available after the ready event is triggered.
         * @zh 视频长度（秒）。ready 事件触发后可用。
         */
        get duration(): number;
        /**
         * @en Returns whether the playback of the audio/video has ended.
         * @zh 返回音频/视频的播放是否已结束。
         */
        get ended(): boolean;
        /**
         * @en Returns a MediaError object representing the audio/video error state.
         * @zh 返回表示音频/视频错误状态的 MediaError 对象。
         */
        get error(): MediaError;
        /**
         * @en Whether the audio/video should loop when it ends.
         * @zh 音频/视频是否应在结束时重新播放。
         */
        get loop(): boolean;
        set loop(value: boolean);
        /**
         * @en The current playback speed of the audio/video. For example:
         * - 1.0: Normal speed
         * - 0.5: Half speed (slower)
         * - 2.0: Double speed (faster)
         * - -1.0: Backwards, normal speed
         * - -0.5: Backwards, half speed
         * Note: Only Google Chrome and Safari support the playbackRate property.
         * @zh 音频/视频的当前播放速度。例如：
         * - 1.0：正常速度
         * - 0.5：半速（更慢）
         * - 2.0：倍速（更快）
         * - -1.0：向后，正常速度
         * - -0.5：向后，半速
         * 注意：只有 Google Chrome 和 Safari 支持 playbackRate 属性。
         */
        get playbackRate(): number;
        set playbackRate(value: number);
        /**
         * @en The muted state of the video.
         * @zh 视频的静音状态。
         */
        get muted(): boolean;
        set muted(value: boolean);
        /**
         * @en If the video is paused.
         * @zh 视频是否暂停。
         */
        get paused(): boolean;
        /**
         * @en The preload attribute. This specifies how the video should be loaded when the page loads.
         * Possible values:
         * - "auto": Indicates that the video should be loaded entirely when the page loads.
         * - "metadata": Indicates that only metadata should be loaded when the page loads.
         * - "none": Indicates that the video should not be loaded when the page loads.
         * @zh preload 属性。这指定了页面加载时应如何加载视频。
         * 可能的值：
         * - "auto"：指示一旦页面加载，则开始加载整个视频。
         * - "metadata"：指示当页面加载后仅加载音频/视频的元数据。
         * - "none"：指示页面加载后不应加载音频/视频。
         */
        get preload(): string;
        set preload(value: string);
        /**
         * @en Used to represent the currently loaded and seekable time range in a video, helping the player or script to know which parts are immediately accessible.
         * @zh 用于表示视频中当前已加载且可以跳转的时间范围，帮助播放器或脚本知道哪些部分可以立即访问。
         * @see http://www.w3school.com.cn/tags/av_prop_seekable.asp
         */
        get seekable(): any;
        /**
         * @en Check if the user is currently seeking in the audio/video.
         * Seeking means that the user is moving/skipping to a new position in the audio/video.
         * @zh 检查用户当前是否正在音频/视频中寻址。
         * 寻址指的是用户在音频/视频中移动/跳跃到新的位置。
         */
        get seeking(): boolean;
        /**
         * @en Destroy the internal event bindings and optionally destroy child nodes
         * @param destroyChildren Whether to destroy child nodes
         * @zh 销毁内部事件绑定，并可选择是否删除子节点
         * @param destroyChildren 是否删除子节点
         */
        destroy(destroyChildren?: boolean): void;
    }
    /**
     * @en VideoTexture Multimedia texture
     * @zh VideoTexture 多媒体纹理
     */
    class VideoTexture extends BaseTexture {
        readonly element: HTMLVideoElement;
        static videoEvent_update: string;
        private _source;
        private _listeningEvents;
        private immediatelyPlay;
        /**
         * 是否开发者自己调用Render
         */
        private _frameRender;
        private _frameDelty;
        private _updateFrame;
        private _useFrame;
        private _lastTimer;
        /**
         * @en videoTexture update frame
         * @zh 视频纹理更新帧率
         */
        set updateFrame(value: number);
        get updateFrame(): number;
        set useFrame(value: boolean);
        get useFrame(): boolean;
        /**
         * @ignore
         * @en Creates an inst
         * @zh VideoTexture对象的构造方法
         */
        constructor();
        private isNeedUpdate;
        /**
         * @en Handle the loadedmetadata event of the video element.
         * Processes the initialization work after the video resource is loaded, ensuring that necessary texture and playback settings are made so that the video can be properly handled during rendering.
         * @zh 视频元素的 loadedmetadata 事件的回调方法。
         * 处理视频资源加载完毕后的初始化工作，用于在视频正确加载后，做必要的纹理和播放设置，确保视频能在渲染时被正确处理。
         */
        loadedmetadata(): void;
        /**
         * @en The gamma correction value
         * @zh gamma 校正值
         */
        get gammaCorrection(): number;
        /**
         * @en The source URL for the video
         * @zh 视频的源 URL
         */
        get source(): string;
        set source(url: string);
        private appendSource;
        /**
         * @en Whether to render every frame
         * @zh 是否每一帧都渲染
         */
        get frameRender(): boolean;
        set frameRender(value: boolean);
        /**
         * @en Start playing the video
         * @zh 开始播放视频
         */
        play(): void;
        _getSource(): any;
        /**
         * @en The default texture
         * @zh 默认纹理
         */
        get defaultTexture(): Texture2D;
        /**
         * @en Pause the video playback
         * @zh 暂停播放视频
         */
        pause(): void;
        /**
         * @en Reload the video
         * @zh 重新加载视频
         */
        load(): void;
        /**
         * @en Check if the specified video format is supported for playback
         * @param type Video format type, such as "mp4", "ogg", "webm", "m3u8", etc.
         * @returns  The level of support. Possible values:
         * - "probably": The browser most likely supports this audio/video type
         * - "maybe": The browser might support this audio/video type
         * - "": (empty string) The browser does not support this audio/video type
         * @zh 检测是否支持播放指定格式视频
         * @param type	视频格式类型 "mp4","ogg","webm","m3u8"等。
         * @return 表示支持的级别。可能的值：
         * - "probably": 浏览器最可能支持该音频/视频类型
         * - "maybe": 浏览器也许支持该音频/视频类型
         * - "": （空字符串）浏览器不支持该音频/视频类型
         */
        canPlayType(type: string): CanPlayTypeResult;
        /**
         * @en Get the TimeRanges object representing the buffered parts of the audio/video
         * The TimeRanges object represents the buffered time ranges of the audio/video. If the user skips around in the audio/video, multiple buffered ranges may be created.
         * buffered.length returns the number of buffered ranges.
         * To get the first buffered range, use buffered.start(0) and buffered.end(0). Values are in seconds.
         * @returns The TimeRanges object
         * @zh 获取表示音视频已缓冲部分的 TimeRanges 对象
         * TimeRanges 对象表示用户的音视频缓冲范围。缓冲范围指的是已缓冲音视频的时间范围。如果用户在音视频中跳跃播放，会得到多个缓冲范围。
         * buffered.length 返回缓冲范围个数。如获取第一个缓冲范围则是 buffered.start(0) 和 buffered.end(0)。以秒计。
         * @returns TimeRanges(JS)对象
         */
        get buffered(): any;
        /**
         * @en The current source URL of the video
         * @zh 当前播放源路径
         */
        get currentSrc(): string;
        /**
         * @en The current playback position in seconds
         * @zh 当前播放头位置（以秒为单位）
         */
        get currentTime(): number;
        set currentTime(value: number);
        /**
         * @en The current volume level
         * @zh 当前音量
         */
        get volume(): number;
        set volume(value: number);
        /**
         * @en The readiness state of the video element:
         * - 0 = HAVE_NOTHING - No information is available about the audio/video
         * - 1 = HAVE_METADATA - Metadata for the audio/video is ready
         * - 2 = HAVE_CURRENT_DATA - Data for the current playback position is available, but not enough to play the next frame/millisecond
         * - 3 = HAVE_FUTURE_DATA - Data for the current and at least the next frame is available
         * - 4 = HAVE_ENOUGH_DATA - Enough data is available to start playing
         * @zh 视频元素的就绪状态：
         * - 0 = HAVE_NOTHING - 没有关于音频/视频是否就绪的信息
         * - 1 = HAVE_METADATA - 关于音频/视频就绪的元数据
         * - 2 = HAVE_CURRENT_DATA - 关于当前播放位置的数据是可用的，但没有足够的数据来播放下一帧/毫秒
         * - 3 = HAVE_FUTURE_DATA - 当前及至少下一帧的数据是可用的
         * - 4 = HAVE_ENOUGH_DATA - 可用数据足以开始播放
         */
        get readyState(): any;
        /**
         * @en The width of the video source. Available after the ready event is triggered.
         * @zh 视频源宽度。ready 事件触发后可用。
         */
        get videoWidth(): number;
        /**
         * @en The height of the video source. Available after the ready event is triggered.
         * @zh 视频源高度。ready 事件触发后可用。
         */
        get videoHeight(): number;
        /**
         * @en The duration of the video in seconds. Available after the ready event is triggered.
         * @zh 视频长度（秒）。ready 事件触发后可用。
         */
        get duration(): number;
        /**
         * @en If the playback of the audio/video has ended
         * @zh 音频/视频的播放是否已结束
         */
        get ended(): boolean;
        /**
         * @en Return the MediaError object representing the error state of the audio/video
         * @zh 返回表示音频/视频错误状态的 MediaError 对象
         */
        get error(): MediaError;
        /**
         * @en Whether the audio/video should loop when it reaches the end
         * @zh 音频/视频是否应在结束时重新播放
         */
        get loop(): boolean;
        set loop(value: boolean);
        /**
         * @en The current playback speed of the audio/video. For example:
         * - 1.0: Normal speed
         * - 0.5: Half speed (slower)
         * - 2.0: Double speed (faster)
         * - -1.0: Backwards, normal speed
         * - -0.5: Backwards, half speed
         * Note: Only Google Chrome and Safari support the playbackRate property.
         * @zh 音频/视频的当前播放速度。如：
         * - 1.0：正常速度
         * - 0.5：半速（更慢）
         * - 2.0：倍速（更快）
         * - -1.0：向后，正常速度
         * - -0.5：向后，半速
         * 注意：只有 Google Chrome 和 Safari 支持 playbackRate 属性。
         */
        get playbackRate(): number;
        set playbackRate(value: number);
        /**
         * @en The muted state of the video
         * @zh 视频的静音状态
         */
        get muted(): boolean;
        set muted(value: boolean);
        /**
         * @en If the video is paused
         * @zh 视频是否暂停
         */
        get paused(): boolean;
        /**
         * @en The preload attribute of the video. Possible values:
         * - "auto": Indicates that the video should be loaded as soon as the page loads
         * - "metadata": Indicates that only metadata should be loaded when the page loads
         * - "none": Indicates that the video should not be loaded when the page loads
         * @zh 视频的预加载属性。可赋值如下：
         * - "auto"：指示一旦页面加载，则开始加载视频
         * - "metadata"：指示当页面加载后仅加载音频/视频的元数据
         * - "none"：指示页面加载后不应加载音频/视频
         */
        get preload(): string;
        set preload(value: string);
        /**
         * @en see: http://www.w3school.com.cn/tags/av_prop_seekable.asp象
         * @zh 参见：http://www.w3school.com.cn/tags/av_prop_seekable.asp
         */
        get seekable(): any;
        /**
         * @en Returns whether the user is currently seeking in the audio/video.
         * Seeking refers to the user moving/jumping to a new position in the audio/video.
         * @zh 返回用户目前是否在音频/视频中寻址。
         * 寻址（Seeking）指的是用户在音频/视频中移动/跳跃到新的位置。
         */
        get seeking(): boolean;
        protected onStartListeningToType(type: string): void;
        /**
         * @en Destroys the current instance and releases resources.
         * @zh 销毁当前实例并释放资源。
         */
        destroy(): void;
    }
    /**
     * @en Web Audio API for playing sounds
     * @zh Web Audio API 方式播放声音
     */
    class WebAudioSound extends EventDispatcher {
        /**
         * @en Audio playback device
         * @zh 音频播放设备
         */
        static ctx: AudioContext;
        /**
         * @en Used to unlock sound playback and resolve memory release issues in iOS 9
         * @zh 用于解锁声音播放以及解决 iOS 9 版本的内存释放问题
         */
        static _miniBuffer: any;
        /**
         * @en Indicates whether the sound is unlocked
         * @zh 是否已解锁声音播放
         */
        private static _unlocked;
        /**
         * @en URL of the sound file
         * @zh 声音文件的 URL
         */
        url: string;
        /**
         * @en Indicates whether the sound has finished loading
         * @zh 指示声音是否已加载完成
         */
        loaded: boolean;
        /**
         * @en Original audio file data
         * @zh 声音原始文件数据
         */
        audioBuffer: AudioBuffer;
        /**
         * @en Channel list to be played
         * @zh 待播放的声音列表
         */
        private __toPlays;
        private _disposed;
        /**
         * @en Play a sound to unlock audio on iOS.
         * @zh 播放声音以解锁IOS的声音播放。
         */
        private static _playEmptySound;
        /**
         * @en Try to unlock the sound
         * @zh 尝试解锁声音
         */
        private static _unlock;
        /**
         * @en Initialize Web Audio
         * @zh 初始化 Web Audio
         */
        static initWebAudio(): void;
        /**
         * @en Load the sound
         * @param url The URL of the sound file to load
         * @zh 加载声音
         * @param url 要加载的声音文件的 URL
         */
        load(url: string): void;
        private _loaded;
        private __playAfterLoaded;
        /**
         * @en Play the sound
         * @param startTime The start time of the sound playback
         * @param loops The number of times to loop the sound
         * @param channel The WebAudioSoundChannel to use for playback
         * @returns The SoundChannel used for playback
         * @zh 播放声音
         * @param startTime 声音播放的起始时间
         * @param loops 声音循环播放的次数
         * @param channel 用于播放的 WebAudioSoundChannel
         * @returns 用于播放的 SoundChannel
         */
        play(startTime?: number, loops?: number, channel?: WebAudioSoundChannel): SoundChannel;
        /**
         * @en The duration of the sound in seconds
         * @zh 声音的持续时间，以秒为单位
         */
        get duration(): number;
        /**
         * @en Dispose of the sound and release resources
         * @zh 销毁声音并释放资源
         */
        dispose(): void;
    }
    /**
     * @en Sound track control for playing sounds using Web Audio API
     * @zh 使用 Web Audio API 方式播放声音的音轨控制
     */
    class WebAudioSoundChannel extends SoundChannel {
        /**
         * @en Original audio file data
         * @zh 声音原始文件数据
         */
        audioBuffer: any;
        /**
         * @en Gain node for audio processing.
         * @zh gain 节点
         */
        private gain;
        /**
         * @en Buffer source for playback.
         * @zh 播放用的数据
         */
        private bufferSource;
        /**
         * @en The current playback time.
         * @zh 当前时间
         */
        private _currentTime;
        /**
         * @en The current volume level.
         * @zh 当前音量
         */
        private _volume;
        /**
         * @en Timestamp when playback starts.
         * @zh 播放开始时的时间戳
         */
        private _startTime;
        private _pauseTime;
        /**
         * @en The audio playback device.
         * @zh 播放设备
         */
        private context;
        private _onPlayEnd;
        private static _tryCleanFailed;
        /**
         * @en Target delay for audio playback (in seconds)
         * @zh 音频播放的目标延迟时间（以秒为单位）
         */
        static SetTargetDelay: number;
        /**@ignore */
        constructor();
        /**
         * @en Play the sound
         * @zh 播放声音
         */
        play(): void;
        private __onPlayEnd;
        /**
         * @en The current playback position in seconds
         * @zh 当前播放位置，以秒为单位
         */
        get position(): number;
        /**
         * @en The duration of the audio in seconds
         * @zh 音频的持续时间，以秒为单位
         */
        get duration(): number;
        private _clearBufferSource;
        private _tryClearBuffer;
        /**
         * @en Stop playing
         * @zh 停止播放
         */
        stop(): void;
        /**
         * @en Pause the audio playback
         * @zh 暂停音频播放
         */
        pause(): void;
        /**
         * @en Resume the audio playback
         * @zh 恢复音频播放
         */
        resume(): void;
        /**
         * @en The volume of the audio
         * @zh 音频的音量
         */
        get volume(): number;
        set volume(v: number);
    }
    /**
     * @en Indicate the navigation area types that the agent can pass through.
     * @zh 表示代理可以通过的导航区域类型。
     */
    class AreaMask {
        /**
         * @en The exclude flag.
         * @zh 排除标志。
         */
        get excludeflag(): number;
        /**
         * @en The current flag.
         * @zh 获取当前标志。
         */
        get flag(): number;
        set flag(value: number);
        /**
         * @en Creates a new instance of AreaMask.
         * @zh 创建 AreaMask 的新实例。
         */
        constructor();
    }
    enum ObstacleAvoidanceType {
        NoObstacle = 0,
        LowQuality = 1,
        MedQuality = 2,
        GoodQuality = 3,
        HighQuality = 4
    }
    /**
     * @en Class used to instantiate a navigation agent
     * @zh 类用来实例化一个寻路代理
     */
    class NavAgent extends Component {
        _navAgentLinkAnim: NavAgentLinkAnim;
        /**
         * @en Radius of the agent.
         * @zh 代理的半径。
         */
        set radius(value: number);
        get radius(): number;
        /**
         * @en Height of the agent.
         * @zh 代理的高度。
         */
        set height(value: number);
        get height(): number;
        /**
         * @en Movement speed of the agent.
         * @zh 代理的移动速度。
         */
        set speed(value: number);
        get speed(): number;
        /**
         * @en Maximum acceleration of the agent.
         * @zh 代理的最大加速度。
         */
        set maxAcceleration(value: number);
        get maxAcceleration(): number;
        /**
         * @en Angular speed of the agent.
         * @zh 代理的转身速度。
         */
        set angularSpeed(value: number);
        get angularSpeed(): number;
        /**
         * @en Offset of the pivot point.
         * @zh 轴心点的偏移。
         */
        set baseOffset(value: number);
        get baseOffset(): number;
        /**
         * @en Obstacle avoidance quality level.
         * @zh 障碍物规避品质级别。
         */
        set quality(value: ObstacleAvoidanceType);
        get quality(): ObstacleAvoidanceType;
        /**
         * @en Avoidance priority level.
         * @zh 规避优先级别。
         */
        set priority(value: number);
        get priority(): number;
        /**
         * @en Whether the agent is bound to a navigation mesh.
         * @zh 代理是否绑定到导航网格。
         */
        get isOnNavMesh(): boolean;
        /**
         * @en Whether the agent is currently on an OffMeshLink.
         * @zh 代理当前是否位于 OffMeshLink 上。
         */
        get isOnOffMeshLink(): boolean;
        /**
         * @en Set the destination for the agent.
         * @param value The destination vector.
         * @zh 设置代理的目的地。
         * @param value 目的地位置向量。
         */
        set destination(value: Vector3);
        get destination(): Vector3;
        /**
         * @en Set the agent type.
         * @param value The agent type.
         * @zh 设置代理类型。
         * @param value 代理类型。
         */
        set agentType(value: string);
        get agentType(): string;
        /**
         * @en Set the area mask for the agent.
         * @zh 设置代理的区域掩码。
         */
        set areaMask(value: number);
        get areaMask(): number;
        /**
         * @en Create a new NavAgent instance.
         * @zh 创建一个新的 NavAgent 实例。
         */
        constructor();
        /**
        * @private
        */
        _getUpdateFlags(): number;
        /**
         * @private
         */
        _onDestroy(): void;
        /**
         * @en Update method called every frame.
         * @zh 每帧调用的更新方法。
         */
        onUpdate(): void;
        /**
         * @en Whether the agent has stopped moving.
         * @zh 代理是否已停止移动。
         */
        isStop(): boolean;
        /**
         * @en Get the current path of the agent.
         * @zh 获取代理的当前路径。
         */
        getCurrentPath(): Array<NavigationPathData>;
        /**
         * @en Set the position of the agent in world coordinates.
         * @param pos The new position in world coordinates.
         * @zh 在世界坐标中设置代理的位置。
         * @param pos 世界坐标系下的新位置。
         */
        setPosition(pos: Vector3): void;
        /**
         * @en Find the distance to the nearest wall.
         * @returns {dist:distance， pos:collision point， normal:Normal vector}
         * @zh 查找到最近墙面的距离。
         * @returns {dist:距离， pos:碰撞点， normal:法向量}
         */
        findDistanceToWall(): {
            dist: number;
            pos: Array<number>;
            normal: Array<number>;
        };
    }
    /**
     * @en NavMeshLink represents a connection between two points outside the navigation mesh.
     * @zh NavMeshLink 表示导航网格外的两点之间的连接。
     */
    class NavMeshLink extends Component {
        /**
         * @en The start position of the link
         * @zh 链接的起始位置
         */
        set start(value: Vector3);
        get start(): Vector3;
        /**
         * @en The end position of the link
         * @zh 链接的结束位置
         */
        set end(value: Vector3);
        get end(): Vector3;
        /**
         * @en The width of the link
         * @zh 链接的宽度
         */
        set width(value: number);
        get width(): number;
        /**
         * @en The area flag of the link
         * @zh 链接的区域标记
         */
        set areaFlag(value: string);
        get areaFlag(): string;
        /**
         * @en The agent type that can use this link
         * @zh 可以使用此链接的代理类型
         */
        set agentType(value: string);
        get agentType(): string;
        /**
         * @en Whether the link is bidirectional
         * @zh 链接是否为双向
         */
        set bidirectional(value: boolean);
        get bidirectional(): boolean;
        /**
         * @ignore
         * @en Creates a new NavMeshLink instance.
         * @zh 创建一个新的 NavMeshLink 实例。
         */
        constructor();
    }
    /**
     * @en NavMeshModifierVolume is a component that modifies the navigation mesh in a specific volume.
     * @zh NavMeshModifierVolume 是一个在特定体积内修改导航网格的组件。
     */
    class NavMeshModifierVolume extends Component {
        /**
         * @en The center of the modifier volume.
         * @zh 修改体积的中心点。
         */
        get center(): Vector3;
        set center(value: Vector3);
        /**
         * @en The size of the modifier volume.
         * @zh 修改体积的大小。
         */
        get size(): Vector3;
        set size(value: Vector3);
        /**
         * @en The agent type that this volume applies to.
         * @zh 该体积适用的代理类型。
         */
        set agentType(value: string);
        get agentType(): string;
        /**
         * @en The area flag for this volume.
         * @zh 该体积的区域标志。
         */
        set areaFlag(value: string);
        get areaFlag(): string;
        /**
         * @en Creates a new NavMeshModifierVolume instance.
         * @zh 创建一个新的 NavMeshModifierVolume 实例。
         */
        constructor();
    }
    /**
     * @en NavMeshModifileSurface is a component that modifies the navigation mesh surface.
     * @zh NavMeshModifileSurface 是一个修改导航网格表面的组件。
     */
    class NavMeshModifileSurface extends NavModifleBase {
        /** @ignore */
        constructor();
        /**
         * @en Sets or gets the baked navigation data.
         * @param value The TextResource containing the navigation data.
         * @returns The TextResource containing the navigation data.
         * @zh 设置或获取烘焙的导航数据。
         * @param value 包含导航数据的 TextResource。
         * @returns 包含导航数据的 TextResource。
         */
        set datas(value: TextResource);
        get datas(): TextResource;
    }
    /**
     * @en Enum for the different types of obstacle meshes supported by the navigation system.
     * @zh 导航系统支持的不同类型的障碍物网格枚举。
     */
    enum NavObstaclesMeshType {
        BOX = 0,
        CAPSULE = 1,
        Num = 2
    }
    /**
     * @en NavMeshObstacles Common shapes for navigation mesh obstacles.
     * @zh NavMeshObstacles 常用的导航网格障碍物形状。
     */
    class NavMeshObstacles extends NavModifleBase {
        static _defaltMax: Vector3;
        /**
         * @en The mesh type of the obstacle.
         * @zh 障碍物的网格类型。
         */
        get meshType(): NavObstaclesMeshType;
        set meshType(value: NavObstaclesMeshType);
        /**
         * @en The center offset of the obstacle.
         * @zh 障碍物的中心偏移。
         */
        get center(): Vector3;
        set center(value: Vector3);
        /**
         * @en The size of the box obstacle.=
         * @zh 盒型障碍物的大小。=
         */
        get size(): Vector3;
        set size(value: Vector3);
        /**
         * @en The height of the capsule obstacle.
         * @zh 胶囊障碍物的圆柱高度。
         */
        get height(): number;
        set height(value: number);
        /**
         * @en Set the radius of the capsule obstacle.
         * @zh 设置胶囊障碍物的圆柱半径。
         */
        get radius(): number;
        set radius(value: number);
        /**
         * @ignore
         * @en Create a new NavMeshObstacles instance.
         * @zh 创建NavMeshObstacles的一个新实例。
         */
        constructor();
    }
    /**
     * @en Data partitioning algorithm
     * @zh 数据分块算法
     */
    enum PartitionType {
        PARTITION_WATERSHED = 0,
        PARTITION_MONOTONE = 1,
        PARTITION_LAYERS = 2
    }
    /**
     * @en NavMeshSurface is a component used to generate navigation mesh.
     * @zh NavMeshSurface 是一个用于生成导航网格的组件。
     */
    class NavMeshSurface extends Component {
        /**
         * @en Find all NavMeshSurface components that match the given agent flags in the sprite hierarchy.
         * @param surfaces An array to store the found NavMeshSurface components.
         * @param sprite The starting Sprite3D to search from.
         * @param agentFlags An array of agent types to filter the NavMeshSurface components.
         * @zh 在精灵层级中查找所有匹配给定代理标志的 NavMeshSurface 组件。
         * @param surfaces 用于存储找到的 NavMeshSurface 组件的数组。
         * @param sprite 开始搜索的 Sprite3D 对象。
         * @param agentFlags 用于过滤 NavMeshSurface 组件的代理类型数组。
         */
        static findNavMeshSurface(surfaces: Array<NavMeshSurface>, sprite: Sprite3D, agentFlags: string[]): void;
        /**
         * @en Agent type
         * @zh 代理类型
         */
        set agentType(value: string);
        get agentType(): string;
        /**
         * @en Area type
         * @zh 区域类型
         */
        set areaFlag(value: string);
        get areaFlag(): string;
        /**
         * @en Whether asynchronous processing is needed
         * @zh 是否需要异步处理
         */
        set asyn(value: boolean);
        get asyn(): boolean;
        /**
         * @en Set the method for generating navMesh
         * @zh 设置生成导航网格的方法
         */
        set partitionType(value: PartitionType);
        get partitionType(): PartitionType;
        /**
         * @readonly
         * @en The minimum bounds of the navigation mesh
         * @zh 导航网格的最小边界
         */
        get boundMin(): Vector3;
        /**
         * @readonly
         * @en The maximum bounds of the navigation mesh
         * @zh 导航网格的最大边界
         */
        get boundMax(): Vector3;
        /**
         * @en Set navigation data
         * @zh 设置导航数据
         */
        set datas(value: TextResource);
        get datas(): TextResource;
        /**
         * @en The navigation mesh
         * @zh 导航网格
         */
        get navMesh(): NavMesh;
        /**
         * @en Instantiate a pathfinding functionality
         * @zh 实例化一个寻路功能
         */
        constructor();
        _cloneTo(dest: NavMeshSurface): void;
        /**
         * add one modifile navMesh
         * @param navModifile
         */
        _addModifileNavMesh(navModifile: NavModifleBase): void;
        /**
         * start build one Mesh
         */
        _buildOneTileMesh(): void;
        /**
         * start build all Mesh
         */
        _buildAllTileMesh(): void;
        /**
         * @en Clean all navigation tiles
         * @zh 清除所有导航网格块
         */
        cleanAllTile(): void;
        /**
         * @en Rebuild a specific tile at the given position
         * @param pos The position vector to determine which tile to rebuild
         * @zh 重建指定位置的导航网格块
         * @param pos 用于确定要重建哪个网格块的位置向量
         */
        rebuildTile(pos: Vector3): void;
    }
    /**
     * @en NavModifleBase is the base class for dynamic navigation nodes.
     * @zh NavModifleBase 是动态导航节点的基类。
     */
    class NavModifleBase extends Component {
        get boundMin(): Vector3;
        get boundMax(): Vector3;
        /**
         * @en Agent type for the navigation node
         * @zh 导航节点的代理类型
         */
        set agentType(value: string);
        get agentType(): string;
        /**
         * @en Area type for the navigation node
         * @zh 导航节点的区域类型
         */
        set areaFlag(value: string);
        get areaFlag(): string;
        /**
         * @en Create a new instance of NavModifleBase.
         * @zh 创建 NavModifleBase 类的新实例。
         */
        constructor();
    }
    /**
     * @en Represents a navigation area flag.
     * @zh 表示导航区域标志。
     */
    class NavAreaFlag {
        /**
         * @en The index of the navigation area flag.
         * @zh 导航区域标志的索引。
         */
        index: number;
        /**
         * @en The cost associated with the navigation area flag.
         * @zh 与导航区域标志相关的代价。
         */
        cost: number;
        /**
         * @en The name of the navigation area flag.
         * @zh 导航区域标志的名称。
         */
        name: string;
        /**
         * @en Get the flag value based on the index.
         * @zh 根据索引获取标志值。
         */
        get flag(): number;
    }
    /**
     * @en NavigationManager is a navigation manager responsible for managing navigation meshes.
     * @zh NavigationManager 是一个导航管理器，负责管理导航网格。
     */
    class NavigationManager implements IElementComponentManager {
        /**
         * @en Instantiates a Navigation manager.
         * @zh 实例化一个 Navigation 管理器。
         */
        constructor();
        /**
         * @en Registers a navigation mesh agent type configuration.
         * @param config The RecastConfig object containing the agent configuration.
         * @zh 注册导航网格的 agent 类型配置。
         * @param config RecastConfig 对象，包含 agent 的配置。
         */
        regNavConfig(config: RecastConfig): void;
        /**
         * @en Gets the navigation mesh agent configuration for a specific type.
         * @param type The agent type name.
         * @returns The RecastConfig for the specified agent type, or undefined if not found.
         * @zh 获取指定类型的导航网格 agent 配置。
         * @param type agent 类型名称。
         * @returns 指定 agent 类型的 RecastConfig，如果未找到则返回 undefined。
         */
        getNavConfig(type: string): RecastConfig;
        /**
         * @en Registers a navigation area type.
         * @param area The NavAreaFlag object representing the area type.
         * @zh 注册导航区域类型。
         * @param area 表示区域类型的 NavAreaFlag 对象。
         */
        regArea(area: NavAreaFlag): void;
        /**
         * @en Gets the configuration for a specific navigation area type.
         * @param type The area type name.
         * @returns The NavAreaFlag for the specified area type, or undefined if not found.
         * @zh 获取指定导航区域类型的配置。
         * @param type 区域类型名称。
         * @returns 指定区域类型的 NavAreaFlag，如果未找到则返回 undefined。
         */
        getArea(type: string): NavAreaFlag;
        /**
         * @en Gets the map of all registered navigation area flags.
         * @returns A Map of area names to NavAreaFlag objects.
         * @zh 获取所有已注册的导航区域标志的映射。
         * @returns 区域名称到 NavAreaFlag 对象的 Map。
         */
        getAreaFlagMap(): Map<string, NavAreaFlag>;
        /**
         * @en Registers a NavMeshLink between two different NavMeshSurfaces.
         * @param start The starting NavMeshSurface.
         * @param end The ending NavMeshSurface.
         * @param link The NavMeshLink to register.
         * @zh 注册连接两个不同 NavMeshSurface 的 NavMeshLink。
         * @param start 起始 NavMeshSurface。
         * @param end 结束 NavMeshSurface。
         * @param link 要注册的 NavMeshLink。
         */
        regNavMeshLink(start: NavMeshSurface, end: NavMeshSurface, link: NavMeshLink): void;
        /**
         * @en Get the corresponding NavMeshSurface based on a world position.
         * @param pos World coordinate position.
         * @param agentType Agent type.
         * @returns NavMeshSurface or null if not found.
         * @zh 通过空间位置获得对应的 NavMeshSurface。
         * @param pos 世界坐标位置。
         * @param agentType agent 类型。
         * @returns NavMeshSurface，如果未找到则返回 null。
         */
        getNavMeshSurface(pos: Vector3, agentType: string): NavMeshSurface;
        /**
         * @en Get all NavMeshSurfaces that contain a given world position.
         * @param pos World coordinate position.
         * @returns Array of NavMeshSurface objects.
         * @zh 通过空间坐标获得所有包含该位置的 NavMeshSurface。
         * @param pos 世界坐标位置。
         * @returns NavMeshSurface 对象数组。
         */
        getNavMeshSurfaces(pos: Vector3): NavMeshSurface[];
    }
    /**
     * @en Represents a navigation path data point.
     * @zh 表示导航路径数据点。
     */
    class NavigationPathData {
        /**
         * @en The position of the path data point.
         * @zh 路径数据点的位置。
         */
        get pos(): Vector3;
        /**
         * @en Get the flag of the path data point.
         * @zh 获取路径数据点的标记。
         */
        get flag(): number;
        /**
         * @ignore
         * @en Creates a new instance of NavigationPathData.
         * @zh 创建 NavigationPathData 的新实例。
         */
        constructor();
    }
    /**
     * @en NavigationUtils is a utility class for handling operations related to navigation meshes.
     * @zh NavigationUtils 是一个导航工具类,主要用于处理与导航网格相关的操作。
     */
    class NavigationUtils {
        /**
         * @en Create navMesh tile to Laya Mesh.
         * @param navMesh The navigation mesh to create the debug mesh from.
         * @param mesh The mesh to update or create. If null, a new mesh will be created.
         * @returns The created or updated mesh.
         * @zh 创建导航网格为Laya的网格。
         * @param navMesh 用于创建调试网格的导航网格。
         * @param mesh 要更新或创建的网格。如果为 null，将创建一个新的网格。
         * @returns 创建或更新后的网格。
         */
        static creageDebugMesh(navMesh: NavMesh, mesh: Mesh): Mesh;
        static transfromBound(mat: Matrix4x4, min: Vector3, max: Vector3, outMin: Vector3, outMax: Vector3): void;
        static boundContainPoint(min: Vector3, max: Vector3, point: Vector3): boolean;
        /**
         * @en Create a new NavMesh.
         * @returns A new NavMesh object.
         * @zh 创建一个新的 NavMesh。
         * @returns 一个新的 NavMesh 对象。
         */
        static createNavMesh(): any;
        /**
         * @en Create a new NavMeshQuery.
         * @returns A new NavMeshQuery object.
         * @zh 创建一个新的 NavMeshQuery。
         * @returns 一个新的 NavMeshQuery 对象。
         */
        static createNavMeshQuery(): any;
        /**
         * @en Create a new RefPointData.
         * @returns A new RefPointData object.
         * @zh 创建一个新的 RefPointData。
         * @returns 一个新的 RefPointData 对象。
         */
        static createRefPointData(): any;
        /**
         * @en Create a new MeshOffLink.
         * @returns A new MeshOffLink object.
         * @zh 创建一个新的 MeshOffLink。
         * @returns 一个新的 MeshOffLink 对象。
         */
        static createMeshOffLink(): any;
        /**
         * @en Create a new ConvexVolume.
         * @returns A new ConvexVolume object.
         * @zh 创建一个新的 ConvexVolume。
         * @returns 一个新的 ConvexVolume 对象。
         */
        static createConvexVolume(): any;
        /**
         * @en Create a new QueryFilter.
         * @returns A new QueryFilter object.
         * @zh 创建一个新的 QueryFilter。
         * @returns 一个新的 QueryFilter 对象。
         */
        static createQueryFilter(): any;
        /**
         * @en Create a new Crowd.
         * @returns A new Crowd object.
         * @zh 创建一个新的 Crowd。
         * @returns 一个新的 Crowd 对象。
         */
        static createCrowd(): any;
        /**
         * @en Create a new NavTileData.
         * @returns A new NavTileData object.
         * @zh 创建一个新的 NavTileData。
         * @returns 一个新的 NavTileData 对象。
         */
        static createdtNavTileData(): any;
        /**
         * @en Get CrowdAgentParams.
         * @returns CrowdAgentParams object.
         * @zh 获取 CrowdAgentParams。
         * @returns CrowdAgentParams 对象。
         */
        static getCrowdAgentParams(): any;
        /**
         * @en Free the NavMeshQuery object.
         * @param data The NavMeshQuery object to free.
         * @zh 释放 NavMeshQuery 对象。
         * @param data 要释放的 NavMeshQuery 对象。
         */
        static freeNavMeshQuery(data: any): void;
        /**
         * @en Free the NavMesh object.
         * @param data The NavMesh object to free.
         * @zh 释放 NavMesh 对象。
         * @param data 要释放的 NavMesh 对象。
         */
        static freeNavMesh(data: any): void;
        /**
         * @en Free the Crowd object.
         * @param data The Crowd object to free.
         * @zh 释放 Crowd 对象。
         * @param data 要释放的 Crowd 对象。
         */
        static freeCrowd(data: any): void;
        /**
         * @en Free any other object.
         * @param data The object to free.
         * @zh 释放任何其他对象。
         * @param data 要释放的对象。
         */
        static free(data: any): void;
        /**
         * @en Free any Laya data object.
         * @param data The Laya data object to free.
         * @zh 释放任何 Laya 数据对象。
         * @param data 要释放的 Laya 数据对象。
         */
        static freeLayaData(data: any): void;
        /**
         * @en Check if the status is successful.
         * @param status The status to check.
         * @returns True if the status is successful, false otherwise.
         * @zh 检查状态是否成功。
         * @param status 要检查的状态。
         * @returns 如果状态成功则返回 true，否则返回 false。
         */
        static statusSucceed(status: any): boolean;
    }
    /**
     * @en NavMesh class is used to create and manage navigation meshes.
     * @zh NavMesh 类用于创建和管理导航网格。
     */
    class NavMesh {
        /**寻路代理 */
        private _crowd;
        /**过滤信息 */
        private _defatfilter;
        /**TODO */
        private _extents;
        /**navigation manager */
        private _manager;
        private _fiterMap;
        get min(): Vector3;
        get max(): Vector3;
        /**
         * @ignore
         * @en Instantiate a NavMesh component.
         * @param config The Recast configuration for the NavMesh.
         * @param bound The bounds of the NavMesh.
         * @param manager The NavigationManager instance.
         * @zh 实例化一个 NavMesh 组件。
         * @param config NavMesh 的 Recast 配置。
         * @param bound NavMesh 的边界。
         * @param manager NavigationManager 实例。
         */
        constructor(config: RecastConfig, min: Vector3, max: Vector3, manager: NavigationManager);
        /**
         * create agent
         * @param agent
         */
        private _createAgents;
        /**
         * @en Add an agent to the NavMesh.
         * @param agent The NavAgent to be added.
         * @zh 向 NavMesh 添加一个代理。
         * @param agent 要添加的 NavAgent。
         */
        addAgent(agent: NavAgent): void;
        /**
         * @en Remove an agent from the NavMesh.
         * @param agent The NavAgent to be removed.
         * @zh 从 NavMesh 中移除一个代理。
         * @param agent 要移除的 NavAgent。
         */
        removeAgent(agent: NavAgent): void;
        /**
         * @en Perform a raycast on the NavMesh.
         * @param ray The ray to cast.
         * @param outPos The output vector to store the hit position.
         * @zh 在 NavMesh 上执行射线投射。
         * @param ray 要投射的射线。
         * @param outPos 用于存储命中位置的输出向量。
         */
        raycastNavMesh(ray: Ray, outPos: Vector3): boolean;
        /**
         * @en Get the flag of the polygon at the specified position.
         * @param pos World coordinates.
         * @param fiter Optional filter for the query.
         * @returns The flag of the polygon.
         * @zh 获取指定位置多边形的标志。
         * @param pos 世界坐标。
         * @param fiter 可选的查询过滤器。
         * @returns 多边形的标志。
         */
        getPolyFlags(pos: Vector3, fiter?: any): number;
        /**
         * @en Get the area flag of the polygon at the specified position.
         * @param pos World coordinates.
         * @param fiter Optional filter for the query.
         * @returns The area flag of the polygon.
         * @zh 获取指定位置多边形的区域标志。
         * @param pos 世界坐标。
         * @param fiter 可选的查询过滤器。
         * @returns 多边形的区域标志。
         */
        getPolyArea(pos: Vector3, fiter?: any): number;
        /**
         * @en Find the nearest polygon to the specified position.
         * @param pos World coordinates.
         * @param fiter Optional filter for the query.
         * @returns Information about the nearest polygon.
         * @zh 查找指定位置最近的多边形。
         * @param pos 世界坐标。
         * @param fiter 可选的查询过滤器。
         * @returns 最近多边形的信息。
         */
        findNearestPoly(pos: Vector3, fiter?: any): any;
        /**
         * @en Find a follow path for the specified agent.
         * @param agent The navigation agent.
         * @param fllowPaths Array to store the resulting path data.
         * @returns Whether the path was successfully found.
         * @zh 为指定的代理查找跟随路径。
         * @param agent 导航代理。
         * @param fllowPaths 用于存储结果路径数据的数组。
         * @returns 是否成功找到路径。
         */
        findFllowPath(agent: NavAgent, fllowPaths: NavigationPathData[]): boolean;
        /**
         * @en Find the distance to the nearest wall for the specified agent.
         * @param agent The navigation agent.
         * @returns An object containing the distance, position, and normal of the nearest wall, or null if not found.
         * @zh 查找指定代理到最近墙壁的距离。
         * @param agent 导航代理。
         * @returns 包含最近墙壁的距离、位置和法线的对象，如果未找到则返回 null。
         */
        findDistanceToWall(agent: NavAgent): {
            dist: number;
            pos: Array<number>;
            normal: Array<number>;
        };
        /**
         * @en Request a move target for the specified agent.
         * @param agent The navigation agent.
         * @param destination The target destination.
         * @returns Whether the move target request was successful.
         * @zh 为指定的代理请求移动目标。
         * @param agent 导航代理。
         * @param destination 目标位置。
         * @returns 移动目标请求是否成功。
         */
        requestMoveTarget(agent: NavAgent, destination: Vector3): boolean;
        /**
         * @en Build and get the debug mesh for the NavMesh.
         * @returns The created debug mesh.
         * @zh 构建并获取 NavMesh 的调试网格。
         * @returns 创建的调试网格。
         */
        buildDebugMesh(): Mesh;
    }
    /**
     * @en The NavMeshGrid class manages the grid division of the navigation mesh.
     * @zh NavMeshGrid 类用于管理导航网格的网格划分。
     */
    class NavMeshGrid {
        /**
         * @en The width of a single tile.
         * @zh 单个瓦片的宽度。
         */
        get tileWidth(): number;
        /**
         * @ignore
         * @en Instance an NavMeshGrid component.
         * @param config The configuration for the navigation mesh.
         * @param bound The bounding box of the navigation mesh.
         * @zh 实例化一个NavMeshGrid组件。
         * @param config 导航网格的配置。
         * @param bound 导航网格的边界框。
         */
        constructor(config: RecastConfig, min: Vector3, max: Vector3);
        /**
         * update bound
         */
        private _updateBound;
        /**
         * @en Update the configuration and bounding box based on the given tile data.
         * @param tile The navigation tile data.
         * @zh 根据给定的瓦片数据更新配置和边界框。
         * @param tile 导航瓦片数据。
         */
        refeachConfig(tile: NavTileData): void;
        /**
         * @en Get the tile indices that intersect with the given bounding box defined by minimum and maximum coordinates.
         * @param min The minimum coordinates of the bounding box.
         * @param max The maximum coordinates of the bounding box.
         * @param isbord Whether to include a border around the bounding box.
         * @returns An array of tile indices.
         * @zh 获取与由最小和最大坐标定义的给定边界框相交的瓦片索引。
         * @param min 边界框的最小坐标。
         * @param max 边界框的最大坐标。
         * @param isbord 是否在边界框周围包含边界。
         * @returns 瓦片索引数组。
         */
        getBoundTileIndex(min: Vector3, max: Vector3, isbord?: boolean): number[];
        /**
         * @en The bounding box of the navigation mesh.
         * @zh 导航网格的边界框。
         */
        get boundMin(): Vector3;
        /**
         * @en The bounding box of the navigation mesh.
         * @zh 导航网格的边界框。
         */
        get boundMax(): Vector3;
        /**
         * @en The configuration of the navigation mesh.
         * @zh 导航网格的配置。
         */
        get config(): RecastConfig;
        /**
         * @en Get the tile index based on world position.
         * @param x The x-coordinate in world space.
         * @param z The z-coordinate in world space.
         * @returns The tile index.
         * @zh 根据世界坐标获取瓦片索引。
         * @param x 世界坐标 x。
         * @param z 世界坐标 z。
         * @returns 瓦片索引。
         */
        getTileIndexByPos(x: number, z: number): number;
        /**
         * @en Get the tile index based on tile coordinates.
         * @param xIndex The x-index of the tile.
         * @param zIndex The z-index of the tile.
         * @returns The tile index, or -1 if out of bounds.
         * @zh 根据瓦片坐标获取瓦片索引。
         * @param xIndex 瓦片的 x 索引。
         * @param zIndex 瓦片的 z 索引。
         * @returns 瓦片索引，如果超出边界则返回 -1。
         */
        getTileIndex(xIndex: number, zIndex: number): number;
        /**
         * @en Get the maximum number of tiles.
         * @zh 获取最大瓦片数量。
         */
        getMaxtiles(): number;
        /**
         * @en Get the maximum number of tiles along the x-axis.
         * @zh 获取 x 轴方向的最大瓦片数量。
         */
        get maxXTileCount(): number;
        /**
         * @en Get the maximum number of tiles along the z-axis.
         * @zh 获取 z 轴方向的最大瓦片数量。
         */
        get maxZTileCount(): number;
        /**
         * @en Get the maximum number of cells along the x-axis.
         * @zh 获取 x 轴方向的最大单元格数量。
         */
        get maxXCellCount(): number;
        /**
         * @en Get the maximum number of cells along the z-axis.
         * @zh 获取 z 轴方向的最大单元格数量。
         */
        get maxZCellCount(): number;
    }
    /**
     * @en The class NavTileCache is used to cache and manage the tile data of the navigation mesh.
     * @zh 类 NavTileCache 用于缓存和管理导航网格的瓦片数据。
     */
    class NavTileCache {
        /**
         * @en The x offset of the tile.
         * @zh 瓦片的x偏移。
         */
        x: number;
        /**
         * @en The y offset of the tile.
         * @zh 瓦片的y偏移。
         */
        y: number;
        /**
         * @en Create a new instance of NavTileCache.
         * @zh 创建 NavTileCache 类的新实例。
         */
        constructor();
        /**
         * @en Triangle vertices
         * @zh 三角形顶点
         */
        set triVertex(data: Float32Array);
        get triVertex(): Float32Array;
        /**
         * @en Triangle indices
         * @zh 三角形索引
         */
        set triIndex(data: Uint32Array);
        get triIndex(): Uint32Array;
        /**
         * @en Triangle flags
         * @zh 三角形标记
         */
        set triFlag(data: Uint8Array);
        get triFlag(): Uint8Array;
        /**
         * @en Bounding box
         * @zh 包围盒大小
         */
        get boundMin(): Vector3;
        get boundMax(): Vector3;
        /**
         * @en Bound data
         * @zh 绑定数据
         */
        get bindData(): any;
        /**
         * @en Destroy the NavTileCache
         * @zh 销毁 NavTileCache
         */
        destroy(): void;
    }
    /**
     * @en NavTileData class for parsing and storing navigation mesh data
     * @zh NavTileData 类用于解析和存储导航网格数据
     */
    class NavTileData {
        /**
         * @en Create a new instance of NavTileData.
         * @param res TextResource containing navigation data
         * @zh 创建 NavTileData 类的新实例。
         * @param res 包含导航数据的 TextResource
         */
        constructor(res: TextResource);
        /**
         * @en Get the dirty flag
         * @zh 获取脏标记
         */
        get dirtyFlag(): number;
        /**
         * @en Get NavTileCache data by index
         * @param index The index of the NavTileCache
         * @zh 通过索引获取 NavTileCache 数据
         * @param index NavTileCache 的索引
         */
        getNavData(index: number): NavTileCache;
        /**
         * @en Get the number of NavTileCache objects
         * @zh 获取 NavTileCache 对象的数量
         */
        get length(): number;
    }
    /**
     * @en Create Recast navMesh Config
     * @zh 创建 Recast 导航网格配置
     */
    class RecastConfig implements IClone {
        /**
         * @en Agent name
         * @zh 代理名称
         */
        agentName: string;
        /**
         * @en Cell height in meters
         * @zh 像素格子高度，单位：米
         */
        cellHeight: number;
        /**
         * @en Maximum slope for the path in degrees
         * @zh 路径最大坡度，单位：角度
         */
        agentMaxSlope: number;
        /**
         * @en Maximum height of the agent in meters
         * @zh 代理最大高度跨度，单位：米
         */
        agentHeight: number;
        /**
         * @en Maximum climb height for the agent in meters
         * @zh 代理最大攀爬高度，单位：米
         */
        agentMaxClimb: number;
        /**
         * @en Agent radius in meters
         * @zh 代理半径，单位：米
         */
        agentRadius: number;
        /**
         * @en Number of cells per tile
         * @zh 每个瓦片的格子数量
         */
        tileSize: number;
        /**
         * @en Cell size in meters
         * @zh 像素格子尺寸，单位：米
         */
        set cellSize(value: number);
        get cellSize(): number;
        /** @ignore */
        constructor();
        /**
         * @en Clone the RecastConfig object
         * @returns A new RecastConfig object with the same properties
         * @zh 克隆 RecastConfig 对象
         * @returns 具有相同属性的新 RecastConfig 对象
         */
        clone(): RecastConfig;
        /**
         * @en Clone properties to another object
         * @param destObject The target object to clone to
         * @zh 将属性克隆到另一个对象
         * @param destObject 要克隆到的目标对象
         */
        cloneTo(destObject: RecastConfig): void;
    }
    /**
     * 自动图集管理类
     * @private
     */
    class AtlasInfoManager {
        static _fileLoadDic: Record<string, {
            url: string;
            baseUrl?: string;
        }>;
        static enable(infoFile: string, callback?: Handler | null): void;
        static addAtlases(data: Record<string, [
            string,
            string[]
        ]>): void;
        static addAtlas(atlasUrl: string, prefix: string, frames: Array<string>): void;
        static getFileLoadPath(file: string): {
            url: string;
            baseUrl?: string;
        };
    }
    type ProgressCallback = (progress: number) => void;
    interface IBatchProgress {
        readonly itemCount: number;
        createCallback(weight?: number): ProgressCallback;
        update(index: number, progress: number): void;
    }
    /**
     * @en Represents a batch progress tracker that manages multiple progress items.
     * @zh 表示一个批量进度跟踪器,用于管理多个进度项。
     */
    class BatchProgress implements IBatchProgress {
        private _callback;
        private _items;
        private _weights;
        private _progress;
        /**
         * @en Creates a new BatchProgress instance.
         * @param callback The callback function to be called when progress updates.
         * @zh 创建一个新的 BatchProgress 实例。
         * @param callback 进度更新时要调用的回调函数。
         */
        constructor(callback: ProgressCallback);
        /**
         * @en The number of progress items.
         * @zh 进度项的数量。
         */
        get itemCount(): number;
        /**
         * @en Resets the progress tracker, clearing all items and weights.
         * @zh 重置进度跟踪器,清除所有项目和权重。
         */
        reset(): void;
        /**
         * @en Creates a callback function for a new progress item.
         * @param weight The weight of the progress item. Defaults to null.
         * @returns A callback function for updating the progress of this item.
         * @zh 为新的进度项创建一个回调函数。
         * @param weight 进度项的权重。默认为null。
         * @returns 用于更新此项目进度的回调函数。
         */
        createCallback(weight?: number): ProgressCallback;
        /**
         * @en Updates the progress of a specific item and recalculates the overall progress.
         * @param index The index of the item to update. Use -1 to update overall progress directly.
         * @param value The new progress value (0-1).
         * @zh 更新特定项目的进度并重新计算总体进度。
         * @param index 要更新的项目索引。使用-1直接更新总体进度。
         * @param value 新的进度值(0-1)。
         */
        update(index: number, value: number): void;
    }
    /**
     * @en Downloader class responsible for handling various types of resource downloads.
     * @zh Downloader类负责处理各种类型的资源下载。
     */
    class Downloader {
        /**
         * @en Downloads common resources using HTTP request.
         * @param owner The owner of the download request.
         * @param url The URL of the resource to download.
         * @param originalUrl The original URL of the resource.
         * @param contentType The content type of the resource.
         * @param onProgress Callback function for download progress.
         * @param onComplete Callback function when download is complete.
         * @zh 使用HTTP请求下载通用资源。
         * @param owner 下载请求的所有者。
         * @param url 要下载的资源的URL。
         * @param originalUrl 资源的原始URL。
         * @param contentType 资源的内容类型。
         * @param onProgress 下载进度的回调函数。
         * @param onComplete 下载完成时的回调函数。
         */
        common(owner: any, url: string, originalUrl: string, contentType: string, onProgress: (progress: number) => void, onComplete: (data: any, error?: string) => void): void;
        /**
         * @en Downloads an image resource.
         * @param owner The owner of the download request.
         * @param url The URL of the image to download.
         * @param originalUrl The original URL of the image.
         * @param onProgress Callback function for download progress.
         * @param onComplete Callback function when download is complete.
         * @zh 下载图像资源。
         * @param owner 下载请求的所有者。
         * @param url 要下载的图像的URL。
         * @param originalUrl 图像的原始URL。
         * @param onProgress 下载进度的回调函数。
         * @param onComplete 下载完成时的回调函数。
         */
        image(owner: any, url: string, originalUrl: string, onProgress: (progress: number) => void, onComplete: (data: any, error?: string) => void): void;
        /**
         * @en Downloads an image from a Blob.
         * @param owner The owner of the download request.
         * @param blob The ArrayBuffer containing the image data.
         * @param originalUrl The original URL of the image.
         * @param onProgress Callback function for download progress.
         * @param onComplete Callback function when download is complete.
         * @zh 从Blob下载图像。
         * @param owner 下载请求的所有者。
         * @param blob 包含图像数据的ArrayBuffer。
         * @param originalUrl 图像的原始URL。
         * @param onProgress 下载进度的回调函数。
         * @param onComplete 下载完成时的回调函数。
         */
        imageWithBlob(owner: any, blob: ArrayBuffer, originalUrl: string, onProgress: (progress: number) => void, onComplete: (data: any, error?: string) => void): void;
        /**
         * @en Downloads an image using a worker.
         * @param owner The owner of the download request.
         * @param url The URL of the image to download.
         * @param originalUrl The original URL of the image.
         * @param onProgress Callback function for download progress.
         * @param onComplete Callback function when download is complete.
         * @zh 使用worker下载图像。
         * @param owner 下载请求的所有者。
         * @param url 要下载的图像的URL。
         * @param originalUrl 图像的原始URL。
         * @param onProgress 下载进度的回调函数。
         * @param onComplete 下载完成时的回调函数。
         */
        imageWithWorker(owner: any, url: string, originalUrl: string, onProgress: (progress: number) => void, onComplete: (data: any, error?: string) => void): void;
        /**
         * @en Downloads an audio resource.
         * @param owner The owner of the download request.
         * @param url The URL of the audio to download.
         * @param originalUrl The original URL of the audio.
         * @param onProgress Callback function for download progress.
         * @param onComplete Callback function when download is complete.
         * @zh 下载音频资源。
         * @param owner 下载请求的所有者。
         * @param url 要下载的音频的URL。
         * @param originalUrl 音频的原始URL。
         * @param onProgress 下载进度的回调函数。
         * @param onComplete 下载完成时的回调函数。
         */
        audio(owner: any, url: string, originalUrl: string, onProgress: (progress: number) => void, onComplete: (data: any, error?: string) => void): void;
        /**
         * @en Pool of HttpRequest instances.
         * @zh HttpRequest实例池。
         */
        httpRequestPool: Array<HttpRequest>;
        protected getRequestInst(): HttpRequest;
        protected returnRequestInst(inst: HttpRequest): void;
    }
    /**
     * @en The `HttpRequest` class encapsulates the HTML `XMLHttpRequest` object to provide full access to the HTTP protocol, including the ability to make POST and HEAD requests as well as regular GET requests. `HttpRequest` only provides asynchronous responses from web servers and can return content in either text or binary form.
     * - Note: It is recommended to use a new `HttpRequest` object for each request, as each call to the send method of this object will clear previously set data and reset the HTTP request status. This can cause previously unreturned responses to be reset, resulting in the loss of response results from previous requests.
     * - EventType Event.PROGRESS: Dispatch when the request progress changes.
     * - EventType Event.COMPLETE: Dispatch after the request ends.
     * - EventType Event.ERROR: Dispatch when the request fails.
     * @zh `HttpRequest` 类通过封装 HTML `XMLHttpRequest` 对象提供了对 HTTP 协议的完全访问，包括发送 POST 和 HEAD 请求以及普通的 GET 请求的能力。`HttpRequest` 只以异步形式返回 Web 服务器的响应，并且能够以文本或二进制形式返回内容。
     * - 注意：建议每次请求都使用新的 `HttpRequest` 对象，因为每次调用该对象的 send 方法时，都会清空之前设置的数据，并重置 HTTP 请求的状态，这会导致之前还未返回响应的请求被重置，从而得不到之前请求的响应结果。
     * - EventType Event.PROGRESS: 请求进度改变时调度。
     * - EventType Event.COMPLETE: 请求结束后调度。
     * - EventType Event.ERROR: 请求出错时调度。
     */
    class HttpRequest extends EventDispatcher {
        protected _http: XMLHttpRequest;
        private static _urlEncode;
        protected _responseType: string;
        protected _data: any;
        protected _url: string;
        /**
         * @en Send an HTTP request.
         * @param url The URL to request. Most browsers implement a same-origin security policy and require that the URL has the same hostname and port as the script.
         * @param data (default = null) The data to be sent.
         * @param method (default = "get") The HTTP method used for the request. Values include "get", "post", "head".
         * @param responseType (default = "text") The response type from the web server, can be set to "text", "json", "xml", "arraybuffer".
         * @param headers (default = null) The header information for the HTTP request. Parameters are in the form of a key-value array: key is the name of the header, should not include whitespace, colon, or newline; value is the value of the header, should not include newline. For example ["Content-Type", "application/json"].
         * @zh 发送 HTTP 请求。
         * @param url 请求的地址。大多数浏览器实施了同源安全策略，要求此 URL 与包含脚本的文本具有相同的主机名和端口。
         * @param data (默认值 = null) 发送的数据。
         * @param method (默认值 = "get") 用于请求的 HTTP 方法。值包括 "get"、"post"、"head"。
         * @param responseType (默认值 = "text") Web 服务器的响应类型，可设置为 "text"、"json"、"xml"、"arraybuffer"。
         * @param headers (默认值 = null) HTTP 请求的头部信息。参数形如 key-value 数组：key 是头部的名称，不应包括空白、冒号或换行；value 是头部的值，不应包括换行。例如 ["Content-Type", "application/json"]。
         */
        send(url: string, data?: any, method?: "get" | "post" | "head", responseType?: "text" | "json" | "xml" | "arraybuffer", headers?: string[]): void;
        /**
         * @en The listening and processing function for requesting progress.
         * @param e The event object.
         * @zh 请求进度的侦听处理函数。
         * @param	e 事件对象。
         */
        protected _onProgress(e: any): void;
        /**
         * @en The listening and processing function for request interruption.
         * @param e The event object.
         * @zh 请求中断的侦听处理函数。
         * @param	e 事件对象。
         */
        protected _onAbort(e: any): void;
        /**
         * @en The listening and processing function for request errors.
         * @param e The event object.
         * @zh 请求出错侦的听处理函数。
         * @param	e 事件对象。
         */
        protected _onError(e: any): void;
        /**
         * @en The listening and processing function for request completion.
         * @param e The event object.
         * @zh 请求消息返回的侦听处理函数。
         * @param	e 事件对象。
         */
        protected _onLoad(e: any): void;
        /**
         * @en Request error handling function.
         * @param message The error message.
         * @zh 请求错误的处理函数。
         * @param	message 错误信息。
         */
        protected error(message: string): void;
        /**
         * @en The processing function for successfully completing the request.
         * @zh 请求成功完成的处理函数。
         */
        protected complete(): void;
        /**
         * @en Clear the current request.
         * @zh 清除当前请求。
         */
        protected clear(): void;
        /**
         * @en The requested URL.
         * @zh 请求的地址。
         */
        get url(): string;
        /**
         * @en The data.
         * @zh 数据。
         */
        get data(): any;
        /**
         * @en The reference to the native XMLHttpRequest object encapsulated by this object.
         * @zh 本对象所封装的原生 XMLHttpRequest 引用。
         */
        get http(): any;
        /**
         * @en Reset the HttpRequest object, clearing all event listeners and data.
         * @zh 重置 HttpRequest 对象，清除所有事件监听器和数据。
         */
        reset(): void;
    }
    interface ILoadTask {
        readonly type: string;
        readonly url: string;
        readonly uuid: string;
        readonly ext: string;
        readonly loader: Loader;
        readonly obsoluteInst: Resource;
        readonly options: Readonly<ILoadOptions>;
        readonly progress: IBatchProgress;
    }
    interface IResourceLoader {
        load(task: ILoadTask): Promise<any>;
        postLoad?(task: ILoadTask, content: any): Promise<void>;
    }
    interface ILoadOptions {
        type?: string;
        priority?: number;
        group?: string;
        cache?: boolean;
        ignoreCache?: boolean;
        noRetry?: boolean;
        silent?: boolean;
        useWorkerLoader?: boolean;
        constructParams?: TextureConstructParams;
        propertyParams?: TexturePropertyParams;
        blob?: ArrayBuffer;
        initiator?: ILoadTask;
        [key: string]: any;
    }
    interface ILoadURL extends ILoadOptions {
        url: string;
    }
    interface ContentTypeMap {
        "text": string;
        "json": any;
        "xml": XML;
        "arraybuffer": ArrayBuffer;
        "image": HTMLImageElement | ImageBitmap;
        "sound": HTMLAudioElement;
    }
    type TypeMapEntry = {
        typeId: number;
        loaderType: new () => IResourceLoader;
        hotReloadable?: boolean;
    };
    interface URLInfo {
        ext: string;
        typeId: number;
        main: boolean;
        loaderType: new () => IResourceLoader;
    }
    /**
     * @en The `Loader` class can be used to load resources such as text, JSON, XML, binary, images, etc.
     * @zh `Loader` 类可用来加载文本、JSON、XML、二进制、图像等资源。
     */
    class Loader extends EventDispatcher {
        /**
         * @en Text type, returns a TextResource object containing a string after loading is complete.
         * @zh 文本类型，加载完成后返回包含 string 的 TextResource 对象。
         */
        static TEXT: string;
        /**
         * @en JSON type, returns a TextResource object containing JSON data after loading is complete.
         * @zh JSON 类型，加载完成后返回包含 json 数据的 TextResource 对象。
         */
        static JSON: string;
        /**
         * @en XML type, returns a TextResource object containing domXML after loading is complete.
         * @zh XML 类型，加载完成后返回包含 domXML 的 TextResource 对象。
         */
        static XML: string;
        /**
         * @en Binary type, returns a TextResource object containing arraybuffer after loading is complete.
         * @zh 二进制类型，加载完成后返回包含 arraybuffer 的 TextResource 对象。
         */
        static BUFFER: string;
        /**
         * @en Texture type, returns a Texture after loading is complete.
         * @zh 纹理类型，加载完成后返回 Texture。
         */
        static IMAGE: string;
        /**
         * @en Sound type, returns a Sound after loading is complete.
         * @zh 声音类型，加载完成后返回 Sound。
         */
        static SOUND: string;
        /**
         * @en Video type, returns a VideoTexture after loading is complete.
         * @zh 视频类型，加载完成后返回 VideoTexture。
         */
        static VIDEO: string;
        /**
         * @en Atlas type, returns atlas JSON information (and creates small Textures within the atlas) after loading is complete.
         * @zh 图集类型，加载完成后返回图集 json 信息（并创建图集内小图 Texture）。
         */
        static ATLAS: string;
        /**
         * @en Bitmap font type, returns a BitmapFont after loading is complete. It will be automatically registered as a bitmap font based on the file name.
         * @zh 位图字体类型，加载完成后返回 BitmapFont，加载后，会根据文件名自动注册为位图字体。
         */
        static FONT: string;
        /**
         * @en TTF font type, returns an object after loading is complete.
         * @zh TTF 字体类型，加载完成后返回一个对象。
         */
        static TTF: string;
        /**
         * @en Hierarchy resource.
         * @zh Hierarchy 资源。
         */
        static HIERARCHY: string;
        /**
         * @en Mesh resource.
         * @zh Mesh 资源。
         */
        static MESH: string;
        /**
         * @en Material resource.
         * @zh Material 资源。
         */
        static MATERIAL: string;
        /**
         * @en Texture2D resource. This is for compatibility, it should actually be BaseTexture.
         * @zh Texture2D 资源。这里是为了兼容，实际应该是 BaseTexture。
         */
        static TEXTURE2D: string;
        /**
         * @en TextureCube resource. For compatibility, now TEXTURE2D type can load Texture or TextureCube.
         * @zh TextureCube 资源。兼容处理，现在 TEXTURE2D 类型可以载入 Texture 或者 TextureCube。
         */
        static TEXTURECUBE: string;
        /**
         * @en TEXTURE2DARRAY resource.
         * @zh TEXTURE2DARRAY 资源。
         */
        static TEXTURE2DARRAY: string;
        /**
         * @en AnimationClip resource.
         * @zh AnimationClip 资源。
         */
        static ANIMATIONCLIP: string;
        /**
         * @en Terrain height data resource.
         * @zh Terrain 高度数据资源。
         */
        static TERRAINHEIGHTDATA: string;
        /**
         * @en Terrain resource.
         * @zh Terrain 资源。
         */
        static TERRAINRES: string;
        /**
         * @en Spine resource.
         * @zh Spine 资源。
         */
        static SPINE: string;
        /**
         * @en Resource download + parse time.
         * @zh 资源下载 + 解析时间。
         */
        static LoaderStat_LoadResourceTime: number;
        /**
         * @en Number of resource downloads.
         * @zh 资源下载次数。
         */
        static LoaderStat_LoaderResourceCount: number;
        /**
         * @en Number of network file requests.
         * @zh 网络文件请求次数。
         */
        static LoaderStat_LoadRequestCount: number;
        /**
         * @en Network download time.
         * @zh 网络下载时间。
         */
        static LoaderStat_LoadRequestTime: number;
        /**
         * @en Number of retry attempts after loading fails, default is 1.
         * @zh 加载出错后的重试次数，默认重试一次。
         */
        retryNum: number;
        /**
         * @en Delay time before retrying after an error, default is to retry immediately.
         * @zh 延迟时间多久再进行错误重试，默认立即重试。
         */
        retryDelay: number;
        /**
         * @en Maximum number of download threads, default is 5.
         * @zh 最大下载线程，默认为 5 个。
         */
        maxLoader: number;
        /**
         * @en List of resource loaders.
         * @zh 资源加载器列表。
         */
        static readonly extMap: {
            [ext: string]: Array<TypeMapEntry>;
        };
        /**
         * @en Resource type mapping table.
         * @zh 资源类型对应表。
         */
        static readonly typeMap: {
            [type: string]: TypeMapEntry;
        };
        /**
         * @en Hot overload identification.
         * @zh 热重载标识。
         */
        static readonly hotReloadableFlags: Record<number, boolean>;
        /**
         * @en If an extension corresponds to multiple loading types, you can define a mapping here, which can be used to obtain the correct loading type through the resource type recorded in the file during deserialization.
         * @zh 如果一个扩展名对应多种加载类型时，那么在可以在这里定义一个映射，用于在反序列化时，通过文件中记录的资源类型获得正确的加载类型。
         */
        static readonly assetTypeToLoadType: Record<string, string>;
        /**
         * @en The downloader used to download resources.
         * @zh 下载器，用来下载资源。
         */
        static downloader: Downloader;
        /**
         * @en Register a resource loader.
         * @param exts Extensions
         * @param cls Loader class
         * @param type Type identifier. If this kind of resource needs to support identification without extension, or if one extension corresponds to multiple resource types, specifying the type parameter is the best practice.
         * @param hotReloadable Whether to support hot reload
         * @zh 注册一种资源装载器。
         * @param exts 扩展名
         * @param cls 加载器类
         * @param type 类型标识。如果这种资源需要支持识别没有扩展名的情况，或者一个扩展名对应了多种资源类型的情况，那么指定 type 参数是个最优实践。
         * @param hotReloadable 是否支持热重载
         */
        static registerLoader(exts: string[], cls: new () => IResourceLoader, type?: string, hotReloadable?: boolean): void;
        /**
         * @en Resource group mapping table.
         * @zh 资源分组对应表。
         */
        static groupMap: {
            [name: string]: Set<string>;
        };
        /**
         * @en Pool of loaded resources.
         * @zh 已加载的资源池。
         */
        static loadedMap: {
            [url: string]: Array<any>;
        };
        /**
         * @en Preloaded data files. If a url has a record here, the data here will be used directly when requested, abandoning network loading.
         * @zh 预加载的数据文件。如果一个 url 在这里有记录，则请求时直接使用这里的数据，放弃网络加载。
         */
        static preLoadedMap: {
            [url: string]: any;
        };
        private _loadings;
        private _queue;
        private _downloadings;
        private _tempTime;
        /** @ignore */
        constructor();
        /**
         * @en Indicates whether there are any loading tasks in progress.
         * @zh 是否有任何的加载任务在进行。
         */
        get loading(): boolean;
        /**
         * @en Loads resources.
         * @param url The URL or array of URLs of the resource(s) to load.
         * @param type The type of resource. For example: Loader.IMAGE.
         * @param onProgress The progress callback function.
         * @returns A Promise that resolves with the loaded resource(s). If url is a single resource, it returns the loaded resource or null if failed. If url is an array, it returns an array of loaded resources or null for each failed load.
         * @zh 加载资源。
         * @param url 要加载的资源地址或资源地址数组。
         * @param type 资源类型。比如：Loader.IMAGE。
         * @param onProgress 进度回调函数。
         * @returns 返回一个 Promise。根据 url 类型不同分为两种情况：1. url 为字符串或 ILoadURL 类型时，如果加载成功，则返回加载完成的资源，否则为 null；2. url 为数组类型时，返回一个数组，数组每个元素为加载完成的资源或 null。
         */
        load(url: string | ILoadURL | (string | Readonly<ILoadURL>)[], type?: string, onProgress?: ProgressCallback): Promise<any>;
        /**
         * @en Loads resources with options.
         * @param url The URL or array of URLs of the resource(s) to load.
         * @param options The loading options.
         * @param onProgress The progress callback function.
         * @returns A Promise that resolves with the loaded resource(s). If url is a single resource, it returns the loaded resource or null if failed. If url is an array, it returns an array of loaded resources or null for each failed load.
         * @zh 使用选项加载资源。
         * @param url 要加载的资源地址或资源地址数组。
         * @param options 加载选项。
         * @param onProgress 进度回调函数。
         * @returns 返回一个 Promise。根据 url 类型不同分为两种情况：1. url 为字符串或 ILoadURL 类型时，如果加载成功，则返回加载完成的资源，否则为 null；2. url 为数组类型时，返回一个数组，数组每个元素为加载完成的资源或 null。
         */
        load(url: string | ILoadURL | (string | Readonly<ILoadURL>)[], options?: Readonly<ILoadOptions>, onProgress?: ProgressCallback): Promise<any>;
        /**
         * @en Loads resources (compatible with engine 2.0 loading interface).
         * @param url The URL or array of URLs of the resource(s) to load. Can be a simple array ["a.png", "b.png"] or a complex array [{url:"a.png",type:Loader.IMAGE,size:100,priority:1},{url:"b.json",type:Loader.JSON,size:50,priority:1}].
         * @param complete The completion callback. Returns the loaded resource if url is a string, or an array of loaded resources (or null for failed loads) if url is an array.
         * @param progress The progress callback. The callback parameter is the current resource loading progress (0-1).
         * @param type The resource type. For example: Loader.IMAGE.
         * @param priority The loading priority. Higher numbers indicate higher priority. Default is 0.
         * @param cache Whether to cache the resource. Default is true.
         * @param group The group name for resource management.
         * @param ignoreCache Whether to ignore the cache. Default is false.
         * @param useWorkerLoader Whether to use worker loading (only for IMAGE and ATLAS types, and when browser supports it). Default is false.
         * @returns A Promise object.
         * @zh 加载资源（兼容 2.0 引擎的加载接口）。
         * @param url 要加载的单个资源地址或资源信息数组。可以是简单数组 ["a.png", "b.png"] 或复杂数组 [{url:"a.png",type:Loader.IMAGE,size:100,priority:1},{url:"b.json",type:Loader.JSON,size:50,priority:1}]。
         * @param complete 加载完成回调。如果 url 是字符串，返回加载完成的资源；如果 url 是数组，返回加载完成的资源数组（加载失败的项为 null）。
         * @param progress 加载进度回调。回调参数为当前资源的加载进度（0-1）。
         * @param type 资源类型。比如：Loader.IMAGE。
         * @param priority 加载优先级，数字越大优先级越高。默认为 0。
         * @param cache 是否缓存资源。默认为 true。
         * @param group 分组名称，用于资源管理。
         * @param ignoreCache 是否忽略缓存。默认为 false。
         * @param useWorkerLoader 是否使用 worker 加载（仅针对 IMAGE 和 ATLAS 类型，且浏览器支持时生效）。默认为 false。
         * @returns Promise 对象。
         */
        load(url: string | ILoadURL | (string | Readonly<ILoadURL>)[], complete?: Handler, progress?: Handler, type?: string, priority?: number, cache?: boolean, group?: string, ignoreCache?: boolean, useWorkerLoader?: boolean): Promise<any>;
        /**
         * @en Download from the specified URL. This is a low-level method for downloading resources. Unlike the load method, it doesn't parse the returned data or cache the downloaded content. Returns the downloaded data on success, null on failure.
         * @param url The URL to download from.
         * @param contentType The expected content type of the resource.
         * @param onProgress Optional callback for progress updates.
         * @param options Optional loading options.
         * @returns A promise that resolves with the downloaded content. If the download fails, the promise resolves with null.
         * @zh 从指定URL下载。这是较为底层的下载资源的方法，它和load方法不同，不对返回的数据进行解析，也不会缓存下载的内容。成功则返回下载的数据，失败返回null。
         * @param url 要下载的URL。
         * @param contentType 预期的资源内容类型。
         * @param onProgress 可选的进度更新回调。
         * @param options 可选的加载选项。
         * @returns 解析为下载内容的Promise，加载失败则返回null
         */
        fetch<K extends keyof ContentTypeMap>(url: string, contentType: K, onProgress?: ProgressCallback, options?: Readonly<ILoadOptions>): Promise<ContentTypeMap[K]>;
        private queueToDownload;
        private download;
        private completeItem;
        /**
         * @en Get URL information based on the provided URL and optional type.
         * @param url The URL to analyze.
         * @param type Optional type specification.
         * @returns URLInfo object containing extension, main flag, typeId, and loaderType.
         * @zh 根据提供的URL和可选类型获取URL信息。
         * @param url 要分析的URL。
         * @param type 可选的类型规范。
         * @returns 包含扩展名、主要标志、类型ID和加载器类型的URLInfo对象。
         */
        static getURLInfo(url: string, type?: string): URLInfo;
        /**
         * @en Log a warning about a failed resource load, optionally including the initiator URL.
         * @param url The URL of the resource that failed to load.
         * @param err Optional error object or message.
         * @param initiatorUrl Optional URL of the resource that initiated the load.
         * @zh 记录资源加载失败的警告，可选择包含启动器URL。
         * @param url 加载失败的资源URL。
         * @param err 可选的错误对象或消息。
         * @param initiatorUrl 可选的启动加载的资源URL。
         */
        static warnFailed(url: string, err?: any, initiatorUrl?: string): void;
        /**
         * @en Log a warning message, optionally including an error object.
         * @param msg The warning message to log.
         * @param err Optional error object to include in the warning.
         * @zh 记录警告消息，可选择包含错误对象。
         * @param msg 要记录的警告消息。
         * @param err 可选的要包含在警告中的错误对象。
         */
        static warn(msg: string, err?: any): void;
        /**
         * @en Retrieve resources from the specified resource address.
         * @param url The resource address.
         * @return Returns the resource.
         * @zh 获取指定资源地址的资源。
         * @param url 资源地址。
         * @return 返回资源。
         */
        static getRes(url: string, type?: string): any;
        /**
         * @en Get a Texture2D resource by URL.
         * @param url The URL of the Texture2D resource.
         * @returns The Texture2D resource.
         * @zh 通过 URL 获取 Texture2D 资源。
         * @param url Texture2D 资源的 URL。
         * @returns Texture2D 资源。
         */
        static getTexture2D(url: string): Texture2D;
        /**
         * @en Get a BaseTexture resource by URL.
         * @param url The URL of the BaseTexture resource.
         * @returns The BaseTexture resource.
         * @zh 通过 URL 获取 BaseTexture 资源。
         * @param url BaseTexture 资源的 URL。
         * @returns BaseTexture 资源。
         */
        static getBaseTexture<T extends BaseTexture>(url: string): T;
        /**
         * @en Get the atlas resource by URL.
         * @param url The URL of the atlas.
         * @returns Return the set of addresses.
         * @zh 获取指定资源地址的图集资源。
         * @param url 图集地址。
         * @returns 返回地址集合。
         */
        static getAtlas(url: string): AtlasResource;
        /**
         * @en Get a resource by URL and type.
         * @param url The URL of the resource.
         * @param type The type of the resource.
         * @returns The resource.
         * @zh 通过 URL 和类型获取资源。
         * @param url 资源的 URL。
         * @param type 资源的类型。
         * @returns 资源。
         */
        getRes(url: string, type?: string): any;
        /**
         * @en Create nodes from a prefab resource.
         * @param url The URL of the prefab resource.
         * @returns The created node.
         * @zh 从预制资源创建节点。
         * @param url 预制资源的 URL。
         * @returns 创建的节点。
         */
        static createNodes<T extends Node>(url: string): T;
        /**
         * @en Cache a resource.
         * @param url The URL of the resource.
         * @param data The content to be cached.
         * @param type The type of the resource.
         * @zh 缓存资源。
         * @param url 资源地址。
         * @param data 要缓存的内容。
         * @param type 资源类型。
         */
        static cacheRes(url: string, data: any, type?: string): void;
        /**
         * @en Cache a resource.
         * @param url The URL of the resource.
         * @param data The content to be cached.
         * @param type The type of the resource.
         * @zh 缓存资源。
         * @param url 资源地址。
         * @param data 要缓存的内容。
         * @param type 资源类型。
         */
        cacheRes(url: string, data: any, type?: string): void;
        /**
         * @en Clear the cached resource at the specified URL.
         * @param url The URL of the resource.
         * @param checkObj If provided, only clear the resource if it matches this object.
         * @zh 清理指定资源地址的缓存。
         * @param url 资源地址。
         * @param checkObj 如果提供，只有缓存中的对象匹配这个才清除，否则不清除。
         */
        static clearRes(url: string, checkObj?: any): void;
        /**
         * @en Clear the cached resource at the specified URL.
         * @param url The URL of the resource.
         * @param checkObj If provided, only clear the resource if it matches this object.
         * @zh 清理指定资源地址的缓存。
         * @param url 资源地址。
         * @param checkObj 如果提供，只有缓存中的对象匹配这个才清除，否则不清除。
         */
        clearRes(url: string, checkObj?: any): void;
        /**
         * @en Destroy the image resource used by a Texture, keeping the texture shell. If the texture's image resource is found to be missing during the next render, it will be automatically restored. Compared to clearRes, clearTextureRes only clears the image resource used in the texture without destroying the texture itself. The image resource will be automatically restored when used again. While clearRes completely destroys the texture, making it unusable, clearTextureRes ensures immediate destruction of the image resource without worrying about incorrect destruction.
         * @param url The URL of the atlas or texture, e.g., "res/atlas/comp.atlas" or "hall/bg.jpg".
         * @zh 销毁 Texture 使用的图片资源，保留 texture 壳。如果下次渲染时发现 texture 使用的图片资源不存在，则会自动恢复。相比 clearRes，clearTextureRes 只是清理 texture 里面使用的图片资源，并不销毁 texture，再次使用到的时候会自动恢复图片资源。而 clearRes 会彻底销毁 texture，导致不能再使用；clearTextureRes 能确保立即销毁图片资源，并且不用担心销毁错误。
         * @param url 图集地址或者 texture 地址，比如 "res/atlas/comp.atlas" 或 "hall/bg.jpg"。
         */
        clearTextureRes(url: string): void;
        /**
         * @en Set the resource group.
         * @param url The URL of the resource.
         * @param group The name of the group.
         * @zh 设置资源分组。
         * @param url 资源地址。
         * @param group 分组名。
         */
        static setGroup(url: string, group: string): void;
        /**
         * @en Clean up resources based on grouping.
         * @param group The name of the group.
         * @zh 根据分组清理资源。
         * @param group 分组名
         */
        static clearResByGroup(group: string): void;
        /**
         * @en Clears all unfinished loading tasks. All unloaded content will stop loading.
         * @zh 清理当前未完成的加载，所有未加载的内容全部停止加载。
         */
        clearUnLoaded(): void;
        /**
         * @en Clears unloaded content based on a collection of URLs.
         * @param urls An array of resource URLs.
         * @zh 根据地址集合清理掉未加载的内容。
         * @param urls 资源地址集合。
         */
        cancelLoadByUrls(urls: any[]): void;
        /**
         * @en Clears unloaded content based on a specific URL.
         * @param url The resource URL.
         * @zh 根据地址清理掉未加载的内容。
         * @param url 资源地址。
         */
        cancelLoadByUrl(url: string): void;
        /**
         * @en Loads a sub-package.
         * @param path The path of the sub-package in mini-game.
         * @param onProgress The callback for loading progress.
         * @returns A Promise that resolves when the package is loaded.
         * @zh 载入一个分包。
         * @param path 小游戏的分包路径。
         * @param onProgress 加载进度回调。
         * @returns 当包加载完成时解析的 Promise。
         */
        loadPackage(path: string, onProgress?: ProgressCallback): Promise<void>;
        /**
         * @en Loads a sub-package.
         * @param path The path of the sub-package.
         * @param remoteUrl If the package is a remote package, provide the remote resource server address, e.g., "http://cdn.com/"
         * @param onProgress The callback for loading progress.
         * @returns A Promise that resolves when the package is loaded.
         * @zh 载入一个分包。
         * @param path 分包路径。
         * @param remoteUrl 如果分包是一个远程包，那需要提供远程资源服务器的地址，例如"http://cdn.com/"
         * @param onProgress 加载进度回调。
         * @returns 当包加载完成时解析的 Promise。
         */
        loadPackage(path: string, remoteUrl?: string, onProgress?: ProgressCallback): Promise<void>;
        private _loadMiniPackage;
        private _loadSubFileConfig;
    }
    /**
     * @en The `LocalStorage` class is used for data storage without time limit.
     * @zh `LocalStorage` 类用于没有时间限制的数据存储。
     */
    class LocalStorage {
        /**
         * @en Data list.
         * @zh 数据列表。
         */
        static items: any;
        /**
         * @en Indicates whether `LocalStorage` is supported.
         * @zh 表示是否支持 `LocalStorage`。
         */
        static support: boolean;
        /**
         * @en Stores a key-value pair as strings.
         * @param key The key name.
         * @param value The value to store.
         * @zh 存储指定键名和键值，字符串类型。
         * @param key 键名。
         * @param value 键值。
         */
        static setItem(key: string, value: string): void;
        /**
         * @en Retrieves the value for the specified key.
         * @param key The key name.
         * @returns The string value associated with the key.
         * @zh 获取指定键名的值。
         * @param key 键名。
         * @returns 与键关联的字符串值。
         */
        static getItem(key: string): string;
        /**
         * @en Stores a key-value pair where the value is an Object.
         * @param key The key name.
         * @param value The value to store. It's an Object type and will be converted to a JSON string for storage.
         * @zh 存储指定键名及其对应的 Object 类型值。
         * @param key 键名。
         * @param value 键值。是 Object 类型，会被转化为 JSON 字符串存储。
         */
        static setJSON(key: string, value: any): void;
        /**
         * @en Retrieves the Object value for the specified key.
         * @param key The key name.
         * @returns The Object value associated with the key.
         * @zh 获取指定键名对应的 Object 类型值。
         * @param key 键名。
         * @returns 与键关联的 Object 类型值。
         */
        static getJSON(key: string): any;
        /**
         * @en Removes the item associated with the specified key.
         * @param key The key name.
         * @zh 删除指定键名的信息。
         * @param key 键名。
         */
        static removeItem(key: string): void;
        /**
         * @en Clears all locally stored information.
         * @zh 清除所有本地存储的信息。
         */
        static clear(): void;
    }
    /**
     * @en Socket encapsulates HTML5 WebSocket, allowing full-duplex real-time communication between server and client, and cross-domain communication. After establishing a connection, both server and Browser/Client Agent can actively send or receive text and binary data to each other.
     * -  To use Socket class methods, first create a Socket object using the constructor new Socket. Socket transmits and receives data asynchronously.
     * - Event.OPEN event: dispatched after successful connection establishment.
     * - Event.MESSAGE event: dispatched after receiving data.
     * - Event.CLOSE event: dispatched after connection closed.
     * - Event.ERROR event: dispatched after an error occurred.
     * @zh Socket 封装了 HTML5 WebSocket，允许服务器端与客户端进行全双工（full-duplex）的实时通信，并且允许跨域通信。在建立连接后，服务器和 Browser/Client Agent 都能主动的向对方发送或接收文本和二进制数据。
     * - 要使用Socket 类的方法，请先使用构造函数 new Socket 创建一个 Socket 对象。 Socket 以异步方式传输和接收数据。
     * - Event.OPEN 事件：连接建立成功后调度。
     * - Event.MESSAGE 事件：接收到数据后调度。
     * - Event.CLOSE 事件：连接被关闭后调度。
     * - Event.ERROR 事件：出现异常后调度。
     */
    class Socket extends EventDispatcher {
        /**
         * @en Little-endian byte order, where the low-order byte is stored in the low address.
         * @zh 小端字节序，地址低位存储值的低位，地址高位存储值的高位。
         */
        static LITTLE_ENDIAN: string;
        /**
         * @en Big-endian byte order, where the high-order byte is stored in the low address. Also known as network byte order.
         * @zh 大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。
         */
        static BIG_ENDIAN: string;
        protected _socket: any;
        private _connected;
        private _addInputPosition;
        private _input;
        private _output;
        /**
         * @en Whether to disable caching of data received from the server. If the transmitted data is in string format, it is recommended to set this to true to reduce binary conversion overhead.
         * @zh 是否禁用服务端发来的数据缓存。如果传输的数据为字符串格式，建议设置为true，减少二进制转换消耗。
         */
        disableInput: boolean;
        private _byteClass;
        /**
         * @en Subprotocol names. A string or an array of strings of subprotocol names. Must be set before calling connect or connectByUrl, otherwise it will be invalid. If specified, the connection will only be established successfully if the server chooses one of these subprotocols, otherwise it will fail and dispatch an Event.ERROR event.
         * @zh 子协议名称。子协议名称字符串，或由多个子协议名称字符串构成的数组。必须在调用 connect 或者 connectByUrl 之前进行赋值，否则无效。指定后，只有当服务器选择了其中的某个子协议，连接才能建立成功，否则建立失败，派发 Event.ERROR 事件。
         */
        protocols: any;
        /**
         * @en The data received from the server.
         * @zh 服务端发来的缓存数据。
         */
        get input(): any;
        /**
         * @en The data in the buffer that needs to be sent to the server.
         * @zh 需要发送至服务端的缓冲区中的数据。
         */
        get output(): any;
        /**
         * @en Indicates whether this Socket object is currently connected.
         * @zh 表示此 Socket 对象目前是否已连接。
         */
        get connected(): boolean;
        /**
         * @en The byte order used by this Socket object.
         * @zh 此 Socket 对象使用的字节序。
         */
        get endian(): string;
        set endian(value: string);
        /**
         * @en Create a new Socket object. The default byte order is Socket.BIG_ENDIAN. If no parameters are specified, a socket initially in a disconnected state will be created. If valid parameters are specified, it attempts to connect to the specified host and port.
         * @param host The server address.
         * @param port The server port.
         * @param byteClass The Byte class used for receiving and sending data. If null, the Byte class will be used. You can also pass in a subclass of the Byte class.
         * @param protocols Subprotocol names. A string or an array of strings of subprotocol names.
         * @param isSecure Whether to use the WebSocket secure protocol wss, default (false) uses the ordinary protocol ws.
         * @zh 创建新的 Socket 对象。默认字节序为 Socket.BIG_ENDIAN 。若未指定参数，将创建一个最初处于断开状态的套接字。若指定了有效参数，则尝试连接到指定的主机和端口。
         * @param host 服务器地址。
         * @param port 服务器端口。
         * @param byteClass 用于接收和发送数据的 Byte 类。如果为 null ，则使用 Byte 类，也可传入 Byte 类的子类。
         * @param protocols 子协议名称。子协议名称字符串，或由多个子协议名称字符串构成的数组。
         * @param isSecure 是否使用WebSocket安全协议wss，默认（false）使用普通协议ws。
         */
        constructor(host?: string | null, port?: number, byteClass?: new () => any, protocols?: any[] | null, isSecure?: boolean);
        /**
         * @en Connect to the specified host and port.
         * - Dispatches Event.OPEN on successful connection; Event.ERROR on connection failure; Event.CLOSE when the connection is closed; Event.MESSAGE when data is received. Except for Event.MESSAGE where the event parameter is the data content, other event parameters are native HTML DOM Event objects.
         * @param host The server address.
         * @param port The server port.
         * @param isSecure Whether to use the WebSocket secure protocol wss, default (false) uses the ordinary protocol ws.
         * @zh 连接到指定的主机和端口。
         * - 连接成功派发 Event.OPEN 事件；连接失败派发 Event.ERROR 事件；连接被关闭派发 Event.CLOSE 事件；接收到数据派发 Event.MESSAGE 事件； 除了 Event.MESSAGE 事件参数为数据内容，其他事件参数都是原生的 HTML DOM Event 对象。
         * @param host 服务器地址。
         * @param port 服务器端口。
         * @param isSecure 是否使用WebSocket安全协议wss，默认（false）使用普通协议ws。
         */
        connect(host: string, port: number, isSecure?: boolean): void;
        /**
         * @en Connect to the specified server WebSocket URL. The URL is similar to ws://yourdomain:port.
         * - Dispatches Event.OPEN on successful connection; Event.ERROR on connection failure; Event.CLOSE when the connection is closed; Event.MESSAGE when data is received. Except for Event.MESSAGE where the event parameter is the data content, other event parameters are native HTML DOM Event objects.
         * @param url The server WebSocket URL to connect to. The URL is similar to ws://yourdomain:port.
         * @zh 连接到指定的服务端 WebSocket URL。 URL 类似 ws://yourdomain:port。
         * - 连接成功派发 Event.OPEN 事件；连接失败派发 Event.ERROR 事件；连接被关闭派发 Event.CLOSE 事件；接收到数据派发 Event.MESSAGE 事件； 除了 Event.MESSAGE 事件参数为数据内容，其他事件参数都是原生的 HTML DOM Event 对象。
         * @param url 要连接的服务端 WebSocket URL。 URL 类似 ws://yourdomain:port。
         */
        connectByUrl(url: string): void;
        /**
         * @en Clean up the Socket: close the Socket connection, remove event listeners, and reset the Socket.
         * @zh 清理Socket：关闭Socket连接，移除事件监听，重置Socket。
         */
        cleanSocket(): void;
        /**
         * @en Close the connection.
         * @zh 关闭连接。
         */
        close(): void;
        /**
         * @en Connection established successfully
         * @zh 连接建立成功 。
         */
        protected _onOpen(e: any): void;
        /**
         * @en Received data processing method.
         * @param msg Data.
         * @zh 接收到数据处理方法。
         * @param msg 数据。
         */
        protected _onMessage(msg: any): void;
        /**
         * @en Connection closed processing method.
         * @zh 连接被关闭处理方法。
         */
        protected _onClose(e: any): void;
        /**
         * @en An error occurred processing method.
         * @zh 出现异常处理方法。
         */
        protected _onError(e: any): void;
        /**
         * @en Send data to the server.
         * @param data The data to be sent, which can be either a String or an ArrayBuffer.
         * @zh 发送数据到服务器。
         * @param data 需要发送的数据，可以是String或者ArrayBuffer。
         */
        send(data: any): void;
        /**
         * @en Send the data in the buffer to the server.
         * @zh 发送缓冲区中的数据到服务器。
         */
        flush(): void;
    }
    /**
     * @en The `URL` class provides URL formatting and version management.
     * - The engine automatically calls the formatURL function to format URL paths when loading resources.
     * - You can set the network base path through the basePath property.
     * - By setting the customFormat function, you can customize the way URLs are formatted.
     * @zh `URL` 类提供URL格式化和版本管理功能。
     * - 引擎加载资源时，会自动调用formatURL函数格式化URL路径。
     * - 通过basePath属性可以设置网络基础路径。
     * - 通过设置customFormat函数，可以自定义URL格式化的方式。
     */
    class URL {
        /**
         * @en URL address version mapping table. For example, {"aaa/bb.png":"edcba","aaa/bb.png":"1342a"}. By default, after formatting through formatURL, it will automatically generate an address like "aaa/bb-1342a.png".
         * @zh URL地址版本映射表。例如，{"aaa/bb.png":"edcba","aaa/bb.png":"1342a"}。默认情况下，通过formatURL格式化后，会自动生成为"aaa/bb-1342a.png"的地址。
         */
        static version: Record<string, string>;
        /**
         * @en Base path. If not set, it defaults to the path of the current web page. The final address will be formatted as basePath + relative URL address.
         * @zh 基础路径。如果不设置，默认为当前网页的路径。最终地址将被格式化为 basePath + 相对URL地址。
         */
        static basePath: string;
        /**
         * @en Extended base path mapping table. For example, {"aa/":"http://abc.com/"}, then resources with paths starting with aa/ will be mapped to http://abc.com/.
         * @zh 扩展的基础路径映射表。例如，{"aa/":"http://abc.com/"}，则把路径以aa/开头的资源映射到http://abc.com/下。
         */
        static basePaths: Record<string, string>;
        private _url;
        private _path;
        private static overrideFileExts;
        private static hasExtOverrides;
        private static usingSafeFileExts;
        private static readonly safeFileExtConversionMap;
        static __init__(): void;
        /**
         * @en Initialize file extension overrides for mini-game.
         * @zh 初始化小游戏的文件扩展名覆盖。
         */
        static initMiniGameExtensionOverrides(): void;
        /**
         * @en Create a new `URL` instance.
         * @param url The URL to be formatted.
         * @zh 创建一个新的 `URL` 实例。
         * @param url 要格式化的URL地址。
         */
        constructor(url: string);
        /**
         * @en The formatted address.
         * @zh 格式化后的地址。
         */
        get url(): string;
        /**
         * @en The folder path of the address (excluding the file name).
         * @zh 地址的文件夹路径（不包括文件名）。
         */
        get path(): string;
        /**
         * @en Custom URL formatting function. For example: customFormat = function(url:String):String{}
         * @zh 自定义URL格式化的方式。例如：customFormat = function(url:String):String{}
         */
        static customFormat: Function;
        /**
         * 指以'~/'开头的的url路径的映射。
         * 不推荐使用，应该使用basePaths。
        */
        static get rootPath(): string;
        static set rootPath(value: string);
        /**
         * 包含normalizedURL功能，并且合并base，如果base没有提供，则使用URL.basePath或者URL.rootPath。
         * @param url 地址。
         * @param base 基础路径，如果没有，则使用URL.basePath或者URL.rootPath。
         * @return 格式化处理后的地址。
         */
        static formatURL(url: string, base?: string): string;
        /**
         * @en Process automatic conversion of file extensions.
         * @param url The address to be processed.
         * @returns The processed address.
         * @zh 处理扩展名的自动转换。
         * @param url 要处理的地址。
         * @return 处理后的地址。
         */
        static postFormatURL(url: string): string;
        /**
         * @en Normalize a relative path. Mainly handles cases with '.' and '..'.
         * @param url The URL to normalize.
         * @returns The normalized URL.
         * @zh 格式化相对路径。主要是处理 '.' 和 '..' 这些情况。
         * @param url 要格式化的路径。
         * @return 格式化后的路径。
         */
        static normalize(url: string): string;
        /**
         * @en Get the resource URL by UUID.
         * @param url The input URL or UUID.
         * @returns The resource URL.
         * @zh 通过 UUID 获取资源 URL。
         * @param url 输入的 URL 或 UUID。
         * @return 资源 URL。
         */
        static getResURLByUUID(url: string): string;
        /**
         * @en Combine and normalize relative paths.
         * @param base The base path.
         * @param path The path to join.
         * @returns The combined and normalized path.
         * @zh 组合相对路径并格式化。
         * @param base 基础路径。
         * @param path 要合并的路径。
         * @return 合并并格式化后的路径。
         */
        static join(base: string, path: string): string;
        /**
         * @en Get the folder path of the specified URL (excluding the file name). Note: the returned path has a trailing slash (/).
         * @param url The URL address.
         * @returns The folder path with a trailing slash (/).
         * @zh 获取指定 URL 的文件夹路径（不包括文件名）。注意：末尾有斜杠（/）。
         * @param url 地址。
         * @return 文件夹路径。
         */
        static getPath(url: string): string;
        /**
         * @en Get the file name of the specified URL.
         * @param url The URL address.
         * @returns The file name.
         * @zh 获取指定 URL 的文件名。
         * @param url 地址。
         * @return 文件名。
         */
        static getFileName(url: string): string;
        /**
         * @en Get the version string of the URL.
         * @param url The URL to check.
         * @returns The version string or null if not found.
         * @zh 获取 URL 版本字符。
         * @param url 要检查的 URL。
         * @return 版本字符串或 null（如果未找到）。
         */
        static getURLVerion(url: string): string;
        /**
         * @en Override the file extension for downloading.
         * @param originalExts The original extensions. For example, ["scene"].
         * @param targetExt The target extension to convert to. For example, "json".
         * @zh 下载时，转换 URL 的扩展名。
         * @param originalExts 原始扩展名。例如["scene"]。
         * @param targetExt 要转换为的扩展名。例如"json"。
         */
        static overrideExtension(originalExts: Array<string>, targetExt: string, miniGameOnly?: boolean): void;
    }
    /**
     * @en Utility class for basic binary hash calculation and binary equality comparison.
     * @zh 用于基本的二进制哈希计算和二进制相等性判断的工具类。
     */
    class BinHashUtils {
        /**
         * @en Calculates the hash value of a binary buffer.
         * @param buffer The binary data to hash.
         * @param start The starting position within the buffer.
         * @param len The length of data to consider for the hash calculation.
         * @param magic A large prime number used as the modulus in the hash calculation, defaults to 9191891.
         * @return The calculated hash value as a number.
         * @zh 计算二进制缓冲区的哈希值。
         * @param buffer 要进行哈希的数据。
         * @param start 缓冲区中的起始位置。
         * @param len 要用于哈希计算的数据长度。
         * @param magic 哈希计算中使用的模数，大质数，默认为9191891。
         * @return 返回计算得到的哈希值。
         */
        static getHash(buffer: Uint8Array, start: number, len: number, magic?: number): number;
        /**
         * @en Compares two binary data segments for equality.
         * @param buffer1 The first binary data buffer.
         * @param start1 The starting position within the first buffer.
         * @param len1 The length of data to compare in the first buffer.
         * @param buffer2 The second binary data buffer.
         * @param start2 The starting position within the second buffer.
         * @param len2 The length of data to compare in the second buffer.
         * @return True if the data segments are equal, false otherwise.
         * @zh 比较两段二进制数据是否相等。
         * @param buffer1 第一个二进制数据缓冲区。
         * @param start1 第一个缓冲区中的起始位置。
         * @param len1 要比较的第一个缓冲区的数据长度。
         * @param buffer2 第二个二进制数据缓冲区。
         * @param start2 第二个缓冲区中的起始位置。
         * @param len2 要比较的第二个缓冲区的数据长度。
         * @return 如果数据段相等则返回true，否则返回false。
         */
        static isSame(buffer1: Uint8Array, start1: number, len1: number, buffer2: Uint8Array, start2: number, len2: number): boolean;
    }
    /**
     * @en JsonBinRead class provides methods for parsing and reading binary JSON-like data.
     *      It uses custom type codes and supports compression and various data structures.
     * @zh JsonBinRead 类提供了用于解析和读取二进制 JSON 数据的方法。
     *      它使用自定义的类型码，支持压缩和多种数据结构。
     */
    class JsonBinRead {
        static ISJSONBIN: number;
        static ISJSONBIN2: number;
        static ISJSONBIN3: number;
        /**
         * @en The character used to split strings in the serialized data.
         * @zh 用于在序列化数据中分割字符串的字符。
         */
        static SPLITCHAR: string;
        /**
         * @en A constant representing a new compression type or mode.
         * @zh 代表一种新的压缩类型或模式的常量。
         */
        static COMPRESS_NEW: number;
        /**
         * @en A constant representing a reference-based compression type or mode.
         * @zh 代表一种基于引用的压缩类型或模式的常量。
         */
        static COMPRESS_REF: number;
        /**
         * @en A constant representing a modified reference-based compression type or mode.
         * @zh 代表一种修改后的基于引用的压缩类型或模式的常量。
         */
        static COMPRESS_REFMODIFY: number;
        /**
         * @en A type code representing an 8-bit integer value.
         * @zh 代表一个8位整数值的类型码。
         */
        static NUM8: number;
        /**
         * @en A type code representing a 16-bit integer value.
         * @zh 代表一个16位整数值的类型码。
         */
        static NUM16: number;
        /**
         * @en A type code representing a 32-bit integer value.
         * @zh 代表一个32位整数值的类型码。
         */
        static NUM32: number;
        /**
         * @en A type code representing a boolean value.
         * @zh 代表一个布尔值的类型码。
         */
        static BOOLEAN: number;
        /**
         * @en A type code representing a double-precision floating-point value.
         * @zh 代表一个双精度浮点值的类型码。
         */
        static DOUBLE: number;
        /**
         * @en A type code representing a string value.
         * @zh 代表一个字符串值的类型码。
         */
        static STRING: number;
        /**
         * @en A type code representing an 8-element array.
         * @zh 代表一个具有8个元素的数组的类型码。
         */
        static ARRAY8: number;
        /**
         * @en A type code representing a 16-element array.
         * @zh 代表一个具有16个元素的数组的类型码。
         */
        static ARRAY16: number;
        /**
         * @en A type code representing an empty array.
         * @zh 代表一个空数组的类型码。
         */
        static ARRAYEMPTY: number;
        /**
         * @en A type code representing an array of 8-bit integer values.
         * @zh 代表一个由8位整数值组成的数组的类型码。
         */
        static ARRAYNUM8: number;
        /**
         * @en A type code representing an array of 16-bit integer values.
         * @zh 代表一个由16位整数值组成的数组的类型码。
         */
        static ARRAYNUM16: number;
        /**
         * @en A type code representing an array of 32-bit integer values.
         * @zh 代表一个由32位整数值组成的数组的类型码。
         */
        static ARRAYNUM32: number;
        /**
         * @en A type code representing an array of double-precision floating-point values.
         * @zh 代表一个由双精度浮点值组成的数组的类型码。
         */
        static ARRAYDOUBLE: number;
        /**
         * @en A type code representing an array of strings.
         * @zh 代表一个由字符串组成的数组的类型码。
         */
        static ARRAYSTRING: number;
        /**
         * @en A type code representing a null value.
         * @zh 代表一个空值的类型码。
         */
        static NULL: number;
        /**
         * @en A type code representing an object.
         * @zh 代表一个对象的类型码。
         */
        static OBJECT: number;
        /**
         * @en A type code representing a 16-bit integer value multiplied by 1000.
         * @zh 代表一个乘以1000的16位整数值的类型码。
         */
        static NUM16_1000: number;
        /**
         * @en A type code representing a 32-bit integer value multiplied by 1000.
         * @zh 代表一个乘以1000的32位整数值的类型码。
         */
        static NUM32_1000: number;
        /**
         * @en A type code representing a word text value.
         * @zh 代表一个单词文本值的类型码。
         */
        static WORDTEXT: number;
        /**
         * @en A type code representing an array buffer.
         * @zh 代表一个数组缓冲区的类型码。
         */
        static ARRAYBUFFER: number;
        /**
         * @en A type code representing an array reference.
         * @zh 代表一个数组引用的类型码。
         */
        static ARRAYREF: number;
        /**
         * @en A type code representing a source array of 8-bit integers for reference.
         * @zh 代表一个用于引用的8位整数源数组的类型码。
         */
        static ARRAYREFSOURCE8: number;
        /**
         * @en A type code representing a source array of 16-bit integers for reference.
         * @zh 代表一个用于引用的16位整数源数组的类型码。
         */
        static ARRAYREFSOURCE16: number;
        /**
         * @en A type code representing an array buffer with 32-bit size.
         * @zh 代表一个具有32位大小的数组缓冲区的类型码。
         */
        static ARRAYBUFFER32: number;
        /**
         * @en A type code representing an array reference with 32-bit size.
         * @zh 代表一个具有32位大小的数组引用的类型码。
         */
        static ARRAYREF32: number;
        /**
         * @en A type code representing a 32-element array.
         * @zh 代表一个具有32个元素的数组的类型码。
         */
        static ARRAY32: number;
        /**
         * @en A type code representing an object with a specific class.
         * @zh 代表一个具有特定类的对象的类型码。
         */
        static OBJECTTHISCLASS: number;
        /**
         * @en A type code representing a 64-bit integer value.
         * @zh 代表一个64位整数值的类型码。
         */
        static NUM64: number;
        /**
         * @en A type code representing an Int8Array.
         * @zh 代表一个Int8Array的类型码。
         */
        static INT8ARRAY: number;
        /**
         * @en A type code representing a Uint8Array.
         * @zh 代表一个Uint8Array的类型码。
         */
        static UINT8ARRAY: number;
        /**
         * @en A type code representing an Int16Array.
         * @zh 代表一个Int16Array的类型码。
         */
        static INT16ARRAY: number;
        /**
         * @en A type code representing a Float32Array.
         * @zh 代表一个Float32Array的类型码。
         */
        static FLOAT32ARRAY: number;
        /**
         * @en A constant value used to mark the end of an object in the serialized data.
         * @zh 用于在序列化数据中标记对象结束的常量值。
         */
        static OBJECTEND: number;
        /**
         * @en The singleton instance of the JsonBinRead class.
         * @zh JsonBinRead类的单例实例。
         */
        private static _instance;
        /**
         * @en Gets the singleton instance of the JsonBinRead class. If it doesn't exist, creates a new one.
         * @returns The singleton instance of the JsonBinRead class.
         * @zh 获取JsonBinRead类的单例实例。如果不存在，则创建一个新的实例。
         * @returns JsonBinRead类的单例实例。
         */
        static get instance(): JsonBinRead;
        /**
         * @en Checks if the given ArrayBuffer contains JSONBin data.
         * @param data The ArrayBuffer to be checked.
         * @returns True if the data is identified as JSONBin data, false otherwise.
         * @zh 检查给定的ArrayBuffer是否包含JsonBin数据。
         * @param data 要检查的ArrayBuffer。
         * @returns 如果数据被识别为JsonBin数据则返回true，否则返回false。
         */
        static IsJsonbin(data: ArrayBuffer): boolean;
        /**
         * @en Parses the given ArrayBuffer as JSONBin data. If it's not in the expected JSONBin format,
         *      tries to parse it as a regular JSON string.
         * @param value The ArrayBuffer to be parsed.
         * @returns The parsed data as an object. If parsing fails, returns null.
         * @zh 将给定的ArrayBuffer解析为JsonBin数据。如果不是预期的JsonBin格式，
         *      则尝试将其作为常规JSON字符串进行解析。
         * @param value 要解析的ArrayBuffer。
         * @returns 解析后的数据作为一个对象。如果解析失败，则返回null。
         */
        static parse(value: ArrayBuffer): any;
        /**
         * @en Parses the given value (assumed to be JSONBin data) and caches the result using the Loader.
         * @param value The value to be parsed.
         * @returns The parsed data as an object.
         * @zh 解析给定的值（假定为JsonBin数据）并使用Loader缓存结果。
         * @param value 要解析的价值。
         * @returns 解析后的数据作为一个对象。
         */
        static parsePack(value: any): any;
        /**
         * @en An object used to store references to other objects during the reading process.
         * @zh 在读取过程中用于存储对其他对象引用的对象。
         */
        private _objectRef;
        /**
         * @en The starting offset of the data within the buffer during the reading process.
         * @zh 在读取过程中缓冲区中数据的起始偏移量。
         */
        private _dataStartOfs;
        /**
         * @en A function used to create an object with a specific class during the reading process.
         * @zh 在读取过程中用于创建具有特定类的对象的函数。
         */
        private _createObjWithClass;
        /** @ignore */
        constructor();
        /**
         * @en Reads an array from the given Byte data buffer based on the specified type and keyMap.
         * @param data The Byte data buffer from which to read the array.
         * @param pos The starting position in the buffer to read the array. If -1, uses the current position.
         * @param n The number of elements in the array.
         * @param type The type code representing the array type.
         * @param keyMap A mapping object that keeps track of keys and their corresponding values and indices.
         * @returns The read array as an object.
         * @zh 根据指定的类型和键映射从给定的Byte数据缓冲区读取数组。
         * @param data 从中读取数组的Byte数据缓冲区。
         * @param pos 在缓冲区中读取数组的起始位置。如果为-1，则使用当前位置。
         * @param n 数组中的元素数量。
         * @param type 代表数组类型的类型码。
         * @param keyMap 一个映射对象，用于跟踪键及其对应的值和索引。
         * @returns 读取的数组作为一个对象。
         */
        private _readArray;
        /**
         * @en Retrieves the length value from the given Byte object.
         *      It interprets the length based on the encoding rules where a single byte might represent the length directly or two bytes need to be combined if the length is larger.
         * @param data The Byte object from which to extract the length.
         * @returns The length value obtained from the Byte object.
         * @zh 从给定的Byte对象中获取长度值。
         *      它根据编码规则解析长度，即单个字节可能直接表示长度，如果长度较大，则需要组合两个字节来获取长度值。
         * @param data 从中提取长度的Byte对象。
         * @returns 从Byte对象获取的长度值。
         */
        private _getLen;
        /**
         * @en Combines two numbers into a single large number representation.
         *      It first converts the second number to a hexadecimal string, pads it to a specific length if needed,
         *      and then concatenates it with the hexadecimal string of the first number to form the large number.
         * @param n1 The first number.
         * @param n2 The second number.
         * @returns The combined large number.
         * @zh 将两个数字组合成一个大数字表示形式。
         *      它首先将第二个数字转换为十六进制字符串，如有需要将其填充到特定长度，
         *      然后将其与第一个数字的十六进制字符串连接起来以形成大数字。
         * @param n1 第一个数字。
         * @param n2 第二个数字。
         * @returns 组合后的大数字。
         */
        static _toLargeNumber(n1: number, n2: number): number;
        /**
         * @en Reads an Int8Array from the given Byte object starting from a specific position and with a given length.
         *      It adjusts the end position to fit within the buffer bounds and creates the Int8Array from the buffer slice. Also updates the internal position of the Byte object after reading.
         * @param byte The Byte object from which to read the Int8Array.
         * @param start The starting position within the Byte object's buffer.
         * @param len The length of the Int8Array to read.
         * @returns The read Int8Array.
         * @zh 从给定的Byte对象中从特定位置开始按给定长度读取一个Int8Array。
         *      它会调整结束位置以适应缓冲区边界，并从缓冲区切片创建Int8Array。读取后还会更新Byte对象的内部位置。
         * @param byte 从中读取Int8Array的Byte对象。
         * @param start Byte对象缓冲区中的起始位置。
         * @param len 要读取的Int8Array的长度。
         * @returns 读取的Int8Array。
         */
        private static readInt8Array;
        /**
         * @en Reads a single value from the given Byte data buffer based on the specified type and keyMap.
         *      It handles different types of values such as null, integers, booleans, strings, arrays, etc., by using specific read operations for each type.
         *      If the type is not recognized among the common ones, it delegates to the _readOne_other method.
         * @param parent The parent object to which the read value may be assigned (used for object property assignment).
         * @param data The Byte data buffer from which to read the value.
         * @param key The key associated with the value (if applicable, for object property setting).
         * @param type The type code representing the value type.
         * @param keyMap A mapping object that keeps track of keys and their corresponding values and indices.
         * @returns The read value.
         * @zh 根据指定的类型和键映射从给定的Byte数据缓冲区读取单个值。
         *      它通过针对每种类型使用特定的读取操作来处理不同类型的值，如空值、整数、布尔值、字符串、数组等。
         *      如果在常见类型中无法识别该类型，则委托给_readOne_other方法处理。
         * @param parent 读取的值可能分配到的父对象（用于对象属性赋值）。
         * @param data 从中读取值的Byte数据缓冲区。
         * @param key 与值关联的键（如果适用，用于设置对象属性）。
         * @param type 代表值类型的类型码。
         * @param keyMap 一个映射对象，用于跟踪键及其对应的值和索引。
         * @returns 读取的值。
         */
        private _readOne;
        /**
         * @en Reads a value from the given Byte data buffer for types that are not handled in the _readOne method directly.
         *      It deals with more complex types like arrays with specific compression or reference handling and objects with class creation.
         * @param parent The parent object related to the value being read (used for property assignment and object hierarchy).
         * @param data The Byte data buffer from which to read the value.
         * @param key The key associated with the value (if applicable for property setting).
         * @param type The type code representing the value type.
         * @param keyMap A mapping object that keeps track of keys and their corresponding values and indices.
         * @returns The read value.
         * @zh 从给定的Byte数据缓冲区读取那些在_readOne方法中未直接处理的类型的值。
         *      它处理更复杂的类型，例如具有特定压缩或引用处理的数组以及需要创建类的对象。
         * @param parent 与正在读取的值相关的父对象（用于属性赋值和对象层次结构）。
         * @param data 从中读取值的Byte数据缓冲区。
         * @param key 与值关联的键（如果适用于属性设置）。
         * @param type 代表值类型的类型码。
         * @param keyMap 一个映射对象，用于跟踪键及其对应的值和索引。
         * @returns 读取的值。
         */
        private _readOne_other;
        /**
         * @en Reads binary JSON data from the given ArrayBuffer and parses it into an object.
         *      It first initializes some internal state, determines the format based on a marker in the buffer, creates a keyMap for decoding, and then uses the _readOne method to start parsing the data. It also measures and may log the parsing time if it exceeds a certain threshold.
         * @param data The ArrayBuffer containing the binary JSON data to be read.
         * @param createObjWithClass A function used to create objects with specific classes during the parsing process (optional).
         * @returns The parsed object. If the data format is not recognized, it returns null.
         * @zh 从给定的ArrayBuffer中读取二进制JSON数据并将其解析为对象。
         *      它首先初始化一些内部状态，根据缓冲区中的标记确定格式，创建用于解码的键映射，然后使用_readOne方法开始解析数据。如果解析时间超过一定阈值，它还会测量并可能记录解析时间。
         * @param data 包含要读取的二进制JSON数据的ArrayBuffer。
         * @param createObjWithClass 在解析过程中用于创建具有特定类的对象的函数（可选）。
         * @returns 解析后的对象。如果数据格式无法识别，则返回null。
         */
        read(data: ArrayBuffer, createObjWithClass?: Function): any;
    }
    /**
     * @en The JsonBinWrite class is responsible for serializing various data types into a binary format that can be saved or transmitted.
     * @zh JsonBinWrite类负责将各种数据类型序列化为可保存或传输的二进制格式。
     */
    class JsonBinWrite {
        /**
         * @en A special string used for compression identification within the serialized data.
         * @zh 用于在序列化数据中标识压缩的特殊字符串。
         */
        static COMPRESS: string;
        /**
         * @en A special string used to mark keys that should not be saved.
         * @zh 用于标记不应保存的键的特殊字符串。
         */
        static NOSAVEKEY: string;
        /**
        * @en A special string used to mark an object that should not be saved in a specific way.
        * @zh 用于以特定方式标记不应保存的对象的特殊字符串。
        */
        static NOSAVETHISOBJ: string;
        /**
         * @en The length of the special NOSAVEKEY string.
         * @zh 特殊的NOSAVEKEY字符串的长度。
         */
        static NOSAVE_KEY_LEN: number;
        /**
         * @en A constant value used to indicate a specific action related to not saving an object (delete).
         * @zh 用于指示与不保存对象相关的特定操作（删除）的常量值。
         */
        static NOSAVETHISOBJ_DELETE: number;
        /**
         * @en A constant value used to indicate a specific action related to not saving an object (true).
         * @zh 用于指示与不保存对象相关的特定操作（真）的常量值。
         */
        static NOSAVETHISOBJ_TRUE: number;
        /**
         * @en The singleton instance of the JsonBinWrite class.
         * @zh JsonBinWrite类的单例实例。
         */
        private static _instance;
        /**
         * @en Gets the singleton instance of the JsonBinWrite class. If it doesn't exist, creates a new one.
         * @returns The singleton instance of the JsonBinWrite class.
         * @zh 获取JsonBinWrite类的单例实例。如果不存在，则创建一个新的实例。
         * @returns JsonBinWrite类的单例实例。
         */
        static get instance(): JsonBinWrite;
        /**
         * @en An object used to store references to other objects during the serialization process.
         * @zh 在序列化过程中用于存储对其他对象引用的对象。
         */
        objectRef: any;
        /**
         * @en A flag used to enable or disable certain class-related functionality during serialization.
         * @zh 在序列化期间用于启用或禁用某些与类相关功能的标志。
         */
        private _classEnable_;
        constructor();
        /**
         * @en Saves a key-value pair with a specific value type to the output buffer.
         * @param key The key to be saved.
         * @param valueType The type of the value associated with the key.
         * @param keyMap A mapping object that keeps track of keys and their corresponding values and indices.
         * @param out The output buffer where the data is written.
         * @zh 将具有特定值类型的键值对保存到输出缓冲区。
         * @param key 要保存的键。
         * @param valueType 与键关联的值的类型。
         * @param keyMap 用于跟踪键及其对应的值和索引的映射对象。
         * @param out 写入数据的输出缓冲区。
         */
        private _saveKey;
        /**
         * @en Determines the appropriate array value type based on the typeof the given value.
         * @param value The value for which the array value type is to be determined.
         * @returns The determined array value type as a number.
         * @zh 根据给定值的类型确定合适的数组值类型。
         * @param value 要确定数组值类型的那个值。
         * @returns 确定的数组值类型（以数字表示）。
         */
        private _getValueArrayType;
        /**
         * @en Writes a string or a word text value to the output buffer along with its associated key.
         * @param keyMap A mapping object that keeps track of keys and their corresponding values and indices.
         * @param key The key associated with the value. Can be null.
         * @param value The value to be written.
         * @param out The output buffer where the data is written.
         * @param isWordText A flag indicating whether the value is a word text.
         * @zh 将字符串或单词文本值及其关联的键写入输出缓冲区。
         * @param keyMap 用于跟踪键及其对应的值和索引的映射对象。
         * @param key 与值关联的键。可以为null。
         * @param value 要写入的值。
         * @param out 写入数据的输出缓冲区。
         * @param isWordText 指示值是否为单词文本的标志。
         */
        private _writeStrOrWordText;
        /**
         * @en Writes a string value to the output buffer.
         * @param keyMap A mapping object that keeps track of keys and their corresponding values and indices.
         * @param value The value to be written.
         * @param out The output buffer where the data is written.
         * @zh 将字符串值写入输出缓冲区。
         * @param keyMap 用于跟踪键及其对应的值和索引的映射对象。
         * @param value 要写入的值。
         * @param out 写入数据的输出缓冲区。
         */
        private _writeString;
        /**
         * @en Gets the type of the given object as a string.
         * @param value The object for which the type is to be determined.
         * @returns The type of the object as a string.
         * @zh 获取给定对象的类型（以字符串表示）。
         * @param value 要确定类型的那个对象。
         * @returns 给定对象的类型（以字符串表示）。
         */
        private _getObjectTypeof;
        /**
         * @en Checks if the given object is a word text.
         * @param o The object to be checked.
         * @returns True if the object is a word text, false otherwise.
         * @zh 检查给定对象是否为单词文本。
         * @param o 要检查的对象。
         * @returns 如果对象是单词文本则返回true，否则返回false。
         */
        static isWordText(o: any): boolean;
        /**
         * @en Writes the length value to the output buffer in a specific format depending on its magnitude.
         * @param out The output buffer where the data is written.
         * @param len The length value to be written.
         * @zh 根据长度值的大小以特定格式将其写入输出缓冲区。
         * @param out 写入数据的输出缓冲区。
         * @param len 要写入的长度值。
         */
        private _writeLen;
        /**
         * @en Writes a large number value to the output buffer in a specific format.
         * @param out The output buffer where the data is written.
         * @param value The large number value to be written.
         * @zh 以特定格式将大数值写入输出缓冲区。
         * @param out 写入数据的输出缓冲区。
         * @param value 要写入的大数值。
         */
        private _writeBigNumber;
        /**
         * @en A counter used to keep track of the depth during the serialization process.
         * @zh 在序列化过程中用于跟踪深度的计数器。
         */
        private deep;
        /**
         * @en Writes a single key-value pair or object to the output buffer.
         * @param out The output buffer where the data is written.
         * @param keyMap A mapping object that keeps track of keys and their corresponding values and indices.
         * @param key The key associated with the value. Can be null.
         * @param value The value to be written.
         * @param parent The parent object of the value (if applicable).
         * @returns True if the write operation was successful, false otherwise.
         * @zh 将单个键值对或对象写入输出缓冲区。
         * @param out 写入数据的输出缓冲区。
         * @param keyMap 用于跟踪键及其对应的值和索引的映射对象。
         * @param key 与值关联的键。可以为null。
         * @param value 要写入的值。
         * @param parent 值的父对象（如果适用）。
         * @returns 如果写入操作成功则返回true，否则返回false。
         */
        private _writeOne;
        /**
         * @en Saves an array of values to the output buffer.
         * @param parent The parent object of the array (if applicable).
         * @param out The output buffer where the data is written.
         * @param keyMap A mapping object that keeps track of keys and their corresponding values and indices.
         * @param key The key associated with the array (if applicable).
         * @param value The array of values to be written.
         * @returns True if the save operation was successful, false otherwise.
         * @zh 将数组的值保存到输出缓冲区。
         * @param parent 数组的父对象（如果适用）。
         * @param out 写入数据的输出缓冲区。
         * @param keyMap 用于跟踪键及其对应的值和索引的映射对象。
         * @param key 与数组关联的键（如果适用）。
         * @param value 要保存的数组值。
         * @returns 如果保存操作成功则返回true，否则返回false。
         */
        private _saveArray;
        /**
         * @en Handles the compression of data if applicable.
         * @param out The output buffer where the data is written.
         * @param keyMap A mapping object that keeps track of keys and their corresponding values and indices.
         * @param key The key associated with the data (if applicable).
         * @param value The data to be compressed (if applicable).
         * @param posHead The position of the head of the data in the buffer.
         * @param dataPos The position of the data in the buffer.
         * @param compress The compression factor or related information.
         * @param typeArray The type of the array or data structure.
         * @zh 如果适用，处理数据的压缩操作。
         * @param out 写入数据的输出缓冲区。
         * @param keyMap 用于跟踪键及其对应的值和 indices的映射对象。
         * @param key 与数据关联的键（如果适用）。
         * @param value 要压缩的数据（如果适用）。
         * @param posHead 缓冲区中数据头部的位置。
         * @param dataPos 缓冲区中数据的位置。
         * @param compress 压缩因子或相关信息。
         * @param typeArray 数组或数据结构的类型。
         */
        private _useCompress;
        /**
         * @en Writes an object to the output buffer.
         * @param out The output buffer where the data is written.
         * @param keyMap A mapping object that keeps track of keys and their corresponding values and indices.
         * @param o The object to be written.
         * @zh 将对象写入输出缓冲区。
         * @param out 写入数据的输出缓冲区。
         * @param keyMap 用于跟踪键及其对应的值和 indices的映射对象。
         * @param o 要写入的对象。
         */
        private _writeObject;
        /**
         * @en Serializes the given object into a binary format and returns the resulting buffer.
         * @param o The object to be serialized.
         * @param __CLASS__ A flag indicating whether to include class information (default is false).
         * @returns The serialized object as an ArrayBuffer.
         * @zh 将给定对象序列化为二进制格式并返回生成的缓冲区。
         * @param o 要序列化的对象。
         * @param __CLASS__ 一个标志，指示是否包含类信息（默认值为false）。
         * @returns 作为ArrayBuffer的序列化对象。
         */
        write(o: any, __CLASS__?: boolean): ArrayBuffer;
    }
    /**
     * @en Image loader that uses a Web Worker for asynchronous loading.
     * @zh 使用Web Worker进行异步加载的图像加载器。
     */
    class WorkerLoader {
        /**
         * @en Path to the worker.js file
         * @zh worker.js的路径
         */
        static workerPath: string;
        private static _worker;
        private static _dispatcher;
        private static _enable;
        /**
         * @en Check if worker is supported
         * @returns Whether worker is supported
         * @zh 检查是否支持worker
         * @returns 是否支持worker
         */
        static workerSupported(): boolean;
        /**
         * @en Whether to enable the worker loader.
         * @zh 是否启用worker加载器。
         */
        static get enable(): boolean;
        static set enable(value: boolean);
        /**
         * @en Loads an image asynchronously using the worker.
         * @param url The URL of the image to load.
         * @param options Additional options for loading.
         * @return A promise that resolves with the loaded image.
         * @zh 使用worker异步加载图像。
         * @param url 要加载的图像URL。
         * @param options 加载的附加选项。
         * @return 返回解析后的加载图像。
         */
        static load(url: string, options: any): Promise<any>;
        /**
         * @en Handles messages received from the worker.
         * @param evt Event data from the worker.
         * @zh 处理从worker接收到的消息。
         * @param evt worker传递的事件数据。
         */
        private static workerMessage;
    }
    enum BaseRender2DType {
        baseRenderNode = 0,
        spine = 1,
        particle = 2,
        spineSimple = 3
    }
    enum Render2DOrderMode {
        elementIndex = 0,
        ysort = 1
    }
    class BaseRenderNode2D extends Component {
        /**
         * 材质集
         */
        _materials: Material[];
        /**
         * 渲染类型
         */
        _renderType: BaseRender2DType;
        /**
         * 帧循环标记
         */
        _renderUpdateMask: number;
        /**
         * sprite ShaderData,可以为null
         */
        _spriteShaderData: ShaderData;
        /**
         * 唯一ID
         */
        private _renderid;
        /**
         * 节点内的渲染排序模式
         */
        private _ordingMode;
        protected _transformChange(): void;
        /**
       * 返回第一个材质。
       */
        get sharedMaterial(): Material;
        set sharedMaterial(value: Material);
        private _setRenderElement2DMaterial;
        constructor();
        /**
         * cmd run时调用，可以用来计算matrix等获得即时context属性
         * @param context
         * @param px
         * @param py
         */
        addCMDCall?(context: Context, px: number, py: number): void;
        /**
         * 帧更新，可以放一些顶点更新，数据计算等
         * @protected
         * @param context
         */
        renderUpdate?(context: IRenderContext2D): void;
        /**
         * 渲染前更新，准备所需的渲染数据
         * @param context
         */
        preRenderUpdate?(context: IRenderContext2D): void;
        clear(): void;
    }
    interface IBatch2DRender {
        /**合批范围，合批的RenderElement2D直接add进list中 */
        batchRenderElement(list: FastSinglelist<IRenderElement2D>, start: number, length: number): void;
        recover(): void;
    }
    class Batch2DInfo {
        batchFun: IBatch2DRender;
        batch: boolean;
        indexStart: number;
        elementLenth: number;
        constructor();
        static _pool: Batch2DInfo[];
        static create(): Batch2DInfo;
        static recover(info: Batch2DInfo): void;
    }
    class RenderManager2D {
        /**
         * 根据不同的RenderNode注册合批方式，来优化性能
         */
        private static _batchMapManager;
        /**
         * 注册渲染节点之间的合批
         */
        static regisBatch(renderElementType: number, batch: IBatch2DRender): void;
        private _lastRenderNodeType;
        private _lastbatch2DInfo;
        _batchInfoList: FastSinglelist<Batch2DInfo>;
        /**
         * 渲染结束标签
         */
        _renderEnd: boolean;
        /**
        * RenderList
        */
        get list(): FastSinglelist<BaseRenderNode2D>;
        set list(value: FastSinglelist<BaseRenderNode2D>);
        constructor();
        /**
        * add Render Node
        * @param object
        */
        addRenderObject(object: BaseRenderNode2D): void;
        /**
         * remove Render Node
         * @param object
         */
        removeRenderObject(object: BaseRenderNode2D): void;
        /**
         * clear list
         */
        clearList(): void;
        /**
         * 帧更新
         */
        renderUpdate(): void;
        /**
         * 渲染
         * @param context
         */
        render(context: IRenderContext2D): void;
        private _cull;
        /**
         * 合批总循环
         */
        private _batch;
        /**
         * 开启一个Batch
         */
        private _batchStart;
        endRender(): void;
    }
    /**
     * @en 2D rectangular collision body
     * @zh 2D矩形碰撞体
     */
    class BoxCollider extends ColliderBase {
        /**
         * @en Rectangle width of collision body
         * @zh 碰撞体矩形宽度
         */
        get width(): number;
        set width(value: number);
        /**
         * @en Rectangle height of collision body
         * @zh 碰撞体矩形高度
         */
        get height(): number;
        set height(value: number);
        /**
        * @en Constructor method
        * @zh 构造方法
        */
        constructor();
    }
    /**
     * @en 2D chain collider
     * @zh 2D 链形碰撞体
     */
    class ChainCollider extends ColliderBase {
        /**
        * @deprecated
        * @en A collection of points separated by commas, format: x, y, x, y, ...
        * @zh 用逗号隔开的点的集合，格式：x,y,x,y ...
        */
        get points(): string;
        set points(value: string);
        /**
         * @en Vertex data x,y,x,y ...
         * @zh 顶点数据 x,y,x,y ...
         */
        get datas(): number[];
        set datas(value: number[]);
        /**
         * @en Whether it is a closed loop. Ensure there are no self-intersecting link shapes, as they may not function properly.
         * @zh 是否是闭环，注意不要有自相交的链接形状，否则它可能不能正常工作
         */
        get loop(): boolean;
        set loop(value: boolean);
        constructor();
        /**
         * @en Called after being added to the node, different from Awake, onAdded will be called even if the node is not active.
         * @zh 被添加到节点后调用，和 Awake 不同的是即使节点未激活 onAdded 也会调用。
         */
        onAdded(): void;
    }
    /**
     * @en 2D CircleCollider
     * @zh 2D圆形碰撞体
     */
    class CircleCollider extends ColliderBase {
        /**
         * @en Circular radius, must be a positive number
         * @zh 圆形半径，必须为正数
         */
        get radius(): number;
        set radius(value: number);
        constructor();
    }
    /**
     * @en Collider base class
     * @zh 碰撞体基类
     */
    class ColliderBase extends Component {
        /**@private box2D fixture Def */
        protected _fixtureDef: any;
        /**
         * @en label
         * @zh 标签
         */
        label: string;
        /**
         * @en The reference to the rigidbody.
         * @zh 刚体引用。
         */
        rigidBody: RigidBody;
        /**
         * @en The x-axis offset relative to the node.
         * @zh 相对于节点的 x 轴偏移。
         */
        get x(): number;
        set x(value: number);
        /**
         * @en The y-axis offset relative to the node.
         * @zh 相对于节点的 y 轴偏移。
         */
        get y(): number;
        set y(value: number);
        /**
         * @en Whether the object is a sensor. A sensor can trigger collision events but does not produce collision responses.
         * @zh 是否是传感器，传感器能够触发碰撞事件，但不会产生碰撞反应
         */
        get isSensor(): boolean;
        set isSensor(value: boolean);
        /**
         * @en The density value. The value can be zero or a positive number. It is recommended to use similar densities to improve stacking stability. The default value is 10.
         * @zh 密度值。值可以为零或者是正数，建议使用相似的密度以改善堆叠稳定性。默认值为 10。
         */
        get density(): number;
        set density(value: number);
        /**
         * @en The friction coefficient. The value ranges from 0 to 1, the larger the value, the greater the friction. The default value is 0.2.
         * @zh 摩擦力。取值范围0-1，值越大，摩擦越大。默认值为0.2。
         */
        get friction(): number;
        set friction(value: number);
        /**
         * @en The restitution coefficient. The value ranges from 0 to 1, the larger the value, the greater the elasticity. The default value is 0.
         * @zh 弹性系数。取值范围0-1，值越大，弹性越大。默认值为0。
         */
        get restitution(): number;
        set restitution(value: number);
        /**
         * @en constructor method
         * @zh 构造方法
         */
        constructor();
        /**@protected 创建Shape*/
        protected _createfixture(): any;
        /**@protected 设置shape属性*/
        protected resetFixtureData(): void;
    }
    enum PhysicsShape {
        BoxShape = 0,
        CircleShape = 1,
        PolygonShape = 2,
        ChainShape = 3,
        EdgeShape = 4
    }
    class FixtureBox2DDef {
        density: number;
        friction: number;
        isSensor: boolean;
        restitution: number;
        shape: PhysicsShape;
        groupIndex: number;
    }
    /**
     * @en 2D edge collider.
     * @zh 2D边缘碰撞体。
     */
    class EdgeCollider extends ColliderBase {
        /**
         * @deprecated
         * 用逗号隔开的点的集合，注意只有两个点，格式：x,y,x,y*/
        get points(): string;
        set points(value: string);
        /**
         * @en Vertex data in the format of x,y,x,y ...
         * @zh 顶点数据，格式为 x,y,x,y ...
         */
        get datas(): number[];
        set datas(value: number[]);
        constructor();
    }
    /**
     * @en 2D polygon collider. Concave polygons are currently not supported. If it is a concave polygon, manually split it into multiple convex polygons first.
     * The maximum number of vertices is `b2_maxPolygonVertices`, which defaults to 8. So it is not recommended to exceed 8 points, and it cannot be less than 3.
     * @zh 2D多边形碰撞体，暂时不支持凹多边形，如果是凹多边形，先手动拆分为多个凸多边形。
     * 节点个数最多是 `b2_maxPolygonVertices`，这数值默认是8，所以点的数量不建议超过8个，也不能小于3个。
     */
    class PolygonCollider extends ColliderBase {
        /**
        * @deprecated
        * 用逗号隔开的点的集合，格式：x,y,x,y ...
        */
        get points(): string;
        set points(value: string);
        /**
         * @en Vertex data in the format: x,y,x,y ...
         * @zh 顶点数据，格式：x,y,x,y ...
         */
        get datas(): number[];
        set datas(value: number[]);
        constructor();
        /**
        * @override
        */
        protected _setShapeData(shape: any): void;
    }
    /**
     * @en Implements Box2D c++ version 2.4.1
     * @zh 实现Box2D c++ 2.4.1 版本
     */
    class physics2DwasmFactory implements IPhysiscs2DFactory {
        private _tempVe21;
        private _tempVe22;
        private _massData;
        set gravity(value: Vector2);
        set allowSleeping(value: boolean);
        /**
         * @en Initialize the Box2D physics engine.
         * @returns A promise that resolves when the initialization is complete.
         * @zh 初始化Box2D物理引擎。
         * @returns 初始化完成时解析的promise。
         */
        initialize(): Promise<void>;
        /**
         * @en Create the Box2D world.
         * @zh 创建Box2D世界。
         */
        start(): void;
        /**
         * @en Update the physics world.
         * @param delta The time step.
         * @zh 更新物理世界。
         * @param delta 时间步长。
         */
        update(delta: number): void;
        /**
         * @en Send physics event.
         * @param type The event type.
         * @param contact The contact object.
         * @zh 发送物理事件。
         * @param type 事件类型。
         * @param contact 碰撞对象。
         */
        sendEvent(type: string, contact: any): void;
        /**
         * @en Create a Box2D body.
         * @param def The body definition.
         * @returns The created Box2D body.
         * @zh 创建一个Box2D刚体。
         * @param def 刚体定义。
         * @returns 创建的Box2D刚体。
         */
        createBody(def: any): any;
        /**
         * @en Remove a Box2D body.
         * @param body The Box2D body to remove.
         * @zh 移除一个Box2D刚体。
         * @param body 要移除的Box2D刚体。
         */
        removeBody(body: any): void;
        /**
         * @en Create a Box2D joint.
         * @param def The joint definition.
         * @param cls The joint class (optional).
         * @returns The created Box2D joint.
         * @zh 创建一个Box2D关节。
         * @param def 关节定义。
         * @param cls 关节类（可选）。
         * @returns 创建的Box2D关节。
         */
        createJoint(def: any, cls?: any): any;
        /**
         * @en Remove a Box2D joint.
         * @param joint The Box2D joint to remove.
         * @zh 移除一个Box2D关节。
         * @param joint 要移除的Box2D关节。
         */
        removeJoint(joint: any): void;
        /**
         * @en Get the user data of a joint.
         * @param joint The joint.
         * @returns The user data of the joint.
         * @zh 获取关节的用户数据。
         * @param joint 关节。
         * @returns 关节的用户数据。
         */
        getJoint_userData(joint: any): any;
        /**
         * @en Check if the user data of a joint is marked as destroyed.
         * @param joint The joint.
         * @returns True if the user data is marked as destroyed, false otherwise.
         * @zh 检查关节的用户数据是否被标记为已销毁。
         * @param joint 关节。
         * @returns 用户数据是否已被标记为已销毁。
         */
        getJoint_userData_destroy(joint: any): boolean;
        /**
         * @en Enable or disable the motor of a joint.
         * @param joint The joint.
         * @param enableMotor True to enable the motor, false to disable it.
         * @zh 启用或禁用关节的马达。
         * @param joint 关节。
         * @param enableMotor 是否启用马达。
         */
        set_Joint_EnableMotor(joint: any, enableMotor: boolean): void;
        /**
         * @en Set the motor speed of a joint.
         * @param joint The joint.
         * @param motorSpeed The motor speed.
         * @zh 设置关节的马达速度。
         * @param joint 关节。
         * @param motorSpeed 马达速度。
         */
        set_Joint_SetMotorSpeed(joint: any, motorSpeed: number): void;
        /**
         * @en Set the maximum motor torque of a joint.
         * @param joint The joint.
         * @param maxTorque The maximum motor torque.
         * @zh 设置关节的最大马达扭矩。
         * @param joint 关节。
         * @param maxTorque 最大马达扭矩。
         */
        set_Joint_SetMaxMotorTorque(joint: any, maxTorque: number): void;
        /**
         * @en Enable or disable the limit of a joint.
         * @param joint The joint.
         * @param enableLimit True to enable the limit, false to disable it.
         * @zh 启用或禁用关节的限制。
         * @param joint 关节。
         * @param enableLimit 是否启用限制。
         */
        set_Joint_EnableLimit(joint: any, enableLimit: boolean): void;
        /**
         * @en Set the limits of a joint.
         * @param joint The joint.
         * @param lowerAngle The lower angle limit.
         * @param upperAngle The upper angle limit.
         * @zh 设置关节的限制。
         * @param joint 关节。
         * @param lowerAngle 底角限制。
         * @param upperAngle 顶角限制。
         */
        set_Joint_SetLimits(joint: any, lowerAngle: number, upperAngle: number): void;
        /**
         * @en Set the frequency and damping ratio of a joint.
         * @param Joint The joint.
         * @param frequency The frequency.
         * @param dampingRatio The damping ratio.
         * @param isdamping True to apply damping, false otherwise.
         * @zh 设置关节的频率和阻尼比。
         * @param Joint 关节。
         * @param frequency 频率。
         * @param dampingRatio 阻尼比。
         * @param isdamping 是否应用阻尼。
         */
        set_Joint_frequencyAndDampingRatio(Joint: any, frequency: number, dampingRatio: number, isdamping: boolean): void;
        /**
         * @en Create a distance joint.
         * @param defStruct The distance joint definition.
         * @returns The created distance joint.
         * @zh 创建一个距离关节。
         * @param defStruct 距离关节定义。
         * @returns 创建的距离关节。
         */
        createDistanceJoint(defStruct: physics2D_DistancJointDef): any;
        /**
         * @en Set the length of a distance joint.
         * @param joint The distance joint.
         * @param length The length.
         * @zh 设置距离关节的长度。
         * @param joint 距离关节。
         * @param length 长度。
         */
        set_DistanceJoint_length(joint: any, length: number): void;
        /**
         * @en Set the maximum length of a distance joint.
         * @param joint The distance joint.
         * @param length The maximum length.
         * @zh 设置距离关节的最大长度。
         * @param joint 距离关节。
         * @param length 最大长度。
         */
        set_DistanceJoint_MaxLength(joint: any, length: number): void;
        /**
         * @en Set the minimum length of a distance joint.
         * @param joint The distance joint.
         * @param length The minimum length.
         * @zh 设置距离关节的最小长度。
         * @param joint 距离关节。
         * @param length 最小长度。
         */
        set_DistanceJoint_MinLength(joint: any, length: number): void;
        /**
         * @en Set the stiffness and damping of a distance joint.
         * @param joint The distance joint.
         * @param stiffness The stiffness.
         * @param damping The damping.
         * @zh 设置距离关节的刚度和阻尼。
         * @param joint 距离关节。
         * @param stiffness 刚度。
         * @param damping 阻尼。
         */
        set_DistanceJointStiffnessDamping(joint: any, stiffness: number, damping: number): void;
        /**
         * @en Create a gear joint.
         * @param defStruct The definition of the gear joint.
         * @returns The created gear joint.
         * @zh 创建齿轮关节。
         * @param defStruct 齿轮关节定义。
         * @returns 创建的齿轮关节。
         */
        create_GearJoint(defStruct: physics2D_GearJointDef): void;
        /**
         * @en Set the ratio of a gear joint.
         * @param joint The gear joint.
         * @param radio The ratio to set.
         * @zh 设置齿轮关节的比率。
         * @param joint 齿轮关节。
         * @param radio 要设置的比率。
         */
        set_GearJoint_SetRatio(joint: any, radio: number): void;
        /**
         * @en Create a pulley joint.
         * @param defStruct The definition of the pulley joint.
         * @returns The created pulley joint.
         * @zh 创建滑轮关节。
         * @param defStruct 滑轮关节定义。
         * @returns 创建的滑轮关节。
         */
        create_PulleyJoint(defStruct: physics2D_PulleyJointDef): void;
        /**
         * @en Create a wheel joint.
         * @param defStruct The definition of the wheel joint.
         * @returns The created wheel joint.
         * @zh 创建轮子关节。
         * @param defStruct 轮子关节定义。
         * @returns 创建的轮子关节。
         */
        create_WheelJoint(defStruct: physics2D_WheelJointDef): any;
        /**
         * @en Create a weld joint.
         * @param defStruct The definition of the weld joint.
         * @returns The created weld joint.
         * @zh 创建焊接关节。
         * @param defStruct 焊接关节定义。
         * @returns 创建的焊接关节。
         */
        create_WeldJoint(defStruct: physics2D_WeldJointDef): any;
        /**
         * @en Create a mouse joint.
         * @param defStruct The definition of the mouse joint.
         * @returns The created mouse joint.
         * @zh 创建鼠标关节。
         * @param defStruct 鼠标关节定义。
         * @returns 创建的鼠标关节。
         */
        create_MouseJoint(defStruct: physics2D_MouseJointJointDef): any;
        /**
         * @en Set the target position of a mouse joint.
         * @param joint The mouse joint.
         * @param x The x-coordinate of the target position.
         * @param y The y-coordinate of the target position.
         * @zh 设置鼠标关节的目标位置。
         * @param joint 鼠标关节。
         * @param x 目标位置的x坐标。
         * @param y 目标位置的y坐标。
         */
        set_MouseJoint_target(joint: any, x: number, y: number): void;
        /**
         * @en Set the frequency and damping ratio of a mouse joint.
         * @param Joint The mouse joint.
         * @param frequency The frequency.
         * @param dampingRatio The damping ratio.
         * @zh 设置鼠标关节的频率和阻尼比。
         * @param Joint 鼠标关节。
         * @param frequency 频率。
         * @param dampingRatio 阻尼比。
         */
        set_MouseJoint_frequencyAndDampingRatio(Joint: any, frequency: number, dampingRatio: number): void;
        /**
         * @en Create a revolute joint.
         * @param defStruct The definition of the revolute joint.
         * @returns The created revolute joint.
         * @zh 创建旋转关节。
         * @param defStruct 旋转关节定义。
         * @returns 创建的旋转关节。
         */
        create_RevoluteJoint(defStruct: physics2D_RevoluteJointDef): any;
        /**
         * @en Create a motor joint.
         * @param defStruct The definition of the motor joint.
         * @returns The created motor joint.
         * @zh 创建马达关节。
         * @param defStruct 马达关节定义。
         * @returns 创建的马达关节。
         */
        create_MotorJoint(defStruct: physics2D_MotorJointDef): any;
        /**
         * @en Set the linear offset of a motor joint.
         * @param joint The motor joint.
         * @param x The x-coordinate of the linear offset.
         * @param y The y-coordinate of the linear offset.
         * @zh 设置马达关节的线性偏移量。
         * @param joint 马达关节。
         * @param x 线性偏移量的x坐标。
         * @param y 线性偏移量的y坐标。
         */
        set_MotorJoint_linearOffset(joint: any, x: number, y: number): void;
        /**
         * @en Set the angular offset of a motor joint.
         * @param joint The motor joint.
         * @param angular The angular offset.
         * @zh 设置马达关节的角度偏移量。
         * @param joint 马达关节。
         * @param angular 角度偏移量。
         */
        set_MotorJoint_SetAngularOffset(joint: any, angular: number): void;
        /**
         * @en Set the maximum force of a motor joint.
         * @param joint The motor joint.
         * @param maxForce The maximum force.
         * @zh 设置马达关节的最大力。
         * @param joint 马达关节。
         * @param maxForce 最大力。
         */
        set_MotorJoint_SetMaxForce(joint: any, maxForce: number): void;
        /**
         * @en Set the maximum torque of a motor joint.
         * @param joint The motor joint.
         * @param maxTorque The maximum torque.
         * @zh 设置马达关节的最大扭矩。
         * @param joint 马达关节。
         * @param maxTorque 最大扭矩。
         */
        set_MotorJoint_SetMaxTorque(joint: any, maxTorque: number): void;
        /**
         * @en Set the correction factor of a motor joint.
         * @param joint The motor joint.
         * @param correctionFactor The correction factor.
         * @zh 设置马达关节的校正因子。
         * @param joint 马达关节。
         * @param correctionFactor 校正因子。
         */
        set_MotorJoint_SetCorrectionFactor(joint: any, correctionFactor: number): void;
        /**
         * @en Create a prismatic joint.
         * @param def The definition of the prismatic joint.
         * @returns The created prismatic joint.
         * @zh 创建平移关节。
         * @param def 平移关节定义。
         * @returns 创建的平移关节。
         */
        create_PrismaticJoint(def: physics2D_PrismaticJointDef): any;
        /**
         * @en Create a box collider shape.
         * @returns The created box collider shape.
         * @zh 创建盒子碰撞器形状。
         * @returns 创建的盒子碰撞器形状。
         */
        create_boxColliderShape(): any;
        /**
         * @en Set the shape of a box collider as a box.
         * @param shape The box collider shape.
         * @param width The width of the box.
         * @param height The height of the box.
         * @param pos The position of the box.
         * @param scaleX The horizontal scale of the box.
         * @param scaleY The vertical scale of the box.
         * @zh 将盒子碰撞器的形状设置为盒子。
         * @param shape 盒子碰撞器形状。
         * @param width 盒子的宽度。
         * @param height 盒子的高度。
         * @param pos 盒子的位置。
         * @param scaleX 盒子的水平缩放。
         * @param scaleY 盒子的垂直缩放。
         */
        set_collider_SetAsBox(shape: any, width: number, height: number, pos: IV2, scaleX: number, scaleY: number): void;
        /**
         * @en Create a chain shape.
         * @returns The created chain shape.
         * @zh 创建链条形状。
         * @returns 创建的链条形状。
         */
        create_ChainShape(): any;
        /**
         * @en Set the data of a chain shape.
         * @param shape The chain shape.
         * @param x The x-coordinate of the chain shape's position.
         * @param y The y-coordinate of the chain shape's position.
         * @param arr The vertex array of the chain shape.
         * @param loop Whether the chain shape is a loop.
         * @param scaleX The horizontal scale of the chain shape.
         * @param scaleY The vertical scale of the chain shape.
         * @zh 设置链条形状的数据。
         * @param shape 链条形状。
         * @param x 链条形状的位置的x坐标。
         * @param y 链条形状的位置的y坐标。
         * @param arr 链条形状的顶点数组。
         * @param loop 链条形状是否为循环。
         * @param scaleX 链条形状的水平缩放。
         * @param scaleY 链条形状的垂直缩放。
         */
        set_ChainShape_data(shape: any, x: number, y: number, arr: number[], loop: boolean, scaleX: number, scaleY: number): void;
        /**
         * @en Create a circle shape.
         * @returns The created circle shape.
         * @zh 创建圆形形状。
         * @returns 创建的圆形形状。
         */
        create_CircleShape(): any;
        /**
         * @en Set the radius of a circle shape.
         * @param shape The circle shape.
         * @param radius The radius of the circle shape.
         * @param scale The scale of the circle shape.
         * @zh 设置圆形形状的半径。
         * @param shape 圆形形状。
         * @param radius 圆形形状的半径。
         * @param scale 圆形形状的缩放。
         */
        set_CircleShape_radius(shape: any, radius: number, scale: number): void;
        /**
         * @en Set the position of a circle shape.
         * @param shape The circle shape.
         * @param x The x-coordinate of the circle shape's position.
         * @param y The y-coordinate of the circle shape's position.
         * @param scale The scale of the circle shape.
         * @zh 设置圆形形状的位置。
         * @param shape 圆形形状。
         * @param x 圆形形状的位置的x坐标。
         * @param y 圆形形状的位置的y坐标。
         * @param scale 圆形形状的缩放。
         */
        set_CircleShape_pos(shape: any, x: number, y: number, scale: number): void;
        /**
         * @en Create an edge shape.
         * @returns The created edge shape.
         * @zh 创建边缘形状。
         * @returns 创建的边缘形状。
         */
        create_EdgeShape(): any;
        /**
         * @en Set the data of an edge shape.
         * @param shape The edge shape.
         * @param x The x-coordinate of the edge shape's position.
         * @param y The y-coordinate of the edge shape's position.
         * @param arr The vertex array of the edge shape.
         * @param scaleX The horizontal scale of the edge shape.
         * @param scaleY The vertical scale of the edge shape.
         * @zh 设置边缘形状的数据。
         * @param shape 边缘形状。
         * @param x 边缘形状的位置的x坐标。
         * @param y 边缘形状的位置的y坐标。
         * @param arr 边缘形状的顶点数组。
         * @param scaleX 边缘形状的水平缩放。
         * @param scaleY 边缘形状的垂直缩放。
         */
        set_EdgeShape_data(shape: any, x: number, y: number, arr: number[], scaleX: number, scaleY: number): void;
        /**
         * @en Create a polygon shape.
         * @returns The created polygon shape.
         * @zh 创建多边形形状。
         * @returns 创建的多边形形状。
         */
        create_PolygonShape(): any;
        /**
         * @en Set the data of a polygon shape.
         * @param shape The polygon shape.
         * @param x The x-coordinate of the polygon shape's position.
         * @param y The y-coordinate of the polygon shape's position.
         * @param arr The vertex array of the polygon shape.
         * @param scaleX The horizontal scale of the polygon shape.
         * @param scaleY The vertical scale of the polygon shape.
         * @zh 设置多边形形状的数据。
         * @param shape 多边形形状。
         * @param x 多边形形状的位置的x坐标。
         * @param y 多边形形状的位置的y坐标。
         * @param arr 多边形形状的顶点数组。
         * @param scaleX 多边形形状的水平缩放。
         * @param scaleY 多边形形状的垂直缩放。
         */
        set_PolygonShape_data(shape: any, x: number, y: number, arr: number[], scaleX: number, scaleY: number): void;
        /**
         * @en Create a fixture definition.
         * @param fixtureDef The fixture definition.
         * @returns The created fixture definition.
         * @zh 创建夹具定义。
         * @param fixtureDef 夹具定义。
         * @returns 创建的夹具定义。
         */
        createFixtureDef(fixtureDef: FixtureBox2DDef): any;
        /**
         * @en Set the group index of a fixture definition.
         * @param def The fixture definition.
         * @param groupIndex The group index.
         * @zh 设置夹具定义的组索引。
         * @param def 夹具定义。
         * @param groupIndex 组索引。
         */
        set_fixtureDef_GroupIndex(def: any, groupIndex: number): void;
        /**
         * @en Set the category bits of a fixture definition.
         * @param def The fixture definition.
         * @param categoryBits The category bits.
         * @zh 设置夹具定义的类别位。
         * @param def 夹具定义。
         * @param categoryBits 类别位。
         */
        set_fixtureDef_CategoryBits(def: any, categoryBits: number): void;
        /**
         * @en Set the mask bits of a fixture definition.
         * @param def The fixture definition.
         * @param maskbits The mask bits.
         * @zh 设置夹具定义的掩码位。
         * @param def 夹具定义。
         * @param maskbits 掩码位。
         */
        set_fixtureDef_maskBits(def: any, maskbits: number): void;
        /**
         * @en Create a fixture by body and definition.
         * @param body The body.
         * @param fixtureDef The fixture definition.
         * @zh 通过物体和定义创建夹具。
         * @param body 物体。
         * @param fixtureDef 夹具定义。
         */
        createfixture(body: any, fixtureDef: any): any;
        /**
         * @en Set the collider of a fixture.
         * @param fixture The fixture.
         * @param instance The collider instance.
         * @zh 设置夹具的碰撞器。
         * @param fixture 夹具。
         * @param instance 碰撞器实例。
         */
        set_fixture_collider(fixture: any, instance: ColliderBase): void;
        /**
         * @en Get the body of a fixture.
         * @param fixture The fixture.
         * @returns The body of the fixture.
         * @zh 获取夹具的物体。
         * @param fixture 夹具。
         * @returns 夹具的物体。
         */
        get_fixture_body(fixture: any): any;
        /**
         * @en Destroy a fixture of a rigid body.
         * @param body The rigid body.
         * @param fixture The fixture to destroy.
         * @zh 销毁刚体的一个夹具。
         * @param body 刚体。
         * @param fixture 要销毁的夹具。
         */
        rigidBody_DestroyFixture(body: any, fixture: any): void;
        /**
         * @en Create a rigid body definition.
         * @param rigidbodyDef The rigid body definition.
         * @returns The created rigid body.
         * @zh 创建刚体定义。
         * @param rigidbodyDef 刚体定义。
         * @returns 创建的刚体。
         */
        rigidBodyDef_Create(rigidbodyDef: RigidBody2DInfo): any;
        /**
         * @en Get the position of a rigid body.
         * @param body The rigid body.
         * @param v2 The vector to store the position.
         * @zh 获取刚体的位置。
         * @param body 刚体。
         * @param v2 用于存储位置的向量。
         */
        get_RigidBody_Position(body: any, v2: Vector2): void;
        /**
         * @en Get the angle of a rigid body.
         * @param body The rigid body.
         * @returns The angle of the rigid body.
         * @zh 获取刚体的角度。
         * @param body 刚体。
         * @returns 刚体的角度。
         */
        get_RigidBody_Angle(body: any): number;
        /**
         * @en Set the enable of a rigid body.
         * @param body The rigid body.
         * @zh 设置刚体是否激活。
         * @param body 刚体。
         */
        set_RigibBody_Enable(body: any, enable: boolean): void;
        /**
         * @en Set the transform of a rigid body.
         * @param body The rigid body.
         * @param x The x-coordinate of the position.
         * @param y The y-coordinate of the position.
         * @param angle The angle of the rigid body.
         * @zh 设置刚体的变换。
         * @param body 刚体。
         * @param x 位置的x坐标。
         * @param y 位置的y坐标。
         * @param angle 刚体的角度。
         */
        set_RigibBody_Transform(body: any, x: number, y: number, angle: any): void;
        /**
         * @en Get the world point of a rigid body.
         * @param body The rigid body.
         * @param x The x-coordinate of the local point.
         * @param y The y-coordinate of the local point.
         * @returns The world point.
         * @zh 获取刚体的世界坐标点。
         * @param body 刚体。
         * @param x 局部坐标的x坐标。
         * @param y 局部坐标的y坐标。
         * @returns 世界坐标点。
         */
        get_rigidBody_WorldPoint(body: any, x: number, y: number): IV2;
        /**
         * @en Get the local point of a rigid body.
         * @param body The rigid body.
         * @param x The x-coordinate of the world point.
         * @param y The y-coordinate of the world point.
         * @returns The local point.
         * @zh 获取刚体的本地坐标点。
         * @param body 刚体。
         * @param x 世界坐标的x坐标。
         * @param y 世界坐标的y坐标。
         * @returns 本地坐标点。
         */
        get_rigidBody_LocalPoint(body: any, x: number, y: number): IV2;
        /**
         * @en Apply a force to a rigid body.
         * @param body The rigid body.
         * @param force The force to apply.
         * @param position The position to apply the force.
         * @zh 对刚体施加力。
         * @param body 刚体。
         * @param force 施加的力。
         * @param position 施加力的位置。
         */
        rigidBody_applyForce(body: any, force: IV2, position: IV2): void;
        /**
         * @en Apply a force to the center of a rigid body.
         * @param body The rigid body.
         * @param force The force to apply.
         * @zh 对刚体的中心施加力。
         * @param body 刚体。
         * @param force 施加的力。
         */
        rigidBody_applyForceToCenter(body: any, force: IV2): void;
        /**
         * @en Apply a linear impulse to a rigid body.
         * @param body The rigid body.
         * @param impulse The linear impulse to apply.
         * @param position The position to apply the impulse.
         * @zh 对刚体施加线性冲量。
         * @param body 刚体。
         * @param impulse 施加的线性冲量。
         * @param position 施加线性冲量的位置。
         */
        rigidbody_ApplyLinearImpulse(body: any, impulse: IV2, position: IV2): void;
        /**
         * @en Apply a linear impulse to the center of a rigid body.
         * @param body The rigid body.
         * @param impulse The linear impulse to apply.
         * @zh 对刚体的中心施加线性冲量。
         * @param body 刚体。
         * @param impulse 施加的线性冲量。
         */
        rigidbody_ApplyLinearImpulseToCenter(body: any, impulse: IV2): void;
        /**
         * @en Apply torque to a rigid body to make it rotate.
         * @param body The rigid body.
         * @param torque The torque to apply.
         * @zh 对刚体施加扭矩，使其旋转。
         * @param body 刚体。
         * @param torque 施加的扭矩。
         */
        rigidbody_applyTorque(body: any, torque: number): void;
        /**
         * @en The velocity to set, e.g., {x: 10, y: 10}.
         * @param body The rigid body.
         * @param velocity The velocity to set.
         * @zh 设置速度，比如{x:10,y:10}
         * @param body 刚体。
         * @param velocity 速度。
         */
        set_rigidbody_Velocity(body: any, velocity: IV2): void;
        /**
         * @en Set the awake state of a rigid body.
         * @param body The rigid body.
         * @param awake The awake state.
         * @zh 设置刚体的唤醒状态。
         * @param body 刚体。
         * @param awake 唤醒状态。
         */
        set_rigidbody_Awake(body: any, awake: boolean): void;
        /**
         * @en Get the mass of a rigid body.
         * @param body The rigid body.
         * @returns The mass of the rigid body.
         * @zh 获取刚体的质量。
         * @param body 刚体。
         * @returns 刚体的质量。
         */
        get_rigidbody_Mass(body: any): number;
        /**
         * @en Set the mass of a rigid body.
         * @param body The rigid body.
         * @param mass The mass to set.
         * @param centerofMass The center of mass to set.
         * @param inertia The inertia to set.
         * @zh 设置刚体的质量。
         * @param body 刚体。
         * @param mass 要设置的质量。
         * @param centerofMass 要设置的质心。
         * @param inertia 要设置的惯性张量。
         */
        set_rigidbody_Mass(body: any, massValue: number, centerofMass: IV2, inertiaValue: number): void;
        /**
         * @en Get the offset of the center of mass relative to the node (0, 0) point.
         * @param body The rigid body.
         * @returns The offset of the center of mass.
         * @zh 获取质心相对于节点 (0, 0) 点的位置偏移。
         * @param body 刚体。
         * @returns 质心相对于节点 (0, 0) 点的位置偏移。
         */
        get_rigidBody_Center(body: any): IV2;
        /**
         * @en Get the inertia tensor of the rigid body.
         * @param body The rigid body.
         * @returns The inertia tensor of the rigid body.
         * @zh 获取刚体的转动张量
         * @param body 刚体。
         * @returns 刚体的转动张量。
         */
        get_rigidbody_Inertia(body: any): number;
        /**
         * @en Check if a rigid body is awake.
         * @param body The rigid body.
         * @returns True if the rigid body is awake, false otherwise.
         * @zh 检查刚体是否处于唤醒状态。
         * @param body 刚体。
         * @returns 若刚体处于唤醒状态，则返回true，否则返回false。
         */
        get_rigidBody_IsAwake(body: any): any;
        /**
         * @en Get the world coordinates of the center of mass relative to the Physics.I.worldRoot node.
         * @param body The rigid body.
         * @returns The world coordinates of the center of mass.
         * @zh 获取质心相对于 Physics.I.worldRoot 节点的世界坐标。
         * @param body 刚体。
         * @returns 质心相对于 Physics.I.worldRoot 节点的世界坐标。
         */
        get_rigidBody_WorldCenter(body: any): IV2;
        /**
         * @en Set the type of a rigid body.
         * @param body The rigid body.
         * @param value The type of the rigid body.
         * @zh 设置刚体的类型。
         * @param body 刚体。
         * @param value 刚体的类型。
         */
        set_rigidBody_type(body: any, value: string): void;
        /**
         * @en Set the gravity scale of a rigid body.
         * @param body The rigid body.
         * @param value The gravity scale.
         * @zh 设置刚体的重力缩放因子。
         * @param body 刚体。
         * @param value 重力缩放因子。
         */
        set_rigidBody_gravityScale(body: any, value: number): void;
        /**
         * @en Set whether a rigid body allows rotation.
         * @param body The rigid body.
         * @param value True if the rigid body allows rotation, false otherwise.
         * @zh 设置刚体是否允许旋转。
         * @param body 刚体。
         * @param value 若为true，则刚体允许旋转；若为false，则刚体不允许旋转。
         */
        set_rigidBody_allowRotation(body: any, value: boolean): void;
        /**
         * @en Set whether a rigid body allows sleeping.
         * @param body The rigid body.
         * @param value True if the rigid body allows sleeping, false otherwise.
         * @zh 设置刚体是否允许休眠。
         * @param body 刚体。
         * @param value 若为true，则刚体允许休眠；若为false，则刚体不允许休眠。
         */
        set_rigidBody_allowSleep(body: any, value: boolean): void;
        /**
         * @en Set the angular damping of a rigid body.
         * @param body The rigid body.
         * @param value The angular damping.
         * @zh 设置刚体的角阻尼。
         * @param body 刚体。
         * @param value 角阻尼。
         */
        set_rigidBody_angularDamping(body: any, value: number): void;
        /**
         * @en Get the angular velocity of a rigid body.
         * @param body The rigid body.
         * @returns The angular velocity.
         * @zh 获取刚体的角速度。
         * @param body 刚体。
         * @returns 角速度。
         */
        get_rigidBody_angularVelocity(body: any): number;
        /**
         * @en Set the angular velocity of a rigid body.
         * @param body The rigid body.
         * @param value The angular velocity.
         * @zh 设置刚体的角速度。
         * @param body 刚体。
         * @param value 角速度。
         */
        set_rigidBody_angularVelocity(body: any, value: number): void;
        /**
         * @en Set the linear damping of a rigid body.
         * @param body The rigid body.
         * @param value The linear damping.
         * @zh 设置刚体的线性阻尼。
         * @param body 刚体。
         * @param value 线性阻尼。
         */
        set_rigidBody_linearDamping(body: any, value: number): void;
        /**
         * @en Get the linear velocity of a rigid body.
         * @param body The rigid body.
         * @returns The linear velocity.
         * @zh 获取刚体的线性速度。
         * @param body 刚体。
         * @returns 线性速度。
         */
        get_rigidBody_linearVelocity(body: any): IV2;
        /**
         * @en Set the linear velocity of a rigid body.
         * @param body The rigid body.
         * @param value The linear velocity.
         * @zh 设置刚体的线性速度。
         * @param body 刚体。
         * @param value 线性速度。
         */
        set_rigidBody_linearVelocity(body: any, value: IV2): void;
        /**
         * @en Set whether a rigid body is a bullet.
         * @param body The rigid body.
         * @param value True if the rigid body is a bullet, false otherwise.
         * @zh 设置刚体是否为子弹。
         * @param body 刚体。
         * @param value 若为true，则刚体为子弹；若为false，则刚体不是子弹。
         */
        set_rigidBody_bullet(body: any, value: boolean): void;
        /**
         * @en Reset the mass data of a rigid body.
         * @param body The rigid body.
         * @zh 重置刚体的质量数据。
         * @param body 刚体。
         */
        retSet_rigidBody_MassData(body: any): void;
    }
    interface IPhysiscs2DFactory {
    }
    /**
     * @en Distance Joint: A joint that maintains a fixed distance between two points on two bodies.
     * @zh 距离关节描述了两个刚体锚点之间的距离，并且最终会保持着这个约束的距离。
     */
    class DistanceJoint extends JointBase {
        /**
         * @en The joint's own rigid body, effective only on the first setting.
         * @zh [首次设置有效]关节的自身刚体。
         */
        selfBody: RigidBody;
        /**
         * @en The joint's connected rigid body, which can be unspecified and defaults to an empty rigid body at the top left corner, effective only on the first setting.
         * @zh [首次设置有效]关节的连接刚体，可不设置，默认为左上角空刚体。
         */
        otherBody: RigidBody;
        /**
         * @en The self body's anchor point, which is the offset relative to the top left corner of the own rigid body, effective only on the first setting.
         * @zh [首次设置有效]自身刚体链接点，是相对于自身刚体的左上角位置偏移。
         */
        selfAnchor: any[];
        /**
         * @en The connected body's anchor point, which is the offset relative to the top left corner of the other body, effective only on the first setting.
         * @zh [首次设置有效]链接刚体链接点，是相对于otherBody的左上角位置偏移。
         */
        otherAnchor: any[];
        /**
         * @en Whether the two rigid bodies can collide with each other, default is false, effective only on the first setting.
         * @zh [首次设置有效]两个刚体是否可以发生碰撞，默认为false。
         */
        collideConnected: boolean;
        /**
         * @en The target rest length of the constraint.
         * @zh 约束的目标静止长度。
         */
        get length(): number;
        set length(value: number);
        /**
         * @en The minimum length of the constraint.
         * @zh 约束的最小长度。
         */
        get minLength(): number;
        set minLength(value: number);
        /**
         * @en The maximum length of the constraint.
         * @zh 约束的最大长度。
         */
        get maxLength(): number;
        set maxLength(value: number);
        /**
         * @en The vibration frequency of a spring system indicates how quickly it completes one oscillation cycle. A higher value signifies a higher frequency, meaning it completes one oscillation cycle in a shorter time. Consequently, the oscillation amplitude is relatively smaller, and the oscillation speed is faster. Conversely, a lower frequency results in a larger oscillation amplitude and slower oscillation speed.
         * @zh 弹簧系统的振动频率，值越大表示振动频率越高，意味着在更短的时间内完成一个振动周期，所以，振动幅度相对较小，振动速度更快。反之，振动幅度相对较大，振动速度更慢。
         */
        get frequency(): number;
        set frequency(value: number);
        /**
         * @en The damping ratio of the body when returning to the node, which is recommended to be between 0 and 1.
         * @zh 刚体在回归到节点过程中受到的阻尼比，建议取值在 0 到 1 之间。
         */
        get damping(): number;
        set damping(value: number);
        /**
         * @en The current length of the joint.
         * @zh 关节的当前长度。
         */
        get jointLength(): number;
        /**
         * @en Called when the object is being destroyed. This method removes event listeners to prevent memory leaks.
         * @zh 在对象被销毁时调用。此方法移除事件监听器以防止内存泄漏。
         */
        onDestroy(): void;
    }
    /**
     * @en Gear joint: used to simulate the constraint relationship between two gears. When a gear rotates, the momentum generated has two output modes: one is the angular velocity of the gear itself, and the other is the linear velocity on the gear surface
     * @zh 齿轮关节：用来模拟两个齿轮间的约束关系，齿轮旋转时，产生的动量有两种输出方式，一种是齿轮本身的角速度，另一种是齿轮表面的线速度
     */
    class GearJoint extends JointBase {
        private _joint1;
        private _joint2;
        /**
         * @en The first joint to be connected, which can be a RevoluteJoint or a PrismaticJoint, effective only on the first setting.
         * @zh [首次设置有效]要绑定的第一个关节，类型可以是旋转关节（RevoluteJoint）或者棱形关节（PrismaticJoint）。
         */
        set joint1(value: RevoluteJoint | PrismaticJoint);
        get joint1(): RevoluteJoint | PrismaticJoint;
        /**
         * @en The second joint to be connected, which can be a RevoluteJoint or a PrismaticJoint, effective only on the first setting.
         * @zh [首次设置有效]要绑定的第二个关节，类型可以是旋转关节（RevoluteJoint）或者棱形关节（PrismaticJoint）。
         */
        set joint2(value: RevoluteJoint | PrismaticJoint);
        get joint2(): RevoluteJoint | PrismaticJoint;
        /**
         * @en Specifies whether the two connected bodies should collide with each other. Default is false, effective only on the first setting.
         * @zh [首次设置有效]两个刚体是否可以发生碰撞，默认为 false。
         */
        collideConnected: boolean;
        /**
         * @en The ratio of the angular velocities of the two gears.
         * @zh 两个齿轮的角速度比例。
         */
        get ratio(): number;
        set ratio(value: number);
    }
    /**
     * @en Joint base class
     * @zh 关节基类
     */
    class JointBase extends Component {
        /**
         * @readonly
         * @en [read-only] Native joint object.
         * @zh [只读]原生关节对象。
         */
        get joint(): any;
        constructor();
    }
    /**
     * Box2D distance Joint def Struct
     */
    class physics2D_DistancJointDef {
        bodyA: any;
        bodyB: any;
        localAnchorA: Vector2;
        localAnchorB: Vector2;
        frequency: number;
        dampingRatio: number;
        collideConnected: boolean;
        length: number;
        maxLength: number;
        minLength: number;
        isLocalAnchor: boolean;
    }
    class physics2D_GearJointDef {
        bodyA: any;
        bodyB: any;
        joint1: any;
        joint2: any;
        ratio: number;
        collideConnected: boolean;
    }
    class physics2D_MotorJointDef {
        bodyA: any;
        bodyB: any;
        linearOffset: Vector2;
        angularOffset: number;
        maxForce: number;
        maxTorque: number;
        correctionFactor: number;
        collideConnected: boolean;
    }
    class physics2D_MouseJointJointDef {
        bodyA: any;
        bodyB: any;
        maxForce: number;
        frequency: number;
        dampingRatio: number;
        target: Vector2;
    }
    class physics2D_PrismaticJointDef {
        bodyA: any;
        bodyB: any;
        anchor: Vector2;
        axis: Vector2;
        enableMotor: boolean;
        motorSpeed: number;
        maxMotorForce: number;
        enableLimit: boolean;
        lowerTranslation: number;
        upperTranslation: number;
        collideConnected: boolean;
    }
    class physics2D_PulleyJointDef {
        bodyA: any;
        bodyB: any;
        groundAnchorA: Vector2;
        groundAnchorB: Vector2;
        localAnchorA: Vector2;
        localAnchorB: Vector2;
        ratio: number;
        collideConnected: boolean;
    }
    class physics2D_RevoluteJointDef {
        bodyA: any;
        bodyB: any;
        anchor: Vector2;
        enableMotor: boolean;
        motorSpeed: number;
        maxMotorTorque: number;
        enableLimit: boolean;
        lowerAngle: number;
        upperAngle: number;
        collideConnected: boolean;
    }
    class physics2D_WeldJointDef {
        bodyA: any;
        bodyB: any;
        anchor: Vector2;
        frequency: number;
        dampingRatio: number;
        collideConnected: boolean;
    }
    class physics2D_WheelJointDef {
        bodyA: any;
        bodyB: any;
        anchor: Vector2;
        axis: Vector2;
        enableMotor: boolean;
        motorSpeed: number;
        maxMotorTorque: number;
        enableLimit: boolean;
        lowerTranslation: number;
        upperTranslation: number;
        frequency: number;
        dampingRatio: number;
        collideConnected: boolean;
    }
    /**
     * @en Motor Joint: Allows specifying the relative position and angle between two rigid bodies, and then attempts to achieve these targets by applying forces and torques, striving to maintain this configuration.
     * @zh 马达关节：允许指定两个刚体间的相对位置和角度，然后尝试通过施加力和扭矩来达到这些目标，并会尽力维持这样的配置。
     */
    class MotorJoint extends JointBase {
        /**
         * @en The self body of the joint, effective only on the first setting.
         * @zh [首次设置有效]关节的自身刚体。
         */
        selfBody: RigidBody;
        /**
         * @en The other body connected by the joint, effective only on the first setting.
         * @zh [首次设置有效]关节的连接刚体。
         */
        otherBody: RigidBody;
        /**
         * @en Specifies whether the two connected bodies should collide with each other. Default is false, effective only on the first setting.
         * @zh [首次设置有效]两个刚体是否可以发生碰撞，默认为 false。
         */
        collideConnected: boolean;
        /**
         * @en The offset from the other body's coordinates, which is also the target position for the self body.
         * @zh 基于 otherBody 坐标位置的偏移量，也是 selfBody 的目标位置。
         */
        get linearOffset(): any[];
        set linearOffset(value: any[]);
        /**
         * @en The angular offset based on the other body, which is also the target angle for the self body.
         * @zh 基于 otherBody 的角度偏移量，也是 selfBody 的目标角度。
         */
        get angularOffset(): number;
        set angularOffset(value: number);
        /**
         * @en The maximum force applied by the motor joint when the selfBody deviates from the target position. When the force applied by the motor joint exceeds the maximum force, the engine automatically limits the force to ensure it does not exceed the specified maximum value.
         * @zh 当 selfBody 偏离目标位置时，马达关节所施加的最大作用力。当马达关节施加的力超过最大力时，引擎会自动截断力的大小，使其不超过设定的最大值。
         */
        get maxForce(): number;
        set maxForce(value: number);
        /**
         * @en The maximum torque is used to ensure that when the torque applied by the motor joint exceeds the maximum torque value, the engine automatically limits the torque to not exceed the specified maximum value.
         * @zh 最大扭矩用于当马达关节施加的扭矩超过最大扭矩值时，引擎会自动截断扭矩的大小，以确保不超过设定的最大值。
         */
        get maxTorque(): number;
        set maxTorque(value: number);
        /**
         * @en The factor of easing when the self body moves towards the target position, with a value from 0 to 1, the larger the value, the faster the speed.
         * @zh selfBody 向目标位置移动时的缓动因子，取值 0~1，值越大速度越快。
         */
        get correctionFactor(): number;
        set correctionFactor(value: number);
    }
    /**
     * @en Mouse joint: A physics constraint used to simulate the user dragging an object with the mouse. It typically allows a rigid body to follow the mouse cursor's movement while also being influenced by other physics effects such as collisions and gravity.
     * @zh 鼠标关节:一种用来模拟用户用鼠标拖拽物体的物理约束。它通常会使得一个刚体可以跟随鼠标移动，但同时也能受到其他物理效果如碰撞、重力等的影响。
     */
    class MouseJoint extends JointBase {
        /**
         * @en The self rigid body of a joint, effective only on the first setting.
         * @zh [首次设置有效]关节的自身刚体。
         */
        selfBody: RigidBody;
        /**
         * @en The connection point of a joint is offset from the position of the upper left corner of its own rigid body. If not set, it is used as the connection point based on the mouse click point. Effective only on the first setting.
         * @zh [首次设置有效]关节的链接点，是相对于自身刚体的左上角位置偏移，如果不设置，则根据鼠标点击点作为连接点。
         */
        anchor: any[];
        /**
         * @en Used to limit the maximum force that the mouse joint can apply when attempting to move an object towards the mouse position, preventing excessive force that could lead to abnormal behavior or unnatural effects.
         * @zh 用于限制鼠标关节试图将物体移向鼠标位置时所能施加的最大力量，避免力过大导致的异常行为或不自然的效果。
         */
        get maxForce(): number;
        set maxForce(value: number);
        /**
         * @en The vibration frequency of the spring system, which can be considered as the spring's elasticity coefficient. The frequency should typically be less than half the time step frequency.
         * @zh 弹簧系统的振动频率，可以视为弹簧的弹性系数，通常频率应该小于时间步长频率的一半。
         */
        get frequency(): number;
        set frequency(value: number);
        /**
         * @en The damping ratio of the body when returning to the anchor, with a recommended value between 0 and 1.
         * @zh 刚体在回归到节点过程中受到的阻尼比，建议取值在 0 到 1 之间。
         */
        get damping(): number;
        set damping(value: number);
    }
    /**
     * @en Translation joint: A movement joint allows two objects to move relative to each other along a specified axis, but it prevents relative rotation
     * @zh 平移关节：移动关节允许两个物体沿指定轴相对移动，它会阻止相对旋转
     */
    class PrismaticJoint extends JointBase {
        /**
         * @en The rigid body to which the joint is attached. This setting is effective only on the first assignment.
         * @zh [首次设置有效]关节的自身刚体。
         */
        selfBody: RigidBody;
        /**
         * @en The connected rigid body of the joint. It can be left unspecified, in which case it defaults to an empty rigid body at the top left corner. This setting is effective only on the first assignment.
         * @zh [首次设置有效]关节的连接刚体，可不设置，默认为左上角空刚体。
         */
        otherBody: RigidBody;
        /**
         * @en The anchor point of the joint, which is the offset relative to the top-left corner of the own rigid body. This setting is effective only on the first assignment.
         * @zh [首次设置有效]关节的控制点，是相对于自身刚体左上角位置的偏移。
         */
        anchor: any[];
        /**
         * @en The angle describing the axis of motion, e.g., 0 degrees represents movement to the right along the X-axis. This setting is effective only on the first assignment.
         * @zh [首次设置有效]描述运动方向的角度，例如 0 度表示沿 X 轴向右移动。
         */
        angle: number;
        /**
         * @en Specifies whether the two connected rigid bodies should collide with each other. Default is false. This setting is effective only on the first assignment.
         * @zh [首次设置有效]两个刚体是否可以发生碰撞，默认为 false。
         */
        collideConnected: boolean;
        /**
         * @en Whether the motor is enabled to drive the connected body.
         * @zh 是否开启马达，开启马达可使目标刚体运动。
         */
        get enableMotor(): boolean;
        set enableMotor(value: boolean);
        /**
         * @en The maximum speed that the motor can achieve along the axis when the motor is enabled.
         * @zh 启用马达后，在axis坐标轴上移动可以达到的最大速度。
         */
        get motorSpeed(): number;
        set motorSpeed(value: number);
        /**
         * @en The maximum force that can be applied by the motor when it is enabled.
         * @zh 启用马达后，可以施加的最大作用力。
         */
        get maxMotorForce(): number;
        set maxMotorForce(value: number);
        /**
         * @en Whether to constrain the movement range of the rigid body.
         * @zh 是否对刚体的移动范围加以约束。
         */
        get enableLimit(): boolean;
        set enableLimit(value: boolean);
        /**
         * @en The lower limit of the body's movement range when the limit is enabled, as an offset from the anchor.
         * @zh 启用限制后，刚体移动范围的下限，是距离anchor的偏移量。
         */
        get lowerTranslation(): number;
        set lowerTranslation(value: number);
        /**
         * @en The upper limit of the body's movement range when the limit is enabled, as an offset from the anchor.
         * @zh 启用限制后，刚体移动范围的上限，是距离anchor的偏移量。
         */
        get upperTranslation(): number;
        set upperTranslation(value: number);
        /**
         * @deprecated
         * @en The axis of motion, which is a vector describing the direction of movement.
         * @zh 启用约束后，刚体移动范围的上限，是距离anchor的偏移量
         */
        get axis(): any;
        set axis(value: any);
    }
    /**
     * @en PulleyJoint class, which connects two bodies to the ground and to each other, when one body rises, the other descends, simulating the behavior of a pulley system.
     * @zh 滑轮关节：它将两个物体接地(ground)并彼此连接，当一个物体上升，另一个物体就会下降
     */
    class PulleyJoint extends JointBase {
        /**
         * @en The rigid body that is attached to the joint. This setting is effective only on the first assignment.
         * @zh [首次设置有效]与关节相连的自身刚体。
         */
        selfBody: RigidBody;
        /**
         * @en The connected rigid body. This setting is effective only on the first assignment.
         * @zh [首次设置有效]连接到关节的另一个刚体。
         */
        otherBody: RigidBody;
        /**
         * @en The anchor point of the rigid body relative to its top-left corner. This setting is effective only on the first assignment.
         * @zh [首次设置有效]自身刚体的链接点，是相对于自身刚体左上角位置的偏移。
         */
        selfAnchor: any[];
        /**
         * @en The anchor point of the connected body relative to its top-left corner. This setting is effective only on the first assignment.
         * @zh [首次设置有效]连接刚体的链接点，是相对于otherBody左上角位置的偏移。
         */
        otherAnchor: any[];
        /**
         * @en The point on the pulley connected to the self anchor, relative to the top-left corner of the rigid body. This setting is effective only on the first assignment.
         * @zh [首次设置有效]滑轮上与自身刚体的 selfAnchor 相连的点，是相对于自身刚体左上角位置的偏移。
         */
        selfGroundPoint: any[];
        /**
         * @en The point on the pulley connected to the other anchor, relative to the top-left corner of the connected body. This setting is effective only on the first assignment.
         * @zh [首次设置有效]滑轮上与连接刚体的 otherAnchor 相连的点，是相对于对方刚体左上角位置的偏移。
         */
        otherGroundPoint: any[];
        /**
         * @en The ratio of movement distances between the two connected rigid bodies. This setting is effective only on the first assignment.
         * @zh [首次设置有效]两个刚体的移动距离比率。
         */
        ratio: number;
        /**
         * @en Specifies whether the two connected rigid bodies can collide with each other. Default is false. This setting is effective only on the first assignment.
         * @zh [首次设置有效]两个连接的刚体是否可以相互碰撞，默认为 false。
         */
        collideConnected: boolean;
    }
    /**
     * @en Rotating joint forces two objects to share an anchor point, and the two objects rotate relative to each other
     * @zh 旋转关节强制两个物体共享一个锚点，两个物体相对旋转
     */
    class RevoluteJoint extends JointBase {
        /**
         * @en The rigid body that is locally attached to the joint. This setting is effective only on the first assignment.
         * @zh [首次设置有效]与关节直接相连的自身刚体。
         */
        selfBody: RigidBody;
        /**
         * @en The connected rigid body. It can be optionally not set. This setting is effective only on the first assignment.
         * @zh [首次设置有效]与关节连接的另一个刚体，可以不设置。
         */
        otherBody: RigidBody;
        /**
         * @en Link points of joints, it is offset from the position of the upper left corner of its own rigid body. This setting is effective only on the first assignment.
         * @zh [首次设置有效]关节的链接点，是相对于自身刚体的左上角位置偏移。
         */
        anchor: any[];
        /**
         * @en Specifies whether the two connected rigid bodies can collide with each other. Default is false. This setting is effective only on the first assignment.
         * @zh [首次设置有效]两个连接的刚体是否可以相互碰撞，默认为 false。
         */
        collideConnected: boolean;
        /**
         * @en Enables or disables the motor, which when enabled, drives the rotation of the target body.
         * @zh 启用或禁用马达，启用后可以驱动目标刚体的旋转。
         */
        get enableMotor(): boolean;
        set enableMotor(value: boolean);
        /**
         * @en The maximum rotational speed that can be achieved when the motor is enabled.
         * @zh 启用马达后可以达到的最大旋转速度。
         */
        get motorSpeed(): number;
        set motorSpeed(value: number);
        /**
         * @en The maximum torque that can be applied when the motor is enabled. Insufficient torque may result in no rotation.
         * @zh 启用马达后可以施加的最大扭距。如果最大扭矩太小，可能导致不旋转。
         */
        get maxMotorTorque(): number;
        set maxMotorTorque(value: number);
        /**
         * @en Whether to constrain the rotation range of the rigid body
         * @zh 是否对刚体的旋转范围加以约束
         */
        get enableLimit(): boolean;
        set enableLimit(value: boolean);
        /**
         * @en The lower limit angle of the rotation range when the limit is enabled.
         * @zh 启用限制后，刚体旋转范围的下限角度。
         */
        get lowerAngle(): number;
        set lowerAngle(value: number);
        /**
         * @en The upper limit angle of the rotation range when the limit is enabled.
         * @zh 启用限制后，刚体旋转范围的上限角度。
         */
        get upperAngle(): number;
        set upperAngle(value: number);
    }
    /**
     * @en WeldJoint class, used to constrain two bodies together so they cannot move relative to each other. The relative position and angle between the two bodies are fixed, making them appear as a single rigid body.
     * @zh 焊接关节：焊接关节的用途是使两个物体不能相对运动，受到关节的限制，两个刚体的相对位置和角度都保持不变，看上去像一个整体
     */
    class WeldJoint extends JointBase {
        /**
         * @en The rigid body that is locally attached to the joint. This setting is effective only on the first assignment.
         * @zh [首次设置有效]与关节直接相连的自身刚体。
         */
        selfBody: RigidBody;
        /**
         * @en The connected rigid body. This setting is effective only on the first assignment.
         * @zh [首次设置有效]与关节连接的另一个刚体。
         */
        otherBody: RigidBody;
        /**
         * @en Link points of joints, it is offset from the position of the upper left corner of its own rigid body. This setting is effective only on the first assignment.
         * @zh [首次设置有效]关节的链接点，是相对于自身刚体的左上角位置偏移。
         */
        anchor: any[];
        /**
         * @en Specifies whether the two connected rigid bodies can collide with each other. Default is false. This setting is effective only on the first assignment.
         * @zh [首次设置有效]两个连接的刚体是否可以相互碰撞，默认为 false。
         */
        collideConnected: boolean;
        /**
         * @en The vibration frequency of the spring system, which can be considered as the spring's elasticity coefficient.The frequency should typically be less than half the time step frequency.
         * @zh 弹簧系统的振动频率，可以视为弹簧的弹性系数。通常频率应该小于时间步长频率的一半。
         */
        get frequency(): number;
        set frequency(value: number);
        /**
         * @en The damping ratio of the body when returning to the anchor point, with a recommended value range of 0 to 1.
         * @zh 刚体在回归到节点过程中受到的阻尼比，建议取值0~1。
         */
        get damping(): number;
        set damping(value: number);
    }
    /**
     * @en WheelJoint: Allows an object to rotate around a fixed axis relative to another object, while also providing spring-like resistance along the axis for bouncing back.
     * @zh 轮子关节：允许一个物体在另一个物体上以固定的轴向转动，同时还能沿着轴向弹簧回弹。
     */
    class WheelJoint extends JointBase {
        /**
         * @en The rigid body that is locally attached to the joint. This setting is effective only on the first assignment.
         * @zh [首次设置有效]与关节直接相连的自身刚体。
         */
        selfBody: RigidBody;
        /**
         * @en The connected rigid body. This setting is effective only on the first assignment.
         * @zh [首次设置有效]与关节连接的另一个刚体。
         */
        otherBody: RigidBody;
        /**
         * @en Link points of joints, it is offset from the position of the upper left corner of its own rigid body. This setting is effective only on the first assignment.
         * @zh [首次设置有效]关节的链接点，是相对于自身刚体的左上角位置偏移。。
         */
        anchor: any[];
        /**
         * @en Specifies whether the two connected rigid bodies can collide with each other. Default is false. This setting is effective only on the first assignment.
         * @zh [首次设置有效]两个连接的刚体是否可以相互碰撞，默认为 false。
         */
        collideConnected: boolean;
        /**
         * @deprecated
         * [首次设置有效]一个向量值，用于定义弹性运动方向，即轮子在哪个方向可以如弹簧一样压缩和伸展，比如1,0是沿X轴向右，0,1是沿Y轴向下*/
        _axis: any[];
        /**
         * @en An angle value that defines the direction of elastic motion, i.e., the direction in which the wheel can compress and extend like a spring. For example, 0 degrees is along the X-axis to the right, and 90 degrees is along the Y-axis downward. This setting is effective only on the first assignment.
         * @zh [首次设置有效]一个角度值，用于定义弹性运动方向，即轮子在哪个方向可以如弹簧一样压缩和伸展，例如 0 度表示沿 X 轴正方向，90 度表示沿 Y 轴负方向。
         */
        angle: number;
        /**
         * @en The vibration frequency of the spring system, which can be considered as the spring's elasticity coefficient.The frequency should typically be less than half the time step frequency.
         * @zh 弹簧系统的振动频率，可以视为弹簧的弹性系数。通常频率应小于时间步长频率的一半。
         */
        get frequency(): number;
        set frequency(value: number);
        /**
         * @en The damping ratio that the body experiences when returning to the anchor point, with a recommended value range of 0 to 1.
         * @zh 刚体在回归到锚点过程中受到的阻尼比，建议取值范围为 0 到 1。
         */
        get damping(): number;
        set damping(value: number);
        /**
         * @en Whether the motor is enabled to drive the rotation of the connected body.
         * @zh 是否启用马达以驱动连接刚体的旋转。
         */
        get enableMotor(): boolean;
        set enableMotor(value: boolean);
        /**
         * @en The maximum rotational speed that can be achieved when the motor is enabled.
         * @zh 启用马达后可以达到的最大旋转速度。
         */
        get motorSpeed(): number;
        set motorSpeed(value: number);
        /**
         * @en The maximum torque that can be applied when the motor is enabled. Insufficient torque may result in no rotation.
         * @zh 启用马达后可以施加的最大扭距。如果最大扭矩太小，可能导致不旋转。
         */
        get maxMotorTorque(): number;
        set maxMotorTorque(value: number);
        /**
         * @en Whether the movement range of the connected body is limited.
         * @zh 是否对连接刚体的移动范围加以约束。
         */
        get enableLimit(): boolean;
        set enableLimit(value: boolean);
        /**
         * @en The lower limit of the movement range when the limit is enabled, as an offset from the anchor.
         * @zh 启用约束后，刚体移动范围的下限，是距离锚点的偏移量。
         */
        get lowerTranslation(): number;
        set lowerTranslation(value: number);
        /**
         * @en The upper limit of the movement range when the limit is enabled, as an offset from the anchor.
         * @zh 启用约束后，刚体移动范围的上限，是距离锚点的偏移量。
         */
        get upperTranslation(): number;
        set upperTranslation(value: number);
        /**
         * @deprecated
         * 启用约束后，刚体移动范围的上限，是距离anchor的偏移量*/
        get axis(): any;
        set axis(value: any);
    }
    /**
     * @en 2D Physics Engine
     * @zh 2D物理引擎
     */
    class Physics2D extends EventDispatcher {
        /**
         * @en Gets the global singleton instance of the Physics2D.
         * @zh 获取全局的 Physics2D 单例。
         */
        static get I(): Physics2D;
        _factory: IPhysiscs2DFactory;
        /**
         * @en whether to enable 2D phyiscs debug draw.
         * @zh 是否启用2D物理绘制
         */
        set enableDebugDraw(enable: boolean);
        /**
         * @en Whether to draw the shape.
         * @zh 是否绘制物理对象的形状。
         */
        set drawShape(enable: boolean);
        /**
         * @en Whether to draw the joints of physics objects.
         * @zh 是否绘制物理对象的关节。
         */
        set drawJoint(enable: boolean);
        /**
         * @en Whether to draw the AABB of physics objects.
         * @zh 是否绘制物理对象的包围盒。
         */
        set drawAABB(enable: boolean);
        /**
        * @en Whether to draw the collision pairs of the physics object.
        * @zh 是否绘制物理对象碰撞对。
        */
        set drawPair(enable: boolean);
        /**
         * @en Whether to draw the center of mass of physics objects.
         * @zh  是否绘制物理对象的质心。
         */
        set drawCenterOfMass(enable: boolean);
        /**
         * @en Whether the engine is allowed to sleep. Allowing the engine to sleep can improve stability and performance, but it usually comes at the cost of accuracy.
         * @zh 引擎是否允许休眠。允许引擎休眠可以提高稳定性和性能，但通常会牺牲准确性。
         */
        get allowSleeping(): boolean;
        set allowSleeping(value: boolean);
        /**
         * @en The gravity of the physics world. The default value is {x: 0, y: 9.8}.
         * Modifying the y direction to make the gravity upward can be done by setting `gravity.y` to -9.8 directly.
         * @zh 物理世界的重力环境。默认值为 {x: 0, y: 9.8}。
         * 如果要修改y方向使重力方向向上，可以直接设置 `gravity.y` 为 -9.8。
         */
        get gravity(): any;
        set gravity(value: Vector2);
        /**
         * @en The root container of the physics world. It serves as the coordinate system for the physics world and is used for coordinate transformations. The default value is the stage.
         * Setting a specific container allows for the collective movement of physical objects while keeping the physics world unchanged.
         * Note that translation will only occur once when setting `worldRoot`. For other situations, use it in conjunction with the `updatePhysicsByWorldRoot` function.
         * @zh 物理世界的根容器，它作为物理世界的坐标系，用于坐标变换，默认值是舞台（stage）。
         * 设置特定的容器后，可以整体移动物理对象，同时保持物理世界的坐标不变。
         * 注意，只有在设置 `worldRoot` 时才会平移一次，在其他情况下，请配合使用 `updatePhysicsByWorldRoot` 函数。
         */
        get worldRoot(): Sprite;
        set worldRoot(value: Sprite);
        /**
         * @en The total number of rigid bodies.
         * @zh 刚体的总数量。
         */
        get bodyCount(): number;
        /**
         * @en The total number of contacts.
         * @zh 碰撞的总数量。
         */
        get contactCount(): number;
        /**
         * @en The total number of joints.
         * @zh 关节的总数量。
         */
        get jointCount(): number;
        /**
         * @en Enables the physics world. This method initializes the physics engine and starts the simulation.
         * @zh 开启物理世界。此方法初始化物理引擎并启动模拟。
         */
        enable(): Promise<void>;
        /**
         * @en Starts the physics world. This method is called after the physics engine is initialized.
         * @zh 开启物理世界。此方法在物理引擎初始化后被调用。
         */
        start(): void;
        /**
         * @en Destroys the current physics world.
         * @zh 销毁当前物理世界。
         */
        destroyWorld(): void;
        /**
         * @en Stops the physics world.
         * @zh 停止物理世界。
         */
        stop(): void;
        /**
         * @deprecated
         * 获得刚体总数量
         * use bodyCount instead
         */
        getBodyCount(): number;
        /**
         * @deprecated
         * 获得碰撞总数量
         * use contactCount instead
         */
        getContactCount(): number;
        /**
         *  @deprecated
         *  获得关节总数量
         *  use jointCount instead
         */
        getJointCount(): number;
        /**
         * @en Manually triggers an update of the physics world after setting the `worldRoot`.
         * @zh 在设定 `worldRoot` 后，手动触发物理世界的更新。
         */
        updatePhysicsByWorldRoot(): void;
    }
    /**
     * @en Physical auxiliary line
     * @zh 物理辅助线
     */
    class Physics2DDebugDraw extends Sprite {
        /**@protected */
        protected _lineWidth: number;
        /**
         * @en The color string used for drawing text.
         * @zh 用于绘制文本的颜色字符串。
         */
        DrawString_color: string;
        /**
         * @en The color string representing red.
         * @zh 表示红色的颜色字符串。
         */
        Red: string;
        /**
         * @en The color string representing green.
         * @zh 表示绿色的颜色字符串。
         */
        Green: string;
        /**
         * @en The Graphics object used for drawing shapes.
         * @zh 用于绘制形状的 Graphics 对象。
         */
        get mG(): Graphics;
        /**
         * @en The Graphics object used for drawing text.
         * @zh 用于绘制文本的 Graphics 对象。
         */
        get textG(): Graphics;
        /**
         * @en The current line width used for drawing.
         * @zh 用于绘制的当前线宽。
         */
        get lineWidth(): number;
        /**
         * @en The camera object associated with the scene or view.
         * @zh 与场景或视图关联的摄像机对象。
         */
        get camera(): any;
        constructor(factory: IPhysiscs2DFactory);
        /**
         * @override
         * @en Renders the object using the given context and position.
         * @zh 使用给定的上下文和位置渲染对象。
         */
        render(ctx: Context, x: number, y: number): void;
        /**
         * @en Saves the current state of the environment and remaps the position and rotation on the canvas.
         * @zh 保存当前环境的状态，重新映射画布上的位置和旋转。
         */
        PushTransform(tx: number, ty: number, angle: number): void;
        /**
         * @en Restores the previously saved path state and properties.
         * @zh 返回之前保存过的路径状态和属性。
         */
        PopTransform(): void;
    }
    /**
     * @en Physics2DOption is used to configure default parameters for 2D physics
     * @zh Physics2DOption 用于配置2D物理的默认参数
     */
    class Physics2DOption {
        /**
         * @en Sets whether sleeping is allowed. Allowing sleep can improve stability and performance, but it usually comes at the cost of accuracy.The default is false.
         * @zh 设置是否允许休眠。允许休眠可以提高稳定性和性能，但通常会牺牲准确性。默认为否。
         */
        static allowSleeping: boolean;
        /**
         * @en Gravity acceleration, with a default value of 9.8, corresponding to 9.8 meters per second squared (m/s²) in the real world.
         * @zh 重力加速度，默认的重力加速度值为 9.8，对应于现实世界中的 9.8米/秒²（m/s²） 。
         */
        static gravity: {
            x: number;
            y: number;
        };
        /**
         * @en Indicates whether the update is performed externally.The default is false.
         * @zh 表示更新是否由外部执行。默认为否。
         */
        static customUpdate: boolean;
        /**
         * @en The number of velocity iterations. Increasing this number will improve accuracy but reduce performance.The default is 8.
         * @zh 旋转迭代次数。增大此数字会提高精度，但会降低性能。默认为8。
         */
        static velocityIterations: number;
        /**
         * @en The number of position iterations. Increasing this number will improve accuracy but reduce performance.The default is 3.
         * @zh 位置迭代次数。增大此数字会提高精度，但会降低性能。默认为3。
         */
        static positionIterations: number;
        /**
         * @en The conversion ratio between rendering pixels and physical units. By default, 1 length unit in the physics engine corresponds to 50 pixels. Modifying this value changes the number of pixels that correspond to 1 length unit in the physics engine.
         * @zh 渲染像素和物理单位的转换比率，物理引擎中的1长度单位默认转换为50个像素，修改此处可改变物理引擎1长度单位对应的渲染像素值。
         */
        static pixelRatio: number;
        /**
         * @en Whether to enable physics drawing.The default is true.
         * @zh 是否开启物理绘制。默认为是。
         */
        static debugDraw: boolean;
        /**
         * @en Whether to draw shapes.The default is true.
         * @zh 是否绘制形状。默认为是。
         */
        static drawShape: boolean;
        /**
         * @en Whether to draw joints.The default is true.
         * @zh 是否绘制关节。默认为是。
         */
        static drawJoint: boolean;
        /**
         * @en Whether to draw the Bounding Box.The default is false.
         * @zh 是否绘制包围盒。默认为否。
         */
        static drawAABB: boolean;
        /**
         * @en Whether to draw the center of mass.The default is false.
         * @zh 是否绘制质心。默认为否。
         */
        static drawCenterOfMass: boolean;
    }
    /**
     * @en 2D rigidbody, display objects are bound to the physics world through RigidBody to keep the positions of physics and display objects synchronized.
     * Changes in the position of the physics world will be automatically synchronized to the display object, and the displacement and rotation of the display object itself (displacement of the parent object is invalid) will also be automatically synchronized to the physics world.
     * If you want to move the physics world as a whole, you can set Physics2D.I.worldRoot = scene, and then move the scene.
     * You can enable the display of physics auxiliary lines by enabling "Project Settings" - "2D Physics" - "Enable 2D Physics Drawing" in the IDE, or through the code Physics2D.I.enableDebugDraw = true.
     * @zh 2D刚体，显示对象通过RigidBody和物理世界进行绑定，保持物理和显示对象之间的位置同步。
     * 物理世界的位置变化会自动同步到显示对象，显示对象本身的位移，旋转（父对象位移无效）也会自动同步到物理世界。
     * 如果想整体位移物理世界，可以设置 Physics2D.I.worldRoot = 场景，然后移动场景即可。
     * 可以通过IDE-"项目设置"-"2D物理"-"是否开启2D物理绘制" 开启物理辅助线显示，或者通过代码 Physics2D.I.enableDebugDraw = true。
     */
    class RigidBody extends Component {
        /**
         * @en [Read-only] Specifies the collision group to which the body belongs, default is 0, the collision rules are as follows:
         * 1. If the group values of two objects are equal:
         *    - If the group value is greater than zero, they will always collide.
         *    - If the group value is less than zero, they will never collide.
         *    - If the group value is equal to 0, then rule 3 is used.
         * 2. If the group values are not equal, then rule 3 is used.
         * 3. Each rigidbody has a category, this property receives a bit field, the range is the power of 2 in the range of [1,2^31].
         * Each rigidbody also has a mask category, which specifies the sum of the category values it collides with (the value is the result of bitwise AND of all categories).
         * @zh [只读] 指定了该主体所属的碰撞组，默认为0，碰撞规则如下：
         * 1. 如果两个对象 group 相等：
         *    - group 值大于零，它们将始终发生碰撞。
         *    - group 值小于零，它们将永远不会发生碰撞。
         *    - group 值等于0，则使用规则3。
         * 2. 如果 group 值不相等，则使用规则3。
         * 3. 每个刚体都有一个 category 类别，此属性接收位字段，范围为 [1,2^31] 范围内的2的幂。
         * 每个刚体也都有一个 mask 类别，指定与其碰撞的类别值之和（值是所有 category 按位 AND 的值）。
         */
        group: number;
        /**
         * @en [Read-only] Collision category, specified using powers of 2, with 32 different collision categories available.
         * @zh [只读] 碰撞类别，使用2的幂次方值指定，有32种不同的碰撞类别可用。
         */
        category: number;
        /**
         * @en [Read-only] Specifies the category of collision bit mask, the result of category bitwise operation.
         * Each rigidbody also has a mask category, which specifies the sum of the category values it collides with (the value is the result of bitwise AND of all categories).
         * @zh [只读] 指定冲突位掩码碰撞的类别，category 位操作的结果。
         * 每个刚体也都有一个 mask 类别，指定与其碰撞的类别值之和（值是所有 category 按位 AND 的值）。
         */
        mask: number;
        /**
         * @en [Read-only] Custom label.
         * @zh [只读] 自定义标签。
         */
        label: string;
        /**
         * @en The center of mass of the rigid body. (Only valid when not using automatic mass calculation)
         * @zh 刚体质心位置（只在未开启自动质量计算时才有效）
         */
        private _centerofMass;
        /**
         * @en The rigid body inertia tensor. (Only valid when not using automatic mass calculation)
         * @zh 刚体惯性张量（只在未开启自动质量计算时才有效）
         */
        private _inertia;
        /**
         * @en Is the rigid body mass calculated based on the collider
         * @zh 是否根据碰撞体计算刚体质量
         */
        get useAutoMass(): boolean;
        set useAutoMass(value: boolean);
        /**
         * @en The rigid body mass. (Only valid when not using automatic mass calculation)
         * @zh 刚体质量（只在未开启自动质量计算时才有效）
         */
        get mass(): number;
        set mass(value: number);
        /**
         * @en The center of mass of the rigid body. (Only valid when not using automatic mass calculation)
         * @zh 刚体质心（只在未开启自动质量计算时才有效）
         */
        get centerOfMass(): IV2;
        set centerOfMass(value: IV2);
        /**
         * @en The Rigidbody's resistance to changes in angular velocity (rotation).(Only valid when not using automatic mass calculation)
         * @zh 刚体惯性张量（只在未开启自动质量计算时才有效）
         */
        get inertia(): number;
        set inertia(value: number);
        /**
         * @en The original body object.
         * @zh 原始body对象。
         */
        get body(): any;
        /**
         * @en The type of the rigid body. Supports three types: static, dynamic, and kinematic.
         * - static: Static type, stays still, not affected by gravity, has infinite mass, can be controlled by moving, rotating, and scaling the node.
         * - dynamic: Dynamic type, affected by gravity.
         * - kinematic: Kinematic type, not affected by gravity, can be moved by applying velocity or force.
         * @zh 刚体类型，支持三种类型：static、dynamic 和 kinematic。
         * - static：静态类型，静止不动，不受重力影响，质量无限大，可以通过节点移动、旋转、缩放进行控制。
         * - dynamic：动态类型，受重力影响。
         * - kinematic：运动类型，不受重力影响，可以通过施加速度或者力的方式使其运动。
         */
        get type(): string;
        set type(value: string);
        /**
         * @en The gravity scale factor. Set it to 0 for no gravity.
         * @zh 重力缩放系数，设置为 0 表示没有重力。
         */
        get gravityScale(): number;
        set gravityScale(value: number);
        /**
         * @en Allowing rotation means that when a force or impact is applied to the rigid body, it will naturally rotate according to physical rules. If you do not want the rigid body to rotate, set this to false.
         * @zh 允许旋转是指当力或者冲击作用于该刚体时，它会按照物理规则进行自然旋转，如果不希望刚体旋转，请设置为 false。
         */
        get allowRotation(): boolean;
        set allowRotation(value: boolean);
        /**
         * @en Whether to allow sleeping. Allowing sleeping can improve performance but may result in the inability to respond immediately.
         * @zh 是否允许休眠，允许休眠能提高性能，但会导致无法即时响应。
         */
        get allowSleep(): boolean;
        set allowSleep(value: boolean);
        /**
         * @en The angular damping coefficient. It can range from 0 to infinity, where 0 means no damping and infinity means full damping. Normally, the damping value should be between 0 and 0.1.
         * @zh 旋转速度阻尼系数，范围可以在 0 到无穷大之间，0 表示没有阻尼，无穷大表示满阻尼，通常阻尼的值应该在 0 到 0.1 之间。
         */
        get angularDamping(): number;
        set angularDamping(value: number);
        /**
         * @en The angular velocity. Setting it will cause rotation.
         * @zh 角速度，设置会导致旋转。
         */
        get angularVelocity(): number;
        set angularVelocity(value: number);
        /**
         * @en The linear damping coefficient. It can range from 0 to infinity, where 0 means no damping and infinity means full damping. Normally, the damping value should be between 0 and 0.1.
         * @zh 线性速度阻尼系数，范围可以在 0 到无穷大之间，0 表示没有阻尼，无穷大表示满阻尼，通常阻尼的值应该在 0 到 0.1 之间。
         */
        get linearDamping(): number;
        set linearDamping(value: number);
        /**
         * @en The linear velocity, such as {x: 5, y: 5}.
         * @zh 线性运动速度，例如 {x: 5, y: 5}。
         */
        get linearVelocity(): IV2;
        set linearVelocity(value: any);
        /**
         * @en Whether it is a high-speed moving object. Setting it to true can prevent high-speed penetration.
         * @zh 是否为高速移动的物体，设置为 true 可以防止高速穿透。
         */
        get bullet(): boolean;
        set bullet(value: boolean);
        /**
         * @en Get the original body object.
         * @zh 获得原始 body 对象。
         */
        getBody(): any;
        /**
         * @en Apply force to the rigid body.
         * @param position The point where the force is applied, such as {x: 100, y: 100}, in global coordinates.
         * @param force The force to be applied, such as {x: 0.1, y: 0.1}.
         * @zh 对刚体施加力。
         * @param position 施加力的点，如 {x: 100, y: 100}，全局坐标。
         * @param force 施加的力，如 {x: 0.1, y: 0.1}。
         */
        applyForce(position: IV2, force: IV2): void;
        /**
         * @en Apply force to the center of the rigid body to prevent object rotation.
         * @param force The force to be applied, such as {x: 0.1, y: 0.1}.
         * @zh 从中心点对刚体施加力，防止对象旋转。
         * @param force 施加的力，如 {x: 0.1, y: 0.1}。
         */
        applyForceToCenter(force: IV2): void;
        /**
         * @en Apply linear impulse. The added velocity impulse will be combined with the rigid body's original velocity to produce a new velocity.
         * @param position The point where the impulse is applied, such as {x: 100, y: 100}, in global coordinates.
         * @param impulse The velocity impulse to be applied, such as {x: 0.1, y: 0.1}.
         * @zh 施加速度冲量，添加的速度冲量会与刚体原有的速度叠加，产生新的速度。
         * @param position 施加力的点，如 {x: 100, y: 100}，全局坐标。
         * @param impulse 施加的速度冲量，如 {x: 0.1, y: 0.1}。
         */
        applyLinearImpulse(position: IV2, impulse: IV2): void;
        /**
         * @en Apply linear impulse to the center. The added velocity impulse will be combined with the rigid body's original velocity to produce a new velocity.
         * @param impulse The velocity impulse to be applied, such as {x: 0.1, y: 0.1}.
         * @zh 施加速度冲量，添加的速度冲量会与刚体原有的速度叠加，产生新的速度。
         * @param impulse 施加的速度冲量，如 {x: 0.1, y: 0.1}。
         */
        applyLinearImpulseToCenter(impulse: IV2): void;
        /**
         * @en Apply torque to the rigid body to make it rotate.
         * @param torque The torque to be applied.
         * @zh 对刚体施加扭矩，使其旋转。
         * @param torque 施加的扭矩。
         */
        applyTorque(torque: number): void;
        /**
         * @en Set the velocity, such as {x: 10, y: 10}.
         * @param velocity The velocity to be set.
         * @zh 设置速度，例如 {x: 10, y: 10}。
         * @param velocity 要设置的速度。
         */
        setVelocity(velocity: IV2): void;
        /**
         * @en Set the angle.
         * @param value The angle value in degrees.
         * @zh 设置角度。
         * @param value 角度值，单位为度。
         */
        setAngle(value: any): void;
        /**
         * @en Get the mass of the rigid body.
         * @zh 获得刚体质量。
         */
        getMass(): number;
        /**
         * @en Get the offset of the center of mass relative to the node's (0, 0) point.
         * @zh 获得质心相对于节点 (0, 0) 点的位置偏移。
         */
        getCenter(): IV2;
        /**
         * @en Get the inertia of the rigid body.
         * @zh 获得刚体的惯性张量。
         * @returns
         */
        getInertia(): number;
        /**
         * @en Get the world coordinates of the center of mass, relative to the Physics2D.I.worldRoot node.
         * @zh 获得质心的世界坐标，相对于 Physics2D.I.worldRoot 节点。
         */
        getWorldCenter(): IV2;
        /**
         * @en Get the world coordinates relative to the body.
         * @param x The x-coordinate in pixels.
         * @param y The y-coordinate in pixels.
         * @zh 获得相对于 body 的世界坐标。
         * @param x 像素坐标的 x 值。
         * @param y 像素坐标的 y 值。
         */
        getWorldPoint(x: number, y: number): Point;
        /**
         * @en Get the local coordinates relative to the body.
         * @param x The x-coordinate in pixels.
         * @param y The y-coordinate in pixels.
         * @zh 获得相对于 body 的本地坐标。
         * @param x 像素坐标的 x 值。
         * @param y 像素坐标的 y 值。
         */
        getLocalPoint(x: number, y: number): Point;
    }
    class RigidBody2DInfo {
        position: Vector2;
        angle: number;
        allowSleep: boolean;
        angularDamping: number;
        angularVelocity: number;
        bullet: boolean;
        fixedRotation: boolean;
        gravityScale: number;
        linearDamping: number;
        linearVelocity: Vector2;
        type: string;
        group: number;
    }
    interface IPhyDebugDrawer {
        /**
         * @en Set the color.
         * @param c The color value.
         * @zh 设置颜色。
         * @param c 颜色值。
         */
        color(c: number): void;
        /**
         * @en Draw a line.
         * @param sx Start point x coordinate.
         * @param sy Start point y coordinate.
         * @param sz Start point z coordinate.
         * @param ex End point x coordinate.
         * @param ey End point y coordinate.
         * @param ez End point z coordinate.
         * @zh 绘制线段。
         * @param sx 起点 x 坐标。
         * @param sy 起点 y 坐标。
         * @param sz 起点 z 坐标。
         * @param ex 终点 x 坐标。
         * @param ey 终点 y 坐标。
         * @param ez 终点 z 坐标。
         */
        line(sx: number, sy: number, sz: number, ex: number, ey: number, ez: number): void;
        /**
         * @en Clear drawn lines.
         * @zh 清除画线结果。
         */
        clear(): void;
    }
    /**
     * @en The `btPhysicsCreateUtil` class is responsible for creating and managing various physics objects and capabilities within the Bullet physics engine.
     * @zh `btPhysicsCreateUtil` 类负责在 Bullet 物理引擎中创建和管理各种物理对象和功能。
     */
    class btPhysicsCreateUtil implements IPhysicsCreateUtil {
        /**
         * @en A map that stores the capabilities of the physics engine.
         * @zh 存储物理引擎功能的映射。
         */
        protected _physicsEngineCapableMap: Map<any, any>;
        /**
         * @en Initializes the physics engine's capabilities, setting up which features are supported.
         * @zh 初始化物理引擎的功能，设置支持的功能项。
         */
        initPhysicsCapable(): void;
        /**
         * @en Get the status of a specific physics capability.
         * @param value The physics capability to query.
         * @returns Whether the capability is available.
         * @zh 获取特定物理能力的状态。
         * @param value 要查询的物理能力。
         * @returns 该能力是否可用。
         */
        getPhysicsCapable(value: EPhysicsCapable): boolean;
        /**
         * @en Initializes the Bullet physics engine. This includes setting up the physics memory, creating an instance of the Bullet physics engine, and initializing various physics components.
         * @returns A promise that resolves when initialization is complete.
         * @zh 初始化 Bullet 物理引擎。这包括设置物理内存、创建 Bullet 物理引擎实例以及初始化各种物理组件。
         * @returns 当初始化完成时解析的 Promise。
         */
        initialize(): Promise<void>;
        /**
         * @en Creates a new instance of the physics manager with the specified settings.
         * @param physicsSettings The physics settings.
         * @returns A btPhysicsManager instance.
         * @zh 使用指定的设置创建一个新的物理管理器实例。
         * @param physicsSettings 物理设置。
         * @returns btPhysicsManager 实例。
         */
        createPhysicsManger(physicsSettings: PhysicsSettings): btPhysicsManager;
        /**
         * @en Create a dynamic collider.
         * @param manager The physics manager.
         * @returns A btRigidBodyCollider instance.
         * @zh 创建动态碰撞器。
         * @param manager 物理管理器。
         * @returns btRigidBodyCollider 实例。
         */
        createDynamicCollider(manager: btPhysicsManager): btRigidBodyCollider;
        /**
         * @en Create a static collider.
         * @param manager The physics manager.
         * @returns A btStaticCollider instance.
         * @zh 创建静态碰撞器。
         * @param manager 物理管理器。
         * @returns btStaticCollider 实例。
         */
        createStaticCollider(manager: btPhysicsManager): btStaticCollider;
        /**
         * @en Create a character controller.
         * @param manager The physics manager.
         * @returns A btCharacterCollider instance.
         * @zh 创建角色控制器。
         * @param manager 物理管理器。
         * @returns btCharacterCollider 实例。
         */
        createCharacterController(manager: btPhysicsManager): btCharacterCollider;
        /**
         * @en Create a fixed joint.
         * @param manager The physics manager.
         * @returns A btFixedJoint instance.
         * @zh 创建固定关节。
         * @param manager 物理管理器。
         * @returns btFixedJoint 实例。
         */
        createFixedJoint(manager: btPhysicsManager): btFixedJoint;
        /**
         * @en Create a hinge joint.
         * @param manager The physics manager.
         * @returns A btHingeJoint instance.
         * @zh 创建铰链关节。
         * @param manager 物理管理器。
         * @returns btHingeJoint 实例。
         */
        createHingeJoint(manager: btPhysicsManager): IHingeJoint;
        /**
         * @en Create a spring joint.
         * @param manager The physics manager.
         * @returns A btSpringJoint instance.
         * @zh 创建弹簧关节。
         * @param manager 物理管理器。
         * @returns btSpringJoint 实例。
         */
        createSpringJoint(manager: btPhysicsManager): btSpringJoint;
        /**
         * @en Create a D6 (6 degrees of freedom) joint.
         * @param manager The physics manager.
         * @returns A btCustomJoint instance.
         * @zh 创建 D6（6 自由度） 关节。
         * @param manager 物理管理器。
         * @returns btCustomJoint 实例。
         */
        createD6Joint(manager: btPhysicsManager): ID6Joint;
        /**
         * @en Create a box collider shape.
         * @returns A btBoxColliderShape instance.
         * @zh 创建盒型碰撞器形状。
         * @returns btBoxColliderShape 实例。
         */
        createBoxColliderShape(): btBoxColliderShape;
        /**
         * @en Create a sphere collider shape.
         * @returns A btSphereColliderShape instance.
         * @zh 创建球形碰撞器形状。
         * @returns btSphereColliderShape 实例。
         */
        createSphereColliderShape(): btSphereColliderShape;
        /**
         * @en Create a capsule collider shape.
         * @returns A btCapsuleColliderShape instance.
         * @zh 创建胶囊碰撞器形状。
         * @returns btCapsuleColliderShape 实例。
         */
        createCapsuleColliderShape(): btCapsuleColliderShape;
        /**
         * @en Create a mesh collider shape.
         * @returns A btMeshColliderShape instance.
         * @zh 创建网格碰撞器形状。
         * @returns btMeshColliderShape 实例。
         */
        createMeshColliderShape(): btMeshColliderShape;
        /**
         * @en Create a plane collider shape.
         * @zh 创建平面碰撞器形状。
         */
        createPlaneColliderShape(): IPlaneColliderShape;
        /**
         * @en Create a cylinder collider shape.
         * @returns A btCylinderColliderShape instance.
         * @zh 创建圆柱碰撞器形状。
         * @returns btCylinderColliderShape 实例。
         */
        createCylinderColliderShape(): btCylinderColliderShape;
        /**
         * @en Create a cone collider shape.
         * @returns A btConeColliderShape instance.
         * @zh 创建圆锥碰撞器形状。
         * @returns btConeColliderShape 实例。
         */
        createConeColliderShape(): btConeColliderShape;
        /**
         * @en Create a compound collider shape.
         * @returns A btCompoundColliderShape instance.
         * @zh 创建组合碰撞器形状。
         * @returns btCompoundColliderShape 实例。
         */
        createCompoundShape(): ICompoundColliderShape;
        /**
         * @en Create a convex mesh from a given mesh.
         * @param mesh The source mesh.
         * @returns The created convex mesh, or null if creation fails.
         * @zh 从给定的网格创建凸包网格。
         * @param mesh 源网格。
         * @returns 创建的凸包网格，如果创建失败则返回 null。
         */
        createCorveMesh(mesh: Mesh): Mesh;
    }
    /**
     * @en The `btPhysicsManager` class is the core class for managing the Bullet physics engine.
     * @zh `btPhysicsManager` 类是用于管理 Bullet 物理引擎的核心类。
     */
    class btPhysicsManager implements IPhysicsManager {
        /**
         * @en Default collision group
         * @zh 默认碰撞组
         */
        static COLLISIONFILTERGROUP_DEFAULTFILTER: number;
        /**
         * @en Static collision group
         * @zh 静态碰撞组
         */
        static COLLISIONFILTERGROUP_STATICFILTER: number;
        /**
         * @en Kinematic rigid body collision group
         * @zh 运动学刚体碰撞组
         */
        static COLLISIONFILTERGROUP_KINEMATICFILTER: number;
        /**
         * @en Debris collision group
         * @zh 碎片碰撞组
         */
        static COLLISIONFILTERGROUP_DEBRISFILTER: number;
        /**
         * @en Sensor trigger group
         * @zh 传感器触发器组
         */
        static COLLISIONFILTERGROUP_SENSORTRIGGER: number;
        /**
         * @en Character filter group
         * @zh 角色过滤器组
         */
        static COLLISIONFILTERGROUP_CHARACTERFILTER: number;
        /**
         * @en Custom filter group 1
         * @zh 自定义过滤组 1
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER1: number;
        /**
         * @en Custom filter group 2
         * @zh 自定义过滤组 2
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER2: number;
        /**
         * @en Custom filter group 3
         * @zh 自定义过滤组 3
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER3: number;
        /**
         * @en Custom filter group 4
         * @zh 自定义过滤组 4
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER4: number;
        /**
         * @en Custom filter group 5
         * @zh 自定义过滤组 5
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER5: number;
        /**
         * @en Custom filter group 6
         * @zh 自定义过滤组 6
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER6: number;
        /**
         * @en Custom filter group 7
         * @zh 自定义过滤组 7
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER7: number;
        /**
         * @en Custom filter group 8
         * @zh 自定义过滤组 8
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER8: number;
        /**
         * @en Custom filter group 9
         * @zh 自定义过滤组 9
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER9: number;
        /**
         * @en Custom filter group 10
         * @zh 自定义过滤组 10
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER10: number;
        /**
         * @en All filter groups
         * @zh 所有过滤组
         */
        static COLLISIONFILTERGROUP_ALLFILTER: number;
        /**
         * @en Initializes the btPhysicsManager.
         * @zh 初始化 btPhysicsManager。
         */
        static init(): void;
        /**
         * @en The maximum number of sub-steps used by the physics engine in one frame to compensate for deceleration. This is the maximum number of simulations allowed per frame. If the engine runs slowly, this number may need to be increased,otherwise the simulator will lose "time". It's crucial that the engine interval time is less than maxSubSteps * fixedTimeStep.
         * @zh 物理引擎在一帧中用于补偿减速的最大次数：模拟器每帧允许的最大模拟次数，如果引擎运行缓慢,可能需要增加该次数，否则模拟器会丢失“时间",引擎间隔时间小于maxSubSteps*fixedTimeStep非常重要。
         */
        maxSubSteps: number;
        /***/
        /**
         * @en The interval time of the physics simulator frame. Reducing fixedTimeStep can increase simulation precision. The default value is 1.0 / 60.0.
         * @zh 物理模拟器帧的间隔时间:通过减少fixedTimeStep可增加模拟精度，默认是1.0 / 60.0。
         */
        fixedTimeStep: number;
        /**
         * @en Whether to enable continuous collision detection.
         * @zh 是否开启连续碰撞检测。
         */
        enableCCD: boolean;
        /**
         * @en The threshold for continuous collision detection.
         * @zh 连续碰撞检测的阈值。
         */
        ccdThreshold: number;
        /**
         * @en The sphere radius for continuous collision detection.
         * @zh 连续碰撞检测的球体半径。
         */
        ccdSphereRadius: number;
        /**
         * @en The delta time used in physics calculations, default is 1/60 second.
         * @zh 物理计算中使用的时间间隔，默认为 1/60 秒。
         */
        dt: number;
        protected _updateCount: number;
        _characters: btCharacterCollider[];
        protected _physicsEngineCapableMap: Map<any, any>;
        /**
         * @ignore
         * @en Creates an instance of a btPhysicsManager.
         * @param physicsSettings The settings for the physics simulation.
         * @zh 创建一个 btPhysicsManager 的实例。
         * @param physicsSettings 物理模拟的设置。
         */
        constructor(physicsSettings: PhysicsSettings);
        /**
         * @en Sets the active state of a btCollider.
         * @param collider The btCollider to set the active state for.
         * @param value The active state to set (true for active, false for inactive).
         * @zh 设置 btCollider 的激活状态。
         * @param collider 要设置激活状态的 btCollider。
         * @param value 要设置的激活状态（true 表示激活，false 表示不激活）。
         */
        setActiveCollider(collider: btCollider, value: boolean): void;
        /**
         * @en Performs a sphere query to find colliders within a specified radius from a given position.
         * @param pos The center position of the sphere query.
         * @param radius The radius of the sphere query.
         * @param result An array to store the found colliders.
         * @param collisionmask The collision mask to filter the query results.
         * @zh 执行球体查询，查找给定位置指定半径内的碰撞体。
         * @param pos 球体查询的中心位置。
         * @param radius 球体查询的半径。
         * @param result 用于存储找到的碰撞体的数组。
         * @param collisionmask 用于过滤查询结果的碰撞掩码。
         */
        sphereQuery?(pos: Vector3, radius: number, result: ICollider[], collisionmask: number): void;
        /**
         * @perfTag PerformanceDefine.T_PhysicsColliderEnter
         * @en Dispatch Collider Enter Event
         * @param colliderA 碰撞组件A
         * @param ownerA 组件A的所属节点
         * @param colliderB 碰撞组件B
         * @param ownerB 组件B的所属节点
         * @param curFrameCol 当前帧碰撞信息
         * @zh 派发碰撞器进入事件
         * @param colliderA Collision Component A
         * @param ownerA The Node to Which Component A Belongs
         * @param colliderB Collision Component B
         * @param ownerB The Node to Which Component B Belongs
         * @param curFrameCol Current Frame Collision Information
         */
        private _collision_EnterEvent;
        /**
         * @perfTag PerformanceDefine.T_PhysicsColliderStay
         * @en Dispatch Collider Stay Event
         * @param colliderA 碰撞组件A
         * @param ownerA 组件A的所属节点
         * @param colliderB 碰撞组件B
         * @param ownerB 组件B的所属节点
         * @param curFrameCol 当前帧碰撞信息
         * @zh 派发碰撞器持续事件
         * @param colliderA Collision Component A
         * @param ownerA The Node to Which Component A Belongs
         * @param colliderB Collision Component B
         * @param ownerB The Node to Which Component B Belongs
         * @param curFrameCol Current Frame Collision Information
         */
        private _collision_StayEvent;
        /**
         * @perfTag PerformanceDefine.T_PhysicsColliderExit
         * @en Dispatch Collider Exit Event
         * @param preColliderA 碰撞组件A
         * @param ownerA 组件A的所属节点
         * @param preColliderB 碰撞组件B
         * @param ownerB 组件B的所属节点
         * @param preFrameCol 当前帧碰撞信息
         * @zh 派发碰撞器离开事件
         * @param preColliderA Collision Component A
         * @param ownerA The Node to Which Component A Belongs
         * @param preColliderB Collision Component B
         * @param ownerB The Node to Which Component B Belongs
         * @param preFrameCol Current Frame Collision Information
         */
        private _collision_ExitEvent;
        /**
         * @perfTag PerformanceDefine.T_PhysicsTriggerEnter
         * @en Dispatch Trigger Enter Event
         * @param colliderA 碰撞组件A
         * @param ownerA 组件A的所属节点
         * @param colliderB 碰撞组件B
         * @param ownerB 组件B的所属节点
         * @zh 派发触发器进入事件
         * @param colliderA Collision Component A
         * @param ownerA The Node to Which Component A Belongs
         * @param colliderB Collision Component B
         * @param ownerB The Node to Which Component B Belongs
         */
        private _trigger_EnterEvent;
        /**
         * @perfTag PerformanceDefine.T_PhysicsTriggerStay
         * @en Dispatch Trigger Enter Event
         * @param colliderA 碰撞组件A
         * @param ownerA 组件A的所属节点
         * @param colliderB 碰撞组件B
         * @param ownerB 组件B的所属节点
         * @zh 派发触发器持续事件
         * @param colliderA Collision Component A
         * @param ownerA The Node to Which Component A Belongs
         * @param colliderB Collision Component B
         * @param ownerB The Node to Which Component B Belongs
         */
        private _trigger_StayEvent;
        /**
         * @perfTag PerformanceDefine.T_PhysicsTriggerExit
         * @en Dispatch Trigger Exit Event
         * @param preColliderA 碰撞组件A
         * @param ownerA 组件A的所属节点
         * @param preColliderB 碰撞组件B
         * @param ownerB 组件B的所属节点
         * @zh 派发触发器离开事件
         * @param preColliderA Collision Component A
         * @param ownerA The Node to Which Component A Belongs
         * @param preColliderB Collision Component B
         * @param ownerB The Node to Which Component B Belongs
         */
        private _trigger_ExitEvent;
        /**
         * @perfTag PerformanceDefine.T_PhysicsEvent
         * @en This method only sends events to objects, it doesn't call collision functions for each component individually.Components need to listen to events if they want to respond to collisions.
         * @zh 这个只是给对象发送事件，不会挨个组件调用碰撞函数。组件要响应碰撞的话，要通过监听事件。
         */
        dispatchCollideEvent(): void;
        /**
         * @en Debugger function to enable or disable the debug drawer.
         * @param value A boolean value to enable (true) or disable (false) the debug drawer.
         * @zh 调试器函数，用于启用或禁用调试绘制器。
         * @param value 布尔值，用于启用（true）或禁用（false）调试绘制器。
         */
        enableDebugDrawer(value: boolean): void;
        /**
         * @en Gets the capability status of a specific physics feature.
         * @param value The physics capability to check.
         * @returns Whether the specified physics capability is supported.
         * @zh 获取特定物理特性的能力状态。
         * @param value 要检查的物理能力。
         * @returns 指定的物理能力是否被支持。
         */
        getPhysicsCapable(value: EPhysicsCapable): boolean;
        /**
         * @en Initializes the physics capabilities map.
         * @zh 初始化物理能力映射。
         */
        initPhysicsCapable(): void;
        /**
         * @en Sets the gravity.
         * @param gravity The gravity to be set.
         * @zh 设置重力。
         * @param gravity 要设置的重力。
         */
        setGravity(gravity: Vector3): void;
        /**
         * @en Adds a collider.
         * @param collider The collider to be added.
         * @zh 添加碰撞体。
         * @param collider 要添加的碰撞体。
         */
        addCollider(collider: ICollider): void;
        /**
         * @en Removes a collider.
         * @param collider The collider to be removed.
         * @zh 移除碰撞体。
         * @param collider 要移除的碰撞体。
         */
        removeCollider(collider: ICollider): void;
        /**
         * @en Adds a joint.
         * @param joint The joint to be added.
         * @zh 添加关节。
         * @param joint 要添加的关节。
         */
        addJoint(joint: btJoint): void;
        /**
         * @en Removes a joint.
         * @param joint The joint to be removed.
         * @zh 移除关节。
         * @param joint 要移除的关节。
         */
        removeJoint(joint: btJoint): void;
        /**
         * @perfTag PerformanceDefine.T_Physics_Simulation
         * @en Updates the physics simulation.
         * @param elapsedTime The time elapsed since the last update.
         * @zh 更新物理模拟。
         * @param elapsedTime 自上次更新以来经过的时间。
         */
        update(elapsedTime: number): void;
        /**
         * @en Performs a ray cast in the physics world.Returns the first hit object.
         * @param ray The ray to cast.
         * @param outHitResult The hit result object to store the result.
         * @param distance The maximum distance of the ray cast.
         * @param collisonGroup The collision group of the ray.
         * @param collisionMask The collision mask of the ray.
         * @returns Whether the ray hit anything.
         * @zh 执行一次射线检测，返回第一个与射线相交的碰撞体信息。
         * @param ray 要投射的射线。
         * @param outHitResult 用于存储结果的命中结果对象。
         * @param distance 射线投射的最大距离。
         * @param collisonGroup 射线的碰撞组。
         * @param collisionMask 射线的碰撞掩码。
         * @returns 射线是否击中了任何物体。
         */
        rayCast(ray: Ray, outHitResult: HitResult, distance?: number, collisonGroup?: number, collisionMask?: number): boolean;
        /**
         * @en Performs a ray cast in the physics world.Returns all hit objects.
         * @param ray The ray to cast.
         * @param out An array to store all hit results.
         * @param distance The maximum distance of the ray cast.
         * @param collisonGroup The collision group of the ray.
         * @param collisionMask The collision mask of the ray.
         * @returns Whether the ray hit anything.
         * @zh 执行一次射线检测，返回所有与射线相交的碰撞体信息。
         * @param ray 要投射的射线。
         * @param out 用于存储所有命中结果的数组。
         * @param distance 射线投射的最大距离。
         * @param collisonGroup 射线的碰撞组。
         * @param collisionMask 射线的碰撞掩码。
         * @returns 射线是否击中了任何物体。
         */
        rayCastAll(ray: Ray, out: HitResult[], distance?: number, collisonGroup?: number, collisionMask?: number): boolean;
        /**
         * @en Performs a shape cast. Returns the first hit object.
         * @param shape The shape to cast.
         * @param fromPosition The starting position of the shape.
         * @param toPosition The ending position of the shape.
         * @param out The hit result object to store the result.
         * @param fromRotation The starting rotation of the shape.
         * @param toRotation The ending rotation of the shape.
         * @param collisonGroup The collision group of the shape.
         * @param collisionMask The collision mask of the shape.
         * @param allowedCcdPenetration The allowed continuous collision detection penetration.
         * @returns Whether hit anything.
         * @zh 执行形状射线检测，返回第一个与射线相交的碰撞体信息。
         * @param shape 要投射的形状。
         * @param fromPosition 形状的起始位置。
         * @param toPosition 形状的结束位置。
         * @param out 用于存储结果的命中结果对象。
         * @param fromRotation 形状的起始旋转。
         * @param toRotation 形状的结束旋转。
         * @param collisonGroup 形状的碰撞组。
         * @param collisionMask 形状的碰撞掩码。
         * @param allowedCcdPenetration 允许的连续碰撞检测穿透。
         * @returns 是否击中了任何物体。
         */
        shapeCast(shape: btColliderShape, fromPosition: Vector3, toPosition: Vector3, out: HitResult, fromRotation?: Quaternion, toRotation?: Quaternion, collisonGroup?: number, collisionMask?: number, allowedCcdPenetration?: number): boolean;
        /**
         * @en Performs a shape cast. Returns all hit objects.
         * @param shape The shape to cast.
         * @param fromPosition The starting position of the shape.
         * @param toPosition The ending position of the shape.
         * @param out An array to store all hit results.
         * @param fromRotation The starting rotation of the shape.
         * @param toRotation The ending rotation of the shape.
         * @param collisonGroup The collision group of the shape.
         * @param collisionMask The collision mask of the shape.
         * @param allowedCcdPenetration The allowed continuous collision detection penetration.
         * @returns Whether hit anything.
         * @zh 执行形状投射，返回所有与射线相交的碰撞体信息。
         * @param shape 要投射的形状。
         * @param fromPosition 形状的起始位置。
         * @param toPosition 形状的结束位置。
         * @param out 用于存储所有命中结果的数组。
         * @param fromRotation 形状的起始旋转。
         * @param toRotation 形状的结束旋转。
         * @param collisonGroup 形状的碰撞组。
         * @param collisionMask 形状的碰撞掩码。
         * @param allowedCcdPenetration 允许的连续碰撞检测穿透。
         * @returns 是否击中了任何物体。
         */
        shapeCastAll(shape: btColliderShape, fromPosition: Vector3, toPosition: Vector3, out: HitResult[], fromRotation?: Quaternion, toRotation?: Quaternion, collisonGroup?: number, collisionMask?: number, allowedCcdPenetration?: number): boolean;
        /**
         * @en Destroys the physics manager and releases all associated resources.
         * @zh 销毁物理管理器并释放所有相关资源。
         */
        destroy(): void;
    }
    /**
     * @en The btCharacterCollider class is used to handle 3D physics character colliders.
     * @zh btCharacterCollider 类用于处理3D物理角色碰撞器。
     */
    class btCharacterCollider extends btCollider implements ICharacterController {
        static __init__(): void;
        /**
         * @en Check if the character is capable of a specific action.
         * @param value The capability to check.
         * @returns True if the character is capable, false otherwise.
         * @zh 检查角色是否能够执行特定动作。
         * @param value 要检查的能力。
         * @returns 如果角色具备该能力则返回 true，否则返回 false。
         */
        getCapable(value: number): boolean;
        /**
         * @en Creates an instance of the btCharacterCollider class.
         * @param physicsManager The physics manager instance.
         * @zh 创建一个 btCharacterCollider 类的实例。
         * @param physicsManager 物理管理器实例。
         */
        constructor(physicsManager: btPhysicsManager);
        /**
         * @en Set the local offset of the collider shape.
         * @param value The local offset vector.
         * @zh 设置碰撞器形状的偏移。
         * @param value 偏移向量。
         */
        setShapelocalOffset(value: Vector3): void;
        /**
         * @en Set the skin width of the character collider.
         * @param width The skin width value.
         * @zh 设置角色碰撞器的皮肤宽度。
         * @param width 皮肤宽度值。
         */
        setSkinWidth?(width: number): void;
        /**
         * @en Set the position.
         * @param value The position vector.
         * @zh 设置位置。
         * @param value 位置向量。
         */
        setPosition(value: Vector3): void;
        /**
         * @en Get the current position.
         * @returns The position vector.
         * @zh 获取当前位置。
         * @returns 位置向量。
         */
        getPosition(): Vector3;
        /**
         * @en Set the radius of the character collider.
         * @param value The radius value.
         * @zh 设置角色碰撞器的半径。
         * @param value 半径值。
         */
        setRadius?(value: number): void;
        /**
         * @en Set the height of the character collider.
         * @param value The height value.
         * @zh 设置角色碰撞器的高度。
         * @param value 高度值。
         */
        setHeight?(value: number): void;
        /**
         * @en Set the minimum distance for the character collider.
         * @param value The minimum distance value.
         * @zh 设置角色碰撞器的最小距离。
         * @param value 最小距离值。
         */
        setminDistance(value: number): void;
        /**
         * @en Get the character capability status.
         * @param value The character capability to check.
         * @zh 获取角色能力状态。
         * @param value 要检查的角色能力。
         */
        static getCharacterCapable(value: ECharacterCapable): boolean;
        /**
         * @en Initialize the capabilities of the character collider.
         * @zh 初始化角色碰撞器的能力。
         */
        static initCapable(): void;
        protected getColliderType(): btColliderType;
        protected _initCollider(): void;
        protected _onShapeChange(): void;
        /**
         * @en Set the world position of the character.
         * @param value The new world position vector.
         * @zh 设置角色的世界位置。
         * @param value 新的世界位置向量。
         */
        setWorldPosition(value: Vector3): void;
        /**
         * @en Move the character by a displacement vector.
         * @param disp The displacement vector.
         * @zh 通过位移向量移动角色。
         * @param disp 位移向量。
         */
        move(disp: Vector3): void;
        /**
         * @en Make the character jump with a given velocity.
         * @param velocity The jump velocity vector.
         * @zh 使角色以给定的速度跳跃。
         * @param velocity 跳跃速度向量。
         */
        jump(velocity: Vector3): void;
        isGrounded(): boolean;
        /**
         * @en Set the jump speed of the character.
         * @param value The jump speed value.
         * @zh 设置角色的跳跃速度。
         * @param value 跳跃速度值。
         */
        setJumpSpeed(value: number): void;
        /**
         * @en Set the step offset (height) for the character.
         * @param offset The step offset value.
         * @zh 设置角色的步高。
         * @param offset 步高值。
         */
        setStepOffset(offset: number): void;
        /**
         * @en Set the up direction for the character.
         * @param up The up direction vector.
         * @zh 设置角色的向上方向。
         * @param up 向上方向向量。
         */
        setUpDirection(up: Vector3): void;
        /**
         * @en Get the vertical velocity of the character.
         * The vertical velocity of the character is particularly useful for determining whether a character is falling or rising. Here are some key points about its value:
         *  - **0** means the character is on the ground.
         *  - **Positive values** indicate the character is rising (e.g., jumping).
         *  - **Negative values** indicate the character is falling.
         * @zh 获取角色的垂直速度。主要用于获取角色在垂直方向（通常是 Y 轴）的当前速度。这个值反映了角色受重力、跳跃或其他垂直运动影响时的状态。
         *  - **值为 0**，表示角色位于地面；
         *  - **为正值**，表示角色正在上升（如跳跃）；
         *  - **为负值**，表示角色在下落。
         */
        getVerticalVel(): number;
        /**
         * @en Set the slope limit for the character.
         * @param slopeLimit The slope limit in degrees.
         * @zh 设置角色的坡度限制。
         * @param slopeLimit 坡度限制（以度为单位）。
         */
        setSlopeLimit(slopeLimit: number): void;
        /**
         * @en Set the fall speed for the character.
         * @param value The fall speed value.
         * @zh 设置角色的下落速度。
         * @param value 下落速度值。
         */
        setfallSpeed(value: number): void;
        /**
         * @en Set the push force for the character.
         * @param value The push force value.
         * @zh 设置角色的推力。
         * @param value 推力值。
         */
        setPushForce(value: number): void;
        /**
         * @en Set the gravity for the character.
         * @param value The gravity vector.
         * @zh 设置角色的重力。
         * @param value 重力向量。
         */
        setGravity(value: Vector3): void;
        /**
         * @en Get the overlapping objects of the character.
         * @param cb Callback function to handle each overlapping object.
         * @zh 获得角色碰撞的对象。
         * @param cb 处理每个重叠对象的回调函数。
         */
        getOverlappingObj(cb: (body: btCollider) => void): void;
        /**
         * @en Set the collider shape for the character.
         * @param shape The collider shape to set.
         * @zh 设置角色的碰撞器形状。
         * @param shape 要设置的碰撞器形状。
         */
        setColliderShape(shape: btColliderShape): void;
        /**
         * @en Destroy CharacterController
         * @zh 销毁角色控制器
         */
        destroy(): void;
    }
    enum btColliderType {
        RigidbodyCollider = 0,
        CharactorCollider = 1,
        StaticCollider = 2
    }
    /**
     * @en btCollider class is used to handle 3D physics collisions.
     * @zh btCollider 类用于处理3D物理碰撞。
     */
    class btCollider implements ICollider {
        component: PhysicsColliderComponent;
        static _colliderID: number;
        static _addUpdateList: boolean;
        /**
         * @en Static rigid body type.
         * Set to a rigid body that will never move, and the engine will not automatically update it.
         * If you intend to move physics objects, it is recommended to use TYPE_KINEMATIC.
         * @zh 刚体类型_静态。
         * 设定为永远不会移动刚体,引擎也不会自动更新。
         * 如果你打算移动物理,建议使用TYPE_KINEMATIC。
         */
        static TYPE_STATIC: number;
        /**
         * @en Dynamic rigid body type.
         * The rigid body can be moved through forces and impulses, and there's no need to modify the movement transformation.
         * @zh 刚体类型_动态。
         * 可以通过力和冲量移动刚体，并且不需要修改移动变换。
         */
        static TYPE_DYNAMIC: number;
        /**
         * @en Kinematic rigid body type.
         * The rigid body can be moved, and the physics engine will automatically handle dynamic interactions.
         * Note: It will not produce dynamic interactions with static or other types of rigid bodies.
         * @zh 刚体类型_运动。
         * 可以移动刚体，物理引擎会自动处理动态交互。
         * 注意：和静态或其他类型刚体不会产生动态交互。
         */
        static TYPE_KINEMATIC: number;
        protected static _btVector30: number;
        /**
         * @en The underlying Bullet physics collider object.
         * @zh 物理碰撞器对象。
         */
        _btCollider: any;
        /**
         * @en The shape of the Bullet physics collider.
         * @zh 物理碰撞器的形状。
         */
        _btColliderShape: btColliderShape;
        /**
         * @en The collision group that this collider belongs to.
         * @zh 此碰撞器所属的碰撞组。
         */
        _collisionGroup: number;
        /**
         * @en The collision mask determining which groups this collider can collide with.
         * @zh 决定此碰撞器可以与哪些组碰撞的碰撞掩码。
         */
        _canCollideWith: number;
        /**
         * @en The physics manager handling this collider.
         * @zh 处理此碰撞器的物理管理器。
         */
        _physicsManager: btPhysicsManager;
        /**
         * @en Indicates whether the collider is currently simulated in the physics world.
         * @zh 表示碰撞器是否已在物理世界中生效。
         */
        _isSimulate: boolean;
        /**
         * @en The type of the collider (static, dynamic, or kinematic).
         * @zh 碰撞器的类型（静态、动态或运动学）。
         */
        _type: btColliderType;
        /**
         * @en update list index.
         * @zh 更新列表中的索引。
         */
        inPhysicUpdateListIndex: number;
        /**
         * @en Unique identifier for the collider.
         * @zh 碰撞器的唯一标识符。
         */
        _id: number;
        /**
         * @en Whether the collider is a trigger.
         * @zh 是否为触发器。
         */
        _isTrigger: boolean;
        /**
         * @en Determines if collision processing is enabled for this collider.
         * @zh 决定是否为此碰撞器启用碰撞处理。
         */
        _enableProcessCollisions: boolean;
        /**
         * @en Indicates whether the collider has been destroyed.
         * @zh 表示碰撞器是否已被销毁。
         */
        _destroyed: boolean;
        /**
         * @en The Sprite3D object that owns this collider.
         * @zh 拥有此碰撞器的Sprite3D对象。
         */
        owner: Sprite3D;
        /**
         * @en The Transform3D component associated with this collider.
         * @zh 与此碰撞器关联的Transform3D组件。
         */
        _transform: Transform3D;
        /**
         * @ignore
         * @en Creates an instance of btCollider.
         * @param physicsManager The physics manager.
         * @zh 创建一个 btCollider 的实例。
         * @param physicsManager 物理管理器。
         */
        constructor(physicsManager: btPhysicsManager);
        active: boolean;
        /**
         * @en Sets the dynamic friction of the collider.
         * @param value The dynamic friction value.
         * @zh 设置碰撞器的动态摩擦力。
         * @param value 动态摩擦力值。
         */
        setDynamicFriction?(value: number): void;
        /**
         * @en Sets the static friction of the collider.
         * @param value The static friction value.
         * @zh 设置碰撞器的静态摩擦力。
         * @param value 静态摩擦力值。
         */
        setStaticFriction?(value: number): void;
        /**
         * @en Sets the friction combine mode.
         * @param value The friction combine mode.
         * @zh 设置摩擦力组合模式。
         * @param value 摩擦力组合模式。
         */
        setFrictionCombine?(value: PhysicsCombineMode): void;
        /**
         * @en Sets the bounce combine mode.
         * @param value The bounce combine mode.
         * @zh 设置弹力组合模式。
         * @param value 弹力组合模式。
         */
        setBounceCombine?(value: PhysicsCombineMode): void;
        /**
         * @en Sets the event filter for the collider.
         * @param events Array of event names to filter.
         * @zh 设置碰撞器的事件过滤器。
         * @param events 要过滤的事件名称。
         */
        setEventFilter?(events: string[]): void;
        allowSleep(value: boolean): void;
        /**
         * @en Checks if the collider is capable of a certain feature.
         * @param value The capability to check.
         * @returns Whether the collider has the capability.
         * @zh 检查碰撞器是否具有某种能力。
         * @param value 要检查的能力。
         * @returns 碰撞器是否具有该能力。
         */
        getCapable(value: number): boolean;
        /**
         * @en Sets the owner of the collider.
         * @param node The Sprite3D node to set as owner.
         * @zh 设置碰撞器的所有者。
         * @param node 所有者节点。
         */
        setOwner(node: Sprite3D): void;
        /**
         * @en Sets the collision group of the collider.
         * @param value The collision group value.
         * @zh 设置碰撞器的碰撞组。
         * @param value 碰撞组的值。
         */
        setCollisionGroup(value: number): void;
        /**
         * @en Sets which groups this collider can collide with.
         * @param value The collision mask value.
         * @zh 设置此碰撞器可以与哪些组碰撞。
         * @param value 碰撞掩码的值。
         */
        setCanCollideWith(value: number): void;
        protected _initCollider(): void;
        protected getColliderType(): btColliderType;
        protected _onShapeChange(): void;
        /**
         * @en Sets the collider shape.
         * @param shape The new collider shape.
         * @zh 设置碰撞器形状。
         * @param shape 新的碰撞器形状。
         */
        setColliderShape(shape: btColliderShape): void;
        /**
         * @en Destroys the collider.
         * @zh 销毁碰撞器。
         */
        destroy(): void;
        /**
         * @en Handles transform changes.
         * @param flag The transform flag.
         * @zh 处理变换改变。
         * @param flag 变换标志。
         */
        transformChanged(flag: number): void;
        /**
         * @en Sets the bounciness (restitution) of the collider.
         * @param value The bounciness value.
         * @zh 设置碰撞器的弹性（恢复系数）。
         * @param value 弹性值。
         */
        setBounciness(value: number): void;
        /**
         * @en Sets the friction of the collider.
         * @param value The friction value.
         * @zh 设置碰撞器的摩擦力。
         * @param value 摩擦力值。
         */
        setfriction(value: number): void;
        /**
         * @en Sets the rolling friction of the collider.
         * @param value The rolling friction value.
         * @zh 设置碰撞器的滚动摩擦力。
         * @param value 滚动摩擦力值。
         */
        setRollingFriction(value: number): void;
        /**
         * @en Sets the CCD (Continuous Collision Detection) motion threshold.
         * @param value The CCD motion threshold value.
         * @zh 设置 CCD（连续碰撞检测）运动阈值。
         * @param value CCD 运动阈值。
         */
        setCcdMotionThreshold(value: number): void;
        /**
         * @en Sets the CCD (Continuous Collision Detection) swept sphere radius.
         * @param value The CCD swept sphere radius value.
         * @zh 设置 CCD（连续碰撞检测）扫描球半径。
         * @param value CCD 扫描球半径。
         */
        setCcdSweptSphereRadius(value: number): void;
    }
    /**
     * @en The `btRigidBodyCollider` class is used to implement 3D physics rigid body colliders.
     * @zh `btRigidBodyCollider` 类用于实现3D物理刚体碰撞器。
     */
    class btRigidBodyCollider extends btCollider implements IDynamicCollider {
        constructor(manager: btPhysicsManager);
        /**
         * @en Get the capability of the rigid body collider.
         * @param value The capability value to check.
         * @returns Whether the rigid body collider has the specified capability.
         * @zh 获取刚体碰撞器的能力。
         * @param value 要检查的能力值。
         * @returns 刚体碰撞器是否具有指定的能力。
         */
        getCapable(value: number): boolean;
        /**
         * @en Get the capability of the rigid body.
         * @param value The capability to check.
         * @returns Whether the rigid body has the specified capability.
         * @zh 获取刚体的能力。
         * @param value 要检查的能力。
         * @returns 刚体是否具有指定的能力。
         */
        static getRigidBodyCapable(value: EColliderCapable): boolean;
        /**
         * @en Initialize the capabilities of the rigid body collider.
         * @zh 初始化刚体碰撞器的能力。
         */
        static initCapable(): void;
        /**
         * @en Set the world position of the rigid body.
         * @param value The new world position.
         * @zh 设置刚体的世界坐标位置。
         * @param value 坐标位置。
         */
        setWorldPosition(value: Vector3): void;
        /**
         * @en Set the world rotation of the rigid body.
         * @param value The new world rotation.
         * @zh 设置刚体在世界坐标系下的旋转。
         * @param value 旋转四元数。
         */
        setWorldRotation(value: Quaternion): void;
        /**
         * @en Set the rigid body to sleep state.
         * @zh 设置刚体进入睡眠状态。
         */
        sleep(): void;
        protected getColliderType(): btColliderType;
        /**
         * @en Whether to override gravity.
         * @zh 是否重载重力。
         */
        private _setoverrideGravity;
        /**
         * @en Whether it is sleeping.
         * @zh 是否处于睡眠状态。
         */
        isSleeping(): boolean;
        protected _initCollider(): void;
        protected _onShapeChange(): void;
        /**
         * @en Set the linear damping of the rigid body.
         * @param value The linear damping value.
         * @zh 设置刚体的线性阻尼。
         * @param value 线性阻尼值。
         */
        setLinearDamping(value: number): void;
        /**
         * @en Set the angular damping of the rigid body.
         * @param value The angular damping value.
         * @zh 设置刚体的角速度阻尼。
         * @param value 角速度阻尼值。
         */
        setAngularDamping(value: number): void;
        /**
         * @en Set the linear velocity of the rigid body.
         * @param value The linear velocity vector.
         * @zh 设置刚体的线速度。
         * @param value 线速度向量。
         */
        setLinearVelocity(value: Vector3): void;
        /**
         * @en Get the linear velocity of the rigid body.
         * @returns The current linear velocity vector.
         * @zh 获取刚体的线速度。
         * @returns 当前的线速度。
         */
        getLinearVelocity(): Vector3;
        /**
         * @en Set the angular velocity of the rigid body.
         * @param value The angular velocity vector.
         * @zh 设置刚体的角速度。
         * @param value 角速度。
         */
        setAngularVelocity(value: Vector3): void;
        /**
         * @en Get the angular velocity of the rigid body.
         * @returns The current angular velocity vector.
         * @zh 获取刚体的角速度。
         * @returns 当前的角速度。
         */
        getAngularVelocity(): Vector3;
        /**
         * @en Set the mass of the rigid body.
         * @param value The mass value.
         * @zh 设置刚体的质量。
         * @param value 质量值。
         */
        setMass(value: number): void;
        /**
         * @en Set the inertia tensor of the rigid body.
         * @param value The inertia tensor vector.
         * @zh 设置刚体的惯性张量。
         * @param value 惯性张量。
         */
        setInertiaTensor(value: Vector3): void;
        /**
         * @en Set the center of mass of the rigid body.
         * @param value The center of mass vector.
         * @zh 设置刚体的质心。
         * @param value 质心。
         */
        setCenterOfMass(value: Vector3): void;
        /**
         * @en Set the maximum angular velocity of the rigid body.
         * @param value The maximum angular velocity.
         * @zh 设置刚体的最大角速度。
         * @param value 角速度。
         */
        setMaxAngularVelocity(value: number): void;
        /**
         * @en Set the maximum depenetration velocity of the rigid body.
         * @param value The maximum depenetration velocity.
         * @zh 设置刚体的最大去穿透速度。
         * @param value 速度。
         */
        setMaxDepenetrationVelocity(value: number): void;
        /**
         * @en Set the linear velocity threshold for the rigid body to sleep.
         * @param value The linear velocity threshold.
         * @zh 设置刚体进入睡眠状态的线速度阈值。
         * @param value 线速度阈值。
         */
        setSleepThreshold(value: number): void;
        /**
         * @en Set the angular velocity threshold for the rigid body to sleep.
         * @param value The angular velocity threshold.
         * @zh 设置刚体进入睡眠状态的角速度阈值。
         * @param value 角速度阈值。
         */
        setSleepAngularThreshold(value: number): void;
        /**
         * @en Set the solver iterations for the rigid body.
         * @param value The number of solver iterations.
         * @zh 设置刚体的求解器迭代次数。
         * @param value 求解器迭代次数。
         */
        setSolverIterations(value: number): void;
        /**
         * @en Set the collision detection mode for the rigid body.
         * @param value The collision detection mode.
         * @zh 设置刚体的碰撞检测模式。
         * @param value 碰撞检测模式。
         */
        setCollisionDetectionMode(value: number): void;
        /**
         * @en Set whether the rigid body is kinematic.
         * @param value True if the body should be kinematic, false otherwise.
         * @zh 设置刚体是否为运动学刚体。
         * @param value 如果为true，则设置为运动学刚体；否则为false。
         */
        setIsKinematic(value: boolean): void;
        /**
         * @en Set the linear and angular factor constraints for the rigid body.
         * @param linearFactor The linear factor constraint.
         * @param angularFactor The angular factor constraint.
         * @zh 设置刚体的线性和角度因子约束。
         * @param linearFactor 线性因子约束。
         * @param angularFactor 角度因子约束。
         */
        setConstraints(linearFactor: Vector3, angularFactor: Vector3): void;
        /**
         * @en Set whether the rigid body is a trigger.
         * @param value True if the body should be a trigger, false otherwise.
         * @zh 设置刚体是否为触发器。
         * @param value 如果为true，则设置为触发器；否则为false。
         */
        setTrigger(value: boolean): void;
        /**
         * @en Apply a force to the rigid body.
         * @param force The force to be applied.
         * @param localOffset The offset. If null, force is applied at the center.
         * @zh 应用作用力。
         * @param force 要施加的作用力。
         * @param localOffset 偏移量，如果为null则为中心点。
         */
        private _applyForce;
        /**
         * @en Apply a torque to the rigid body.
         * @param torque The torque to be applied.
         * @zh 应用扭转力。
         * @param torque 要施加的扭转力。
         */
        private _applyTorque;
        /**
         * @en Apply an impulse to the rigid body.
         * @param impulse The impulse to be applied.
         * @param localOffset The offset. If null, force is applied at the center.
         * @zh 应用冲量。
         * @param impulse 要施加的冲量。
         * @param localOffset 偏移量，如果为null则为中心点。
         */
        private _applyImpulse;
        /**
         * @en Apply a torque impulse to the rigid body.
         * @param torqueImpulse The torque impulse to be applied.
         * @zh 应用扭转冲量。
         * @param torqueImpulse 要施加的扭转冲量。
         */
        private _applyTorqueImpulse;
        /**
         * @en Add a force to the rigid body.
         * @param force The force to be added.
         * @param mode The force mode.
         * @param localOffset The offset from the center of mass.
         * @zh 向刚体添加力。
         * @param force 要添加的力。
         * @param mode 力的模式。
         * @param localOffset 相对于质心的偏移量。
         */
        addForce(force: Vector3, mode: PhysicsForceMode, localOffset: Vector3): void;
        /**
         * @en Add a torque to the rigid body.
         * @param torque The torque to be added.
         * @param mode The force mode.
         * @zh 向刚体添加扭矩。
         * @param torque 要添加的扭矩。
         * @param mode 力的模式。
         */
        addTorque(torque: Vector3, mode: PhysicsForceMode): void;
        /**
         * @en Clear all forces applied to the rigid body.
         * @zh 清除应用到刚体上的所有力。
         */
        private clearForces;
        /**
         * @en Wake up the rigid body.
         * @zh 唤醒刚体。
         */
        wakeUp(): void;
        protected _onScaleChange(scale: Vector3): void;
        /**
         * @en Set the collider shape for the rigid body.
         * @param shape The collider shape to be set.
         * @zh 设置刚体的碰撞器形状。
         * @param shape 要设置的碰撞器形状。
         */
        setColliderShape(shape: btColliderShape): void;
        /**
         * @en Destroy the rigid body.
         * @zh 销毁刚体。
         */
        destroy(): void;
    }
    /**
     * @en The `btStaticCollider` class is used to create and manage static colliders.
     * @zh `btStaticCollider` 类用于创建和管理静态碰撞体。
     */
    class btStaticCollider extends btCollider implements IStaticCollider {
        protected _initCollider(): void;
        /**
         * @en Set whether the collider is a trigger.
         * @param value True if the collider should be a trigger, false otherwise.
         * @zh 设置碰撞体是否为触发器。
         * @param value 如果为true，则设置为触发器；否则为false。
         */
        setTrigger(value: boolean): void;
        allowSleep(value: boolean): void;
        protected getColliderType(): btColliderType;
        /**
         * @en Check if the collider has a specific capability.
         * @param value The capability to check.
         * @returns Whether the collider has the specified capability.
         * @zh 检查碰撞体是否具有特定能力。
         * @param value 要检查的能力。
         * @returns 碰撞体是否具有指定的能力。
         */
        getCapable(value: number): boolean;
        /**
         * @ignore
         * @en Creates an instance of `btStaticCollider`.
         * @param physicsManager The physics manager.
         * @zh 创建一个 `btStaticCollider` 的实例。
         * @param physicsManager 物理管理器。
         */
        constructor(physicsManager: btPhysicsManager);
        /**
         * @en Check if the static collider has a specific capability.
         * @param value The capability to check.
         * @returns Whether the static collider has the specified capability.
         * @zh 检查静态碰撞体是否具有特定能力。
         * @param value 要检查的能力。
         * @returns 静态碰撞体是否具有指定的能力。
         */
        static getStaticColliderCapable(value: EColliderCapable): boolean;
        /**
         * @en Initialize the capabilities of the static collider.
         * @zh 初始化静态碰撞体的能力。
         */
        static initCapable(): void;
        /**
         * @en Set the world position of the static collider.
         * @param value The world position.
         * @zh 设置静态碰撞体的世界坐标位置。
         * @param value 坐标位置。
         */
        setWorldPosition(value: Vector3): void;
        /**
         * @en Destroy Static Collider
         * @zh 销毁静态碰撞器
         */
        destroy(): void;
    }
    /**
     * @en The `btCustomJoint` class is used for detailed control of joints.
     * @zh 类`btCustomJoint`用于实现关节的详细控制。
     */
    class btCustomJoint extends btJoint implements ID6Joint {
        /**
         * @en Initializes the joint.
         * @zh 初始化关节。
         */
        initJoint(): void;
        protected _createJoint(): void;
        /**
         * @en Initializes all constraint information for the joint.
         * @zh 初始化关节的所有约束信息。
         */
        _initAllConstraintInfo(): void;
        /**
         * @ignore
         * @en Creates an instance of btCustomJoint.
         * @param manager The Bullet physics manager instance used to handle physics simulations.
         * @zh 创建一个btCustomJoint的实例。
         * @param manager 用于处理物理模拟的Bullet物理管理器实例。
         */
        constructor(manager: btPhysicsManager);
        /**
         * @en Sets the local position of the joint.
         * @param pos The new local position vector.
         * @zh 设置关节的局部位置。
         * @param pos 新的局部位置向量。
         */
        setLocalPos(pos: Vector3): void;
        /**
         * @en Sets the connected local position of the joint.
         * @param pos The new connected local position vector.
         * @zh 设置关节的连接局部位置。
         * @param pos 新的连接局部位置向量。
         */
        setConnectLocalPos(pos: Vector3): void;
        /**
         * @en Sets the primary and secondary axes for the joint.
         * @param axis The primary axis vector.
         * @param secendary The secondary axis vector.
         * @zh 设置关节的主轴和次轴。
         * @param axis 主轴向量。
         * @param secendary 次轴向量。
         */
        setAxis(axis: Vector3, secendary: Vector3): void;
        /**
         * @en Sets the motion type for a specific axis of the constraint.
         * @param axis The constraint type to set.
         * @param motionType The motion type to apply.
         * @zh 设置约束特定轴的运动类型。
         * @param axis 要设置的约束类型。
         * @param motionType 要应用的运动类型。
         */
        setMotion(axis: D6Axis, motionType: D6MotionType): void;
        /**
         * @en Sets the distance limit for the constraint.
         * @param limit The distance limit.
         * @param bounceness The bounciness of the constraint.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring stiffness.
         * @param damp The damping value.
         * @zh 设置约束的距离限制。
         * @param limit 距离限制。
         * @param bounceness 约束的弹性。
         * @param bounceThreshold 弹跳阈值。
         * @param spring 弹簧刚度。
         * @param damp 阻尼值。
         */
        setDistanceLimit(limit: number, bounceness: number, bounceThreshold: number, spring: number, damp: number): void;
        /**
         * @en Sets the linear limit for a specific axis of the constraint.
         * @param linearAxis The linear axis to set the limit for.
         * @param upper The upper limit.
         * @param lower The lower limit.
         * @param bounceness The bounciness of the constraint.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring stiffness.
         * @param damping The damping value.
         * @zh 设置约束特定轴的线性限制。
         * @param linearAxis 要设置限制的线性轴。
         * @param upper 上限。
         * @param lower 下限。
         * @param bounceness 约束的弹性。
         * @param bounceThreshold 弹跳阈值。
         * @param spring 弹簧刚度。
         * @param damping 阻尼值。
         */
        setLinearLimit(linearAxis: D6MotionType, upper: number, lower: number, bounceness: number, bounceThreshold: number, spring: number, damping: number): void;
        /**
         * @en Sets the twist limit for the constraint.
         * @param upper The upper twist limit (in radians).
         * @param lower The lower twist limit (in radians).
         * @param bounceness The bounciness of the constraint.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring stiffness.
         * @param damping The damping value.
         * @zh 设置约束的扭转限制。
         * @param upper 上扭转限制（弧度）。
         * @param lower 下扭转限制（弧度）。
         * @param bounceness 约束的弹性。
         * @param bounceThreshold 弹跳阈值。
         * @param spring 弹簧刚度。
         * @param damping 阻尼值。
         */
        setTwistLimit(upper: number, lower: number, bounceness: number, bounceThreshold: number, spring: number, damping: number): void;
        /**
         * @en Sets the swing limit for the constraint.
         * @param yAngle The Y-axis swing limit (in radians).
         * @param zAngle The Z-axis swing limit (in radians).
         * @param bounceness The bounciness of the constraint.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring stiffness.
         * @param damping The damping value.
         * @zh 设置约束的摆动限制。
         * @param yAngle Y轴摆动限制（弧度）。
         * @param zAngle Z轴摆动限制（弧度）。
         * @param bounceness 约束的弹性。
         * @param bounceThreshold 弹跳阈值。
         * @param spring 弹簧刚度。
         * @param damping 阻尼值。
         */
        setSwingLimit(yAngle: number, zAngle: number, bounceness: number, bounceThreshold: number, spring: number, damping: number): void;
        /**
         * @en Sets the drive parameters for a specific axis of the constraint.
         * @param index The drive axis index.
         * @param stiffness The drive stiffness.
         * @param damping The drive damping.
         * @param forceLimit The force limit for the drive.
         * @zh 设置约束特定轴的驱动参数。
         * @param index 驱动轴索引。
         * @param stiffness 驱动刚度。
         * @param damping 驱动阻尼。
         * @param forceLimit 驱动力限制。
         */
        setDrive(index: D6Drive, stiffness: number, damping: number, forceLimit: number): void;
        /**
         * @en Sets the drive transform for the constraint.
         * @param position The target position.
         * @param rotate The target rotation.
         * @zh 设置约束的驱动变换。
         * @param position 目标位置。
         * @param rotate 目标旋转。
         */
        setDriveTransform(position: Vector3, rotate: Quaternion): void;
        /**
         * @en Sets the drive velocity for the constraint.
         * @param position The target linear velocity.
         * @param angular The target angular velocity.
         * @zh 设置约束的驱动速度。
         * @param position 目标线性速度。
         * @param angular 目标角速度。
         */
        setDriveVelocity(position: Vector3, angular: Vector3): void;
        /**
         * @en Gets the current twist angle of the constraint.
         * @zh 获取约束当前的扭转角度。
         */
        getTwistAngle(): number;
        /**
         * @en Gets the current swing Y angle of the constraint.
         * @returns The current swing Y angle.
         * @zh 获取约束当前的Y轴摆动角度。
         * @returns 当前Y轴摆动角度。
         */
        getSwingYAngle(): number;
        /**
         * @en Gets the current swing Z angle of the constraint.
         * @returns The current swing Z angle.
         * @zh 获取约束当前的Z轴摆动角度。
         * @returns 当前Z轴摆动角度。
         */
        getSwingZAngle(): number;
        /**
         * @en Destroy joint
         * @zh 销毁关节
         */
        destroy(): void;
    }
    /**
     * @en Class `btFixedJoint` is used to create a fixed joint in the physical engine.
     * @zh 类`btFixedJoint`用于在物理引擎中创建固定关节。
     */
    class btFixedJoint extends btJoint implements IFixedJoint {
        /**
         * @en Creates an instance of `btFixedJoint`.
         * @param manager The physics manager that will handle this joint.
         * @zh 创建一个实例`btFixedJoint`。
         * @param manager 将处理这个关节的物理管理器。
         */
        constructor(manager: btPhysicsManager);
        protected _createJoint(): void;
        /**
         * @en Destroy joint
         * @zh 销毁关节
         */
        destroy(): void;
    }
    /**
     * @en The class `btHingeJoint` represents a hinge joint between two rigid bodies.
     * @zh 类 `btHingeJoint` 表示两个刚体之间的摆动关节。
     */
    class btHingeJoint extends btJoint implements IHingeJoint {
        protected _createJoint(): void;
        /**
         * @ignore
         * @en Creates an instance of btHingeJoint.
         * @param manager The physics manager.
         * @zh 创建 `btHingeJoint` 的实例。
         * @param manager 物理管理器。
         */
        constructor(manager: btPhysicsManager);
        /**
         * @en Sets the local position of the joint.
         * @param pos The new local position vector.
         * @zh 设置关节的局部位置。
         * @param pos 新的局部位置。
         */
        setLocalPos(pos: Vector3): void;
        /**
         * @en Sets the connected local position of the joint.
         * @param pos The new connected local position vector.
         * @zh 设置关节的连接局部位置。
         * @param pos 新的连接局部位置。
         */
        setConnectLocalPos(pos: Vector3): void;
        /**
         * @en Sets the lower limit of the joint's rotation.
         * @param lowerLimit The new lower limit in radians.
         * @zh 设置关节旋转的下限。
         * @param lowerLimit 新的下限值，单位为弧度。
         */
        setLowerLimit(lowerLimit: number): void;
        /**
         * @en Sets the upper limit of the joint's rotation.
         * @param value The new upper limit in radians.
         * @zh 设置关节旋转的上限。
         * @param value 新的上限值，单位为弧度。
         */
        setUpLimit(value: number): void;
        /**
         * @en Sets the bounciness of the joint.
         * @param value The bounce factor. If less than or equal to 0, it will be set to 0.
         * @zh 设置关节的弹性。
         * @param value 弹跳因子。如果小于或等于0，将被设置为0。
         */
        setBounceness(value: number): void;
        /**
         * @en Sets the minimum velocity for bounce.
         * @param value The minimum velocity value.
         * @zh 设置弹跳的最小速度。
         * @param value 最小速度值。
         */
        setBouncenMinVelocity(value: number): void;
        /**
         * @en Sets the contact distance for the joint.
         * @param value The contact distance value.
         * @zh 设置关节的接触距离。
         * @param value 接触距离值。
         */
        setContactDistance(value: number): void;
        /**
         * @en Enables or disables the joint limit.
         * @param value True to enable the limit, false to disable.
         * @zh 启用或禁用关节限制。
         * @param value 为true时启用限制，为false时禁用。
         */
        enableLimit(value: boolean): void;
        /**
         * @en Enables or disables the joint drive.
         * @param value True to enable the drive, false to disable.
         * @zh 启用或禁用关节驱动。
         * @param value 为true时启用驱动，为false时禁用。
         */
        enableDrive(value: boolean): void;
        /**
         * @en Enables or disables free spin for the joint.
         * @param value True to enable free spin, false to disable.
         * @zh 启用或禁用关节的自由旋转。
         * @param value 为true时启用自由旋转，为false时禁用。
         */
        enableFreeSpin(value: boolean): void;
        /**
         * @en Sets the axis of rotation for the hinge joint.
         * @param value A vector representing the axis of rotation.
         * @zh 设置铰链关节的旋转轴。
         * @param value 表示旋转轴的向量。
         */
        setAxis(value: Vector3): void;
        /**
         * @en Sets the swing offset for the joint.
         * @param value The swing offset vector.
         * @zh 设置关节的摆动偏移。
         * @param value 摆动偏移向量。
         */
        setSwingOffset(value: Vector3): void;
        /**
         * @en Gets the current angle of the joint.
         * @zh 获取关节的当前角度。
         */
        getAngle(): number;
        /**
         * @en Gets the current velocity of the joint.
         * @zh 获取关节的当前速度。
         */
        getVelocity(): Readonly<Vector3>;
        /**
         * @en Sets the hard limit for the joint.
         * @param lowerLimit The lower limit of the joint's movement.
         * @param upperLimit The upper limit of the joint's movement.
         * @param contactDist The contact distance.
         * @zh 设置关节的硬限制。
         * @param lowerLimit 关节运动的下限。
         * @param upperLimit 关节运动的上限。
         * @param contactDist 接触距离。
         */
        setHardLimit(lowerLimit: number, upperLimit: number, contactDist: number): void;
        /**
         * @en Sets the soft limit for the joint.
         * @param lowerLimit The lower limit of the joint's movement.
         * @param upperLimit The upper limit of the joint's movement.
         * @param stiffness The stiffness of the soft limit.
         * @param damping The damping of the soft limit.
         * @zh 设置关节的软限制。
         * @param lowerLimit 关节运动的下限。
         * @param upperLimit 关节运动的上限。
         * @param stiffness 软限制的刚度。
         * @param damping 软限制的阻尼。
         */
        setSoftLimit(lowerLimit: number, upperLimit: number, stiffness: number, damping: number): void;
        /**
         * @en Sets the drive velocity for the joint.
         * @param velocity The target velocity for the joint's motor.
         * @zh 设置关节的驱动速度。
         * @param velocity 关节电机的目标速度。
         */
        setDriveVelocity(velocity: number): void;
        /**
         * @en Sets the drive force limit for the joint.
         * @param limit The maximum force that can be applied by the joint's motor.
         * @zh 设置关节的驱动力限制。
         * @param limit 关节电机可以施加的最大力。
         */
        setDriveForceLimit(limit: number): void;
        /**
         * @en Sets the drive gear ratio for the joint.
         * @param ratio The gear ratio for the joint's motor.
         * @zh 设置关节的驱动齿轮比。
         * @param ratio 关节电机的齿轮比。
         */
        setDriveGearRatio(ratio: number): void;
        /**
         * @en Sets a specific flag for the hinge joint.
         * @param flag The flag to be set.
         * @param value The boolean value to set the flag to.
         * @zh 为铰链关节设置特定标志。
         * @param flag 要设置的标志。
         * @param value 设置标志的布尔值。
         */
        setHingeJointFlag(flag: number, value: boolean): void;
        /**
         * @en Destroy joint
         * @zh 销毁关节
         */
        destroy(): void;
    }
    /**
     * @en Class `btJoint` is the base class for all joints in LayaAir physics engine.
     * @zh 类`btJoint`用于实现物理关节的基类。
     */
    class btJoint implements IJoint {
        _manager: btPhysicsManager;
        /**
         * @en Whether to perform collision detection between the two connected objects.
         * @zh 连接的两个物体是否进行碰撞检测。
         */
        _disableCollisionsBetweenLinkedBodies: boolean;
        static __init__(): void;
        /**
         * @en Initialize the joint capability map.
         * @zh 初始化关节能力映射。
         */
        static initJointCapable(): void;
        /**
         * @en Get the joint capability.
         * @param value The joint capability to check.
         * @returns Whether the joint has the specified capability.
         * @zh 获取关节能力。
         * @param value 要检查的关节能力。
         * @returns 关节是否具有指定的能力。
         */
        static getJointCapable(value: EJointCapable): boolean;
        /**
         * @en Creates an instance of btJoint.
         * @param manager The physics manager.
         * @zh 创建一个 btJoint 的实例。
         * @param manager 物理管理器。
         */
        constructor(manager: btPhysicsManager);
        protected _createJoint(): void;
        destroy(): void;
        /**
         * @en Set the collider for the joint.
         * @param collider The collider to set.
         * @zh 设置关节的碰撞器。
         * @param collider 要设置的碰撞器。
         */
        setCollider(collider: btCollider): void;
        /**
         * @en Set the connected collider for the joint.
         * @param collider The connected collider to set.
         * @zh 设置关节的连接碰撞器。
         * @param collider 要设置的连接碰撞器。
         */
        setConnectedCollider(collider: btCollider): void;
        /**
         * @en Set the local position of the joint.
         * @param pos The local position to set.
         * @zh 设置关节的局部位置。
         * @param pos 要设置的局部位置。
         */
        setLocalPos(pos: Vector3): void;
        /**
         * @en Set the connected local position of the joint.
         * @param pos The connected local position to set.
         * @zh 设置关节的连接局部位置。
         * @param pos 要设置的连接局部位置。
         */
        setConnectLocalPos(pos: Vector3): void;
        /**
         * @en Get the linear force of the joint.
         * @zh 获取关节的线性力。
         */
        getlinearForce(): Vector3;
        /**
         * @en Get the angular force of the joint.
         * @zh 获取关节的角力。
         */
        getAngularForce(): Vector3;
        /**
         * @en Check if the joint is valid.
         * @zh 检查关节是否有效。
         */
        isValid(): boolean;
        /**
         * @en Enable or disable the joint.
         * @param value Whether to enable the joint.
         * @zh 启用或禁用关节。
         * @param value 是否启用关节。
         */
        isEnable(value: boolean): void;
        /**
         * @en Set whether collision is enabled between connected bodies.
         * @param value Whether to enable collision.
         * @zh 设置连接的物体之间是否启用碰撞。
         * @param value 是否启用碰撞。
         */
        isCollision(value: boolean): void;
        protected initJoint(): void;
        /**
         * @en Set the owner of the joint.
         * @param owner The owner to set.
         * @zh 设置关节的所有者。
         * @param owner 要设置的所有者。
         */
        setOwner(owner: Sprite3D): void;
        /**
         * @en Check if the joint is constrained by break force or torque.
         * @zh 检查关节是否受到断裂力或扭矩的约束。
         */
        _isBreakConstrained(): boolean;
        /**
         * @en Set the mass scale of the connected body.
         * @param value The mass scale to set.
         * @zh 设置连接物体的质量比例。
         * @param value 要设置的质量比例。
         */
        setConnectedMassScale(value: number): void;
        /**
         * @en Set the inertia scale of the connected body.
         * @param value The inertia scale to set.
         * @zh 设置连接物体的惯性比例。
         * @param value 要设置的惯性比例。
         */
        setConnectedInertiaScale(value: number): void;
        /**
         * @en Set the mass scale of the joint.
         * @param value The mass scale to set.
         * @zh 设置关节的质量比例。
         * @param value 要设置的质量比例。
         */
        setMassScale(value: number): void;
        /**
         * @en Set the inertia scale of the joint.
         * @param value The inertia scale to set.
         * @zh 设置关节的惯性比例。
         * @param value 要设置的惯性比例。
         */
        setInertiaScale(value: number): void;
        /**
         * @en Set the break force of the joint.
         * @param value The break force to set.
         * @zh 设置关节的断裂力。
         * @param value 要设置的断裂力。
         */
        setBreakForce(value: number): void;
        /**
         * @en Set the break torque of the joint.
         * @param value The break torque to set.
         * @zh 设置关节的断裂扭矩。
         * @param value 要设置的断裂扭矩。
         */
        setBreakTorque(value: number): void;
    }
    /**
     * @en The `btSpringJoint` class is used to create and manage spring joints in the physics engine.
     * @zh 类`btSpringJoint`用于在物理引擎中创建和管理弹簧关节。
     */
    class btSpringJoint extends btJoint implements ISpringJoint {
        protected _createJoint(): void;
        /**
         * @ignore
         * @en Creates an instance of the `btSpringJoint` class.
         * @param manager The physics manager.
         * @zh 创建一个btSpringJoint类的实例。
         * @param manager 物理管理器。
         */
        constructor(manager: btPhysicsManager);
        /**
         * @en Sets the local position of the joint.
         * @param pos The local position.
         * @zh 设置关节的局部位置。
         * @param pos 局部位置。
         */
        setLocalPos(pos: Vector3): void;
        /**
         * @en Sets the connected local position of the joint.
         * @param pos The connected local position.
         * @zh 设置关节连接的局部位置。
         * @param pos 连接局部位置。
         */
        setConnectLocalPos(pos: Vector3): void;
        /**
         * @en Sets the swing offset of the joint.
         * @param value The swing offset.
         * @zh 设置关节的摆动偏移量。
         * @param value 摆动偏移量。
         */
        setSwingOffset(value: Vector3): void;
        /**
         * @en Sets the minimum distance of the spring joint.
         * @param distance The minimum distance value.
         * @zh 设置弹簧关节的最小距离。
         * @param distance 最小距离值。
         */
        setMinDistance(distance: number): void;
        /**
         * @en Sets the maximum distance of the spring joint.
         * @param distance The maximum distance value.
         * @zh 设置弹簧关节的最大距离。
         * @param distance 最大距离值。
         */
        setMaxDistance(distance: number): void;
        /**
         * @ignore
         */
        setTolerance(tolerance: number): void;
        /**
         * @en Sets the stiffness of the spring joint.
         * @param stiffness The stiffness value.
         * @zh 设置弹簧关节的刚度。
         * @param stiffness 刚度值。
         */
        setStiffness(stiffness: number): void;
        /**
         * @en Sets the damping of the spring joint.
         * @param damping The damping value.
         * @zh 设置弹簧关节的阻尼。
         * @param damping 阻尼值。
         */
        setDamping(damping: number): void;
        /**
         * @en Destroy joint
         * @zh 销毁关节
         */
        destroy(): void;
    }
    /**
     * @en The `btBoxColliderShape` class is used to create and manage box collision shapes for the physics engine.
     * @zh 类`btBoxColliderShape` 用于创建和管理物理引擎的盒子碰撞形状。
     */
    class btBoxColliderShape extends btColliderShape implements IBoxColliderShape {
        constructor();
        private changeBoxShape;
        protected _createShape(): void;
        protected _getType(): number;
        /**
         * @en Sets the size of the box collider shape.
         * @param size The new size of the box.
         * @zh 设置盒子碰撞器形状的大小。
         * @param size 盒子的新大小。
         */
        setSize(size: Vector3): void;
        /**
         * @en Destroys the box collider shape and releases resources.
         * @zh 销毁盒子碰撞器形状并释放资源。
         */
        destroy(): void;
    }
    /**
     * @en The `btCapsuleColliderShape` class is used to create and manage capsule-shaped colliders.
     * @zh 类 `btCapsuleColliderShape` 用于创建和管理胶囊形状的碰撞体。
     */
    class btCapsuleColliderShape extends btColliderShape implements ICapsuleColliderShape {
        private static _tempVector30;
        constructor();
        protected _createShape(): void;
        protected _getType(): number;
        /**
         * @en Sets the radius of the capsule.
         * @param radius The radius of the capsule.
         * @zh 设置胶囊体的半径。
         * @param radius 胶囊体的半径。
         */
        setRadius(radius: number): void;
        /**
         * @en Sets the height of the capsule.
         * @param height The height of the capsule.
         * @zh 设置胶囊体的高度。
         * @param height 胶囊体的高度。
         */
        setHeight(height: number): void;
        /**
         * @en Sets the up axis of the capsule.
         * @param upAxis The up axis of the capsule.
         * @zh 设置胶囊体的朝向轴。
         * @param upAxis 胶囊体的朝向轴。
         */
        setUpAxis(upAxis: number): void;
        /**
         * @en Sets the world scale of the capsule collider shape.
         * @param scale The scale of the capsule collider shape.
         * @zh 设置胶囊碰撞器形状的世界缩放。
         * @param scale 缩放比例。
         */
        setWorldScale(scale: Vector3): void;
        /**
         * @en Destroys the capsule collider shape and releases resources.
         * @zh 销毁胶囊碰撞器形状并释放资源。
         */
        destroy(): void;
    }
    /**
     * @en The `btColliderShape` class is the base class for defining and managing physics collision shapes.
     * @zh 类`btColliderShape` 用于定义和管理物理碰撞形状的基类。
     */
    class btColliderShape implements IColliderShape {
        /**
         * @en Shape orientation along positive X-axis
         * @zh 形状方向沿 X 轴正向
         */
        static SHAPEORIENTATION_UPX: number;
        /**
         * @en Shape orientation along positive Y-axis
         * @zh 形状方向沿 Y 轴正向
         */
        static SHAPEORIENTATION_UPY: number;
        /**
         * @en Shape orientation along positive Z-axis
         * @zh 形状方向沿 Z 轴正向
         */
        static SHAPEORIENTATION_UPZ: number;
        _type: number;
        _btShape: any;
        _btScale: any;
        _localOffset: Vector3;
        _worldScale: Vector3;
        _btCollider: btCollider;
        _destroyed: boolean;
        constructor();
        /**
         * @en Gets the physics shape.
         * @returns The physics shape.
         * @zh 获取物理形状。
         * @returns 物理形状。
         */
        getPhysicsShape(): any;
        /**
         * @override
         */
        protected _createShape(): void;
        /**
         * @override
         */
        protected _getType(): number;
        /**
         * @en Sets the local offset of the shape.
         * @param value The offset value.
         * @zh 设置形状的局部偏移。
         * @param value 偏移量。
         */
        setOffset(value: Vector3): void;
        /**
         * @en Gets the local offset of the shape.
         * @returns The local offset of the shape.
         * @zh 获取形状的局部偏移。
         * @returns 局部偏移量。
         */
        getOffset(): Vector3;
        /**
         * @en Sets the world scale of the shape.
         * @param scale The scale value.
         * @zh 设置形状的世界缩放。
         * @param scale 缩放比例。
         */
        setWorldScale(scale: Vector3): void;
        /**
         * @en Destroys the collider shape and releases resources.
         * @zh 销毁碰撞器形状并释放资源。
         */
        destroy(): void;
    }
    /**
     * @en use to create compound collider.
     * @zh 用于创建组合碰撞器。
     */
    class btCompoundColliderShape extends btColliderShape implements ICompoundColliderShape {
        /**
         * @en create a new instance of btCompoundColliderShape.
         * @zh 创建一个新的组合碰撞形状实例。
         */
        constructor();
        clearChildShape(): void;
        protected _getType(): number;
        addChildShape(shape: btColliderShape): void;
        removeChildShape(shape: btColliderShape, index: number): void;
        setShapeData(component: PhysicsColliderComponent): void;
        getChildShapeCount(): number;
        /**
         * @inheritDoc
         * @override
         */
        destroy(): void;
    }
    /**
     * @en The `btConeColliderShape` class creates a cone shape, which is a cylinder with a conical top.
     * @zh 类 `btConeColliderShape` 用于创建和管理物理引擎中圆锥碰撞器形状。
     */
    class btConeColliderShape extends btColliderShape implements IConeColliderShape {
        private static _tempVector30;
        constructor();
        protected _createShape(): void;
        protected _getType(): number;
        /**
         * @en Sets the radius of the cone.
         * @param radius The radius to set.
         * @zh 设置圆锥的半径。
         * @param radius 圆锥的半径。
         */
        setRadius(radius: number): void;
        /**
         * @en Sets the height of the cone.
         * @param height The height to set.
         * @zh 设置圆锥的高度。
         * @param height 圆锥的高度。
         */
        setHeight(height: number): void;
        /**
         * @en Sets the up axis of the cone.
         * @param upAxis The up axis to set.
         * @zh 设置圆锥的朝向轴。
         * @param upAxis 圆锥的朝向轴。
         */
        setUpAxis(upAxis: number): void;
        /**
         * @en Destroys the cone collider shape and releases resources.
         * @zh 销毁圆锥碰撞器形状并释放资源。
         */
        destroy(): void;
    }
    /**
     * @en The `btCylinderColliderShape` class is used to create and manage cylinder collision shapes.
     * @zh `btCylinderColliderShape` 类用于创建和管理圆柱体碰撞形状。
     */
    class btCylinderColliderShape extends btColliderShape implements ICylinderColliderShape {
        private static _tempVector30;
        private _btSize;
        constructor();
        protected _createShape(): void;
        protected _getType(): number;
        /**
         * @en Sets the radius of the cylinder.
         * @param radius The radius of the cylinder.
         * @zh 设置圆柱体的半径。
         * @param radius 圆柱体的半径。
         */
        setRadius(radius: number): void;
        /**
         * @en Sets the height of the cylinder.
         * @param height The height of the cylinder.
         * @zh 设置圆柱体的高度。
         * @param height 圆柱体的高度。
         */
        setHeight(height: number): void;
        /**
         * @en Sets the up axis of the cylinder.
         * @param upAxis The up axis of the cylinder.
         * @zh 设置圆柱体的朝上轴。
         * @param upAxis 圆柱体的朝上轴。
         */
        setUpAxis(upAxis: number): void;
        /**
         * @en Destroys the cylinder collider shape and releases resources.
         * @zh 销毁圆柱体碰撞器形状并释放资源。
         */
        destroy(): void;
    }
    /**
     * @en The `btMeshColliderShape` class is used to create and manage mesh-based collision shapes.
     * @zh `btMeshColliderShape` 类用于创建和管理基于网格的碰撞形状。
     */
    class btMeshColliderShape extends btColliderShape implements IMeshColliderShape {
        private _limitvertex;
        private _convex;
        /**
         * @en The mesh of the collider shape.
         * @zh 碰撞器形状的网格。
         */
        get mesh(): Mesh;
        set mesh(value: Mesh);
        static __init__(): void;
        /** @ignore */
        constructor();
        /**
         * @en Set the physics mesh from a given mesh.
         * @param value The mesh to set.
         * @zh 从给定的网格设置物理网格。
         * @param value 网格。
         */
        setPhysicsMeshFromMesh(value: Mesh): void;
        /**
         * @en Set the convex mesh.
         * @param value The mesh to set.
         * @zh 设置凸包网格。
         * @param value 网格。
         */
        setConvexMesh(value: Mesh): void;
        /**
         * @en Set the limit of vertices.
         * @param limit The limit value.
         * @zh 设置顶点限制。
         * @param limit 限制值。
         */
        setLimitVertex(limit: number): void;
        private _createPhysicsMeshFromMesh;
        private _createConvexMeshFromMesh;
        protected _createTrianggleMeshGeometry(): void;
        protected _createConvexMeshGeometry(): void;
        /**
         * @en Set the world scale of the collider shape.
         * @param value The scale vector to set.
         * @zh 设置碰撞器形状的世界缩放。
         * @param value 缩放向量。
         */
        setWorldScale(value: Vector3): void;
    }
    /**
     * @en The `btSphereColliderShape` class is used to create and manage spherical collision shapes.
     * @zh `btSphereColliderShape` 类用于创建和管理球形碰撞体形状。
     */
    class btSphereColliderShape extends btColliderShape implements ISphereColliderShape {
        /** @ignore */
        constructor();
        protected _getType(): number;
        protected _createShape(): void;
        /**
         * @en Sets the radius of the sphere.
         * @param radius The radius to set.
         * @zh 设置球体的半径。
         * @param radius 要设置的半径。
         */
        setRadius(radius: number): void;
        /**
         * @en Destroys the sphere collider shape and cleans up resources.
         * @zh 销毁球形碰撞体形状并清理资源。
         */
        destroy(): void;
    }
    /**
     * @en Interface for character controllers.
     * @zh 角色控制器的接口。
     */
    interface ICharacterController extends ICollider {
        /**
         * @en Moves the character using a "collide-and-slide" algorithm.
         * @param disp Displacement vector
         * @zh 使用"碰撞并滑动"算法移动角色。
         * @param disp 位移向量
         */
        move(disp: Vector3): void;
        /**
         * @en Make the character jump.
         * @param velocity Jump velocity
         * @zh 使角色跳跃。
         * @param velocity 跳跃速度
         */
        jump?(velocity: Vector3): void;
        /**
         * @en Set position of CharacterController.
         * @param value New position
         * @zh 设置角色控制器的位置。
         * @param value 位置
         */
        setPosition(value: Vector3): void;
        /**
         * @en Get current position of characterController.
         * @returns Current position
         * @zh 获取角色控制器的当前位置。
         * @returns 当前位置
         */
        getPosition?(): Vector3;
        /**
         * @en Set the step height for the characterController.
         * @param offset The new step offset
         * @zh 设置角色控制器的步高。
         * @param offset 步高偏移量
         */
        setStepOffset?(offset: number): void;
        /**
         * @en Set skin width for the characterController.
         * @param width The new skin width
         * @zh 设置角色控制器的皮肤宽度。
         * @param width 皮肤宽度
         */
        setSkinWidth?(width: number): void;
        /**
         * @en Set the 'up' direction for the characterController.
         * @param up The up direction
         * @zh 设置角色控制器的"向上"方向。
         * @param up 向上方向
         */
        setUpDirection?(up: Vector3): void;
        /**
         * @en Get the vertical velocity of the characterController.
         * @returns Vertical velocity
         * @zh 获取角色控制器的垂直速度。
         * @returns 垂直速度
         */
        getVerticalVel?(): number;
        /**
         * @en Set the slope limit for the characterController.
         * @param slopeLimit The new slope limit
         * @zh 设置角色控制器的斜坡限制。
         * @param slopeLimit 斜坡限制
         */
        setSlopeLimit?(slopeLimit: number): void;
        /**
         * @en Set the gravity for the characterController.
         * @param value Gravity vector
         * @zh 设置角色控制器的重力。
         * @param value 重力
         */
        setGravity?(value: Vector3): void;
        /**
         * @en Set the radius of the characterController.
         * @param value The new radius
         * @zh 设置角色的半径。
         * @param value 半径
         */
        setRadius?(value: number): void;
        /**
         * @en Set the height of the characterController.
         * @param value The height
         * @zh 设置角色的高度。
         * @param value 高度
         */
        setHeight?(value: number): void;
        /**
         * @en Set the minimum distance for the characterController.
         * @param value The minimum distance
         * @zh 设置角色控制器的最小距离。
         * @param value 最小距离
         */
        setminDistance(value: number): void;
        /**
         * @en Set the local offset of the characterController's shape.
         * @param value The local offset
         * @zh 设置角色控制器形状的局部偏移。
         * @param value 局部偏移
         */
        setShapelocalOffset(value: Vector3): void;
        /**
         * @en Set the push force for the characterController.
         * @param value The push force
         * @zh 设置角色控制器的推力。
         * @param value 推力
         */
        setPushForce?(value: number): void;
        /**
         * @en Set the jump speed for the characterController.
         * @param value The jump speed
         * @zh 设置角色控制器的跳跃速度。
         * @param value 跳跃速度
         */
        setJumpSpeed?(value: number): void;
        /**
         * @en Whether the character is on the ground.
         * @returns Whether the character is on the ground.
         * @zh 是否在地面上。
         * @returns 是否在地面上。
         */
        isGrounded?(): boolean;
    }
    /**
     * @en Interface for collider.
     * @zh 碰撞器的接口。
     */
    interface ICollider {
        /**
         * @en The owner node of the collider.
         * @zh 碰撞器所属的节点。
         */
        owner: Node;
        /**
         * @en Indicates whether the collider can be enabled. It's true only when placed in the scene and the physics component is effective.
         * @zh 是否可以启用，只有放入scene中且物理组件生效才会为true。
         */
        active: boolean;
        /**
         * @en Index in the physics update list.
         * @zh 在物理更新列表中的索引。
         */
        inPhysicUpdateListIndex: number;
        /**
         * @en The physics collider component associated with this collider.
         * @zh 与此碰撞器关联的物理碰撞器组件。
         */
        component: PhysicsColliderComponent;
        /**
         * @en Get the capability of the collider.
         * @param value The capability value to check.
         * @zh 获取碰撞器的能力。
         * @param value 要检查的能力值。
         */
        getCapable(value: number): boolean;
        /**
         * @en Set the collider shape.
         * @param shape The collider shape to set.
         * @zh 设置碰撞器形状。
         * @param shape 要设置的碰撞器形状。
         */
        setColliderShape(shape: IColliderShape): void;
        /**
         * @en Destroy the collider.
         * @zh 销毁碰撞器。
         */
        destroy(): void;
        /**
         * @en Set the collision group of the collider.
         * @param value The collision group value.
         * @zh 设置碰撞器的碰撞组。
         * @param value 碰撞组的值。
         */
        setCollisionGroup(value: number): void;
        /**
         * @en Set the groups that this collider can collide with.
         * @param value The collision mask value.
         * @zh 设置此碰撞器可以与之碰撞的组。
         * @param value 碰撞掩码的值。
         */
        setCanCollideWith(value: number): void;
        /**
         * @en Set the owner node of the collider.
         * @param node The owner node to set.
         * @zh 设置碰撞器的所有者节点。
         * @param node 要设置的所有者节点。
         */
        setOwner(node: Node): void;
        /**
         * @en Handle transform changes of the collider.
         * @param flag The transform change flag.
         * @zh 处理碰撞器的变换改变。
         * @param flag 变换改变标志。
         */
        transformChanged(flag: number): void;
        /**
         * @en Set the bounciness of the collider.
         * @param value The bounciness value.
         * @zh 设置碰撞器的弹性。
         * @param value 弹性值。
         */
        setBounciness?(value: number): void;
        /**
         * @en Set the friction of the collider.
         * @param value The friction value.
         * @zh 设置碰撞器的摩擦力。
         * @param value 摩擦力值。
         */
        setfriction?(value: number): void;
        /**
         * @en Set the rolling friction of the collider.
         * @param value The rolling friction value.
         * @zh 设置碰撞器的滚动摩擦力。
         * @param value 滚动摩擦力值。
         */
        setRollingFriction?(value: number): void;
        /**
         * @en Set the dynamic friction of the collider.
         * @param value The dynamic friction value.
         * @zh 设置碰撞器的动态摩擦力。
         * @param value 动态摩擦力值。
         */
        setDynamicFriction?(value: number): void;
        /**
         * @en Set the static friction of the collider.
         * @param value The static friction value.
         * @zh 设置碰撞器的静态摩擦力。
         * @param value 静态摩擦力值。
         */
        setStaticFriction?(value: number): void;
        /**
         * @en Set the friction combine mode of the collider.
         * @param value The friction combine mode.
         * @zh 设置碰撞器的摩擦力合并模式。
         * @param value 摩擦力合并模式。
         */
        setFrictionCombine?(value: PhysicsCombineMode): void;
        /**
         * @en Set the bounce combine mode of the collider.
         * @param value The bounce combine mode.
         * @zh 设置碰撞器的弹性合并模式。
         * @param value 弹性合并模式。
         */
        setBounceCombine?(value: PhysicsCombineMode): void;
        /**
         * @en Set the event filter for the collider.
         * @param events An array of event names to filter.
         * @zh 设置碰撞器的事件过滤器。
         * @param events 要过滤的事件数组。
         */
        setEventFilter?(events: string[]): void;
        /**
         * @en Set whether the collider allows sleep.
         * @param value Whether the collider allows sleep.
         * @zh 设置碰撞器是否允许睡眠。
         * @param value 是否允许睡眠。
         */
        allowSleep(value: boolean): void;
    }
    /**
     * @en Interface of physics dynamic collider.
     * @zh 物理动态碰撞器的接口。
     */
    interface IDynamicCollider extends ICollider {
        /**
         * @en Sets the linear damping coefficient.
         * @param value Linear damping coefficient.
         * @zh 设置线性阻尼系数。
         * @param value 线性阻尼系数。
         */
        setLinearDamping(value: number): void;
        /**
         * @en Sets the angular damping coefficient.
         * @param value Angular damping coefficient.
         * @zh 设置角度阻尼系数。
         * @param value 角度阻尼系数。
         */
        setAngularDamping(value: number): void;
        /**
         * @en Sets the linear velocity of the actor.
         * @param value New linear velocity of actor.
         * @zh 设置物体的线性速度。
         * @param value 物体的新线性速度。
         */
        setLinearVelocity(value: Vector3): void;
        /**
         * @en Get the linear velocity of the actor.
         * @zh 获取物体的线性速度。
         */
        getLinearVelocity(): Vector3;
        /**
         * @en Sets the angular velocity of the actor.
         * @param value New angular velocity of actor.
         * @zh 设置物体的角速度。
         * @param value 物体的新角速度。
         */
        setAngularVelocity(value: Vector3): void;
        /**
         * @en Gets the angular velocity of the actor.
         * @zh 获取物体的角速度。
         */
        getAngularVelocity(): Vector3;
        /**
         * @en Sets the mass of a dynamic actor.
         * @param value New mass value for the actor.
         * @zh 设置动态物体的质量。
         * @param value 物体的新质量值。
         */
        setMass(value: number): void;
        /**
         * @en Sets the pose of the center of mass relative to the actor.
         * @param value Mass frame offset transform relative to the actor frame.
         * @zh 设置质心相对于物体的位置。
         * @param value 质心相对于物体框架的偏移变换。
         */
        setCenterOfMass(value: Vector3): void;
        /**
         * @en Sets the inertia tensor, using a parameter specified in mass space coordinates.
         * @param value New mass space inertia tensor for the actor.
         * @zh 设置惯性张量，使用质量空间坐标中指定的参数。
         * @param value 物体的新质量空间惯性张量。
         */
        setInertiaTensor(value: Vector3): void;
        /**
         * @en Set the linear velocity threshold for the rigid body to sleep.
         * @param value The linear velocity threshold.
         * @zh 设置刚体进入睡眠状态的线速度阈值。
         * @param value 线速度睡眠阈值。
         */
        setSleepThreshold(value: number): void;
        /**
         * @en Set the angular velocity threshold for the rigid body to sleep.
         * @param value The angular velocity threshold.
         * @zh 设置刚体进入睡眠状态的角速度阈值。
         * @param value 角速度阈值。
         */
        setSleepAngularThreshold?(value: number): void;
        /**
        * @en Whether it is sleeping.
        * @zh 是否处于睡眠状态。
        */
        isSleeping(): boolean;
        /**
         * @en Sets the colliders' collision detection mode.
         * @param value Rigid body flag.
         * @zh 设置碰撞器的碰撞检测模式。
         * @param value 刚体标志。
         */
        setCollisionDetectionMode(value: number): void;
        /**
         * @en Controls whether physics affects the dynamic collider.
         * @param value Whether physics affects the dynamic collider.
         * @zh 控制物理是否影响动态碰撞器。
         * @param value 物理是否影响动态碰撞器。
         */
        setIsKinematic(value: boolean): void;
        /**
         * @en Raises or clears a particular rigid dynamic lock flag.
         * @param linearFactor Linear constraint factor.
         * @param angularFactor Angular constraint factor.
         * @zh 设置或清除特定的刚体动态锁定标志。
         * @param linearFactor 线性约束因子。
         * @param angularFactor 角度约束因子。
         */
        setConstraints(linearFactor: Vector3, angularFactor: Vector3): void;
        /**
         * @en Apply a force to the dynamic collider.
         * @param force The force to make the collider move.
         * @param mode The mode of applying the force.
         * @param localOffset The local offset where the force is applied.
         * @zh 对动态碰撞器施加力。
         * @param force 使碰撞器移动的力。
         * @param mode 施加力的模式。
         * @param localOffset 力施加的局部偏移。
         */
        addForce(force: Vector3, mode: PhysicsForceMode, localOffset: Vector3): void;
        /**
         * @en Apply a torque to the dynamic collider.
         * @param torque The torque to make the collider rotate.
         * @param mode The mode of applying the torque.
         * @zh 对动态碰撞器施加扭矩。
         * @param torque 使碰撞器旋转的扭矩。
         * @param mode 施加扭矩的模式。
         */
        addTorque(torque: Vector3, mode: PhysicsForceMode): void;
        /**
         * @en Forces a collider to sleep at least one frame.
         * @zh 强制碰撞器至少休眠一帧。
         */
        sleep?(): void;
        /**
         * @en Forces a collider to wake up.
         * @zh 强制唤醒碰撞器。
         */
        wakeUp(): void;
        /**
         * @en Sets the world position of the collider.
         * @param value The new world position.
         * @zh 设置碰撞器的世界位置。
         * @param value 位置。
         */
        setWorldPosition(value: Vector3): void;
        /**
         * @en Sets the world rotation of the collider.
         * @param value The new world rotation.
         * @zh 设置碰撞器的世界旋转。
         * @param value 旋转四元数。
         */
        setWorldRotation(value: Quaternion): void;
        /**
         * @en Sets whether the collider is a trigger.
         * @param value Whether the collider is a trigger.
         * @zh 设置碰撞器是否为触发器。
         * @param value 碰撞器是否为触发器。
         */
        setTrigger(value: boolean): void;
    }
    /**
     * @en Interface for physics creation utility.
     * @zh 物理创建工具接口。
     */
    interface IPhysicsCreateUtil {
        /**
         * @en Initialize the physics system.
         * @zh 初始化物理。
         */
        initialize(): Promise<void>;
        /**
         * @en Set the physics engine capabilities.
         * @zh 设置物理引擎能力。
         */
        initPhysicsCapable(): void;
        /**
         * @en Get the physics engine capability.
         * @param value The capability to check.
         * @zh 获取物理引擎能力。
         * @param value 要检查的能力。
         */
        getPhysicsCapable(value: EPhysicsCapable): boolean;
        /**
         * @en Create a physics manager.
         * @param physicsSettings The physics settings.
         * @zh 创建物理管理器。
         * @param physicsSettings 物理设置。
         */
        createPhysicsManger(physicsSettings: PhysicsSettings): IPhysicsManager;
        /**
         * @en Create a dynamic collider.
         * @param manager The physics manager.
         * @zh 创建动态碰撞体。
         * @param manager 物理管理器。
         */
        createDynamicCollider(manager: IPhysicsManager): IDynamicCollider;
        /**
         * @en Create a static collider.
         * @param manager The physics manager.
         * @zh 创建静态碰撞体。
         * @param manager 物理管理器。
         */
        createStaticCollider(manager: IPhysicsManager): IStaticCollider;
        /**
         * @en Create a character controller.
         * @param manager The physics manager.
         * @zh 创建角色碰撞器。
         * @param manager 物理管理器。
         */
        createCharacterController(manager: IPhysicsManager): ICharacterController;
        /**
         * @en Create fixed joint.
         * @param manager The physics manager.
         * @zh 创建固定关节。
         * @param manager 物理管理器。
         */
        createFixedJoint(manager: IPhysicsManager): IFixedJoint;
        /**
         * @en Create hinge joint.
         * @param manager The physics manager.
         * @zh 创建铰链关节。
         * @param manager 物理管理器。
         */
        createHingeJoint(manager: IPhysicsManager): IHingeJoint;
        /**
         * @en Create spring joint.
         * @param manager The physics manager.
         * @zh 创建弹簧关节。
         * @param manager 物理管理器。
         */
        createSpringJoint(manager: IPhysicsManager): ISpringJoint;
        /**
         * @en Create Custom Joint.
         * @param manager The physics manager.
         * @zh 创建自定义关节。
         * @param manager 物理管理器。
         */
        createD6Joint(manager: IPhysicsManager): ID6Joint;
        /**
         * @en Create box collider shape.
         * @zh 创建盒形碰撞器形状。
         */
        createBoxColliderShape(): IBoxColliderShape;
        /**
         * @en Create sphere collider shape.
         * @zh 创建球形碰撞器形状。
         */
        createSphereColliderShape(): ISphereColliderShape;
        /**
         * @en Create plane collider shape.
         * @zh 创建平面碰撞器形状。
         */
        createPlaneColliderShape(): IPlaneColliderShape;
        /**
         * @en Create capsule collider shape.
         * @zh 创建胶囊碰撞器形状。
         */
        createCapsuleColliderShape?(): ICapsuleColliderShape;
        /**
         * @en Create mesh collider shape.
         * @zh 创建网格碰撞器形状。
         */
        createMeshColliderShape?(): IMeshColliderShape;
        /**
         * @en Create cylinder collider shape.
         * @zh 创建圆柱碰撞器形状。
         */
        createCylinderColliderShape?(): ICylinderColliderShape;
        /**
         * @en Create cone collider shape.
         * @zh 创建圆锥碰撞器形状。
         */
        createConeColliderShape?(): IConeColliderShape;
        /**
         * @en Create height field shape.
         * @zh 创建高度场形状。
         */
        createHeightFieldShape?(): IHeightFieldShape;
        /**
         * @en Create compound collider shape.
         * @zh 创建组合碰撞形状。
         */
        createCompoundShape(): ICompoundColliderShape;
        /**
         * @en Create curve mesh.
         * @param mesh The input mesh.
         * @zh 创建曲线网格。
         * @param mesh 输入的网格。
         */
        createCorveMesh?(mesh: Mesh): Mesh;
    }
    /**
     * @en Interface for physics manager.
     * @zh 物理管理器的接口。
     */
    interface IPhysicsManager {
        /**
         * @en Set gravity for the physics world.
         * @param gravity Physics gravity vector.
         * @zh 设置物理世界的重力。
         * @param gravity 物理重力向量。
         */
        setGravity(gravity: Vector3): void;
        /**
         * @en Add ICollider into the manager.
         * @param collider StaticCollider or DynamicCollider to be added.
         * @zh 向物理管理器添加碰撞器。
         * @param collider 要添加的静态碰撞器或动态碰撞器。
         */
        addCollider(collider: ICollider): void;
        /**
         * @en Set whether the collider is active.
         * @param collider The collider to set active state.
         * @param value Whether the collider is active.
         * @zh 是否启用碰撞器。
         * @param collider 要设置启用状态的碰撞器。
         * @param value 碰撞器是否处于启用状态。
         */
        setActiveCollider(collider: ICollider, value: boolean): void;
        /**
         * @en Remove ICollider from the physics manager.
         * @param collider StaticCollider or DynamicCollider to be removed.
         * @zh 从物理管理器中移除碰撞器。
         * @param collider 要移除的静态碰撞器或动态碰撞器。
         */
        removeCollider(collider: ICollider): void;
        /**
         * @en Update the physics world, called on every frame to update object poses.
         * @param elapsedTime Step time for the update.
         * @zh 更新物理世界，每帧调用以更新对象姿态。
         * @param elapsedTime 更新的步进时间。
         */
        update(elapsedTime: number): void;
        /**
         * @en Perform a raycast to find the first collision.
         * @param ray The ray to cast.
         * @param outHitResult The result of the raycast.
         * @param distance Maximum distance of the raycast.
         * @param collisonGroup Collision group for filtering.
         * @param collisionMask Collision mask for filtering.
         * @zh 执行射线检测以找到第一个碰撞。
         * @param ray 要投射的射线。
         * @param outHitResult 射线检测的结果。
         * @param distance 射线检测的最大距离。
         * @param collisonGroup 用于过滤的碰撞组。
         * @param collisionMask 用于过滤的碰撞掩码。
         */
        rayCast?(ray: Ray, outHitResult: HitResult, distance?: number, collisonGroup?: number, collisionMask?: number): boolean;
        /**
         * @en Perform a raycast to find all collisions.
         * @param ray The ray to cast.
         * @param out Array to store all hit results.
         * @param distance Maximum distance of the raycast.
         * @param collisonGroup Collision group for filtering.
         * @param collisionMask Collision mask for filtering.
         * @zh 执行射线检测以找到所有碰撞。
         * @param ray 要投射的射线。
         * @param out 用于存储所有命中结果的数组。
         * @param distance 射线检测的最大距离。
         * @param collisonGroup 用于过滤的碰撞组。
         * @param collisionMask 用于过滤的碰撞掩码。
         */
        rayCastAll?(ray: Ray, out: HitResult[], distance?: number, collisonGroup?: number, collisionMask?: number): boolean;
        /**
         * @en Enable or disable the debug drawer.
         * @param value Whether to enable the debug drawer.
         * @zh 启用或禁用调试器。
         * @param value 是否启用调试器。
         */
        enableDebugDrawer?(value: boolean): void;
        /**
         * @en Destroy the physics manager.
         * @zh 销毁物理管理器。
         */
        destroy(): void;
        /**
         * @en Perform a shape cast to find the first collision.
         * @param shape The shape to cast.
         * @param fromPosition Start position of the cast.
         * @param toPosition End position of the cast.
         * @param out The result of the shape cast.
         * @param fromRotation Start rotation of the cast.
         * @param toRotation End rotation of the cast.
         * @param collisonGroup Collision group for filtering.
         * @param collisionMask Collision mask for filtering.
         * @param allowedCcdPenetration Allowed continuous collision detection penetration.
         * @zh 执行形状投射以找到第一个碰撞。
         * @param shape 要投射的形状。
         * @param fromPosition 投射的起始位置。
         * @param toPosition 投射的结束位置。
         * @param out 形状投射的结果。
         * @param fromRotation 投射的起始旋转。
         * @param toRotation 投射的结束旋转。
         * @param collisonGroup 用于过滤的碰撞组。
         * @param collisionMask 用于过滤的碰撞掩码。
         * @param allowedCcdPenetration 允许的连续碰撞检测穿透。
         */
        shapeCast(shape: IColliderShape, fromPosition: Vector3, toPosition: Vector3, out: HitResult, fromRotation?: Quaternion, toRotation?: Quaternion, collisonGroup?: number, collisionMask?: number, allowedCcdPenetration?: number): boolean;
        /**
         * @en Perform a shape cast to find all collisions.
         * @param shape The shape to cast.
         * @param fromPosition Start position of the cast.
         * @param toPosition End position of the cast.
         * @param out Array to store all hit results.
         * @param fromRotation Start rotation of the cast.
         * @param toRotation End rotation of the cast.
         * @param collisonGroup Collision group for filtering.
         * @param collisionMask Collision mask for filtering.
         * @param allowedCcdPenetration Allowed continuous collision detection penetration.
         * @zh 执行形状投射以找到所有碰撞。
         * @param shape 要投射的形状。
         * @param fromPosition 投射的起始位置。
         * @param toPosition 投射的结束位置。
         * @param out 用于存储所有命中结果的数组。
         * @param fromRotation 投射的起始旋转。
         * @param toRotation 投射的结束旋转。
         * @param collisonGroup 用于过滤的碰撞组。
         * @param collisionMask 用于过滤的碰撞掩码。
         * @param allowedCcdPenetration 允许的连续碰撞检测穿透。
         */
        shapeCastAll(shape: IColliderShape, fromPosition: Vector3, toPosition: Vector3, out: HitResult[], fromRotation?: Quaternion, toRotation?: Quaternion, collisonGroup?: number, collisionMask?: number, allowedCcdPenetration?: number): boolean;
    }
    /**
     * @en Interface for physics material.
     * @zh 物理材质的接口。
     */
    interface IPhysicsMaterial {
        /**
         * @en Sets the bounciness.
         * @param value The bounciness value.
         * @zh 设置弹力。
         * @param value 弹力值。
         */
        setBounciness(value: number): void;
        /**
         * @en Sets the dynamic friction.
         * @param value The dynamic friction.
         * @zh 设置动态摩擦力。
         * @param value 动态摩擦力值。
         */
        setDynamicFriction(value: number): void;
        /**
         * @en Sets the static friction.
         * @param value The static friction.
         * @zh 设置静态摩擦力。
         * @param value 静态摩擦力值。
         */
        setStaticFriction(value: number): void;
        /**
         * @en Sets the bounce combine mode.
         * @param value The bounce combine mode.
         * @zh 设置弹性组合模式。
         * @param value 弹力组合模式。
         */
        setBounceCombine(value: number): void;
        /**
         * @en Sets the friction combine mode.
         * @param value The friction combine mode.
         * @zh 设置摩擦组合模式。
         * @param value 摩擦力组合模式。
         */
        setFrictionCombine(value: number): void;
        /**
         * @en Decrements the reference count of a material and releases it if the new reference count is zero.
         * @zh 减少材质的引用计数，如果新的引用计数为零则释放它。
         */
        destroy(): void;
    }
    /**
     * @en Interface for static physics collider.
     * @zh 静态物理碰撞器的接口。
     */
    interface IStaticCollider extends ICollider {
        /**
         * @en Sets whether the collider is a trigger.
         * @param value Whether the collider is a trigger.
         * @zh 设置碰撞器是否为触发器。
         * @param value 碰撞器是否为触发器。
         */
        setTrigger(value: boolean): void;
    }
    /**
     * @en Interface for custom joints in the physics system.
     * @zh 用于物理系统中自定义关节的接口。
     */
    interface ICustomJoint extends IJoint {
    }
    /**
     * @en Enumeration of motion types for a 6-degree-of-freedom joint.
     * @zh 6自由度关节的运动类型枚举。
     */
    enum D6MotionType {
        /**
         * @en Motion along the X axis
         * @zh X轴方向的运动
         */
        eX = 0,
        /**
         * @en Motion along the Y axis
         * @zh Y轴方向的运动
         */
        eY = 1,
        /**
         * @en Motion along the Z axis
         * @zh Z轴方向的运动
         */
        eZ = 2,
        /**
         * @en Motion around the X axis
         * @zh 绕X轴的运动
         */
        eTWIST = 3,
        /**
         * @en Motion around the Y axis
         * @zh 绕Y轴的运动
         */
        eSWING1 = 4,
        /**
         * @en Motion around the Z axis
         * @zh 绕Z轴的运动
         */
        eSWING2 = 5
    }
    /**
     * @en Enumeration of axis states for a 6-degree-of-freedom joint.
     * @zh 6自由度关节的轴状态枚举。
     */
    enum D6Axis {
        /**
         * @en The degree of freedom is locked, not allowing relative motion.
         * @zh 自由度被锁定，不允许相对运动。
         */
        eLOCKED = 0,
        /**
         * @en The degree of freedom is limited, only allowing motion within a specific range.
         * @zh 自由度受限，只允许在特定范围内运动。
         */
        eLIMITED = 1,
        /**
         * @en The degree of freedom is free, allowing its full range of motion.
         * @zh 自由度是自由的，允许其全范围运动。
         */
        eFREE = 2
    }
    /**
     * @en Enumeration of drive types for a 6-degree-of-freedom joint.
     * @zh 6自由度关节的驱动类型枚举。
     */
    enum D6Drive {
        /**
         * @en Drive along the X-axis
         * @zh 沿X轴驱动
         */
        eX = 0,
        /**
         * @en Drive along the Y-axis
         * @zh 沿Y轴驱动
         */
        eY = 1,
        /**
         * @en Drive along the Z-axis
         * @zh 沿Z轴驱动
         */
        eZ = 2,
        /**
         * @en Drive of displacement from the X-axis
         * @zh 相对于X轴的位移驱动
         */
        eSWING = 3,
        /**
         * @en Drive of the displacement around the X-axis
         * @zh 绕X轴的位移驱动
         */
        eTWIST = 4,
        /**
         * @en Drive of all three angular degrees along a SLERP-path
         * @zh 沿SLERP路径的三个角度自由度的驱动
         */
        eSLERP = 5
    }
    /**
     * @en Interface for a 6-degree-of-freedom joint in the physics system.
     * @zh 物理系统中6自由度关节的接口。
     */
    interface ID6Joint extends IJoint {
        /**
         * @en Set the primary and secondary axes for the joint.
         * @param axis The primary axis.
         * @param secendary The secondary axis.
         * @zh 设置关节的主轴和次轴。
         * @param axis 主轴。
         * @param secendary 次轴。
         */
        setAxis(axis: Vector3, secendary: Vector3): void;
        /**
         * @en Set the motion type around the specified axis.
         * @param axis The axis to set.
         * @param motionType The type of motion to set.
         * @zh 设置指定轴的运动类型。
         * @param axis 轴。
         * @param motionType 运动类型。
         */
        setMotion(axis: D6Axis, motionType: D6MotionType): void;
        /**
         * @en Set Distance limit Params
         * @param limit The distance limit.
         * @param bounciness The bounciness of the limit.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring coefficient.
         * @param damp The damping coefficient.
         * @zh 设置关节的距离限制参数。
         * @param limit 距离限制。
         * @param bounciness 限制的弹性。
         * @param bounceThreshold 弹跳阈值。
         * @param spring 弹簧系数。
         * @param damp 阻尼系数。
         */
        setDistanceLimit(limit: number, bounciness: number, bounceThreshold: number, spring: number, damp: number): void;
        /**
         * @en x,y,z linear Limit.
         * @param linearAxis The axis to set the limit for.
         * @param upper The upper limit.
         * @param lower The lower limit.
         * @param bounciness The bounciness of the limit.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring coefficient.
         * @param damping The damping coefficient.
         * @zh 设置x,y,z轴的线性限制。
         * @param linearAxis 轴。
         * @param upper 上限。
         * @param lower 下限。
         * @param bounciness 弹性。
         * @param bounceThreshold 弹跳阈值。
         * @param spring 弹簧系数。
         * @param damping 阻尼系数。
         */
        setLinearLimit(linearAxis: D6MotionType, upper: number, lower: number, bounciness: number, bounceThreshold: number, spring: number, damping: number): void;
        /**
         * @en The twist limit controls the range of motion around the twist axis.
         * @param upper The upper limit of the twist.
         * @param lower The lower limit of the twist.
         * @param bounciness The bounciness of the limit.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring coefficient.
         * @param damping The damping coefficient.
         * @zh 扭转限制控制绕扭转轴的运动范围。
         * @param upper 扭转轴的上限。
         * @param lower 扭转轴的下限。
         * @param bounciness 弹性。
         * @param bounceThreshold 弹跳阈值。
         * @param spring 弹簧系数。
         * @param damping 阻尼系数。
         */
        setTwistLimit(upper: number, lower: number, bounciness: number, bounceThreshold: number, spring: number, damping: number): void;
        /**
         * @en Set the cone-like swing limit for the joint.
         * @param yAngle The angle limit around the Y axis.
         * @param zAngle The angle limit around the Z axis.
         * @param bounciness The bounciness of the limit.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring coefficient.
         * @param damping The damping coefficient.
         * @zh 设置关节的锥形摆动限制。
         * @param yAngle Y轴的角度限制。
         * @param zAngle Z轴的角度限制。
         * @param bounciness 弹性。
         * @param bounceThreshold 弹跳阈值。
         * @param spring 弹簧系数。
         * @param damping 阻尼系数。
         */
        setSwingLimit(yAngle: number, zAngle: number, bounciness: number, bounceThreshold: number, spring: number, damping: number): void;
        /**
         * @en Set the drive parameters for a specific drive type.
         * @param index The drive type to set.
         * @param stiffness The stiffness of the drive.
         * @param damping The damping of the drive.
         * @param forceLimit The force limit of the drive.
         * @zh 设置特定驱动类型的驱动参数。
         * @param index 驱动类型。
         * @param stiffness 刚度。
         * @param damping 阻尼。
         * @param forceLimit 力限。
         */
        setDrive(index: D6Drive, stiffness: number, damping: number, forceLimit: number): void;
        /**
         * @en Set the drive transform for the joint.
         * @param position The target position.
         * @param rotate The target rotation.
         * @zh 设置关节的驱动变换。
         * @param position 目标位置。
         * @param rotate 目标旋转。
         */
        setDriveTransform(position: Vector3, rotate: Quaternion): void;
        /**
         * @en Set the drive velocity for the joint.
         * @param position The linear velocity.
         * @param angular The angular velocity.
         * @zh 设置关节的驱动速度。
         * @param position 线速度。
         * @param angular 角速度。
         */
        setDriveVelocity(position: Vector3, angular: Vector3): void;
        /**
         * @en Get the twist angle of the joint, in the range (-2*Pi, 2*Pi].
         * @zh 获取关节的扭转角度，范围为(-2*Pi, 2*Pi]。
         */
        getTwistAngle(): number;
        /**
         * @en Get the swing angle of the joint from the Y axis.
         * @zh 获取关节相对于Y轴的摆动角度。
         */
        getSwingYAngle(): number;
        /**
         * @en Get the swing angle of the joint from the Z axis.
         * @zh 获取关节相对于Z轴的摆动角度。
         */
        getSwingZAngle(): number;
    }
    /**
     * @en Interface for a fixed joint in the physics system.
     * @zh 物理系统中固定关节的接口。
     */
    interface IFixedJoint extends IJoint {
    }
    /**
     * @en Interface for a hinge joint.
     * @zh 铰链关节接口。
     */
    interface IHingeJoint extends IJoint {
        /**
         * @en Sets the axis of rotation for the hinge joint.
         * @param value The axis vector to set.
         * @zh 设置铰链关节的旋转轴。
         * @param value 要设置的轴向量。
         */
        setAxis(value: Vector3): void;
        /**
         * @en The current angle in degrees of the joint relative to its rest position.
         * @zh 当前关节相对于其静止位置的角度。
         */
        getAngle(): number;
        /**
         * @en The angular velocity of the joint in degrees per second.
         * @zh 关节的角速度（以度/秒为单位）。
         */
        getVelocity(): Readonly<Vector3>;
        /**
         * @en Sets the lower limit of the joint's rotation.
         * @param lowerLimit The lower limit value in degrees.
         * @zh 设置关节旋转的下限。
         * @param lowerLimit 下限值（以度为单位）。
         */
        setLowerLimit(lowerLimit: number): void;
        /**
         * @en Sets the upper limit of the joint's rotation.
         * @param value The upper limit value in degrees.
         * @zh 设置关节旋转的上限。
         * @param value 上限值（以度为单位）。
         */
        setUpLimit(value: number): void;
        /**
         * @en Sets the bounciness of the joint.
         * @param value The bounciness value.
         * @zh 设置关节的反弹性。
         * @param value 反弹性值。
         */
        setBounceness(value: number): void;
        /**
         * @en Sets the minimum velocity required for the joint to bounce.
         * @param value The minimum bounce velocity.
         * @zh 设置关节反弹所需的最小速度。
         * @param value 最小反弹速度。
         */
        setBouncenMinVelocity(value: number): void;
        /**
         * @en Sets the contact distance for the joint.
         * @param value The contact distance value.
         * @zh 设置关节的接触距离。
         * @param value 接触距离值。
         */
        setContactDistance(value: number): void;
        /**
         * @en Enables or disables the joint's rotation limit.
         * @param value True to enable the limit, false to disable.
         * @zh 启用或禁用关节的旋转限制。
         * @param value 为true时启用限制，为false时禁用。
         */
        enableLimit(value: boolean): void;
        /**
         * @en Enables or disables the joint's drive.
         * @param value True to enable the drive, false to disable.
         * @zh 启用或禁用关节的驱动。
         * @param value 为true时启用驱动，为false时禁用。
         */
        enableDrive(value: boolean): void;
        /**
         * @en Enables or disables free spin for the joint.
         * @param value True to enable free spin, false to disable.
         * @zh 启用或禁用关节的自由旋转。
         * @param value 为true时启用自由旋转，为false时禁用。
         */
        enableFreeSpin(value: boolean): void;
        /**
         * @en Sets the target velocity for the drive model.
         * @param velocity The drive target velocity.
         * @zh 设置驱动模型的目标速度。
         * @param velocity 驱动目标速度。
         */
        setDriveVelocity(velocity: number): void;
        /**
         * @en Sets the maximum torque the drive can exert.
         * @param limit The maximum torque value.
         * @zh 设置驱动可施加的最大扭矩。
         * @param limit 最大扭矩值。
         */
        setDriveForceLimit(limit: number): void;
    }
    /**
     * @en Interface for a joint in a physics system.
     * @zh 物理系统中关节的接口。
     */
    interface IJoint {
        /**
         * @en Sets the owner node of the joint.
         * @param value The node to set as the owner.
         * @zh 设置关节的所有者节点。
         * @param value 要设置为所有者的节点。
         */
        setOwner(value: Node): void;
        /**
         * @en Sets the collider for this joint.
         * @param owner The collider to set.
         * @zh 设置此关节的碰撞体。
         * @param owner 要设置的碰撞体。
         */
        setCollider(owner: ICollider): void;
        /**
         * @en Sets the connected collider for this joint.
         * @param owner The collider to connect to.
         * @zh 设置此关节连接的碰撞体。
         * @param owner 要连接的碰撞体。
         */
        setConnectedCollider(owner: ICollider): void;
        /**
         * @en The scale to apply to the inverse mass of collider 0 for resolving this constraint.
         * @param value The scale value to set.
         * @zh 设置应用于连接碰撞体逆质量的缩放比例，用于解析此约束。
         * @param value 要设置的缩放值。
         */
        setConnectedMassScale(value: number): void;
        /**
         * @en The scale to apply to the inverse inertia of collider0 for resolving this constraint.
         * @param value The scale value to set.
         * @zh 设置应用于连接碰撞体逆惯性的缩放比例，用于解析此约束。
         * @param value 要设置的缩放值。
         */
        setConnectedInertiaScale(value: number): void;
        /**
         * @en The scale to apply to the inverse mass of collider 1 for resolving this constraint.
         * @param value The scale value to set.
         * @zh 设置应用于主碰撞体逆质量的缩放比例，用于解析此约束。
         * @param value 要设置的缩放值。
         */
        setMassScale(value: number): void;
        /**
         * @en The scale to apply to the inverse inertia of collider1 for resolving this constraint.
         * @param value The scale value to set.
         * @zh 设置应用于主碰撞体逆惯性的缩放比例，用于解析此约束。
         * @param value 要设置的缩放值。
         */
        setInertiaScale(value: number): void;
        /**
         * @en The maximum force the joint can apply before breaking.
         * @param value The maximum force value.
         * @zh 设置关节在断裂前可施加的最大力。
         * @param value 最大力值。
         */
        setBreakForce(value: number): void;
        /**
         * @en The maximum torque the joint can apply before breaking.
         * @param value The maximum torque value.
         * @zh 设置关节在断裂前可施加的最大扭矩。
         * @param value 最大扭矩值。
         */
        setBreakTorque(value: number): void;
        /**
         * @en Sets the local anchor/frame position for the main actor.
         * @param pos The local position to set.
         * @zh 设置主执行体的本地锚点/框架位置。
         * @param pos 要设置的本地位置。
         */
        setLocalPos(pos: Vector3): void;
        /**
         * @en Sets the local anchor/frame position for the connected actor.
         * @param pos The local position to set.
         * @zh 设置连接执行体的本地锚点/框架位置。
         * @param pos 要设置的本地位置。
         */
        setConnectLocalPos(pos: Vector3): void;
        /**
         * @en Gets the linear force applied by the joint.
         * @zh 获取关节施加的线性力。
         */
        getlinearForce(): Vector3;
        /**
         * @en Gets the angular force applied by the joint.
         * @zh 获取关节施加的角力。
         */
        getAngularForce(): Vector3;
        /**
         * @en Checks if the joint is still valid (not broken).
         * @zh 检查关节是否仍然有效（未断裂）。
         */
        isValid(): boolean;
        /**
         * @en Enables or disables the joint.
         * @param value True to enable, false to disable.
         * @zh 启用或禁用关节。
         * @param value 为true时启用，为false时禁用。
         */
        isEnable(value: boolean): void;
        /**
         * @en Sets whether collision is enabled between the connected bodies.
         * @param value True to enable collision, false to disable.
         * @zh 设置是否启用连接体之间的碰撞。
         * @param value 为true时启用碰撞，为false时禁用。
         */
        isCollision(value: boolean): void;
        /**
         * @en Destroy the joint.
         * @zh 销毁关节。
         */
        destroy(): void;
    }
    /**
     * @en Interface for a spring joint.
     * @zh 弹簧关节接口。
     */
    interface ISpringJoint extends IJoint {
        /**
         * @en Set the allowed minimum distance for the joint.
         * @param distance The minimum distance.
         * @zh 设置关节允许的最小距离。
         * @param distance 最小距离。
         */
        setMinDistance(distance: number): void;
        /**
         * @en Set the allowed maximum distance for the joint.
         * @param distance The maximum distance.
         * @zh 设置关节允许的最大距离。
         * @param distance 最大距离。
         */
        setMaxDistance(distance: number): void;
        /**
         * @en Set the error tolerance of the joint.
         * @param tolerance The distance beyond the allowed range at which the joint becomes active.
         * @zh 设置关节的误差容限。
         * @param tolerance 超出允许范围时关节变为活动状态的距离。
         */
        setTolerance(tolerance: number): void;
        /**
         * @en Set the strength of the joint spring.
         * @param stiffness The spring strength of the joint.
         * @zh 设置关节弹簧的强度。
         * @param stiffness 关节弹簧的强度。
         */
        setStiffness(stiffness: number): void;
        /**
         * @en Set the damping of the joint spring.
         * @param damping The degree of damping of the joint spring.
         * @zh 设置关节弹簧的阻尼。
         * @param damping 关节弹簧的阻尼程度。
         */
        setDamping(damping: number): void;
    }
    class Physics3DStatInfo {
        private static _PhysicsStatisticsInfo;
        /**
         * @en enable Physics Statistics
         * @zh 启动物理统计信息
         */
        static enableStatistics: boolean;
        /**
         * @en enable Frame ClearData
         * @zh 是否每帧自动清理
         */
        static autoFrameClear: boolean;
        /**
         * @en Initialize Physical Statistics Map
         * @zh 初始化物理统计信息表
         */
        static initStatisticsInfo(): void;
        /**
         * @en Set Physical Statistics Values
         * @param info Physical Statistics Enumeration
         * @param value value
         * @zh 设置物理统计信息值
         * @param info 物理统计信息枚举
         * @param value 值
         */
        static addStatisticsInfo(info: EPhysicsStatisticsInfo, value: number): void;
        /**
         * @en Get Physical Statistics Values
         * @param info Physical Statistics Enumeration
         * @returns Physical Statistics value
         * @zh 获取物理统计信息值
         * @param info 物理统计信息枚举
         * @returns 物理统计信息值
         */
        static getStatisticsInfo(info: EPhysicsStatisticsInfo): number;
        /**
         * @en Per Frame Cleanup of Physical Statistics
         * @zh 每帧清理物理统计信息
         */
        static clearStatisticsInfo(): void;
        /**
         * @en Stop Statistics
         * @zh 停止统计信息
         */
        static stopAndClearAllStatisticsInfo(): void;
    }
    /**
     * @en Interface for box collider shape.
     * @zh 盒形碰撞器的接口。
     */
    interface IBoxColliderShape extends IColliderShape {
        /**
         * @en Set size of Box Shape.
         * @param size The size of the box
         * @zh 设置盒子形状的大小。
         * @param size 盒子的大小
         */
        setSize(size: Vector3): void;
    }
    /**
     * @en Interface for capsule collider shape.
     * @zh 胶囊体碰撞器的接口。
     */
    interface ICapsuleColliderShape extends IColliderShape {
        /**
         * @en Set radius of capsule.
         * @param radius The radius of the capsule
         * @zh 设置胶囊体的半径。
         * @param radius 胶囊体的半径
         */
        setRadius(radius: number): void;
        /**
         * @en Set height of capsule.
         * @param height The height of the capsule
         * @zh 设置胶囊体的高度。
         * @param height 胶囊体的高度
         */
        setHeight(height: number): void;
        /**
         * @en Set up axis of capsule.
         * @param upAxis The up axis of the capsule
         * @zh 设置胶囊体的朝上轴。
         * @param upAxis 胶囊体的朝上轴
         */
        setUpAxis(upAxis: number): void;
    }
    /**
     * @en Interface for collider shape.
     * @zh 碰撞器形状的接口。
     */
    interface IColliderShape {
        /**
         * @en Set local position of the collider shape.
         * @param position The local position to set
         * @zh 设置碰撞器形状的局部位置。
         * @param position 要设置的局部位置
         */
        setOffset(position: Vector3): void;
        /**
         * @en Gets the local offset of the shape.
         * @returns The local offset of the shape.
         * @zh 获取形状的局部偏移。
         * @returns 局部偏移量。
         */
        getOffset(): Vector3;
        /**
         * @en Decrements the reference count of a shape and releases it if the new reference count is zero.
         * @zh 减少形状的引用计数，如果新的引用计数为零则释放它。
         */
        destroy(): void;
        /**
         * @en Gets the physics shape.
         * @returns The physics shape.
         * @zh 获取物理形状。
         * @returns 物理形状。
         */
        getPhysicsShape(): any;
    }
    /**
     * @en The `ICompoundColliderShape` interface defines the methods for managing compound collider shapes.
     * @zh `ICompoundColliderShape` 接口定义了用于管理组合碰撞器形状的方法。
     */
    interface ICompoundColliderShape extends IColliderShape {
        /**
         * @en Adds a child shape to the compound collider shape.
         * @param shape The child shape to add.
         * @zh 添加一个子形状到组合碰撞器形状。
         * @param shape 要添加的子形状。
         */
        addChildShape(shape: IColliderShape): void;
        /**
         * @en Removes a child shape from the compound collider shape.
         * @param shape The child shape to remove.
         * @param index The index of the child shape to remove.
         * @zh 从组合碰撞器形状中移除一个子形状。
         * @param shape 要移除的子形状。
         * @param index 要移除的子形状的索引。
         */
        removeChildShape(shape: IColliderShape, index: number): void;
        /**
         * @en Sets the data of the shape.
         * @param component The component to set the data.
         * @zh 设置形状的数据。
         * @param component 要设置数据的组件。
         */
        setShapeData?(component: PhysicsColliderComponent): void;
    }
    /**
     * @en Interface for cone collider shape.
     * @zh 锥体碰撞器的接口。
     */
    interface IConeColliderShape extends IColliderShape {
        /**
         * @en Set radius of the cone.
         * @param radius The radius of the cone base
         * @zh 设置锥体的半径。
         * @param radius 锥体底部的半径
         */
        setRadius(radius: number): void;
        /**
         * @en Set height of the cone.
         * @param height The height of the cone
         * @zh 设置锥体的高度。
         * @param height 锥体的高度
         */
        setHeight(height: number): void;
        /**
         * @en Set up axis of the cone.
         * @param upAxis The up axis of the cone
         * @zh 设置锥体的朝上轴。
         * @param upAxis 锥体的朝上轴
         */
        setUpAxis(upAxis: number): void;
    }
    /**
     * @en Interface for cylinder collider shape.
     * @zh 圆柱体碰撞器的接口。
     */
    interface ICylinderColliderShape extends IColliderShape {
        /**
         * @en Set radius of the cylinder.
         * @param radius The radius of the cylinder base
         * @zh 设置圆柱体的半径。
         * @param radius 圆柱体底面的半径
         */
        setRadius(radius: number): void;
        /**
         * @en Set height of the cylinder.
         * @param height The height of the cylinder
         * @zh 设置圆柱体的高度。
         * @param height 圆柱体的高度
         */
        setHeight(height: number): void;
        /**
         * @en Set up axis of the cylinder.
         * @param upAxis The up axis of the cylinder
         * @zh 设置圆柱体的朝上轴。
         * @param upAxis 圆柱体的朝上轴
         */
        setUpAxis(upAxis: number): void;
    }
    /**
     * @en Interface for height field shape.
     * @zh 高度场的接口。
     */
    interface IHeightFieldShape extends IColliderShape {
        /**
         * @en Set height field data.
         * @param numRows Number of rows in the height field
         * @param numCols Number of columns in the height field
         * @param heightData Array of height values
         * @param flag Array of flags for each cell
         * @param scale Scale of the height field
         * @zh 设置高度数据。
         * @param numRows 高度场的行数
         * @param numCols 高度场的列数
         * @param heightData 高度值数组
         * @param flag 每个单元格的标志数组
         * @param scale 高度场的缩放
         */
        setHeightFieldData(numRows: number, numCols: number, heightData: Float32Array, flag: Uint8Array, scale: Vector3): void;
        /**
         * @en Get the number of rows in the height field.
         * @zh 获取高度场的行数。
         */
        getNbRows(): number;
        /**
         * @en Get the number of columns in the height field.
         * @zh 获取高度场的列数。
         */
        getNbColumns(): number;
        /**
         * @en Get the height at a specific row and column.
         * @param rows Row index
         * @param cols Column index
         * @returns The height at the specified position
         * @zh 获取指定行列位置的高度。
         * @param rows 行索引
         * @param cols 列索引
         * @returns 指定位置的高度
         */
        getHeight(rows: number, cols: number): number;
    }
    /**
     * @en Interface for mesh collider shape.
     * @zh 网格碰撞器的接口。
     */
    interface IMeshColliderShape extends IColliderShape {
        /**
         * @en Create physics mesh from regular Mesh.
         * @param value The source Mesh to create physics mesh from
         * @zh 从常规网格创建物理网格。
         * @param value 用于创建物理网格的源网格
         */
        setPhysicsMeshFromMesh(value: Mesh): void;
        /**
         * @en Set convex mesh for the collider shape.
         * @param value The convex Mesh to set
         * @zh 为碰撞器形状设置凸多边形网格。
         * @param value 要设置的凸多边形网格
         */
        setConvexMesh(value: Mesh): void;
        /**
         * @en Set the vertex limit for mesh simplification.
         * @param limit The maximum number of vertices allowed
         * @zh 设置网格简化的顶点限制。
         * @param limit 允许的最大顶点数
         */
        setLimitVertex(limit: number): void;
    }
    interface IPlaneColliderShape extends IColliderShape {
    }
    /**
     * @en Interface for sphere collider shape.
     * @zh 球形碰撞器的接口。
     */
    interface ISphereColliderShape extends IColliderShape {
        /**
         * @en Set the radius of the sphere.
         * @param radius The radius of the sphere
         * @zh 设置球体的半径。
         * @param radius 球体的半径
         */
        setRadius(radius: number): void;
    }
    enum ECharacterCapable {
        /**
         * @en Gravity applied to the character.
         * @zh 应用于角色的重力。
         */
        Charcater_Gravity = 0,
        /**
         * @en Collision group for the character.
         * @zh 角色的碰撞分组。
         */
        Charcater_CollisionGroup = 1,
        /**
         * @en World position of the character.
         * @zh 角色在世界坐标中的位置。
         */
        Charcater_WorldPosition = 2,
        /**
         * @en Directional movement of the character.
         * @zh 角色的方向移动。
         */
        Charcater_Move = 3,
        /**
         * @en Jump capability of the character.
         * @zh 角色的跳跃能力。
         */
        Charcater_Jump = 4,
        /**
         * @en Step offset for the character.
         * @zh 角色的步幅偏移。
         */
        Charcater_StepOffset = 5,
        /**
         * @en Up direction of the character.
         * @zh 角色的向上方向。
         */
        Character_UpDirection = 6,
        /**
         * @en Fall speed of the character.
         * @zh 角色的下落速度。
         */
        Character_FallSpeed = 7,
        /**
         * @en Slope limit for the character.
         * @zh 角色的坡度限制。
         */
        Character_SlopeLimit = 8,
        /**
         * @en Force when character collides with other objects.
         * @zh 角色碰撞其他物体的力。
         */
        Character_PushForce = 9,
        /**
         * @en Radius of the character.
         * @zh 角色的半径。
         */
        Character_Radius = 10,
        /**
         * @en Height of the character.
         * @zh 角色的高度。
         */
        Character_Height = 11,
        /**
         * @en Offset of the character.
         * @zh 角色的偏移。
         */
        Character_offset = 12,
        /**
         * @en Skin of the character.
         * @zh 角色的皮肤。
         */
        Character_Skin = 13,
        /**
         * @en Minimum distance for the character.
         * @zh 角色的最小距离。
         */
        Character_minDistance = 14,
        /**
         * @en Event filter for the character controller.
         * @zh 角色控制器的事件过滤器。
         */
        Character_EventFilter = 15,
        /**
         * @en Simulate gravity for the character controller.
         * @zh 模拟角色控制器的重力。
         */
        Character_SimulateGravity = 16,
        /**
         * @en Whether the character is on the ground.
         * @zh 是否在地面上。
         */
        Character_IsOnGround = 17
    }
    enum EColliderCapable {
        /**
         * @en Collision group for the collider.
         * @zh 碰撞体的碰撞分组。
         */
        Collider_CollisionGroup = 0,
        /**
         * @en Friction of the collider.
         * @zh 碰撞体的摩擦力。
         */
        Collider_Friction = 1,
        /**
         * @en Rolling friction of the collider.
         * @zh 碰撞体的滚动摩擦力。
         */
        Collider_RollingFriction = 2,
        /**
         * @en Restitution (bounciness) of the collider.
         * @zh 碰撞体的弹力。
         */
        Collider_Restitution = 3,
        /**
         * @en Whether the collider supports triggers.
         * @zh 碰撞体是否支持触发器。
         */
        Collider_AllowTrigger = 4,
        /**
         * @en Dynamic friction of the collider.
         * @zh 碰撞体的动态摩擦力。
         */
        Collider_DynamicFriction = 5,
        /**
         * @en Static friction of the collider.
         * @zh 碰撞体的静态摩擦力。
         */
        Collider_StaticFriction = 6,
        /**
         * @en Bounce combine mode of the collider.
         * @zh 碰撞体的弹力组合模式。
         */
        Collider_BounceCombine = 7,
        /**
         * @en Friction combine mode of the collider.
         * @zh 碰撞体的摩擦力组合模式。
         */
        Collider_FrictionCombine = 8,
        /**
         * @en Event filter for the collider.
         * @zh 碰撞体的事件过滤器。
         */
        Collider_EventFilter = 9,
        /**
         * @en Collision detection mode for the collider.
         * @zh 碰撞体的碰撞检测模式。
         */
        Collider_CollisionDetectionMode = 10,
        /**
         * @en Whether the rigid body supports kinematic mode.
         * @zh 刚体是否支持运动学模式。
         */
        RigidBody_CanKinematic = 11,
        /**
         * @en Whether the rigid body supports sleeping.
         * @zh 刚体是否支持睡眠。
         */
        RigidBody_AllowSleep = 12,
        /**
         * @en Gravity applied to the rigid body.
         * @zh 应用于刚体的重力。
         */
        RigidBody_Gravity = 13,
        /**
         * @en Linear damping of the rigid body.
         * @zh 刚体的线性阻尼。
         */
        RigidBody_LinearDamp = 14,
        /**
         * @en Angular damping of the rigid body.
         * @zh 刚体的角度阻尼。
         */
        RigidBody_AngularDamp = 15,
        /**
         * @en Linear velocity of the rigid body.
         * @zh 刚体的线速度。
         */
        RigidBody_LinearVelocity = 16,
        /**
         * @en Angular velocity of the rigid body.
         * @zh 刚体的角速度。
         */
        RigidBody_AngularVelocity = 17,
        /**
         * @en Mass of the rigid body.
         * @zh 刚体的质量。
         */
        RigidBody_Mass = 18,
        /**
         * @en World position of the rigid body.
         * @zh 刚体在世界坐标中的位置。
         */
        RigidBody_WorldPosition = 19,
        /**
         * @en World orientation of the rigid body.
         * @zh 刚体在世界坐标中的旋转。
         */
        RigidBody_WorldOrientation = 20,
        /**
         * @en Inertia tensor of the rigid body.
         * @zh 刚体的惯性张量。
         */
        RigidBody_InertiaTensor = 21,
        /**
         * @en Center of mass of the rigid body.
         * @zh 刚体的重心。
         */
        RigidBody_MassCenter = 22,
        /**
         * @en Maximum angular velocity of the rigid body.
         * @zh 刚体的最大角速度。
         */
        RigidBody_MaxAngularVelocity = 23,
        /**
         * @en Maximum depenetration velocity of the rigid body.
         * @zh 刚体的最大侵入速度。
         */
        RigidBody_MaxDepenetrationVelocity = 24,
        /**
         * @en Sleep threshold of the rigid body.
         * @zh 刚体的睡眠阈值。
         */
        RigidBody_SleepThreshold = 25,
        /**
         * @en Sleep angular velocity of the rigid body.
         * @zh 刚体的睡眠角速度。
         */
        RigidBody_SleepAngularVelocity = 26,
        /**
         * @en Number of physics iterations for the rigid body.
         * @zh 刚体的物理迭代次数。
         */
        RigidBody_SolverIterations = 27,
        /**
         * @en Whether the rigid body supports dynamic switching of object types.
         * @zh 刚体是否支持动态切换物体类型。
         */
        RigidBody_AllowDetectionMode = 28,
        /**
         * @en Whether the rigid body supports kinematic mode.
         * @zh 刚体是否支持运动学模式。
         */
        RigidBody_AllowKinematic = 29,
        /**
         * @en Whether the rigid body supports character mode.
         * @zh 刚体是否支持角色模式。
         */
        RigidBody_AllowCharacter = 30,
        /**
         * @en Linear velocity scale factor of the rigid body.
         * @zh 刚体的线速度缩放因子。
         */
        RigidBody_LinearFactor = 31,
        /**
         * @en Angular velocity scale factor of the rigid body.
         * @zh 刚体的角速度缩放因子。
         */
        RigidBody_AngularFactor = 32,
        /**
         * @en Apply force to the rigid body.
         * @zh 对刚体施加力。
         */
        RigidBody_ApplyForce = 33,
        /**
         * @en Clear forces applied to the rigid body.
         * @zh 清除施加在刚体上的力。
         */
        RigidBody_ClearForce = 34,
        /**
         * @en Apply force at an offset position to the rigid body.
         * @zh 对刚体施加偏移位置的力。
         */
        RigidBody_ApplyForceWithOffset = 35,
        /**
         * @en Apply torque to the rigid body.
         * @zh 对刚体施加扭力。
         */
        RigidBody_ApplyTorque = 36,
        /**
         * @en Apply impulse to the rigid body.
         * @zh 对刚体施加冲量。
         */
        RigidBody_ApplyImpulse = 37,
        /**
         * @en Apply torque impulse to the rigid body.
         * @zh 对刚体施加扭力冲量。
         */
        RigidBody_ApplyTorqueImpulse = 38
    }
    enum EJointCapable {
        /**
         * @en The anchor point of the joint.
         * @zh 关节的锚点。
         */
        Joint_Anchor = 0,
        /**
         * @en The connected anchor point of the joint.
         * @zh 关节的连接锚点。
         */
        Joint_ConnectAnchor = 1
    }
    enum EPhysicsCapable {
        /**
         * @en Gravity in the physics system.
         * @zh 物理系统中的重力。
         */
        Physics_Gravity = 0,
        /**
         * @en Support for static collider mode.
         * @zh 是否支持静态碰撞体模式。
         */
        Physics_StaticCollider = 1,
        /**
         * @en Support for dynamic collider mode.
         * @zh 是否支持动态碰撞体模式。
         */
        Physics_DynamicCollider = 2,
        /**
         * @en Support for character collider mode.
         * @zh 是否支持角色碰撞体模式。
         */
        Physics_CharacterCollider = 3,
        /**
         * @en Box-shaped collider shape.
         * @zh 盒状碰撞形状。
         */
        Physics_BoxColliderShape = 4,
        /**
         * @en Sphere-shaped collider shape.
         * @zh 球状碰撞形状。
         */
        Physics_SphereColliderShape = 5,
        /**
         * @en Capsule-shaped collider shape.
         * @zh 胶囊碰撞形状。
         */
        Physics_CapsuleColliderShape = 6,
        /**
         * @en Cylinder-shaped collider shape.
         * @zh 圆柱碰撞形状。
         */
        Physics_CylinderColliderShape = 7,
        /**
         * @en Cone-shaped collider shape.
         * @zh 圆锥碰撞形状。
         */
        Physics_ConeColliderShape = 8,
        /**
         * @en Mesh collider shape.
         * @zh 网格碰撞形状。
         */
        Physics_MeshColliderShape = 9,
        /**
         * @en Compound collider shape.
         * @zh 组合碰撞形状。
         */
        Physics_CompoundColliderShape = 10,
        /**
         * @en Support for creating curve mesh.
         * @zh 支持创建曲线网格。
         */
        Physics_CreateCorveMesh = 11,
        /**
         * @en Height field collider shape.
         * @zh 高度场碰撞形状。
         */
        physics_heightFieldColliderShape = 12,
        /**
         * @en General joint capability.
         * @zh 常规关节能力。
         */
        Physics_Joint = 13,
        /**
         * @en Fixed joint capability.
         * @zh 固定关节能力。
         */
        Physics_FixedJoint = 14,
        /**
         * @en Spring joint capability.
         * @zh 弹簧关节能力。
         */
        Physics_SpringJoint = 15,
        /**
         * @en Hinge joint capability.
         * @zh 铰链关节能力。
         */
        Physics_HingeJoint = 16,
        /**
         * @en 6 Degrees of Freedom (D6) joint capability.
         * @zh 6自由度（D6）关节能力。
         */
        Physics_D6Joint = 17
    }
    /**
     * @en Physical Statistics Data
     * @zh 物理统计数据
     */
    enum EPhysicsStatisticsInfo {
        /**
         * @en Physical Event Count Enumeration
         * @zh 物理事件计数枚举
         */
        C_PhysicsEventCount = 0,
        /**
         * @en Cleanup Count Per Frame
         * @zh 每帧清理个数
         */
        FrameClearCount = 1,
        /**
         * @en Physical Dynamics Rigid Body Count Enumeration
         * @zh 物理动力学刚体计数枚举
         */
        C_PhysicaDynamicRigidBody = 2,
        /**
         * @en Physical Static Rigid Body Count Enumeration
         * @zh 物理静态刚体计数枚举
         */
        C_PhysicaStaticRigidBody = 3,
        /**
         * @en Physical Kinematic Rigid Body Count Enumeration
         * @zh 物理运动学刚体计数枚举
         */
        C_PhysicaKinematicRigidBody = 4,
        /**
         * @en Physical Character Controller Count Enumeration
         * @zh 物理角色控制器计数枚举
         */
        C_PhysicaCharacterController = 5,
        /**
         * @en Physical Joint Count Enumeration
         * @zh 物理关节计数枚举
         */
        C_PhysicsJoint = 6,
        /**
         * @en Enumeration Count
         * @zh 枚举个数
         */
        Count = 7
    }
    enum ControllerNonWalkableMode {
        /**
         * @en Stops character from climbing up non-walkable slopes, but doesn't move it otherwise.
         * @zh 阻止角色爬上不可行走的斜坡，但不会对其他情况进行移动。
         */
        ePREVENT_CLIMBING = 0,
        /**
         * @en Stops character from climbing up non-walkable slopes, and forces it to slide down those slopes.
         * @zh 阻止角色爬上不可行走的斜坡，并强制其沿这些斜坡滑下。
         */
        ePREVENT_CLIMBING_AND_FORCE_SLIDING = 1
    }
    enum ECharacterCollisionFlag {
        /**
         * @en Character is colliding to the sides.
         * @zh 角色与侧面发生碰撞。
         */
        eCOLLISION_SIDES = 1,
        /**
         * @en Character has collision above.
         * @zh 角色上方发生碰撞。
         */
        eCOLLISION_UP = 2,
        /**
         * @en Character has collision below.
         * @zh 角色下方发生碰撞。
         */
        eCOLLISION_DOWN = 4
    }
    /**
     * @en The `pxCharactorCollider` class implements character controller functionality in the physics engine.
     * @zh `pxCharactorCollider` 类用于在物理引擎中实现角色控制器的功能。
     */
    class pxCharactorCollider extends pxCollider implements ICharacterController {
        static tempV3: Vector3;
        _shapeID: number;
        private _nonWalkableMode;
        private _gravity;
        private _characterCollisionFlags;
        /**
         * @en Creates a instance of pxCharactorCollider.
         * @param manager The physics manager responsible for this collider.
         * @zh 创建一个 pxCharactorCollider 实例。
         * @param manager 负责管理此碰撞器的物理管理器。
         */
        constructor(manager: pxPhysicsManager);
        setColliderShape(shape: pxColliderShape): void;
        private _getNodeScale;
        protected _initCollider(): void;
        /**
         * @en Gets the capability of the character controller.
         * @param value The capability to check.
         * @returns Whether the capability is supported.
         * @zh 获取角色控制器的能力。
         * @param value 要检查的能力。
         * @returns 是否支持该能力。
         */
        getCapable(value: number): boolean;
        /**
         * @en Gets the character capability.
         * @param value The character capability to check.
         * @returns Whether the capability is supported.
         * @zh 获取角色能力。
         * @param value 要检查的角色能力。
         * @returns 是否支持该能力。
         */
        static getCharacterCapable(value: ECharacterCapable): boolean;
        /**
         * @en Initializes the character capabilities.
         * @zh 初始化角色能力。
         */
        static initCapable(): void;
        /**
         * @en Creates the character controller in the physics engine.
         * @zh 在物理引擎中创建角色控制器。
         */
        _createController(): void;
        /**
         * @en Sets the collision flag for the character controller.
         * @param value The collision flag to set.
         * @zh 设置角色控制器的碰撞标志。
         * @param value 要设置的碰撞标志。
         */
        _setCharacterCollisonFlag(value: ECharacterCollisionFlag): void;
        /**
         * @en Releases the character controller from the physics engine.
         * @zh 从物理引擎中释放角色控制器。
         */
        _releaseController(): void;
        /**
         * @en Moves the character controller.
         * @param disp The displacement vector.
         * @zh 移动角色控制器。
         * @param disp 位移向量。
         */
        move(disp: Vector3): void;
        /**
         * @en Makes the character jump.
         * @param velocity The jump velocity.
         * @zh 使角色跳跃。
         * @param velocity 跳跃速度。
         */
        jump?(velocity: Vector3): void;
        isGrounded(): boolean;
        /**
         * @en Sets the step offset for the character controller.
         * @param offset The step offset value.
         * @zh 设置角色控制器的台阶偏移。
         * @param offset 台阶偏移值。
         */
        setStepOffset(offset: number): void;
        /**
         * @en Sets the up direction for the character controller.
         * @param up The up direction vector.
         * @zh 设置角色控制器的向上方向。
         * @param up 向上方向向量。
         */
        setUpDirection(up: Vector3): void;
        /**
         * @en Sets the slope limit for the character controller.
         * @param value The slope limit value in radians.
         * @zh 设置角色控制器的坡度限制。
         * @param value 坡度限制值（弧度）。
         */
        setSlopeLimit(value: number): void;
        /**
         * @en Sets the gravity for the character controller.
         * @param value The gravity vector.
         * @zh 设置角色控制器的重力。
         * @param value 重力向量。
         */
        setGravity(value: Vector3): void;
        /**
         * @en Sets the push force for the character controller.
         * @param value The push force value.
         * @zh 设置角色控制器的推力。
         * @param value 推力值。
         */
        setPushForce(value: number): void;
        /**
         * @en Updates the character's world transform from the physics engine.
         * @zh 从物理引擎更新角色的世界变换。
         */
        getWorldTransform(): void;
        /**
         * @en Sets the skin width for the character controller.
         * @param width The skin width value.
         * @zh 设置角色控制器的皮肤宽度。
         * @param width 皮肤宽度值。
         */
        setSkinWidth(width: number): void;
        /**
         * @en Destroys the character controller.
         * @zh 销毁角色控制器。
         */
        destroy(): void;
        /**
         * @en Sets the position of the character controller.
         * @param value The position vector.
         * @zh 设置角色控制器的位置。
         * @param value 位置向量。
         */
        setPosition(value: Vector3): void;
        /**
         * @en Gets the position of the character controller.
         * @returns The position vector.
         * @zh 获取角色控制器的位置。
         * @returns 位置向量。
         */
        getPosition(): Vector3;
        /**
         * @en Sets the local offset of the character's shape.
         * @param value The local offset vector.
         * @zh 设置角色形状的局部偏移。
         * @param value 局部偏移向量。
         */
        setShapelocalOffset(value: Vector3): void;
        /**
         * @en Sets the height of the character controller.
         * @param value The height value.
         * @zh 设置角色控制器的高度。
         * @param value 高度值。
         */
        setHeight(value: number): void;
        /**
         * @en Sets the radius of the character controller.
         * @param value The radius value.
         * @zh 设置角色控制器的半径。
         * @param value 半径值。
         */
        setRadius(value: number): void;
        /**
         * @en Sets the minimum distance for the character controller.
         * @param value The minimum distance value.
         * @zh 设置角色控制器的最小距离。
         * @param value 最小距离值。
         */
        setminDistance(value: number): void;
        /**
         * @en Sets the non-walkable mode for the character controller.
         * @param value The non-walkable mode.
         * @zh 设置角色控制器的不可行走模式。
         * @param value 不可行走模式。
         */
        setNonWalkableMode(value: ControllerNonWalkableMode): void;
        /**
         * @en Sets the event filter for the character controller.
         * @param events An array of events to filter.
         * @zh 设置角色控制器的事件过滤器。
         * @param events 要过滤的事件数组。
         */
        setEventFilter(events: [
        ]): void;
        /**
         * @en Releases the character controller resources.
         * @zh 释放角色控制器资源。
         */
        release(): void;
    }
    /**
     * @en Enumeration of collider types.
     * @zh 碰撞器类型枚举。
     */
    enum pxColliderType {
        RigidbodyCollider = 0,
        CharactorCollider = 1,
        StaticCollider = 2
    }
    /**
     * @en PhysX actor flags.
     * @zh PhysX 执行器标志。
     */
    enum pxActorFlag {
        /**
         * @en Enable debug renderer for this actor.
         * @zh 为此执行器启用调试渲染器。
         */
        eVISUALIZATION = 1,
        /**
         * @en Disables scene gravity for this actor.
         * @zh 禁用此执行器的场景重力。
         */
        eDISABLE_GRAVITY = 2,
        /**
         * @en Enables the sending of PxSimulationEventCallback::onWake() and PxSimulationEventCallback::onSleep() notify events.
         * @zh 启用 PxSimulationEventCallback::onWake() 和 PxSimulationEventCallback::onSleep() 通知事件的发送。
         */
        eSEND_SLEEP_NOTIFIES = 4,
        /**
         * @en Disables simulation for the actor.
         * @zh 禁用执行器的模拟。
         */
        eDISABLE_SIMULATION = 8
    }
    /**
     * @en The `pxCollider` class is used to handle physics colliders.
     * @zh `pxCollider` 类用于处理物理碰撞器。
     */
    class pxCollider implements ICollider {
        /**temp tranform object */
        private static _tempTransform;
        /**actor */
        _pxActor: any;
        /**owner transform */
        _transform: Transform3D;
        /**type data */
        _type: pxColliderType;
        /**触发器 */
        _isTrigger: boolean;
        /**can collision Group*/
        _canCollisionWith: number;
        /**collision group */
        _collisionGroup: number;
        /**pxshape */
        _shape: pxColliderShape;
        /**manager */
        _physicsManager: pxPhysicsManager;
        /**check destroy */
        _destroyed: boolean;
        /**
         * @en The index of this collider in the physics update list.
         * @zh 此碰撞器在物理更新列表中的索引。
         */
        inPhysicUpdateListIndex: number;
        /**id */
        _id: number;
        private _bounciness;
        /**
         * @en Creates a instance of pxCollider.
         * @param manager The physics manager responsible for this collider.
         * @zh 创建一个 pxCollider 实例。
         * @param manager 负责管理此碰撞器的物理管理器。
         */
        constructor(manager: pxPhysicsManager);
        /**
         * @en Indicates whether the collider is active.
         * @zh 表示碰撞器是否处于激活状态。
         */
        active: boolean;
        /**
         * @en Sets the friction value for the collider.
         * @param value The friction value to set.
         * @zh 设置碰撞器的摩擦力值。
         * @param value 要设置的摩擦力值。
         */
        setfriction?(value: number): void;
        /**
         * @en Sets the rolling friction value for the collider.
         * @param value The rolling friction value to set.
         * @zh 设置碰撞器的滚动摩擦力值。
         * @param value 要设置的滚动摩擦力值。
         */
        setRollingFriction?(value: number): void;
        protected setActorFlag(flag: pxActorFlag, value: boolean): void;
        /**
         * @en Gets the capability of the collider.
         * @param value The capability to check.
         * @zh 获取碰撞器的能力。
         * @param value 要检查的能力。
         */
        getCapable(value: number): boolean;
        /**
         * @en Sets the collider shape for this collider.
         * @param shape The collider shape to set.
         * @zh 为此碰撞器设置碰撞形状。
         * @param shape 要设置的碰撞形状。
         */
        setColliderShape(shape: pxColliderShape): void;
        protected _initColliderShapeByCollider(): void;
        /**
         * @en Destroys the collider and releases its resources.
         * @zh 销毁碰撞器并释放其资源。
         */
        destroy(): void;
        /**
         * @en Sets the collision group for this collider.
         * @param value The collision group value.
         * @zh 设置此碰撞器的碰撞组。
         * @param value 碰撞组值。
         */
        setCollisionGroup(value: number): void;
        /**
         * @en Sets which groups this collider can collide with.
         * @param value The collision mask value.
         * @zh 设置此碰撞器可以与哪些组碰撞。
         * @param value 碰撞掩码值。
         */
        setCanCollideWith(value: number): void;
        /**
         * @en Sets the event filter for the collider.
         * @param events An array of events to filter.
         * @zh 设置碰撞器的事件过滤器。
         * @param events 要过滤的事件数组。
         */
        setEventFilter(events: [
        ]): void;
        allowSleep(value: boolean): void;
        /**
         * @en Sets the owner node for this collider.
         * @param node The Sprite3D node that owns this collider.
         * @zh 设置此碰撞器的所有者节点。
         * @param node 拥有此碰撞器的 Sprite3D 节点。
         */
        setOwner(node: Sprite3D): void;
        protected _initCollider(): void;
        /**
         * @en Notifies that the transform has changed.
         * @param flag The transform change flag.
         * @zh 通知变换已更改。
         * @param flag 变换更改标志。
         */
        transformChanged(flag: number): void;
        /**
         * @en Sets the world transform of the collider.
         * @param focus Whether to force update even if no change is detected.
         * @zh 设置碰撞器的世界变换。
         * @param focus 是否强制更新，即使未检测到变化。
         */
        setWorldTransform(focus: boolean): void;
        /**
         * @en Sets the bounciness (restitution) of the collider.
         * @param value The bounciness value.
         * @zh 设置碰撞器的弹性（恢复）。
         * @param value 弹性值。
         */
        setBounciness(value: number): void;
        /**
         * @en Sets the dynamic friction of the collider.
         * @param value The dynamic friction value.
         * @zh 设置碰撞器的动态摩擦力。
         * @param value 动态摩擦力值。
         */
        setDynamicFriction(value: number): void;
        /**
         * @en Sets the static friction of the collider.
         * @param value The static friction value.
         * @zh 设置碰撞器的静态摩擦力。
         * @param value 静态摩擦力值。
         */
        setStaticFriction(value: number): void;
        /**
         * @en Sets the friction combine mode of the collider.
         * @param value The friction combine mode.
         * @zh 设置碰撞器的摩擦力合并模式。
         * @param value 摩擦力合并模式。
         */
        setFrictionCombine(value: PhysicsCombineMode): void;
        /**
         * @en Sets the bounce combine mode of the collider.
         * @param value The bounce combine mode.
         * @zh 设置碰撞器的弹性合并模式。
         * @param value 弹性合并模式。
         */
        setBounceCombine(value: PhysicsCombineMode): void;
    }
    /**
     * @en The collision detection mode constants.
     * @zh 碰撞检测模式常量。
     */
    enum CollisionDetectionMode {
        /**
         * @en Continuous collision detection is off for this dynamic collider.
         * @zh 对于这个动态碰撞体，连续碰撞检测是关闭的。
         */
        Discrete = 0,
        /**
         * @en Continuous collision detection is on for colliding with static mesh geometry.
         * @zh 对于与静态网格几何体的碰撞，连续碰撞检测是开启的。
         */
        Continuous = 1,
        /**
         * @en Continuous collision detection is on for colliding with static and dynamic geometry.
         * @zh 对于与静态和动态几何体的碰撞，连续碰撞检测是开启的。
         */
        ContinuousDynamic = 2,
        /**
         * @en Speculative continuous collision detection is on for static and dynamic geometries.
         * @zh 对于静态和动态几何体，推测性连续碰撞检测是开启的。
         */
        ContinuousSpeculative = 3
    }
    /**
     * @en Use these flags to constrain motion of dynamic collider.
     * @zh 使用这些标志来限制动态碰撞体的运动。
     */
    enum DynamicColliderConstraints {
        /**
         * @en Not Freeze.
         * @zh 不冻结任何运动。
         */
        None = 0,
        /**
         * @en Freeze motion along the X-axis.
         * @zh 冻结沿 X 轴的运动。
         */
        FreezePositionX = 1,
        /**
         * @en Freeze motion along the Y-axis.
         * @zh 冻结沿 Y 轴的运动。
         */
        FreezePositionY = 2,
        /**
         * @en Freeze motion along the Z-axis.
         * @zh 冻结沿 Z 轴的运动。
         */
        FreezePositionZ = 4,
        /**
         * @en Freeze rotation along the X-axis.
         * @zh 冻结绕 X 轴的旋转。
         */
        FreezeRotationX = 8,
        /**
         * @en Freeze rotation along the Y-axis.
         * @zh 冻结绕 Y 轴的旋转。
         */
        FreezeRotationY = 16,
        /**
         * @en Freeze rotation along the Z-axis.
         * @zh 冻结绕 Z 轴的旋转。
         */
        FreezeRotationZ = 32
    }
    /**
     * @en The `pxDynamicCollider` class is used to manage dynamic colliders in the physics engine.
     * @zh `pxDynamicCollider` 类用于在物理引擎中管理动态碰撞体。
     */
    class pxDynamicCollider extends pxCollider implements IDynamicCollider {
        /**
         * @en Get the static collider capability for a given value.
         * @param value The collider capability to check.
         * @returns Whether the static collider has the specified capability.
         * @zh 获取指定值的静态碰撞体能力。
         * @param value 要检查的碰撞体能力。
         * @returns 静态碰撞体是否具有指定的能力。
         */
        static getStaticColliderCapable(value: EColliderCapable): boolean;
        /**
         * @en Initialize the capabilities map for dynamic colliders.
         * @zh 初始化动态碰撞体的能力映射。
         */
        static initCapable(): void;
        /**
         * @en Indicates whether the collider is kinematic.
         * @zh 表示碰撞体是否是运动学的。
         */
        IsKinematic: boolean;
        private _mass;
        private _linearDamping;
        private _angularDamping;
        private _linearVelocity;
        private _angularVelocity;
        private _centerOfMass;
        private _inertiaTensor;
        private _sleepThreshold;
        private _collisionDetectionMode;
        private _solverIterations;
        /**
         * @en Create a pxDynamicCollider instance.
         * @param manager The physics manager instance.
         * @zh 创建 pxDynamicCollider 类的实例。
         * @param manager 物理管理器实例。
         */
        constructor(manager: pxPhysicsManager);
        /**
         * @en Get the capability of the collider for a given value.
         * @param value The capability value to check.
         * @returns Whether the collider has the specified capability.
         * @zh 获取碰撞体对于给定值的能力。
         * @param value 要检查的能力值。
         * @returns 碰撞体是否具有指定的能力。
         */
        getCapable(value: number): boolean;
        protected _initCollider(): void;
        protected _initColliderShapeByCollider(): void;
        /**
         * @en Set the world rotation of the dynamic collider.
         * @param value The new world rotation.
         * @zh 设置动态碰撞体的世界旋转。
         * @param value 新的世界旋转。
         */
        setWorldRotation(value: Quaternion): void;
        /**
         * @en Set the world position of the dynamic collider.
         * @param value The new world position.
         * @zh 设置动态碰撞体的世界位置。
         * @param value 新的世界位置。
         */
        setWorldPosition(value: Vector3): void;
        /**
         * @en Get the world transform of the dynamic collider.
         * @zh 获取动态碰撞体的世界变换。
         */
        getWorldTransform(): void;
        /**
         * @en Set the trigger state of the collider.
         * @param value True to set as trigger, false otherwise.
         * @zh 设置碰撞体的触发器状态。
         * @param value 为 true 时设置为触发器，否则为 false。
         */
        setTrigger(value: boolean): void;
        /**
         * @en Set the linear damping of the dynamic collider.
         * @param value The linear damping value.
         * @zh 设置动态碰撞体的线性阻尼。
         * @param value 线性阻尼值。
         */
        setLinearDamping(value: number): void;
        /**
         * @en Set the angular damping of the dynamic collider.
         * @param value The angular damping value.
         * @zh 设置动态碰撞体的角度阻尼。
         * @param value 角度阻尼值。
         */
        setAngularDamping(value: number): void;
        /**
         * @en Set the linear velocity of the dynamic collider.
         * @param value The linear velocity vector.
         * @zh 设置动态碰撞体的线性速度。
         * @param value 线性速度向量。
         */
        setLinearVelocity(value: Vector3): void;
        /**
         * @en Get the linear velocity of the dynamic collider.
         * @returns The current linear velocity.
         * @zh 获取动态碰撞体的线性速度。
         * @returns 当前的线性速度。
         */
        getLinearVelocity(): Vector3;
        /**
         * @en Set the angular velocity of the dynamic collider.
         * @param value The angular velocity vector.
         * @zh 设置动态碰撞体的角速度。
         * @param value 角速度向量。
         */
        setAngularVelocity(value: Vector3): void;
        /**
         * @en Get the angular velocity of the dynamic collider.
         * @returns The current angular velocity.
         * @zh 获取动态碰撞体的角速度。
         * @returns 当前的角速度。
         */
        getAngularVelocity(): Vector3;
        /**
         * @en Set the mass of the dynamic collider.
         * @param value The mass value.
         * @zh 设置动态碰撞体的质量。
         * @param value 质量值。
         */
        setMass(value: number): void;
        /**
         * @en Set the center of mass of the dynamic collider.
         * @param value The center of mass vector.
         * @zh 设置动态碰撞体的质心。
         * @param value 质心向量。
         */
        setCenterOfMass(value: Vector3): void;
        /**
         * @en Set the inertia tensor of the dynamic collider.
         * @param value The inertia tensor vector.
         * @zh 设置动态碰撞体的惯性张量。
         * @param value 惯性张量向量。
         */
        setInertiaTensor(value: Vector3): void;
        /**
         * @en Whether it is sleeping.
         * @zh 是否处于睡眠状态。
         */
        isSleeping(): boolean;
        /**
         * @en Set the sleep threshold of the dynamic collider.
         * @param value The sleep threshold value.
         * @zh 设置动态碰撞体的睡眠阈值。
         * @param value 睡眠阈值。
         */
        setSleepThreshold(value: number): void;
        /**
         * @en Set the collision detection mode of the dynamic collider.
         * @param value The collision detection mode.
         * @zh 设置动态碰撞体的碰撞检测模式。
         * @param value 碰撞检测模式。
         */
        setCollisionDetectionMode(value: number): void;
        /**
         * @en Set the solver iterations of the dynamic collider.
         * @param value The number of solver iterations.
         * @zh 设置动态碰撞体的求解器迭代次数。
         * @param value 求解器迭代次数。
         */
        setSolverIterations(value: number): void;
        /**
         * @en Set whether the dynamic collider is kinematic.
         * @param value True if kinematic, false otherwise.
         * @zh 设置动态碰撞体是否为运动学的。
         * @param value 为 true 时设置为运动学，否则为 false。
         */
        setIsKinematic(value: boolean): void;
        allowSleep(value: boolean): void;
        /**
         * @en Set the constraints of the dynamic collider.
         * @param linearFactor The linear factor vector.
         * @param angularFactor The angular factor vector.
         * @zh 设置动态碰撞体的约束。
         * @param linearFactor 线性因子向量。
         * @param angularFactor 角度因子向量。
         */
        setConstraints(linearFactor: Vector3, angularFactor: Vector3): void;
        /**
         * @en Add force to the dynamic collider.
         * @param force The force vector to add.
         * @param mode The physics force mode.
         * @param localOffset The local offset vector.
         * @zh 为动态碰撞体添加力。
         * @param force 要添加的力向量。
         * @param mode 物理力模式。
         * @param localOffset 局部偏移向量。
         */
        addForce(force: Vector3, mode: PhysicsForceMode, localOffset: Vector3): void;
        /**
         * @en Add torque to the dynamic collider.
         * @param torque The torque vector to add.
         * @param mode The physics force mode.
         * @zh 为动态碰撞体添加扭矩。
         * @param torque 要添加的扭矩向量。
         * @param mode 物理力模式。
         */
        addTorque(torque: Vector3, mode: PhysicsForceMode): void;
        /**
         * @en Put the dynamic collider to sleep.
         * @zh 使动态碰撞体进入睡眠状态。
         */
        sleep(): void;
        /**
         * @en Wake up the dynamic collider.
         * @zh 唤醒动态碰撞体。
         */
        wakeUp(): void;
        /**
         * @en Move the kinematic actor to a new pose.
         * @param positionOrRotation The new position or rotation.
         * @param rotation The new rotation (optional).
         * @zh 将运动学角色移动到新的姿态。
         * @param positionOrRotation 新的位置或旋转。
         * @param rotation 新的旋转（可选）。
         */
        move(positionOrRotation: Vector3 | Quaternion, rotation?: Quaternion): void;
        /**
         * @en Destroy Rigidbody
         * @zh 销毁刚体
         */
        destroy(): void;
    }
    /**
     * @en Class representing a static collider in the PhysX physics engine.
     * @zh 表示 PhysX 物理引擎中的静态碰撞器的类。
     */
    class pxStaticCollider extends pxCollider implements IStaticCollider {
        /**
         * @en Get the capability of a static collider for a specific collider capable.
         * @param value The collider capable to check.
         * @returns Whether the static collider is capable of the specified feature.
         * @zh 获取静态碰撞器对特定碰撞器能力的支持状态。
         * @param value 要检查的碰撞器能力。
         * @returns 静态碰撞器是否支持指定的特性。
         */
        static getStaticColliderCapable(value: EColliderCapable): boolean;
        /**
         * @en Initialize the capabilities map for static colliders.
         * @zh 初始化静态碰撞器的能力映射表。
         */
        static initCapable(): void;
        /**
         * @en Creates an instance of pxStaticCollider.
         * @param manager The physics manager.
         * @zh 创建一个 pxStaticCollider 实例。
         * @param manager 物理管理器。
         */
        constructor(manager: pxPhysicsManager);
        /**
         * @en Check if the static collider is capable of a specific feature.
         * @param value The capability to check.
         * @returns Whether the static collider is capable of the specified feature.
         * @zh 检查静态碰撞器是否具有特定能力。
         * @param value 要检查的能力。
         * @returns 静态碰撞器是否具有指定的能力。
         */
        getCapable(value: number): boolean;
        protected _initCollider(): void;
        /**
         * @en Set the trigger state of the collider.
         * @param value Whether the collider should act as a trigger.
         * @zh 设置碰撞器的触发器状态。
         * @param value 碰撞器是否应该作为触发器。
         */
        setTrigger(value: boolean): void;
        protected _initColliderShapeByCollider(): void;
        /**
         * @en Destroy Static Collider
         * @zh 销毁静态碰撞器
         */
        destroy(): void;
    }
    enum PxD6JointDriveFlag {
        /**
         * @en drive spring is for the acceleration at the joint (rather than the force).
         * @zh 表示驱动弹簧用于关节的加速度，而不是力。
         */
        eACCELERATION = 1
    }
    /**
     * @en The `pxD6Joint` class is used to create and manage D6 joints (6 degrees of freedom joints) in the PhysX physics engine.
     * @zh `pxD6Joint` 类用于创建和管理 PhysX 物理引擎中的 D6 关节（6 自由度关节）。
     */
    class pxD6Joint extends pxJoint implements ID6Joint {
        /**
         * create Joint
         */
        protected _createJoint(): void;
        /**
         * set local Pose
         * @param actor
         * @param position
         */
        protected _setLocalPose(actor: number, position: Vector3): void;
        /**
         * @en Sets the joint's primary and secondary axes.
         * @param axis The primary axis.
         * @param secendary The secondary axis.
         * @zh 设置关节的主轴和次轴。
         * @param axis 主轴。
         * @param secendary 次轴。
         */
        setAxis(axis: Vector3, secendary: Vector3): void;
        /**
         * @en Sets the motion type for a specific axis.
         * @param axis The axis to set.
         * @param motionType The motion type to apply.
         * @zh 设置特定轴的运动类型。
         * @param axis 要设置的轴。
         * @param motionType 要应用的运动类型。
         */
        setMotion(axis: D6Axis, motionType: D6MotionType): void;
        /**
         * @en Sets the distance limit for the joint.
         * @param limit The distance limit.
         * @param bounceness The bounciness of the limit.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring coefficient.
         * @param damp The damping coefficient.
         * @zh 设置关节的距离限制。
         * @param limit 距离限制。
         * @param bounceness 限制的弹性。
         * @param bounceThreshold 反弹阈值。
         * @param spring 弹簧系数。
         * @param damp 阻尼系数。
         */
        setDistanceLimit(limit: number, bounceness: number, bounceThreshold: number, spring: number, damp: number): void;
        /**
         * @en Sets the linear limit for a specific axis.
         * @param linearAxis The linear axis to set.
         * @param upper The upper limit.
         * @param lower The lower limit.
         * @param bounceness The bounciness of the limit.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring coefficient.
         * @param damping The damping coefficient.
         * @zh 设置特定轴的线性限制。
         * @param linearAxis 要设置的线性轴。
         * @param upper 上限。
         * @param lower 下限。
         * @param bounceness 限制的弹性。
         * @param bounceThreshold 反弹阈值。
         * @param spring 弹簧系数。
         * @param damping 阻尼系数。
         */
        setLinearLimit(linearAxis: D6MotionType, upper: number, lower: number, bounceness: number, bounceThreshold: number, spring: number, damping: number): void;
        /**
         * @en Sets the twist limit for the joint.
         * @param upper The upper limit.
         * @param lower The lower limit.
         * @param bounceness The bounciness of the limit.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring coefficient.
         * @param damping The damping coefficient.
         * @zh 设置关节的扭转限制。
         * @param upper 上限。
         * @param lower 下限。
         * @param bounceness 限制的弹性。
         * @param bounceThreshold 反弹阈值。
         * @param spring 弹簧系数。
         * @param damping 阻尼系数。
         */
        setTwistLimit(upper: number, lower: number, bounceness: number, bounceThreshold: number, spring: number, damping: number): void;
        /**
         * @en Sets the swing limit for the joint.
         * @param yAngle The Y angle limit.
         * @param zAngle The Z angle limit.
         * @param bounceness The bounciness of the limit.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring coefficient.
         * @param damping The damping coefficient.
         * @zh 设置关节的摆动限制。
         * @param yAngle Y 角度限制。
         * @param zAngle Z 角度限制。
         * @param bounceness 限制的弹性。
         * @param bounceThreshold 反弹阈值。
         * @param spring 弹簧系数。
         * @param damping 阻尼系数。
         */
        setSwingLimit(yAngle: number, zAngle: number, bounceness: number, bounceThreshold: number, spring: number, damping: number): void;
        /**
         * @en Sets the drive parameters for a specific drive index.
         * @param index The drive index.
         * @param stiffness The stiffness of the drive.
         * @param damping The damping of the drive.
         * @param forceLimit The force limit of the drive.
         * @zh 设置特定驱动索引的驱动参数。
         * @param index 驱动索引。
         * @param stiffness 驱动的刚度。
         * @param damping 驱动的阻尼。
         * @param forceLimit 驱动的力限制。
         */
        setDrive(index: D6Drive, stiffness: number, damping: number, forceLimit: number): void;
        /**
         * @en Sets the drive transform for the joint.
         * @param position The target position.
         * @param rotate The target rotation.
         * @zh 设置关节的驱动变换。
         * @param position 目标位置。
         * @param rotate 目标旋转。
         */
        setDriveTransform(position: Vector3, rotate: Quaternion): void;
        /**
         * @en Sets the drive velocity for the joint.
         * @param position The linear velocity.
         * @param angular The angular velocity.
         * @zh 设置关节的驱动速度。
         * @param position 线性速度。
         * @param angular 角速度。
         */
        setDriveVelocity(position: Vector3, angular: Vector3): void;
        /**
         * @en Gets the current twist angle of the joint.
         * @returns The twist angle in radians.
         * @zh 获取关节当前的扭转角度。
         * @returns 扭转角度（弧度）。
         */
        getTwistAngle(): number;
        /**
         * @en Gets the current swing Y angle of the joint.
         * @returns The swing Y angle in radians.
         * @zh 获取关节当前的 Y 轴摆动角度。
         * @returns Y 轴摆动角度（弧度）。
         */
        getSwingYAngle(): number;
        /**
         * @en Gets the current swing Z angle of the joint.
         * @returns The swing Z angle in radians.
         * @zh 获取关节当前的 Z 轴摆动角度。
         * @returns Z 轴摆动角度（弧度）。
         */
        getSwingZAngle(): number;
        /**
         * @en Destroy joint
         * @zh 销毁关节
         */
        destroy(): void;
    }
    /**
     * @en The pxDistanceJoint class represents a distance joint in the PhysX physics engine.
     * @zh pxDistanceJoint 类表示 PhysX 物理引擎中的距离关节。
     */
    class pxDistanceJoint extends pxJoint implements ISpringJoint {
        /**
         * create Joint
         */
        protected _createJoint(): void;
        /**
         * @en Sets the minimum distance for the joint.
         * @param distance The minimum distance value.
         * @zh 设置关节的最小距离。
         * @param distance 最小距离值。
         */
        setMinDistance(distance: number): void;
        /**
         * @en Sets the maximum distance for the joint.
         * @param distance The maximum distance value.
         * @zh 设置关节的最大距离。
         * @param distance 最大距离值。
         */
        setMaxDistance(distance: number): void;
        /**
         * @en Sets the connect distance for the joint.
         * @param distance The connect distance value.
         * @zh 设置关节的连接距离。
         * @param distance 连接距离值。
         */
        setConnectDistance(distance: number): void;
        /**
         * @en Allows the spring to have a different rest length.
         * @param tolerance The tolerance value for the spring rest length.
         * @zh 允许弹簧具有不同的静止长度。
         * @param tolerance 弹簧静止长度的容差值。
         */
        setTolerance(tolerance: number): void;
        /**
         * @en Sets the stiffness of the joint spring.
         * @param stiffness The stiffness value.
         * @zh 设置关节弹簧的刚度。
         * @param stiffness 刚度值。
         */
        setStiffness(stiffness: number): void;
        /**
         * @en Sets the damping of the joint spring.
         * @param damping The damping value.
         * @zh 设置关节弹簧的阻尼。
         * @param damping 阻尼值。
         */
        setDamping(damping: number): void;
        /**
         * @en Destroy joint
         * @zh 销毁关节
         */
        destroy(): void;
    }
    /**
     * @en The pxFixedJoint class represents a fixed joint in the PhysX physics engine.
     * @zh pxFixedJoint 类表示 PhysX 物理引擎中的固定关节。
     */
    class pxFixedJoint extends pxJoint implements IFixedJoint {
        /**
         * create Joint
         */
        protected _createJoint(): void;
        /**
         * @en Destroy joint
         * @zh 销毁关节
         */
        destroy(): void;
    }
    /**
     * joint flag
     */
    enum PxConstraintFlag {
        eBROKEN = 1,
        ePROJECT_TO_ACTOR0 = 2,
        ePROJECT_TO_ACTOR1 = 4,
        ePROJECTION = 6,
        eCOLLISION_ENABLED = 8,
        eVISUALIZATION = 16,
        eDRIVE_LIMITS_ARE_FORCES = 32,
        eIMPROVED_SLERP = 128,
        eDISABLE_PREPROCESSING = 256,
        eENABLE_EXTENDED_LIMITS = 512,
        eGPU_COMPATIBLE = 1024,
        eALWAYS_UPDATE = 2048,
        eDISABLE_CONSTRAINT = 4096
    }
    /**
     * @en The `pxJoint` class is used to implement joint functionality in the physical engine.
     * @zh `pxJoint`类用于在物理引擎中实现关节功能。
     */
    class pxJoint implements IJoint {
        /**
         * @en Create an instance of the pxJoint class.
         * @param manager The physics manager.
         * @zh 创建pxJoint类的shape实例。
         * @param manager 物理管理器。
         */
        constructor(manager: pxPhysicsManager);
        destroy(): void;
    }
    enum PxRevoluteJointFlag {
        eLIMIT_ENABLED = 1,
        eDRIVE_ENABLED = 2,
        eDRIVE_FREESPIN = 4
    }
    /**
     * @en `pxRevoluteJoint` is a joint that allows rotation around an axis.
     * @zh `pxRevoluteJoint`类用于在物理引擎中创建和管理旋转关节（铰链关节）
     */
    class pxRevoluteJoint extends pxJoint implements IHingeJoint {
        /**
         * create Joint
         */
        protected _createJoint(): void;
        /**
         * @en Destroy joint
         * @zh 销毁关节
         */
        destroy(): void;
    }
    class pxSphereJoint extends pxJoint {
    }
    /**
     * @en Implements PhysX collision data content
     * @zh 实现PhysX碰撞数据内容
     */
    class pxCollisionTool {
        /**@ignore */
        constructor();
        /**
         * @en Convert PhysX LayaQuaryResult to HitResult type
         * @param out The HitResult object to store the result
         * @param quaryResult The PhysX query result
         * @returns The converted HitResult
         * @zh 转换PhysX的LayaQuaryResult到HitResult类型
         * @param out 用于存储结果的HitResult对象
         * @param quaryResult PhysX查询结果
         * @returns 转换后的HitResult
         */
        static getRayCastResult(out: HitResult, quaryResult: any): HitResult;
        /**
         * @en Convert all PhysX LayaQuaryResults to HitResult type
         * @param out The array to store the converted HitResults
         * @param quaryResults The PhysX query results
         * @returns The array of converted HitResults
         * @zh 转换所有PhysX的LayaQuaryResult到HitResult类型
         * @param out 用于存储转换后HitResult的数组
         * @param quaryResults PhysX查询结果
         * @returns 转换后的HitResult数组
         */
        static getRayCastResults(out: HitResult[], quaryResults: any): HitResult[];
        /**
         * @en Recycle Collision object back to the pool
         * @param value The Collision object to be recycled
         * @zh 回收Collision对象到对象池
         * @param value 要回收的Collision对象
         */
        static reCoverCollision(value: Collision): void;
        /**
         * @en Recycle HitResult object back to the pool
         * @param value The HitResult object to be recycled
         * @zh 回收HitResult对象到对象池
         * @param value 要回收的HitResult对象
         */
        static reCoverHitresults(value: HitResult): void;
    }
    /**
     * @en PhysX physics creation utility class
     * @zh PhysX物理创建工具类
     */
    class pxPhysicsCreateUtil implements IPhysicsCreateUtil {
        static _physXPVD: boolean;
        static _PxPvdPort: any;
        static _allocator: any;
        static _tolerancesScale: any;
        protected _physicsEngineCapableMap: Map<any, any>;
        /**
         * @en Initialize physics capabilities
         * @zh 初始化物理能力
         */
        initPhysicsCapable(): void;
        /**
         * @en Get the capability status of a specific physics feature.
         * @param value The physics capability to query.
         * @returns Whether the specified physics capability is available.
         * @zh 获取特定物理功能的能力状态。
         * @param value 要查询的物理能力。
         * @returns 指定的物理能力是否可用。
         */
        getPhysicsCapable(value: EPhysicsCapable): boolean;
        /**
         * @en Initialize the physics engine.
         * @returns A promise that resolves when initialization is complete.
         * @zh 初始化物理引擎。
         * @returns 当初始化完成时解析的Promise。
         */
        initialize(): Promise<void>;
        /**
         * @en Enable PhysX PVD (PhysX Visual Debugger) using Socket transport.
         * @param physX The PhysX instance.
         * @param pxFoundation The PhysX foundation instance.
         * @zh 使用Socket传输启用PhysX PVD（PhysX可视化调试器）。
         * @param physX PhysX实例。
         * @param pxFoundation PhysX foundation实例。
         */
        _physxPVDSocketConnect(physX: any, pxFoundation: any): any;
        private _init;
        /**
         * @en Create a physics manager.
         * @param physicsSettings The physics settings.
         * @returns A new physics manager instance.
         * @zh 创建物理管理器。
         * @param physicsSettings 物理设置。
         * @returns 新的物理管理器实例。
         */
        createPhysicsManger(physicsSettings: PhysicsSettings): pxPhysicsManager;
        /**
         * @en Create a dynamic collider.
         * @param manager The physics manager.
         * @returns A new dynamic collider instance.
         * @zh 创建动态碰撞器。
         * @param manager 物理管理器。
         * @returns 新的动态碰撞器实例。
         */
        createDynamicCollider(manager: pxPhysicsManager): IDynamicCollider;
        /**
         * @en Create a static collider.
         * @param manager The physics manager.
         * @returns A new static collider instance.
         * @zh 创建静态碰撞器。
         * @param manager 物理管理器。
         * @returns 新的静态碰撞器实例。
         */
        createStaticCollider(manager: pxPhysicsManager): IStaticCollider;
        /**
         * @en Create a character controller.
         * @param manager The physics manager.
         * @returns A new character controller instance.
         * @zh 创建角色控制器。
         * @param manager 物理管理器。
         * @returns 新的角色控制器实例。
         */
        createCharacterController(manager: pxPhysicsManager): ICharacterController;
        /**
         * @en Create a fixed joint.
         * @param manager The physics manager.
         * @returns A new fixed joint instance.
         * @zh 创建固定关节。
         * @param manager 物理管理器。
         * @returns 新的固定关节实例。
         */
        createFixedJoint(manager: pxPhysicsManager): IFixedJoint;
        /**
         * @en Create a hinge joint.
         * @param manager The physics manager.
         * @returns A new hinge joint instance.
         * @zh 创建铰链关节。
         * @param manager 物理管理器。
         * @returns 新的铰链关节实例。
         */
        createHingeJoint(manager: pxPhysicsManager): IHingeJoint;
        /**
         * @en Create a spring joint.
         * @param manager The physics manager.
         * @returns A new spring joint instance.
         * @zh 创建弹簧关节。
         * @param manager 物理管理器。
         * @returns 新的弹簧关节实例。
         */
        createSpringJoint(manager: pxPhysicsManager): ISpringJoint;
        /**
         * @en Create a D6 joint.
         * @param manager The physics manager.
         * @returns A new D6 joint instance.
         * @zh 创建D6关节。
         * @param manager 物理管理器。
         * @returns 新的D6关节实例。
         */
        createD6Joint(manager: pxPhysicsManager): ID6Joint;
        /**
         * @en Create a box collider shape.
         * @returns A new box collider shape instance.
         * @zh 创建盒子碰撞器形状。
         * @returns 新的盒子碰撞器形状实例。
         */
        createBoxColliderShape(): IBoxColliderShape;
        /**
         * @en Create a sphere collider shape.
         * @returns A new sphere collider shape instance.
         * @zh 创建球体碰撞器形状。
         * @returns 新的球体碰撞器形状实例。
         */
        createSphereColliderShape(): ISphereColliderShape;
        /**
         * @en Create a plane collider shape.
         * @zh 创建平面碰撞器形状。
         */
        createPlaneColliderShape(): IPlaneColliderShape;
        /**
         * @en Create a capsule collider shape.
         * @returns A new capsule collider shape instance.
         * @zh 创建胶囊碰撞器形状。
         * @returns 新的胶囊碰撞器形状实例。
         */
        createCapsuleColliderShape?(): ICapsuleColliderShape;
        /**
         * @en Create a mesh collider shape.
         * @returns A new mesh collider shape instance.
         * @zh 创建网格碰撞器形状。
         * @returns 新的网格碰撞器形状实例。
         */
        createMeshColliderShape?(): IMeshColliderShape;
        /**
         * @en Create a cylinder collider shape.
         * @zh 创建圆柱体碰撞器形状。
         */
        createCylinderColliderShape?(): ICylinderColliderShape;
        /**
         * @en Create a cone collider shape.
         * @zh 创建圆锥体碰撞器形状。
         */
        createConeColliderShape?(): IConeColliderShape;
        /**
         * @en Create a height field shape.
         * @returns A new height field shape instance.
         * @zh 创建高度场形状。
         * @returns 新的高度场形状实例。
         */
        createHeightFieldShape(): pxHeightFieldShape;
        /**
         * @en Create a compound collider shape.
         * @returns A new compound collider shape instance.
         * @zh 创建组合碰撞器形状。
         * @returns 新的组合碰撞器形状实例。
         */
        createCompoundShape(): ICompoundColliderShape;
        /**
         * @en Create a convex mesh from a given mesh.
         * @param mesh The input mesh.
         * @zh 从给定的网格创建凸包网格。
         * @param mesh 输入的网格。
         */
        createCorveMesh(mesh: Mesh): Mesh;
        /**
         * @en Create a Float32Array with allocated memory.
         * @param length The length of the array.
         * @zh 创建具有分配内存的Float32Array。
         * @param length 数组的长度。
         */
        static createFloat32Array(length: number): {
            ptr: number;
            buffer: Float32Array;
        };
        /**
         * @en Create a Uint32Array with allocated memory.
         * @param length The length of the array.
         * @zh 创建具有分配内存的Uint32Array。
         * @param length 数组的长度。
         */
        static createUint32Array(length: number): {
            ptr: number;
            buffer: Uint32Array;
        };
        /**
         * @en Create a Uint16Array with allocated memory.
         * @param length The length of the array.
         * @zh 创建具有分配内存的Uint16Array。
         * @param length 数组的长度。
         */
        static createUint16Array(length: number): {
            ptr: number;
            buffer: Uint16Array;
        };
        /**
         * @en Create a Uint8Array with allocated memory.
         * @param length The length of the array.
         * @zh 创建具有分配内存的Uint8Array。
         * @param length 数组的长度。
         */
        static createUint8Array(length: number): {
            ptr: number;
            buffer: Uint8Array;
        };
        /**
         * @en Free the allocated memory for a buffer.
         * @param data The buffer object to free.
         * @zh 释放为缓冲区分配的内存。
         * @param data 要释放的缓冲区对象。
         */
        static freeBuffer(data: any): void;
    }
    enum partFlag {
        eSOLVE_CONTACT = 1,
        eMODIFY_CONTACTS = 2,
        eNOTIFY_TOUCH_FOUND = 4,
        eNOTIFY_TOUCH_PERSISTS = 8,
        eNOTIFY_TOUCH_LOST = 16,
        eNOTIFY_TOUCH_CCD = 32,
        eNOTIFY_THRESHOLD_FORCE_FOUND = 64,
        eNOTIFY_THRESHOLD_FORCE_PERSISTS = 128,
        eNOTIFY_THRESHOLD_FORCE_LOST = 256,
        eNOTIFY_CONTACT_POINTS = 512,
        eDETECT_DISCRETE_CONTACT = 1024,
        eDETECT_CCD_CONTACT = 2048,
        ePRE_SOLVER_VELOCITY = 4096,
        ePOST_SOLVER_VELOCITY = 8192,
        eCONTACT_EVENT_POSE = 16384,
        eNEXT_FREE = 32768,
        eCONTACT_DEFAULT = 1025,
        eTRIGGER_DEFAULT = 1044
    }
    /**
     * @en The `pxPhysicsManager` class is used to implement physics management.
     * @zh `pxPhysicsManager` 类用于实现物理管理。
     */
    class pxPhysicsManager implements IPhysicsManager {
        _dynamicUpdateList: PhysicsUpdateList;
        /**
         * @en Fixed time step for physics simulation.
         * @zh 物理模拟的固定时间步长。
         */
        fixedTime: number;
        /**
         * @en Whether to enable Continuous Collision Detection (CCD).
         * @zh 是否启用连续碰撞检测(CCD)。
         */
        enableCCD: boolean;
        _pxcontrollerManager: any;
        private _gravity;
        /**temp tranform object */
        private static _tempTransform;
        /**
         * @en Create a new instance of `pxPhysicsManager`.
         * @param physicsSettings The physics settings to initialize the manager.
         * @zh 创建`pxPhysicsManager`类的新实例。
         * @param physicsSettings 用于初始化管理器的物理设置。
         */
        constructor(physicsSettings: PhysicsSettings);
        /**
         * @en Set the active state of a collider.
         * @param collider The collider to set.
         * @param value The active state to set.
         * @zh 设置碰撞器的活动状态。
         * @param collider 要设置的碰撞器。
         * @param value 要设置的活动状态。
         */
        setActiveCollider(collider: pxCollider, value: boolean): void;
        /**
         * @en Enable or disable the debug drawer.
         * @param value Whether to enable the debug drawer.
         * @zh 启用或禁用调试绘制器。
         * @param value 是否启用调试绘制器。
         */
        enableDebugDrawer?(value: boolean): void;
        /**
         * @en Set collision data to the appropriate map based on the event type.
         * @param dataCallBack The collision data callback.
         * @param eventType The type of collision event.
         * @param isTrigger Whether the collision is a trigger event.
         * @zh 根据事件类型将碰撞数据设置到适当的映射中。
         * @param dataCallBack 碰撞数据回调。
         * @param eventType 碰撞事件的类型。
         * @param isTrigger 碰撞是否为触发器事件。
         */
        setDataToMap(dataCallBack: any, eventType: string, isTrigger?: boolean): void;
        /**
         * @en Set the gravity of the physics world.
         * @param gravity The gravity vector to set.
         * @zh 设置物理世界的重力。
         * @param gravity 要设置的重力向量。
         */
        setGravity(gravity: Vector3): void;
        private _addCharactorCollider;
        private _removeCharactorCollider;
        private addDynamicElementByUUID;
        private removeDynamicElementByUUID;
        /**
         * @en Add a collider to the physics world.
         * @param collider The collider to be added.
         * @zh 将碰撞器添加到物理世界中。
         * @param collider 要添加的碰撞器。
         */
        addCollider(collider: ICollider): void;
        /**
         * @en Remove a collider from the physics world.
         * @param collider The collider to be removed.
         * @zh 从物理世界中移除碰撞器。
         * @param collider 要移除的碰撞器。
         */
        removeCollider(collider: ICollider): void;
        /**
         * @private
         * @perfTag PerformanceDefine.T_PhysicsCollider
         */
        private _collision_event;
        /**
         * @private
         * @perfTag PerformanceDefine.T_PhysicsColliderEnter
         */
        private _collision_EnterEvent;
        /**
         * @private
         * @perfTag PerformanceDefine.T_PhysicsColliderStay
         */
        private _collision_StayEvent;
        /**
         * @private
         * @perfTag PerformanceDefine.T_PhysicsColliderExit
         */
        private _collision_ExitEvent;
        /**
         * @private
         * @perfTag PerformanceDefine.T_PhysicsTrigger
         */
        private _trigger_Event;
        /**
         * @private
         * @perfTag PerformanceDefine.T_PhysicsTriggerEnter
         */
        private _trigger_EnterEvent;
        /**
         * @private
         * @perfTag PerformanceDefine.T_PhysicsTriggerStay
         */
        private _trigger_StayEvent;
        /**
         * @private
         * @perfTag PerformanceDefine.T_PhysicsTriggerExit
         */
        private _trigger_ExitEvent;
        /**
         * @private
         * @perfTag PerformanceDefine.T_PhysicsEvent
         */
        private _updatePhysicsEvents;
        /**
         * @private
         * @perfTag PerformanceDefine.T_Physics_UpdateNode
         */
        private _updatePhysicsTransformToRender;
        /**
         * @perfTag PerformanceDefine.T_Physics_Simulation
         * @en Update the physics simulation.
         * @param elapsedTime The elapsed time since the last update.
         * @zh 更新物理模拟。
         * @param elapsedTime 自上次更新以来经过的时间。
         */
        update(elapsedTime: number): void;
        /**
         * @en Performs a ray cast in the physics world.Returns the first hit object.
         * @param ray The ray to cast.
         * @param outHitResult The result of the raycast.
         * @param distance The maximum distance of the raycast.
         * @param collisonGroup The collision group of the ray.
         * @param collisionMask The collision mask of the ray.
         * @returns Whether the raycast hit anything.
         * @zh 执行一次射线检测，返回第一个与射线相交的碰撞体信息。
         * @param ray 要投射的射线。
         * @param outHitResult 射线检测的结果。
         * @param distance 射线检测的最大距离。
         * @param collisonGroup 射线的碰撞组。
         * @param collisionMask 射线的碰撞掩码。
         * @returns 射线是否击中了任何物体。
         */
        rayCast(ray: Ray, outHitResult: HitResult, distance?: number, collisonGroup?: number, collisionMask?: number): boolean;
        /**
         * @en Performs a ray cast in the physics world.Returns all hit objects.
         * @param ray The ray to cast.
         * @param out An array to store all hit results.
         * @param distance The maximum distance of the raycast.
         * @param collisonGroup The collision group of the ray.
         * @param collisionMask The collision mask of the ray.
         * @returns Whether the raycast hit anything.
         * @zh 执行一次射线检测，返回所有与射线相交的碰撞体信息。
         * @param ray 要投射的射线。
         * @param out 用于存储所有击中结果的数组。
         * @param distance 射线检测的最大距离。
         * @param collisonGroup 射线的碰撞组。
         * @param collisionMask 射线的碰撞掩码。
         * @returns 射线是否击中了任何物体。
         */
        rayCastAll?(ray: Ray, out: HitResult[], distance?: number, collisonGroup?: number, collisionMask?: number): boolean;
        /**
         * @en Performs a shape cast. Returns the first hit object.
         * @param shape The shape to cast.
         * @param fromPosition The starting position of the shape.
         * @param toPosition The ending position of the shape.
         * @param out The result of the shape cast.
         * @param fromRotation The starting rotation of the shape.
         * @param toRotation The ending rotation of the shape.
         * @param collisonGroup The collision group of the shape.
         * @param collisionMask The collision mask of the shape.
         * @param allowedCcdPenetration The allowed continuous collision detection penetration.
         * @returns Whether the shape cast hit anything.
         * @zh 执行形状射线检测，返回第一个与射线相交的碰撞体信息。
         * @param shape 要投射的形状。
         * @param fromPosition 形状的起始位置。
         * @param toPosition 形状的结束位置。
         * @param out 形状投射的结果。
         * @param fromRotation 形状的起始旋转。
         * @param toRotation 形状的结束旋转。
         * @param collisonGroup 形状的碰撞组。
         * @param collisionMask 形状的碰撞掩码。
         * @param allowedCcdPenetration 允许的连续碰撞检测穿透。
         * @returns 形状投射是否击中了任何物体。
         */
        shapeCast(shape: pxColliderShape, fromPosition: Vector3, toPosition: Vector3, out: HitResult, fromRotation?: Quaternion, toRotation?: Quaternion, collisonGroup?: number, collisionMask?: number, allowedCcdPenetration?: number): boolean;
        /**
         * @en Performs a shape cast. Returns all hit objects.
         * @param shape The shape to cast.
         * @param fromPosition The starting position of the shape.
         * @param toPosition The ending position of the shape.
         * @param out An array to store all hit results.
         * @param fromRotation The starting rotation of the shape.
         * @param toRotation The ending rotation of the shape.
         * @param collisonGroup The collision group of the shape.
         * @param collisionMask The collision mask of the shape.
         * @param allowedCcdPenetration The allowed continuous collision detection penetration.
         * @returns Whether the shape cast hit anything.
         * @zh 执行形状投射，返回所有与射线相交的碰撞体信息。
         * @param shape 要投射的形状。
         * @param fromPosition 形状的起始位置。
         * @param toPosition 形状的结束位置。
         * @param out 用于存储所有击中结果的数组。
         * @param fromRotation 形状的起始旋转。
         * @param toRotation 形状的结束旋转。
         * @param collisonGroup 形状的碰撞组。
         * @param collisionMask 形状的碰撞掩码。
         * @param allowedCcdPenetration 允许的连续碰撞检测穿透。
         * @returns 形状投射是否击中了任何物体。
         */
        shapeCastAll(shape: pxColliderShape, fromPosition: Vector3, toPosition: Vector3, out: HitResult[], fromRotation?: Quaternion, toRotation?: Quaternion, collisonGroup?: number, collisionMask?: number, allowedCcdPenetration?: number): boolean;
        sphereQuery?(pos: Vector3, radius: number, result: ICollider[], collisionmask: number): void;
        destroy(): void;
    }
    /**
     * @en Represents a physics material in the PhysX engine.
     * @zh 表示PhysX引擎中的物理材质。
     */
    class pxPhysicsMaterial {
        private _bounciness;
        private _dynamicFriction;
        private _staticFriction;
        private _bounceCombine;
        private _frictionCombine;
        /**
         * @en Creates a new pxPhysicsMaterial class.
         * @zh 创建一个新的pxPhysicsMaterial类。
         */
        constructor();
        /**
         * @en Sets the bounciness (restitution).
         * @param value The bounciness value.
         * @zh 设置反弹性（恢复系数）。
         * @param value 反弹性值。
         */
        setBounciness(value: number): void;
        /**
         * @en Sets the dynamic friction.
         * @param value The dynamic friction value.
         * @zh 设置动态摩擦力。
         * @param value 动态摩擦力值。
         */
        setDynamicFriction(value: number): void;
        /**
         * @en Sets the static friction.
         * @param value The static friction value.
         * @zh 设置静态摩擦力。
         * @param value 静态摩擦力值。
         */
        setStaticFriction(value: number): void;
        /**
         * @en Sets the bounce combine mode.
         * @param value The bounce combine mode.
         * @zh 设置反弹组合模式。
         * @param value 反弹组合模式。
         */
        setBounceCombine(value: PhysicsCombineMode): void;
        /**
         * @en Sets the friction combine mode.
         * @param value The friction combine mode.
         * @zh 设置摩擦力组合模式。
         * @param value 摩擦力组合模式。
         */
        setFrictionCombine(value: PhysicsCombineMode): void;
        /**
         * @en Destroys the physics material and releases associated resources.
         * @zh 销毁物理材质并释放相关资源。
         */
        destroy(): void;
    }
    /**
     * @en Represents a box collider shape in the PhysX physics engine.
     * @zh 表示 PhysX 物理引擎中的盒状碰撞器形状。
     */
    class pxBoxColliderShape extends pxColliderShape implements IBoxColliderShape {
        private static _tempHalfExtents;
        /**
         * @en Creates a new instance of pxBoxColliderShape.
         * @zh 创建 pxBoxColliderShape 的新实例。
         */
        constructor();
        /**
         * @en Sets the size of the box collider.
         * @param size The new size of the box collider.
         * @zh 设置盒状碰撞器的大小。
         * @param size 盒状碰撞器的新大小。
         */
        setSize(size: Vector3): void;
        /**
         * @en Sets the offset of the box collider.
         * @param position The new offset position.
         * @zh 设置盒状碰撞器的偏移。
         * @param position 新的偏移位置。
         */
        setOffset(position: Vector3): void;
        /**
         * @en Destroys the box collider shape and releases resources.
         * @zh 销毁盒状碰撞器形状并释放资源。
         */
        destroy(): void;
    }
    /**
     * @en Represents a capsule collider shape in the PhysX physics engine.
     * @zh 表示 PhysX 物理引擎中的胶囊碰撞器形状。
     */
    class pxCapsuleColliderShape extends pxColliderShape implements ICapsuleColliderShape {
        private _upAxis;
        /**
         * @en Creates a new instance of pxCapsuleColliderShape.
         * @zh 创建 pxCapsuleColliderShape 的新实例。
         */
        constructor();
        /**
         * @en Adds the shape to a collider.
         * @param collider The collider to add the shape to.
         * @zh 将形状添加到碰撞器。
         * @param collider 要添加形状的碰撞器。
         */
        addToActor(collider: pxCollider): void;
        /**
         * @en Sets the radius of the capsule.
         * @param radius The new radius value.
         * @zh 设置胶囊体的半径。
         * @param radius 新的半径值。
         */
        setRadius(radius: number): void;
        /**
         * @en Sets the height of the capsule.
         * @param height The new height value.
         * @zh 设置胶囊体的高度。
         * @param height 新的高度值。
         */
        setHeight(height: number): void;
        /**
         * @en Sets the up axis of the capsule.
         * @param upAxis The new up axis value.
         * @zh 设置胶囊体的向上轴。
         * @param upAxis 新的向上轴值。
         */
        setUpAxis(upAxis: number): void;
        /**
         * @en Sets the offset of the capsule collider.
         * @param position The new offset position.
         * @zh 设置胶囊碰撞器的偏移。
         * @param position 新的偏移位置。
         */
        setOffset(position: Vector3): void;
        /**
         * @en Destroys the capsule collider shape and releases resources.
         * @zh 销毁胶囊碰撞器形状并释放资源。
         */
        destroy(): void;
    }
    /**
     * Flags which affect the behavior of Shapes.
     */
    enum ShapeFlag {
        /** The shape will partake in collision in the physical simulation. */
        SIMULATION_SHAPE = 1,
        /** The shape will partake in scene queries (ray casts, overlap tests, sweeps, ...). */
        SCENE_QUERY_SHAPE = 2,
        /** The shape is a trigger which can send reports whenever other shapes enter/leave its volume. */
        TRIGGER_SHAPE = 4
    }
    interface pxFilterData {
        word0?: number;
        word1?: number;
        word2?: number;
        word3?: number;
    }
    /**
     * @en Represents a collider shape in the PhysX physics engine.
     * @zh 表示 PhysX 物理引擎中的碰撞器形状。
     */
    class pxColliderShape implements IColliderShape {
        static _shapePool: Map<number, pxColliderShape>;
        static _pxShapeID: number;
        static transform: {
            translation: Vector3;
            rotation: Quaternion;
        };
        _offset: Vector3;
        _scale: Vector3;
        _shapeFlags: ShapeFlag;
        _pxShape: any;
        _pxGeometry: any;
        _destroyed: boolean;
        _id: number;
        /**
         * @en Filter data for collision and query. [0]: group, [1]: mask, [2]: event
         * @zh 碰撞和查询的过滤数据。[0]: 组, [1]: 掩码, [2]: 事件
         */
        filterData: pxFilterData;
        /** @ignore */
        constructor();
        /**
         * @override
         */
        protected _createShape(): void;
        private _modifyFlag;
        getPhysicsShape(): any;
        /**
         * @en Adds the shape to a collider.
         * @param collider The collider to add the shape to.
         * @zh 将形状添加到碰撞器。
         * @param collider 要添加形状的碰撞器。
         */
        addToActor(collider: pxCollider): void;
        /**
         * @en Removes the shape from a collider.
         * @param collider The collider to remove the shape from.
         * @zh 从碰撞器中移除形状。
         * @param collider 要移除形状的碰撞器。
         */
        removeFromActor(collider: pxCollider): void;
        /**
         * @en Sets the offset of the shape.
         * @param position The new offset position.
         * @zh 设置形状的偏移。
         * @param position 新的偏移位置。
         */
        setOffset(position: Vector3): void;
        getOffset(): Vector3;
        /**
         * @en Sets whether the shape is a trigger.
         * @param value True if the shape should be a trigger, false otherwise.
         * @zh 设置形状是否为触发器。
         * @param value 如果形状应为触发器则为 true，否则为 false。
         */
        setIsTrigger(value: boolean): void;
        _setShapeFlags(flags: ShapeFlag): void;
        /**
         * @en Sets the simulation filter data.
         * @param colliderGroup The collider group.
         * @param colliderMask The collider mask.
         * @zh 设置模拟过滤数据。
         * @param colliderGroup 碰撞器组。
         * @param colliderMask 碰撞器掩码。
         */
        setSimulationFilterData(colliderGroup: number, colliderMask: number): void;
        /**
         * @en Optimizes event return.
         * @param filterWorld2Number The filter data.
         * @zh 优化事件返回。
         * @param filterWorld2Number 过滤数据。
         */
        setEventFilterData(filterWorld2Number: number): void;
        /**
         * @en Destroys the collider shape and releases resources.
         * @zh 销毁碰撞器形状并释放资源。
         */
        destroy(): void;
    }
    class pxCompoundShape extends pxColliderShape implements ICompoundColliderShape {
        private _physicsComponent;
        pxShapes: pxColliderShape[];
        constructor();
        addChildShape(shape: pxColliderShape): void;
        removeChildShape(shape: pxColliderShape, index: number): void;
        setShapeData(component: PhysicsColliderComponent): void;
        refreshShapes(): void;
    }
    /**
     * @en Represents a height field shape in the PhysX physics engine.
     * @zh 表示 PhysX 物理引擎中的高度场形状。
     */
    class pxHeightFieldShape extends pxColliderShape implements IHeightFieldShape {
        /**@ignore */
        constructor();
        /**
         * get height data tranform
         * @returns
         */
        private getHeightData;
        /**
         * get flag Data
         * @returns
         */
        private getFlagData;
        /**
         * create HeightField Geometry
         */
        private _createHeightField;
        /**
         * @en Sets the height field data.
         * @param numRows Number of rows.
         * @param numCols Number of columns.
         * @param heightData Height data array.
         * @param flag Flag data array.
         * @param scale Scale of the height field.
         * @zh 设置高度场数据。
         * @param numRows 行数。
         * @param numCols 列数。
         * @param heightData 高度数据数组。
         * @param flag 标志数据数组。
         * @param scale 高度场的缩放。
         */
        setHeightFieldData(numRows: number, numCols: number, heightData: Float32Array, flag: Uint8Array, scale: Vector3): void;
        /**
         * @en Gets the number of rows in the height field.
         * @returns Number of rows.
         * @zh 获取高度场的行数。
         * @returns 行数。
         */
        getNbRows(): number;
        /**
         * @en Gets the number of columns in the height field.
         * @returns Number of columns.
         * @zh 获取高度场的列数。
         * @returns 列数。
         */
        getNbColumns(): number;
        /**
         * @en Gets the height at a specific row and column.
         * @param rows Row index.
         * @param cols Column index.
         * @returns Height value.
         * @zh 获取特定行列的高度值。
         * @param rows 行索引。
         * @param cols 列索引。
         * @returns 高度值。
         */
        getHeight(rows: number, cols: number): number;
    }
    enum PxConvexFlag {
        e16_BIT_INDICES = 1,
        eCOMPUTE_CONVEX = 2,
        eCHECK_ZERO_AREA_TRIANGLES = 4,
        eQUANTIZE_INPUT = 8,
        eDISABLE_MESH_VALIDATION = 16,
        ePLANE_SHIFTING = 32,
        eFAST_INERTIA_COMPUTATION = 64,
        eGPU_COMPATIBLE = 128,
        eSHIFT_VERTICES = 256
    }
    enum PxConvexMeshGeometryFlag {
        eTIGHT_BOUNDS = 1
    }
    enum PxMeshGeometryFlag {
        eTIGHT_BOUNDS = 1,
        eDOUBLE_SIDED = 2
    }
    /**
     * @en Represents a mesh collider shape in the physics engine.
     * @zh 表示物理引擎中的网格碰撞器形状。
     */
    class pxMeshColliderShape extends pxColliderShape implements IMeshColliderShape {
        private _limitvertex;
        private _mesh;
        private _convex;
        private _meshScale;
        /**
         * @en Creates a new instance of pxMeshColliderShape.
         * @zh 创建一个新的 pxMeshColliderShape 实例。
         */
        constructor();
        private _getMeshPosition;
        private _getIndices;
        private _createConvexMeshGeometry;
        private _createTrianggleMeshGeometry;
        /**
         * @override
         */
        protected _createShape(): void;
        private _reConfigShape;
        private _setScale;
        /**
         * @en Sets the offset of the collider shape.
         * @param position The new offset position.
         * @zh 设置碰撞器形状的偏移。
         * @param position 新的偏移位置。
         */
        setOffset(position: Vector3): void;
        /**
         * @en Sets the physics mesh from a given mesh.
         * @param value The mesh to use for physics.
         * @zh 从给定的网格设置物理网格。
         * @param value 用于物理的网格。
         */
        setPhysicsMeshFromMesh(value: Mesh): void;
        /**
         * @en Sets the convex mesh for the collider.
         * @param value The convex mesh to use.
         * @zh 设置碰撞器的凸面网格。
         * @param value 要使用的凸面网格。
         */
        setConvexMesh(value: Mesh): void;
        /**
         * @en Sets the vertex limit for convex mesh generation.
         * @param limit The maximum number of vertices.
         * @zh 设置凸面网格生成的顶点限制。
         * @param limit 最大顶点数。
         */
        setLimitVertex(limit: number): void;
    }
    /**
     * @en Represents a sphere collider shape in the physics engine.
     * @zh 表示物理引擎中的球体碰撞器形状。
     */
    class pxSphereColliderShape extends pxColliderShape implements ISphereColliderShape {
        /**
         * @en Creates a new instance of pxSphereColliderShape.
         * @zh 创建一个新的 pxSphereColliderShape 实例。
         */
        constructor();
        /**
         * @en Sets the radius of the sphere collider.
         * @param radius The new radius value.
         * @zh 设置球体碰撞器的半径。
         * @param radius 新的半径值。
         */
        setRadius(radius: number): void;
        /**
         * @en Sets the offset position of the sphere collider.
         * @param position The new offset position.
         * @zh 设置球体碰撞器的偏移位置。
         * @param position 新的偏移位置。
         */
        setOffset(position: Vector3): void;
        /**
         * @en Destroys the sphere collider shape and releases resources.
         * @zh 销毁球体碰撞器形状并释放资源。
         */
        destroy(): void;
    }
    /**
     * 前向渲染流程通用类
     */
    class ForwardAddClusterRP {
        pipelineMode: PipelineMode;
        depthPipelineMode: PipelineMode;
        depthNormalPipelineMode: PipelineMode;
        depthTarget: InternalRenderTarget;
        destTarget: InternalRenderTarget;
        camera: ICameraNodeData;
        cameraCullInfo: CameraCullInfo;
        depthTextureMode: DepthTextureMode;
        depthNormalTarget: InternalRenderTarget;
        beforeForwardCmds: CommandBuffer[];
        beforeSkyboxCmds: CommandBuffer[];
        beforeTransparentCmds: CommandBuffer[];
        skyRenderNode: WebBaseRenderNode;
        clearColor: Color;
        clearFlag: number;
        enableCMD: boolean;
        enableOpaque: boolean;
        enableTransparent: boolean;
        protected _opaqueList: RenderListQueue;
        protected _transparent: RenderListQueue;
        protected _zBufferParams: Vector4;
        protected _defaultNormalDepthColor: Color;
        protected _viewPort: Viewport;
        setViewPort(value: Viewport): void;
        protected _scissor: Vector4;
        setScissor(value: Vector4): void;
        constructor();
        /**
         * 设置相机裁剪信息
         * @param camera
         */
        setCameraCullInfo(camera: Camera): void;
        /**
         * 设置渲染命令（前向渲染之前）
         * @param value
         */
        setBeforeForwardCmds(value: CommandBuffer[]): void;
        /**
         * 设置渲染命令（天空渲染之前）
         * @param value
         */
        setBeforeSkyboxCmds(value: CommandBuffer[]): void;
        /**
         * 设置渲染命令（透明物体渲染之前）
         * @param value
         */
        setBeforeTransparentCmds(value: CommandBuffer[]): void;
        /**
         * 渲染流程（TODO:其他两个pass合并MulTargetRT）
         * @param context
         * @param list
         * @param count
         */
        render(context: IRenderContext3D, list: WebBaseRenderNode[], count: number): void;
        /**
         * 清除渲染队列
         */
        protected _clearRenderList(): void;
        /**
         * 缓存视口和裁剪
         */
        protected _cacheViewPortAndScissor(): void;
        /**
         * 渲染深度流程
         * @param context
         */
        protected _renderDepthPass(context: IRenderContext3D): void;
        /**
         * 渲染法线深度流程
         * @param context
         */
        protected _renderDepthNormalPass(context: IRenderContext3D): void;
        /**
         * 主渲染流程
         * @param context
         */
        protected _mainPass(context: IRenderContext3D): void;
        /**
         * 渲染不透明贴图流程
         */
        protected _opaqueTexturePass(): void;
    }
    /**
     * 裁剪通用工具类
     */
    class RenderCullUtil {
        /**
         * 相机裁剪
         * @param cameraCullInfo 相机裁剪信息
         * @param list 渲染节点列表
         * @param count 渲染节点数量（为什么不是list.length?）
         * @param opaqueList 不透明队列
         * @param transparent 透明队列
         * @param context 渲染上下文
         */
        static cullByCameraCullInfo(cameraCullInfo: CameraCullInfo, list: WebBaseRenderNode[], count: number, opaqueList: RenderListQueue, transparent: RenderListQueue, context: IRenderContext3D): void;
        /**
         * 方向光源裁剪
         * @param shadowCullInfo
         * @param list
         * @param count
         * @param opaqueList
         * @param context
         */
        static cullDirectLightShadow(shadowCullInfo: ShadowCullInfo, list: WebBaseRenderNode[], count: number, opaqueList: RenderListQueue, context: IRenderContext3D): void;
        /**
         * 聚光灯裁剪
         * @param cameraCullInfo
         * @param list
         * @param count
         * @param opaqueList
         * @param context
         */
        static cullSpotShadow(cameraCullInfo: CameraCullInfo, list: WebBaseRenderNode[], count: number, opaqueList: RenderListQueue, context: IRenderContext3D): void;
    }
    /**
     * 渲染节点队列
     */
    class RenderListQueue {
        private _elements;
        get elements(): FastSinglelist<IRenderElement3D>;
        private _quickSort;
        private _isTransparent;
        _batch: IInstanceRenderBatch;
        constructor(isTransParent: boolean);
        /**
         * 添加渲染元素
         * @param renderelement
         */
        addRenderElement(renderelement: IRenderElement3D): void;
        /**
         * 合并渲染队列
         */
        private _batchQueue;
        /**
         * 渲染队列
         * @param context
         */
        renderQueue(context: IRenderContext3D): void;
        /**
         * 清空队列
         */
        clear(): void;
        /**
         * 销毁
         */
        destroy(): void;
    }
    /**
     * 渲染流程通用工具类
     */
    class RenderPassUtil {
        static contextViewPortCache: Viewport;
        static contextScissorCache: Vector4;
        /**
         * 执行渲染命令
         * @param cmds
         * @param context
         */
        static renderCmd(cmds: CommandBuffer[], context: IRenderContext3D): void;
        /**
         * 恢复渲染上下文
         * @param context
         * @param renderTarget
         */
        static recoverRenderContext3D(context: IRenderContext3D, renderTarget: InternalRenderTarget): void;
    }
    /**
     * 渲染节点快速排序
     */
    class RenderQuickSort {
        private elementArray;
        private isTransparent;
        /**
         * 快速排序
         * @param elements
         * @param isTransparent
         * @param left
         * @param right
         */
        sort(elements: FastSinglelist<IRenderElement3D>, isTransparent: boolean, left: number, right: number): void;
    }
    interface I2DRenderPassFactory {
        createRenderElement2D(): IRenderElement2D;
        createRenderContext2D(): IRenderContext2D;
    }
    interface IRenderContext2D {
        invertY: boolean;
        pipelineMode: string;
        sceneData: ShaderData;
        setRenderTarget(value: InternalRenderTarget, clear: boolean, clearColor: Color): void;
        setOffscreenView(width: number, height: number): void;
        drawRenderElementOne(node: IRenderElement2D): void;
        drawRenderElementList(list: SingletonList<IRenderElement2D>): number;
    }
    interface IRenderElement2D {
        geometry: IRenderGeometryElement;
        materialShaderData: ShaderData;
        value2DShaderData: ShaderData;
        subShader: SubShader;
        renderStateIsBySprite: boolean;
        destroy(): void;
    }
    interface IRender3DProcess {
        render3DManager: ISceneRenderManager;
        fowardRender(context: IRenderContext3D, camera: Camera): void;
        destroy(): void;
    }
    type PipelineMode = "Forward" | "ShadowCaster" | "DepthNormal" | string;
    interface IRenderContext3D {
        globalShaderData: ShaderData;
        sceneData: ShaderData;
        sceneModuleData: ISceneNodeData;
        cameraModuleData: ICameraNodeData;
        cameraData: ShaderData;
        sceneUpdataMask: number;
        cameraUpdateMask: number;
        pipelineMode: PipelineMode;
        invertY: boolean;
        setRenderTarget(value: InternalRenderTarget, clearFlag: RenderClearFlag): void;
        setViewPort(value: Viewport): void;
        setScissor(value: Vector4): void;
        setClearData(clearFlag: number, clolor: Color, depth: number, stencil: number): number;
        drawRenderElementList(list: FastSinglelist<IRenderElement3D>): number;
        drawRenderElementOne(node: IRenderElement3D): number;
        runOneCMD(cmd: IRenderCMD): void;
        runCMDList(cmds: IRenderCMD[]): void;
    }
    interface IRenderElement3D {
        geometry: IRenderGeometryElement;
        materialShaderData: ShaderData;
        materialRenderQueue: number;
        renderShaderData: ShaderData;
        transform: Transform3D;
        canDynamicBatch: boolean;
        isRender: boolean;
        owner: IBaseRenderNode;
        subShader: SubShader;
        materialId: number;
        destroy(): void;
    }
    interface IInstanceRenderBatch {
        batch(elements: SingletonList<IRenderElement3D>): void;
        clearRenderData(): void;
        recoverData(): void;
    }
    interface IInstanceRenderElement3D extends IRenderElement3D {
        instanceElementList: SingletonList<IRenderElement3D>;
        setGeometry(geometry: IRenderGeometryElement): void;
        clearRenderData(): void;
        recover(): void;
    }
    interface ISkinRenderElement3D {
        skinnedData: Float32Array[];
    }
    interface I3DRenderPassFactory {
        createRender3DProcess(): IRender3DProcess;
        createRenderContext3D(): IRenderContext3D;
        createRenderElement3D(): IRenderElement3D;
        createInstanceBatch(): IInstanceRenderBatch;
        createInstanceRenderElement3D(): IInstanceRenderElement3D;
        createSkinRenderElement(): ISkinRenderElement3D;
        createSceneRenderManager(): ISceneRenderManager;
        createDrawNodeCMDData(): DrawNodeCMDData;
        createBlitQuadCMDData(): BlitQuadCMDData;
        createDrawElementCMDData(): DrawElementCMDData;
        createSetViewportCMD(): SetViewportCMD;
        createSetRenderTargetCMD(): SetRenderTargetCMD;
        createSetRenderDataCMD(): SetRenderDataCMD;
        createSetShaderDefineCMD(): SetShaderDefineCMD;
    }
    enum RenderCMDType {
        DrawNode = 0,
        DrawElement = 1,
        Blit = 2,
        ChangeData = 3,
        ChangeShaderDefine = 4,
        ChangeViewPort = 5,
        ChangeRenderTarget = 6
    }
    interface IRenderCMD {
        type: RenderCMDType;
        apply(context: IRenderContext3D): void;
    }
    class DrawNodeCMDData implements IRenderCMD {
        type: RenderCMDType;
        protected _node: IBaseRenderNode;
        protected _destShaderData: ShaderData;
        protected _destSubShader: SubShader;
        protected _subMeshIndex: number;
        get node(): IBaseRenderNode;
        set node(value: IBaseRenderNode);
        get destShaderData(): ShaderData;
        set destShaderData(value: ShaderData);
        get destSubShader(): SubShader;
        set destSubShader(value: SubShader);
        get subMeshIndex(): number;
        set subMeshIndex(value: number);
        apply(context: IRenderContext3D): void;
    }
    class BlitQuadCMDData implements IRenderCMD {
        type: RenderCMDType;
        protected _dest: InternalRenderTarget;
        protected _viewport: Viewport;
        protected _scissor: Vector4;
        protected _source: InternalTexture;
        protected _offsetScale: Vector4;
        protected _element: IRenderElement3D;
        get element(): IRenderElement3D;
        set element(value: IRenderElement3D);
        get dest(): InternalRenderTarget;
        set dest(value: InternalRenderTarget);
        get viewport(): Viewport;
        set viewport(value: Viewport);
        get scissor(): Vector4;
        set scissor(value: Vector4);
        get source(): InternalTexture;
        set source(value: InternalTexture);
        get offsetScale(): Vector4;
        set offsetScale(value: Vector4);
        apply(context: IRenderContext3D): void;
    }
    class DrawElementCMDData implements IRenderCMD {
        type: RenderCMDType;
        setRenderelements(value: IRenderElement3D[]): void;
        apply(context: IRenderContext3D): void;
    }
    class SetViewportCMD implements IRenderCMD {
        type: RenderCMDType;
        protected _viewport: Viewport;
        protected _scissor: Vector4;
        get viewport(): Viewport;
        set viewport(value: Viewport);
        get scissor(): Vector4;
        set scissor(value: Vector4);
        apply(context: IRenderContext3D): void;
    }
    class SetRenderTargetCMD implements IRenderCMD {
        type: RenderCMDType;
        protected _rt: InternalRenderTarget;
        protected _clearFlag: number;
        protected _clearDepthValue: number;
        protected _clearStencilValue: number;
        protected _clearColorValue: Color;
        get rt(): InternalRenderTarget;
        set rt(value: InternalRenderTarget);
        get clearFlag(): number;
        set clearFlag(value: number);
        get clearDepthValue(): number;
        set clearDepthValue(value: number);
        get clearStencilValue(): number;
        set clearStencilValue(value: number);
        get clearColorValue(): Color;
        set clearColorValue(value: Color);
        apply(context: IRenderContext3D): void;
    }
    class SetRenderDataCMD implements IRenderCMD {
        type: RenderCMDType;
        protected _value: ShaderDataItem;
        protected _dataType: ShaderDataType;
        protected _propertyID: number;
        protected _dest: ShaderData;
        get value(): ShaderDataItem;
        set value(value: ShaderDataItem);
        get dataType(): ShaderDataType;
        set dataType(value: ShaderDataType);
        get propertyID(): number;
        set propertyID(value: number);
        get dest(): ShaderData;
        set dest(value: ShaderData);
        apply(context: IRenderContext3D): void;
    }
    class SetShaderDefineCMD implements IRenderCMD {
        type: RenderCMDType;
        protected _define: ShaderDefine;
        protected _dest: ShaderData;
        protected _add: boolean;
        get define(): ShaderDefine;
        set define(value: ShaderDefine);
        get dest(): ShaderData;
        set dest(value: ShaderData);
        get add(): boolean;
        set add(value: boolean);
        apply(context: IRenderContext3D): void;
    }
    /**
     * @deprecated
     */
    interface IRenderEngine3DOBJFactory {
        /**
         * @deprecated
         */
        createVertexBuffer3D(byteLength: number, bufferUsage: BufferUsage, canRead: boolean): VertexBuffer3D;
        /**
         * @deprecated
         */
        createIndexBuffer3D(indexType: IndexFormat, indexCount: number, bufferUsage: BufferUsage, canRead: boolean): IndexBuffer3D;
    }
    /**
     * 可替换的SceneManager
     */
    interface ISceneRenderManager {
        list: FastSinglelist<BaseRender>;
        /**
         * add one BaseRender
         * @param object
         */
        addRenderObject(object: BaseRender): void;
        /**
         * remove RenderObject
         * @param object
         */
        removeRenderObject(object: BaseRender): void;
        /**
         * 移除某个动态的渲染节点
         * @param object
         */
        removeMotionObject(object: BaseRender): void;
        /**
         * 增加运动物体
         * @param object
         */
        addMotionObject(object: BaseRender): void;
        /**
         * 更新运动物体
         */
        updateMotionObjects(): void;
        /**
         * release Manager Node
         */
        destroy(): void;
    }
    /**
     * @deprecated
     */
    class LengencyRenderEngine3DFactory implements IRenderEngine3DOBJFactory {
        /**
         * @deprecated use new VertexBuffer3D
         * @param byteLength
         * @param bufferUsage
         * @param canRead
         * @returns
         */
        createVertexBuffer3D(byteLength: number, bufferUsage: BufferUsage, canRead?: boolean): VertexBuffer3D;
        /**
         * @deprecated use new IndexBuffer3D
         * @param indexType
         * @param indexCount
         * @param bufferUsage
         * @param canRead
         * @returns
         */
        createIndexBuffer3D(indexType: IndexFormat, indexCount: number, bufferUsage?: BufferUsage, canRead?: boolean): IndexBuffer3D;
    }
    type UniformProperty = {
        id: number;
        propertyName: string;
        uniformtype: ShaderDataType;
    };
    class CommandUniformMap {
        constructor(stateName: string);
        /**
         * 增加一个Uniform参数
         */
        addShaderUniform(propertyID: number, propertyKey: string, uniformtype: ShaderDataType, block?: string): void;
        /**
         * 增加一个UniformArray参数
         */
        addShaderUniformArray(propertyID: number, propertyName: string, uniformtype: ShaderDataType, arrayLength: number, block?: string): void;
        /**
         * 增加一个Uniform
         */
        addShaderBlockUniform(propertyID: number, blockname: string, blockProperty: UniformProperty[]): void;
    }
    interface IBufferState {
        _bindedIndexBuffer: IIndexBuffer;
        _vertexBuffers: IVertexBuffer[];
        applyState(vertexBuffers: IVertexBuffer[], indexBuffer: IIndexBuffer | null): void;
        destroy(): void;
    }
    interface IIndexBuffer {
        destroy(): void;
        _setIndexDataLength(data: number): void;
        _setIndexData(data: Uint32Array | Uint16Array | Uint8Array, bufferOffset: number): void;
        indexType: IndexFormat;
        indexCount: number;
    }
    interface InternalRenderTarget {
        _isCube: boolean;
        _samples: number;
        _generateMipmap: boolean;
        _textures: InternalTexture[];
        _texturesResolve?: InternalTexture[];
        _depthTexture: InternalTexture;
        colorFormat: RenderTargetFormat;
        depthStencilFormat: RenderTargetFormat;
        isSRGB: boolean;
        gpuMemory: number;
        dispose(): void;
    }
    /**
     * 内部纹理对象
     */
    interface InternalTexture {
        /**
         * gpu texture object
         */
        resource: any;
        width: number;
        height: number;
        depth: number;
        isPotSize: boolean;
        mipmap: boolean;
        mipmapCount: number;
        filterMode: FilterMode;
        wrapU: WrapMode;
        wrapV: WrapMode;
        wrapW: WrapMode;
        anisoLevel: number;
        baseMipmapLevel: number;
        maxMipmapLevel: number;
        compareMode: TextureCompareMode;
        /**bytelength */
        gpuMemory: number;
        /**
         * 是否使用 sRGB格式 加载图片数据
         */
        useSRGBLoad: boolean;
        /**
         * gamma 矫正值
         */
        gammaCorrection: number;
        dispose(): void;
    }
    interface IRenderDeviceFactory {
        createShaderInstance(shaderProcessInfo: ShaderProcessInfo, shaderPass: ShaderCompileDefineBase): IShaderInstance;
        createIndexBuffer(bufferUsage: BufferUsage): IIndexBuffer;
        createVertexBuffer(bufferUsageType: BufferUsage): IVertexBuffer;
        createBufferState(): IBufferState;
        createRenderGeometryElement(mode: MeshTopology, drawType: DrawType): IRenderGeometryElement;
        createEngine(config: Config, canvas: any): Promise<void>;
        createGlobalUniformMap(blockName: string): CommandUniformMap;
        createShaderData(ownerResource?: Resource): ShaderData;
    }
    interface IRenderEngine {
        _context: any;
        _enableStatistics: boolean;
        _remapZ: boolean;
        _screenInvertY: boolean;
        _lodTextureSample: boolean;
        _breakTextureSample: boolean;
        initRenderEngine(canvas: any): void;
        copySubFrameBuffertoTex(texture: InternalTexture, level: number, xoffset: number, yoffset: number, x: number, y: number, width: number, height: number): void;
        resizeOffScreen(width: number, height: number): void;
        propertyNameToID(name: string): number;
        propertyIDToName(id: number): string;
        getDefineByName(name: string): ShaderDefine;
        getNamesByDefineData(defineData: IDefineDatas, out: Array<string>): void;
        addTexGammaDefine(key: number, value: ShaderDefine): void;
        getParams(params: RenderParams): number;
        getCapable(capatableType: RenderCapable): boolean;
        getTextureContext(): ITextureContext;
        getCreateRenderOBJContext(): IRenderEngineFactory;
        getUBOPointer?(name: string): number;
        createBuffer?(targetType: BufferTargetType, bufferUsageType: BufferUsage): GLBuffer;
        endFrame(): void;
    }
    interface IRenderEngineFactory {
        createUniformBufferObject(glPointer: number, name: string, bufferUsage: BufferUsage, byteLength: number, isSingle: boolean): UniformBufferObject;
        createEngine(config: Config, canvas: any): Promise<void>;
    }
    interface IRenderGeometryElement {
    }
    interface IRenderTarget {
        _renderTarget: InternalRenderTarget;
        _isCameraTarget: boolean;
        isCube: boolean;
        samples: number;
        generateMipmap: boolean;
        depthStencilTexture: BaseTexture | null;
    }
    interface IShaderInstance {
        _create(shaderProcessInfo: ShaderProcessInfo, shaderPass: ShaderPass): void;
        _disposeResource(): void;
    }
    interface ITextureContext {
        needBitmap: boolean;
        /**
         * 为 Texture 创建 InternalTexture
         * @param width
         * @param height
         * @param format
         * @param generateMipmap
         * @param sRGB
         * @returns
         */
        createTextureInternal(dimension: TextureDimension, width: number, height: number, format: TextureFormat, generateMipmap: boolean, sRGB: boolean, premultipliedAlpha: boolean): InternalTexture;
        setTextureImageData(texture: InternalTexture, source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureSubImageData(texture: InternalTexture, source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, x: number, y: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexturePixelsData(texture: InternalTexture, source: ArrayBufferView, premultiplyAlpha: boolean, invertY: boolean): void;
        initVideoTextureData(texture: InternalTexture): void;
        setTextureSubPixelsData(texture: InternalTexture, source: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, width: number, height: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureDDSData(texture: InternalTexture, ddsInfo: DDSTextureInfo): void;
        setTextureKTXData(texture: InternalTexture, ktxInfo: KTXTextureInfo): void;
        setTextureHDRData(texture: InternalTexture, hdrInfo: HDRTextureInfo): void;
        setCubeImageData(texture: InternalTexture, sources: (HTMLImageElement | HTMLCanvasElement | ImageBitmap)[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubePixelsData(texture: InternalTexture, source: ArrayBufferView[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubeSubPixelData(texture: InternalTexture, source: ArrayBufferView[], mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, width: number, height: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setCubeDDSData(texture: InternalTexture, ddsInfo: DDSTextureInfo): void;
        setCubeKTXData(texture: InternalTexture, ktxInfo: KTXTextureInfo): void;
        setTextureCompareMode(texture: InternalTexture, compareMode: TextureCompareMode): TextureCompareMode;
        createRenderTargetInternal(width: number, height: number, format: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number): InternalRenderTarget;
        createRenderTargetCubeInternal(size: number, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number): InternalRenderTarget;
        createRenderTargetDepthTexture(renderTarget: InternalRenderTarget, dimension: TextureDimension, width: number, height: number): InternalTexture;
        bindRenderTarget(renderTarget: InternalRenderTarget, faceIndex?: number): void;
        bindoutScreenTarget(): void;
        unbindRenderTarget(renderTarget: InternalRenderTarget): void;
        /**
         * @deprecated 请使用readRenderTargetPixelDataAsync函数代替
         * @param renderTarget
         * @param xOffset
         * @param yOffset
         * @param width
         * @param height
         * @param out
         */
        readRenderTargetPixelData(renderTarget: InternalRenderTarget, xOffset: number, yOffset: number, width: number, height: number, out: ArrayBufferView): ArrayBufferView;
        readRenderTargetPixelDataAsync(renderTarget: InternalRenderTarget, xOffset: number, yOffset: number, width: number, height: number, out: ArrayBufferView): Promise<ArrayBufferView>;
        updateVideoTexture(texture: InternalTexture, video: HTMLVideoElement, premultiplyAlpha: boolean, invertY: boolean): void;
        createTexture3DInternal(dimension: TextureDimension, width: number, height: number, depth: number, format: TextureFormat, generateMipmap: boolean, sRGB: boolean, premultipliedAlpha: boolean): InternalTexture;
        setTexture3DImageData(texture: InternalTexture, source: HTMLImageElement[] | HTMLCanvasElement[] | ImageBitmap[], depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DPixelsData(texture: InternalTexture, source: ArrayBufferView, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DSubPixelsData(texture: InternalTexture, source: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, zOffset: number, width: number, height: number, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
    }
    interface IVertexBuffer {
        vertexDeclaration: VertexDeclaration;
        instanceBuffer: boolean;
        setData(buffer: ArrayBuffer, bufferOffset: number, dataStartIndex: number, dataCount: number): void;
        setDataLength(byteLength: number): void;
        destroy(): void;
    }
    type uboParams = {
        ubo: UniformBufferObject;
        uboBuffer: UnifromBufferData;
    };
    enum ShaderDataType {
        None = 0,
        Int = 1,
        Bool = 2,
        Float = 3,
        Vector2 = 4,
        Vector3 = 5,
        Vector4 = 6,
        Color = 7,
        Matrix4x4 = 8,
        Texture2D = 9,
        Texture3D = 10,
        TextureCube = 11,
        Buffer = 12,
        Matrix3x3 = 13,
        Texture2DArray = 14
    }
    type ShaderDataItem = number | boolean | Vector2 | Vector3 | Vector4 | Color | Matrix4x4 | BaseTexture | Float32Array | Matrix3x3;
    function ShaderDataDefaultValue(type: ShaderDataType): false | Readonly<Vector2> | 0 | Readonly<Matrix3x3> | Readonly<Vector3> | Readonly<Matrix4x4> | Readonly<Vector4> | Color;
    /**
     * 着色器数据类。
     */
    class ShaderData implements IClone {
        _releaseUBOData(): void;
        getDefineData(): IDefineDatas;
        /**
         * 增加Shader宏定义。
         */
        addDefine(define: ShaderDefine): void;
        addDefines(define: IDefineDatas): void;
        /**
         * 移除Shader宏定义。
         */
        removeDefine(define: ShaderDefine): void;
        /**
         * 是否包含Shader宏定义。
         */
        hasDefine(define: ShaderDefine): boolean;
        /**
         * 清空宏定义。
         */
        clearDefine(): void;
        /**
         * 获取布尔。
         * @param	index shader索引。
         * @return  布尔。
         */
        getBool(index: number): boolean;
        /**
         * 设置布尔。
         * @param	index shader索引。
         * @param	value 布尔。
         */
        setBool(index: number, value: boolean): void;
        /**
         * 获取整形。
         * @param	index shader索引。
         * @return  整形。
         */
        getInt(index: number): number;
        /**
         * 设置整型。
         * @param	index shader索引。
         * @param	value 整形。
         */
        setInt(index: number, value: number): void;
        /**
         * 获取浮点。
         * @param	index shader索引。
         * @return	浮点。
         */
        getNumber(index: number): number;
        /**
         * 设置浮点。
         * @param	index shader索引。
         * @param	value 浮点。
         */
        setNumber(index: number, value: number): void;
        /**
         * 获取Vector2向量。
         * @param	index shader索引。
         * @return Vector2向量。
         */
        getVector2(index: number): Vector2;
        /**
         * 设置Vector2向量。
         * @param	index shader索引。
         * @param	value Vector2向量。
         */
        setVector2(index: number, value: Vector2): void;
        /**
         * 获取Vector3向量。
         * @param	index shader索引。
         * @return Vector3向量。
         */
        getVector3(index: number): Vector3;
        /**
         * 设置Vector3向量。
         * @param	index shader索引。
         * @param	value Vector3向量。
         */
        setVector3(index: number, value: Vector3): void;
        /**
         * 获取颜色。
         * @param 	index shader索引。
         * @return  向量。
         */
        getVector(index: number): Vector4;
        /**
         * 设置向量。
         * @param	index shader索引。
         * @param	value 向量。
         */
        setVector(index: number, value: Vector4): void;
        /**
         * 获取颜色
         * @param index 索引
         * @returns 颜色
         */
        getColor(index: number): Color;
        /**
         * 设置颜色
         * @param index 索引
         * @param value 颜色值
         */
        setColor(index: number, value: Color): void;
        /**
         * 获取矩阵。
         * @param	index shader索引。
         * @return  矩阵。
         */
        getMatrix4x4(index: number): Matrix4x4;
        /**
         * 设置矩阵。
         * @param	index shader索引。
         * @param	value  矩阵。
         */
        setMatrix4x4(index: number, value: Matrix4x4): void;
        /**
         * 获取矩阵
         * @param index
         * @returns
         */
        getMatrix3x3(index: number): Matrix3x3;
        /**
         * 设置矩阵。
         */
        setMatrix3x3(index: number, value: Matrix3x3): void;
        /**
         * 获取Buffer。
         * @param	index shader索引。
         * @return
         */
        getBuffer(index: number): Float32Array;
        /**
         * 设置Buffer。
         * @param	index shader索引。
         * @param	value  buffer数据。
         */
        setBuffer(index: number, value: Float32Array): void;
        /**
         * 设置纹理。
         * @param	index shader索引。
         * @param	value 纹理。
         */
        setTexture(index: number, value: BaseTexture): void;
        /**
         * 获取纹理。
         * @param	index shader索引。
         * @return  纹理。
         */
        getTexture(index: number): BaseTexture;
        setUniformBuffer(index: number, value: UniformBufferObject): void;
        getUniformBuffer(index: number): UniformBufferObject;
        setShaderData(uniformIndex: number, type: ShaderDataType, value: ShaderDataItem | Quaternion): void;
        getShaderData(uniformIndex: number, type: ShaderDataType): ShaderDataItem;
        /**
         * @private
         */
        _setInternalTexture(index: number, value: InternalTexture): void;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: ShaderData): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
        reset(): void;
        destroy(): void;
    }
    interface IUniformBufferUser {
        needUpload: boolean;
        bufferBlock: UniformBufferBlock;
        bufferAlone: UniformBufferAlone;
        manager: UniformBufferManager;
        data: ShaderData;
        offset: number;
        clearGPUBufferBind(): void;
        notifyGPUBufferChange(): void;
    }
    /**
     * 单独的UniformBuffer
     */
    class UniformBufferAlone {
        buffer: any;
        data: ArrayBuffer;
        size: number;
        alignedSize: number;
        manager: UniformBufferManager;
        destroyed: boolean;
        constructor(size: number, manager: UniformBufferManager);
        /**
         * 上传数据
         */
        upload(): void;
        /**
         * 销毁
         */
        destroy(): boolean;
    }
    /**
     * Uniform内存块（小内存块）
     */
    class UniformBufferBlock {
        sn: number;
        cluster: UniformBufferCluster;
        index: number;
        offset: number;
        size: number;
        alignedSize: number;
        uploadNum: number;
        moved: boolean;
        user: IUniformBufferUser;
        destroyed: boolean;
        constructor(sn: number, cluster: UniformBufferCluster, index: number, size: number, alignedSize: number, user: IUniformBufferUser);
        /**
         * 标记块需要上传
         */
        needUpload(): void;
        /**
         * 销毁
         */
        destroy(): boolean;
    }
    /**
     * Uniform内存块（大内存块）
     */
    class UniformBufferCluster {
        sn: number;
        totalSize: number;
        blockSize: number;
        blockNum: number;
        needUpload: boolean[];
        destroyed: boolean;
        buffer: any;
        blocks: UniformBufferBlock[];
        expand: number;
        data: ArrayBuffer;
        move: Uint8Array;
        manager: UniformBufferManager;
        constructor(blockSize: number, blockNum: number, manager: UniformBufferManager);
        get usedNum(): number;
        /**
         * 扩展GPU缓冲区
         */
        private _expandBuffer;
        /**
         * 移动内存块，后面的块向前移动，填补指定的内存空洞
         * @param index
         */
        private _moveBlock;
        /**
         * 获取内存块
         * @param size 需求尺寸
         * @param user 使用者
         */
        getBlock(size: number, user: IUniformBufferUser): UniformBufferBlock;
        /**
         * 释放内存块
         */
        freeBlock(bb: UniformBufferBlock): boolean;
        /**
         * 将数据上传到GPU内存，合并相邻块，尽可能减少上传次数
         */
        upload(): void;
        /**
         * 优化块顺序，上传频繁的块排前面
         */
        optimize(): void;
        /**
         * 移除空洞
         */
        removeHole(): void;
        /**
         * 清理，释放所有内存块，回到内存未占用状态
         * @param blockNum 保留多少小块
         */
        clear(blockNum?: number): void;
        /**
         * 获取一个空闲块，如果空间不够，扩大内存块
         */
        private _getBlockWithExpand;
        /**
         * 销毁
         */
        destroy(): boolean;
    }
    type TypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array;
    type TypedArrayConstructor = Int8ArrayConstructor | Uint8ArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor;
    /**
     * 向上圆整到align的整数倍
     * @param n
     * @param align
     */
    function roundUp(n: number, align: number): number;
    /**
     * 向下圆整到align的整数倍
     * @param n
     * @param align
     */
    function roundDown(n: number, align: number): number;
    /**
     * Uniform内存块管理
     */
    class UniformBufferManager {
        renderContext: any;
        clustersAll: Map<number, UniformBufferCluster[]>;
        clustersCur: Map<number, UniformBufferCluster>;
        useBigBuffer: boolean;
        destroyed: boolean;
        snCounter: number;
        byteAlign: number;
        clusterMaxBlock: number;
        uploadThreshold: number;
        moveNum: number;
        uploadNum: number;
        uploadByte: number;
        removeHoleTimer: number;
        timeCostAvg: number;
        timeCostSum: number;
        timeCostCount: number;
        constructor(useBigBuffer: boolean);
        /**
         * 添加大内存块
         * @param size
         * @param blockNum
         */
        private _addCluster;
        /**
         * 移除空洞
         */
        private _removeHole;
        /**
         * 开始新的一帧
         */
        startFrame(): void;
        /**
         * 设置渲染上下文
         * @param renderContext
         */
        setRenderContext(renderContext: any): void;
        /**
         * 获取单独的UniformBuffer
         * @param size
         * @param name
         */
        getBufferAlone(size: number, name?: string): void;
        /**
         * 删除大内存块
         * @param size
         * @param sn
         */
        removeCluster(size: number, sn: number): void;
        /**
         * 获取小内存块
         * @param size
         * @param user
         */
        getBlock(size: number, user: IUniformBufferUser): UniformBufferBlock;
        /**
         * 释放小内存块
         * @param bb
         */
        freeBlock(bb: UniformBufferBlock): boolean;
        /**
         * 上传数据
         */
        upload(): void;
        /**
         * 清理所有内存
         */
        clear(): void;
        /**
         * 销毁
         */
        destroy(): boolean;
        /**
         * 创建GPU内存对象
         * @param size 字节长度
         * @param name 名称
         */
        createGPUBuffer(size: number, name?: string): void;
        /**
         * 将数据写入GPU内存
         * @param buffer GPU内存对象
         * @param data CPU数据对象
         * @param offset 数据在大内存中的偏移量（字节）
         * @param size 写入的数据长度（字节）
         */
        writeBuffer(buffer: any, data: ArrayBuffer, offset: number, size: number): void;
        /**
         * 统计GPU内存使用量
         * @param bytes 字节
         */
        statisGPUMemory(bytes: number): void;
        /**
         * 统计上传次数
         * @param count 上传次数
         * @param bytes 上传字节
         */
        statisUpload(count: number, bytes: number): void;
    }
    type ItemType = {
        name: string;
        view: TypedArray;
        type: string;
        align: number;
        size: number;
        elements: number;
        count: number;
    };
    /**
     * UniformBuffer使用者
     */
    class UniformBufferUser implements IUniformBufferUser {
        name: string;
        strId: string;
        size: number;
        items: Map<number, ItemType>;
        itemNum: number;
        destroyed: boolean;
        needUpload: boolean;
        bufferBlock: UniformBufferBlock;
        bufferAlone: UniformBufferAlone;
        manager: UniformBufferManager;
        data: ShaderData;
        offset: number;
        constructor(name: string, size: number, manager: UniformBufferManager, data: ShaderData);
        /**
         * 通知GPUBuffer改变
         */
        notifyGPUBufferChange(): void;
        /**
         * 清除GPUBuffer绑定
         */
        clearGPUBufferBind(): void;
        /**
         * 添加uniform字段
         * @param id
         * @param name
         * @param type
         * @param offset
         * @param align
         * @param size
         * @param elements
         * @param count
         */
        addUniform(id: number, name: string, type: string, offset: number, align: number, size: number, elements: number, count: number): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setUniformData(id: number, data: any): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setBool(id: number, data: boolean): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setBoolArray(id: number, data: boolean[]): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setInt(id: number, data: number): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setIntArray(id: number, data: number[]): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setFloat(id: number, data: number): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setFloatArray(id: number, data: number[]): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setVector2(id: number, data: Vector2): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setVector2Array(id: number, data: Vector2[]): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setVector3(id: number, data: Vector3): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setVector3Array(id: number, data: Vector3[]): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setVector4(id: number, data: Vector4): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setVector4Array(id: number, data: Vector4[]): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setMatrix3x3(id: number, data: Matrix3x3): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setMatrix3x3Array(id: number, data: Matrix3x3[]): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setMatrix4x4(id: number, data: Matrix4x4): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setMatrix4x4Array(id: number, data: Matrix4x4[]): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setBuffer(id: number, data: Float32Array): void;
        /**
         * 获取uniformItem
         * @param id
         */
        getUniform(id: number): ItemType;
        /**
         * 是否存在指定的uniform
         * @param id
         */
        hasUniform(id: number): boolean;
        /**
         * 根据strId判断是否命中
         * @param strId
         */
        isMe(strId: string): boolean;
        /**
         * 上传数据
         */
        upload(): void;
        /**
         * 清除所有uniform
         */
        clear(): void;
        /**
         * 销毁
         */
        destroy(): boolean;
        /**
         * 获取一个unifromItem
         * @param name
         * @param tac
         * @param type
         * @param offset
         * @param align
         * @param size
         * @param elements
         * @param count
         */
        protected _getUniformItem(name: string, tac: TypedArrayConstructor, type: string, offset: number, align: number, size: number, elements: number, count: number): {
            name: string;
            view: TypedArray;
            type: string;
            align: number;
            size: number;
            elements: number;
            count: number;
        };
        /**
         * 根据type获取TypeArray类型
         * @param type
         */
        protected static _typeArray(type: string): Float32ArrayConstructor | Int32ArrayConstructor;
    }
    class NoRender2DProcess implements I2DRenderPassFactory {
        createRenderElement2D(): IRenderElement2D;
        createRenderContext2D(): IRenderContext2D;
    }
    class NoRenderElement2D implements IRenderElement2D {
        geometry: IRenderGeometryElement;
        materialShaderData: ShaderData;
        value2DShaderData: ShaderData;
        subShader: SubShader;
        renderStateIsBySprite: boolean;
        destroy(): void;
    }
    class NoRenderContext2D implements IRenderContext2D {
        sceneData: ShaderData;
        invertY: boolean;
        pipelineMode: string;
        setRenderTarget(value: InternalRenderTarget, clear: boolean, clearColor: Color): void;
        setOffscreenView(width: number, height: number): void;
        drawRenderElementOne(node: IRenderElement2D): void;
        drawRenderElementList(list: SingletonList<IRenderElement2D>): number;
    }
    class NoRender3DRenderPassFactory implements I3DRenderPassFactory {
        createRender3DProcess(): IRender3DProcess;
        createRenderContext3D(): IRenderContext3D;
        createRenderElement3D(): IRenderElement3D;
        createInstanceBatch(): IInstanceRenderBatch;
        createInstanceRenderElement3D(): IInstanceRenderElement3D;
        createSkinRenderElement(): ISkinRenderElement3D;
        createSceneRenderManager(): ISceneRenderManager;
        createDrawNodeCMDData(): DrawNodeCMDData;
        createBlitQuadCMDData(): BlitQuadCMDData;
        createDrawElementCMDData(): DrawElementCMDData;
        createSetViewportCMD(): SetViewportCMD;
        createSetRenderTargetCMD(): SetRenderTargetCMD;
        createSetRenderDataCMD(): SetRenderDataCMD;
        createSetShaderDefineCMD(): SetShaderDefineCMD;
    }
    class NoRenderRender3DProcess implements IRender3DProcess {
        render3DManager: NoRenderSceneRenderManager;
        destroy(): void;
        fowardRender(context: IRenderContext3D, camera: Camera): void;
    }
    class NoRenderSceneRenderManager implements ISceneRenderManager {
        addRenderObject(object: BaseRender): void;
        removeRenderObject(object: BaseRender): void;
        removeMotionObject(object: BaseRender): void;
        addMotionObject(object: BaseRender): void;
        updateMotionObjects(): void;
        destroy(): void;
        list: FastSinglelist<BaseRender>;
        baseRenderList: FastSinglelist<IBaseRenderNode>;
    }
    class NoRenderRenderContext3D implements IRenderContext3D {
        globalShaderData: ShaderData;
        sceneData: ShaderData;
        sceneModuleData: ISceneNodeData;
        cameraModuleData: ICameraNodeData;
        cameraData: ShaderData;
        sceneUpdataMask: number;
        cameraUpdateMask: number;
        pipelineMode: string;
        invertY: boolean;
        setRenderTarget(value: InternalRenderTarget, clearFlag: RenderClearFlag): void;
        setViewPort(value: Viewport): void;
        setScissor(value: Vector4): void;
        setClearData(clearFlag: number, clolor: Color, depth: number, stencil: number): number;
        drawRenderElementList(list: FastSinglelist<IRenderElement3D>): number;
        drawRenderElementOne(node: IRenderElement3D): number;
        runOneCMD(cmd: IRenderCMD): void;
        runCMDList(cmds: IRenderCMD[]): void;
    }
    class NoRenderRenderElement3D implements IRenderElement3D {
        geometry: IRenderGeometryElement;
        materialShaderData: ShaderData;
        materialRenderQueue: number;
        renderShaderData: ShaderData;
        transform: Transform3D;
        canDynamicBatch: boolean;
        isRender: boolean;
        owner: IBaseRenderNode;
        subShader: SubShader;
        materialId: number;
        destroy(): void;
    }
    class NoRenderInstanceRenderBatch implements IInstanceRenderBatch {
        batch(elements: SingletonList<IRenderElement3D>): void;
        clearRenderData(): void;
        recoverData(): void;
    }
    class NoRenderInstanceRenderElement3D implements IInstanceRenderElement3D {
        instanceElementList: SingletonList<IRenderElement3D>;
        setGeometry(geometry: IRenderGeometryElement): void;
        clearRenderData(): void;
        recover(): void;
        geometry: IRenderGeometryElement;
        materialShaderData: ShaderData;
        materialRenderQueue: number;
        renderShaderData: ShaderData;
        transform: Transform3D;
        canDynamicBatch: boolean;
        isRender: boolean;
        owner: IBaseRenderNode;
        subShader: SubShader;
        materialId: number;
        destroy(): void;
    }
    class NoRenderSkinRenderElement3D implements ISkinRenderElement3D {
        skinnedData: Float32Array[];
    }
    class NoRenderDrawNodeCMDData extends DrawNodeCMDData {
        type: RenderCMDType;
        protected _node: WebBaseRenderNode;
        protected _destShaderData: NoRenderShaderData;
        protected _destSubShader: SubShader;
        protected _subMeshIndex: number;
        get node(): WebBaseRenderNode;
        set node(value: WebBaseRenderNode);
        get destShaderData(): NoRenderShaderData;
        set destShaderData(value: NoRenderShaderData);
        get destSubShader(): SubShader;
        set destSubShader(value: SubShader);
        get subMeshIndex(): number;
        set subMeshIndex(value: number);
        constructor();
        apply(context: NoRenderRenderContext3D): void;
    }
    class NoRenderBlitQuadCMDData extends BlitQuadCMDData {
        type: RenderCMDType;
        private _sourceTexelSize;
        protected _dest: NoInternalRT;
        protected _viewport: Viewport;
        protected _source: InternalTexture;
        protected _scissor: Vector4;
        protected _offsetScale: Vector4;
        protected _element: NoRenderRenderElement3D;
        get dest(): NoInternalRT;
        set dest(value: NoInternalRT);
        get viewport(): Viewport;
        set viewport(value: Viewport);
        get scissor(): Vector4;
        set scissor(value: Vector4);
        get source(): InternalTexture;
        set source(value: InternalTexture);
        get offsetScale(): Vector4;
        set offsetScale(value: Vector4);
        get element(): NoRenderRenderElement3D;
        set element(value: NoRenderRenderElement3D);
        constructor();
        apply(context: NoRenderRenderContext3D): void;
    }
    class NoRenderDrawElementCMDData extends DrawElementCMDData {
        type: RenderCMDType;
        private _elemets;
        constructor();
        setRenderelements(value: NoRenderRenderElement3D[]): void;
        apply(context: NoRenderRenderContext3D): void;
    }
    class NoRenderSetViewportCMD extends SetViewportCMD {
        type: RenderCMDType;
        protected _viewport: Viewport;
        protected _scissor: Vector4;
        get viewport(): Viewport;
        set viewport(value: Viewport);
        get scissor(): Vector4;
        set scissor(value: Vector4);
        constructor();
        apply(context: NoRenderRenderContext3D): void;
    }
    class NoRenderSetRenderTargetCMD extends SetRenderTargetCMD {
        type: RenderCMDType;
        protected _rt: InternalRenderTarget;
        protected _clearFlag: number;
        protected _clearColorValue: Color;
        protected _clearDepthValue: number;
        protected _clearStencilValue: number;
        get rt(): InternalRenderTarget;
        set rt(value: InternalRenderTarget);
        get clearFlag(): number;
        set clearFlag(value: number);
        get clearColorValue(): Color;
        set clearColorValue(value: Color);
        get clearDepthValue(): number;
        set clearDepthValue(value: number);
        get clearStencilValue(): number;
        set clearStencilValue(value: number);
        constructor();
        apply(context: NoRenderRenderContext3D): void;
    }
    class NoRenderSetRenderData extends SetRenderDataCMD {
        type: RenderCMDType;
        protected _dataType: ShaderDataType;
        protected _propertyID: number;
        protected _dest: NoRenderShaderData;
        protected _value: ShaderDataItem;
        data_v4: Vector4;
        data_v3: Vector3;
        data_v2: Vector2;
        data_mat: Matrix4x4;
        data_number: number;
        data_texture: BaseTexture;
        data_Color: Color;
        data_Buffer: Float32Array;
        get dataType(): ShaderDataType;
        set dataType(value: ShaderDataType);
        get propertyID(): number;
        set propertyID(value: number);
        get dest(): NoRenderShaderData;
        set dest(value: NoRenderShaderData);
        get value(): ShaderDataItem;
        set value(value: ShaderDataItem);
        constructor();
        apply(context: NoRenderRenderContext3D): void;
    }
    class NoRenderSetShaderDefine extends SetShaderDefineCMD {
        type: RenderCMDType;
        protected _define: ShaderDefine;
        protected _dest: NoRenderShaderData;
        protected _add: boolean;
        get define(): ShaderDefine;
        set define(value: ShaderDefine);
        get dest(): NoRenderShaderData;
        set dest(value: NoRenderShaderData);
        get add(): boolean;
        set add(value: boolean);
        constructor();
        apply(context: NoRenderRenderContext3D): void;
    }
    class NoRenderDeviceFactory implements IRenderDeviceFactory {
        createShaderInstance(shaderProcessInfo: ShaderProcessInfo, shaderPass: ShaderCompileDefineBase): IShaderInstance;
        createIndexBuffer(bufferUsage: BufferUsage): IIndexBuffer;
        createVertexBuffer(bufferUsageType: BufferUsage): IVertexBuffer;
        createBufferState(): IBufferState;
        createRenderGeometryElement(mode: MeshTopology, drawType: DrawType): IRenderGeometryElement;
        createEngine(config: Config, canvas: any): Promise<void>;
        createGlobalUniformMap(blockName: string): CommandUniformMap;
        createShaderData(ownerResource?: Resource): ShaderData;
    }
    class NoRenderCommandUnifojrmMap extends CommandUniformMap {
        constructor(stateName: string);
        /**
         * 增加一个Uniform参数
         */
        addShaderUniform(propertyID: number, propertyKey: string, uniformtype: ShaderDataType, block?: string): void;
        /**
         * 增加一个UniformArray参数
         * @param propertyID
         * @param propertyName
         */
        addShaderUniformArray(propertyID: number, propertyName: string, uniformtype: ShaderDataType, arrayLength: number, block?: string): void;
        /**
         * 增加一个Uniform
         */
        addShaderBlockUniform(propertyID: number, blockname: string, blockProperty: UniformProperty[]): void;
    }
    class NoRenderShaderInstance implements IShaderInstance {
        _create(shaderProcessInfo: ShaderProcessInfo, shaderPass: ShaderPass): void;
        _disposeResource(): void;
    }
    class NoRenderIndexBuffer implements IIndexBuffer {
        destroy(): void;
        _setIndexDataLength(data: number): void;
        _setIndexData(data: Uint32Array | Uint16Array | Uint8Array, bufferOffset: number): void;
        indexType: IndexFormat;
        indexCount: number;
    }
    class NoRenderVertexBuffer implements IVertexBuffer {
        vertexDeclaration: VertexDeclaration;
        instanceBuffer: boolean;
        setData(buffer: ArrayBuffer, bufferOffset: number, dataStartIndex: number, dataCount: number): void;
        setDataLength(byteLength: number): void;
        destroy(): void;
    }
    class NoRenderBufferState implements IBufferState {
        _bindedIndexBuffer: IIndexBuffer;
        _vertexBuffers: IVertexBuffer[];
        applyState(vertexBuffers: IVertexBuffer[], indexBuffer: IIndexBuffer): void;
        destroy(): void;
    }
    class NoRenderGeometryElement implements IRenderGeometryElement {
        bufferState: IBufferState;
        mode: MeshTopology;
        drawType: DrawType;
        instanceCount: number;
        indexFormat: IndexFormat;
        setDrawArrayParams(first: number, count: number): void;
        setDrawElemenParams(count: number, offset: number): void;
        clearRenderParams(): void;
        destroy(): void;
    }
    class NoRenderShaderData extends ShaderData {
        _releaseUBOData(): void;
        getDefineData(): WebDefineDatas;
        /**
         * 增加Shader宏定义。
         */
        addDefine(define: ShaderDefine): void;
        addDefines(define: IDefineDatas): void;
        /**
         * 移除Shader宏定义。
         */
        removeDefine(define: ShaderDefine): void;
        /**
         * 是否包含Shader宏定义。
         */
        hasDefine(define: ShaderDefine): boolean;
        /**
         * 清空宏定义。
         */
        clearDefine(): void;
        /**
         * 获取布尔。
         * @param	index shader索引。
         * @return  布尔。
         */
        getBool(index: number): boolean;
        /**
         * 设置布尔。
         * @param	index shader索引。
         * @param	value 布尔。
         */
        setBool(index: number, value: boolean): void;
        /**
         * 获取整形。
         * @param	index shader索引。
         * @return  整形。
         */
        getInt(index: number): number;
        /**
         * 设置整型。
         * @param	index shader索引。
         * @param	value 整形。
         */
        setInt(index: number, value: number): void;
        /**
         * 获取浮点。
         * @param	index shader索引。
         * @return	浮点。
         */
        getNumber(index: number): number;
        /**
         * 设置浮点。
         * @param	index shader索引。
         * @param	value 浮点。
         */
        setNumber(index: number, value: number): void;
        /**
         * 获取Vector2向量。
         * @param	index shader索引。
         * @return Vector2向量。
         */
        getVector2(index: number): Vector2;
        /**
         * 设置Vector2向量。
         * @param	index shader索引。
         * @param	value Vector2向量。
         */
        setVector2(index: number, value: Vector2): void;
        /**
         * 获取Vector3向量。
         * @param	index shader索引。
         * @return Vector3向量。
         */
        getVector3(index: number): Vector3;
        /**
         * 设置Vector3向量。
         * @param	index shader索引。
         * @param	value Vector3向量。
         */
        setVector3(index: number, value: Vector3): void;
        /**
         * 获取颜色。
         * @param 	index shader索引。
         * @return  向量。
         */
        getVector(index: number): Vector4;
        /**
         * 设置向量。
         * @param	index shader索引。
         * @param	value 向量。
         */
        setVector(index: number, value: Vector4): void;
        /**
         * 获取颜色
         * @param index 索引
         * @returns 颜色
         */
        getColor(index: number): Color;
        /**
         * 设置颜色
         * @param index 索引
         * @param value 颜色值
         */
        setColor(index: number, value: Color): void;
        /**
         * 获取矩阵。
         * @param	index shader索引。
         * @return  矩阵。
         */
        getMatrix4x4(index: number): Matrix4x4;
        /**
         * 设置矩阵。
         * @param	index shader索引。
         * @param	value  矩阵。
         */
        setMatrix4x4(index: number, value: Matrix4x4): void;
        /**
         * 获取矩阵
         * @param index
         * @returns
         */
        getMatrix3x3(index: number): Matrix3x3;
        /**
         * 设置矩阵。
         */
        setMatrix3x3(index: number, value: Matrix3x3): void;
        /**
         * 获取Buffer。
         * @param	index shader索引。
         * @return
         */
        getBuffer(index: number): Float32Array;
        /**
         * 设置Buffer。
         * @param	index shader索引。
         * @param	value  buffer数据。
         */
        setBuffer(index: number, value: Float32Array): void;
        /**
         * 设置纹理。
         * @param	index shader索引。
         * @param	value 纹理。
         */
        setTexture(index: number, value: BaseTexture): void;
        /**
         * 获取纹理。
         * @param	index shader索引。
         * @return  纹理。
         */
        getTexture(index: number): BaseTexture;
        /**
         *
         * @param index
         * @param value
         */
        setUniformBuffer(index: number, value: UniformBufferObject): void;
        getUniformBuffer(index: number): UniformBufferObject;
        setShaderData(uniformIndex: number, type: ShaderDataType, value: ShaderDataItem | Quaternion): void;
        getShaderData(uniformIndex: number, type: ShaderDataType): ShaderDataItem;
        /**
         * @private
         */
        _setInternalTexture(index: number, value: InternalTexture): void;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: NoRenderShaderData): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
        reset(): void;
        destroy(): void;
    }
    class NoRenderEngineFactory implements IRenderEngineFactory {
        createUniformBufferObject(glPointer: number, name: string, bufferUsage: BufferUsage, byteLength: number, isSingle: boolean): UniformBufferObject;
        createEngine(config: Config, canvas: any): Promise<void>;
    }
    class NoRenderEngine implements IRenderEngine {
        endFrame(): void;
        _context: any;
        _isShaderDebugMode: boolean;
        _renderOBJCreateContext: IRenderEngineFactory;
        _enableStatistics: boolean;
        _remapZ: boolean;
        _screenInvertY: boolean;
        _lodTextureSample: boolean;
        _breakTextureSample: boolean;
        initRenderEngine(canvas: any): void;
        copySubFrameBuffertoTex(texture: InternalTexture, level: number, xoffset: number, yoffset: number, x: number, y: number, width: number, height: number): void;
        resizeOffScreen(width: number, height: number): void;
        propertyNameToID(name: string): number;
        propertyIDToName(id: number): string;
        static _maskMap: Array<{
            [key: number]: string;
        }>;
        getDefineByName(name: string): ShaderDefine;
        getNamesByDefineData(defineData: IDefineDatas, out: string[]): void;
        addTexGammaDefine(key: number, value: ShaderDefine): void;
        getParams(params: RenderParams): number;
        getCapable(capatableType: RenderCapable): boolean;
        getTextureContext(): ITextureContext;
        getCreateRenderOBJContext(): IRenderEngineFactory;
        clearStatisticsInfo(): void;
        getStatisticsInfo(info: GPUEngineStatisticsInfo): number;
    }
    class NoInternalTexture implements InternalTexture {
        resource: any;
        width: number;
        height: number;
        depth: number;
        isPotSize: boolean;
        mipmap: boolean;
        mipmapCount: number;
        filterMode: FilterMode;
        wrapU: WrapMode;
        wrapV: WrapMode;
        wrapW: WrapMode;
        anisoLevel: number;
        baseMipmapLevel: number;
        maxMipmapLevel: number;
        compareMode: TextureCompareMode;
        gpuMemory: number;
        useSRGBLoad: boolean;
        gammaCorrection: number;
        dispose(): void;
    }
    class NoInternalRT implements InternalRenderTarget {
        _isCube: boolean;
        _samples: number;
        _generateMipmap: boolean;
        _textures: InternalTexture[];
        _texturesResolve?: InternalTexture[];
        _depthTexture: InternalTexture;
        colorFormat: RenderTargetFormat;
        depthStencilFormat: RenderTargetFormat;
        isSRGB: boolean;
        gpuMemory: number;
        dispose(): void;
    }
    class NoTextureContext implements ITextureContext {
        needBitmap: boolean;
        createTextureInternal(dimension: TextureDimension, width: number, height: number, format: TextureFormat, generateMipmap: boolean, sRGB: boolean, premultipliedAlpha: boolean): InternalTexture;
        setTextureImageData(texture: InternalTexture, source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureSubImageData(texture: InternalTexture, source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, x: number, y: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexturePixelsData(texture: InternalTexture, source: ArrayBufferView, premultiplyAlpha: boolean, invertY: boolean): void;
        initVideoTextureData(texture: InternalTexture): void;
        setTextureSubPixelsData(texture: InternalTexture, source: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, width: number, height: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureDDSData(texture: InternalTexture, ddsInfo: DDSTextureInfo): void;
        setTextureKTXData(texture: InternalTexture, ktxInfo: KTXTextureInfo): void;
        setTextureHDRData(texture: InternalTexture, hdrInfo: HDRTextureInfo): void;
        setCubeImageData(texture: InternalTexture, sources: (HTMLImageElement | HTMLCanvasElement | ImageBitmap)[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubePixelsData(texture: InternalTexture, source: ArrayBufferView[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubeSubPixelData(texture: InternalTexture, source: ArrayBufferView[], mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, width: number, height: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setCubeDDSData(texture: InternalTexture, ddsInfo: DDSTextureInfo): void;
        setCubeKTXData(texture: InternalTexture, ktxInfo: KTXTextureInfo): void;
        setTextureCompareMode(texture: InternalTexture, compareMode: TextureCompareMode): TextureCompareMode;
        createRenderTargetInternal(width: number, height: number, format: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number): InternalRenderTarget;
        createRenderTargetCubeInternal(size: number, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number): InternalRenderTarget;
        createRenderTargetDepthTexture(renderTarget: InternalRenderTarget, dimension: TextureDimension, width: number, height: number): InternalTexture;
        bindRenderTarget(renderTarget: InternalRenderTarget, faceIndex?: number): void;
        bindoutScreenTarget(): void;
        unbindRenderTarget(renderTarget: InternalRenderTarget): void;
        readRenderTargetPixelData(renderTarget: InternalRenderTarget, xOffset: number, yOffset: number, width: number, height: number, out: ArrayBufferView): ArrayBufferView;
        readRenderTargetPixelDataAsync(renderTarget: InternalRenderTarget, xOffset: number, yOffset: number, width: number, height: number, out: ArrayBufferView): Promise<ArrayBufferView>;
        updateVideoTexture(texture: InternalTexture, video: HTMLVideoElement, premultiplyAlpha: boolean, invertY: boolean): void;
        createTexture3DInternal(dimension: TextureDimension, width: number, height: number, depth: number, format: TextureFormat, generateMipmap: boolean, sRGB: boolean, premultipliedAlpha: boolean): InternalTexture;
        setTexture3DImageData(texture: InternalTexture, source: HTMLImageElement[] | HTMLCanvasElement[] | ImageBitmap[], depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DPixelsData(texture: InternalTexture, source: ArrayBufferView, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DSubPixelsData(texture: InternalTexture, source: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, zOffset: number, width: number, height: number, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
    }
    class GLESRender2DProcess implements I2DRenderPassFactory {
        createRenderElement2D(): GLESREnderElement2D;
        createRenderContext2D(): GLESREnderContext2D;
    }
    class GLESREnderContext2D implements IRenderContext2D {
        static isCreateBlitScreenELement: boolean;
        static blitScreenElement: GLESREnderElement2D;
        get invertY(): boolean;
        set invertY(value: boolean);
        get pipelineMode(): string;
        set pipelineMode(value: string);
        _nativeObj: any;
        constructor();
        private _sceneData;
        get sceneData(): ShaderData;
        set sceneData(value: ShaderData);
        private setBlitScreenElement;
        private _tempList;
        drawRenderElementList(list: FastSinglelist<GLESREnderElement2D>): number;
        setRenderTarget(value: GLESInternalRT, clear: boolean, clearColor: Color): void;
        setOffscreenView(width: number, height: number): void;
        drawRenderElementOne(node: GLESREnderElement2D): void;
    }
    class GLESREnderElement2D implements IRenderElement2D {
        private _geometry;
        private _materialShaderData;
        private _value2DShaderData;
        private _subShader;
        set geometry(data: GLESRenderGeometryElement);
        get geometry(): GLESRenderGeometryElement;
        set materialShaderData(data: GLESShaderData);
        get materialShaderData(): GLESShaderData;
        set value2DShaderData(data: GLESShaderData);
        get value2DShaderData(): GLESShaderData;
        get subShader(): SubShader;
        set subShader(value: SubShader);
        protected init(): void;
        constructor();
        private _nodeCommonMap;
        get nodeCommonMap(): string[];
        set nodeCommonMap(value: string[]);
        private _renderStateIsBySprite;
        get renderStateIsBySprite(): boolean;
        set renderStateIsBySprite(value: boolean);
        destroy(): void;
    }
    class GLES3DRenderPassFactory implements I3DRenderPassFactory {
        createInstanceBatch(): IInstanceRenderBatch;
        createRender3DProcess(): IRender3DProcess;
        createRenderContext3D(): IRenderContext3D;
        createSetRenderDataCMD(): SetRenderDataCMD;
        createSetShaderDefineCMD(): SetShaderDefineCMD;
        createDrawNodeCMDData(): DrawNodeCMDData;
        createBlitQuadCMDData(): BlitQuadCMDData;
        createDrawElementCMDData(): DrawElementCMDData;
        createSetViewportCMD(): SetViewportCMD;
        createSetRenderTargetCMD(): SetRenderTargetCMD;
        createSetRenderData(): GLESSetRenderData;
        createSceneRenderManager(): ISceneRenderManager;
        createSkinRenderElement(): GLESSkinRenderElement3D;
        createInstanceRenderElement3D(): IInstanceRenderElement3D;
        createDirectLightShadowRP(): GLESDirectLightShadowRP;
        createSpotLightShadowRP(): GLESSpotLightShadowRP;
        createForwardAddRP(): GLESForwardAddRP;
        createForwardAddCluster(): GLESForwardAddClusterRP;
        createRenderElement3D(): GLESRenderElement3D;
    }
    class GLESDirectLightShadowRP {
        private _light;
        get light(): RTDirectLight;
        set light(value: RTDirectLight);
        private _camera;
        get camera(): RTCameraNodeData;
        set camera(value: RTCameraNodeData);
        private _destTarget;
        get destTarget(): GLESInternalRT;
        set destTarget(value: GLESInternalRT);
        _nativeObj: any;
        constructor();
        destroy(): void;
        private _shadowCasterCommanBuffer;
        get shadowCasterCommanBuffer(): CommandBuffer[];
        set shadowCasterCommanBuffer(value: CommandBuffer[]);
        private _setCmd;
    }
    class GLESForwardAddClusterRP {
        get enableOpaque(): boolean;
        set enableOpaque(value: boolean);
        get enableCMD(): boolean;
        set enableCMD(value: boolean);
        get enableTransparent(): boolean;
        set enableTransparent(value: boolean);
        get enableOpaqueTexture(): boolean;
        set enableOpaqueTexture(value: boolean);
        private _destTarget;
        get destTarget(): GLESInternalRT;
        set destTarget(value: GLESInternalRT);
        get pipelineMode(): string;
        set pipelineMode(value: string);
        private _depthTarget;
        get depthTarget(): GLESInternalRT;
        set depthTarget(value: GLESInternalRT);
        get depthPipelineMode(): string;
        set depthPipelineMode(value: string);
        private _depthNormalTarget;
        get depthNormalTarget(): GLESInternalRT;
        set depthNormalTarget(value: GLESInternalRT);
        get depthNormalPipelineMode(): string;
        set depthNormalPipelineMode(value: string);
        private _skyRenderNode;
        get skyRenderNode(): RTBaseRenderNode;
        set skyRenderNode(value: RTBaseRenderNode);
        get depthTextureMode(): DepthTextureMode;
        set depthTextureMode(value: DepthTextureMode);
        private _opaqueTexture;
        get opaqueTexture(): GLESInternalRT;
        set opaqueTexture(value: GLESInternalRT);
        private _camera;
        get camera(): RTCameraNodeData;
        set camera(value: RTCameraNodeData);
        private _clearColor;
        get clearColor(): Color;
        set clearColor(value: Color);
        get clearFlag(): number;
        set clearFlag(value: number);
        setCameraCullInfo(value: Camera): void;
        setViewPort(value: Viewport): void;
        setScissor(value: Vector4): void;
        private _getRenderCMDArray;
        get opaquePassCommandBuffer(): CommandBuffer;
        set opaquePassCommandBuffer(value: CommandBuffer);
        setBeforeForwardCmds(value: CommandBuffer[]): void;
        setBeforeSkyboxCmds(value: CommandBuffer[]): void;
        setBeforeTransparentCmds(value: CommandBuffer[]): void;
        _nativeObj: any;
        constructor();
        destroy(): void;
    }
    class GLESForwardAddRP {
        get shadowCastPass(): boolean;
        set shadowCastPass(value: boolean);
        private _directLightShadowPass;
        get directLightShadowPass(): GLESDirectLightShadowRP;
        set directLightShadowPass(value: GLESDirectLightShadowRP);
        get enableDirectLightShadow(): boolean;
        set enableDirectLightShadow(value: boolean);
        private _spotLightShadowPass;
        get spotLightShadowPass(): GLESSpotLightShadowRP;
        set spotLightShadowPass(value: GLESSpotLightShadowRP);
        get enableSpotLightShadowPass(): boolean;
        set enableSpotLightShadowPass(value: boolean);
        private _renderpass;
        get renderpass(): GLESForwardAddClusterRP;
        set renderpass(value: GLESForwardAddClusterRP);
        private _enablePostProcess;
        get enablePostProcess(): boolean;
        set enablePostProcess(value: boolean);
        get postProcess(): CommandBuffer;
        set postProcess(value: CommandBuffer);
        get finalize(): CommandBuffer;
        set finalize(value: CommandBuffer);
        _nativeObj: any;
        constructor();
        private _getRenderCMDArray;
        setAfterEventCmd(value: CommandBuffer[]): void;
        setBeforeImageEffect(value: CommandBuffer[]): void;
        destroy(): void;
    }
    class GLESRender3DProcess implements IRender3DProcess {
        private _nativeObj;
        private _tempList;
        private renderpass;
        constructor();
        private _render3DManager;
        get render3DManager(): RTScene3DRenderManager;
        set render3DManager(value: RTScene3DRenderManager);
        destroy(): void;
        initRenderpass(camera: Camera, context: GLESRenderContext3D): void;
        renderDepth(camera: Camera): void;
        fowardRender(context: GLESRenderContext3D, camera: Camera): void;
        renderFowarAddCameraPass(context: GLESRenderContext3D, renderpass: GLESForwardAddRP): void;
    }
    class GLESDrawNodeCMDData extends DrawNodeCMDData {
        type: RenderCMDType;
        protected _node: RTBaseRenderNode;
        protected _destShaderData: GLESShaderData;
        protected _destSubShader: SubShader;
        protected _subMeshIndex: number;
        get node(): RTBaseRenderNode;
        set node(value: RTBaseRenderNode);
        get destShaderData(): GLESShaderData;
        set destShaderData(value: GLESShaderData);
        get destSubShader(): SubShader;
        set destSubShader(value: SubShader);
        get subMeshIndex(): number;
        set subMeshIndex(value: number);
        constructor();
    }
    class GLESBlitQuadCMDData extends BlitQuadCMDData {
        type: RenderCMDType;
        protected _dest: GLESInternalRT;
        protected _viewport: Viewport;
        protected _source: GLESInternalTex;
        protected _scissor: Vector4;
        protected _offsetScale: Vector4;
        protected _element: GLESRenderElement3D;
        get dest(): GLESInternalRT;
        set dest(value: GLESInternalRT);
        get viewport(): Viewport;
        set viewport(value: Viewport);
        get scissor(): Vector4;
        set scissor(value: Vector4);
        get source(): GLESInternalTex;
        set source(value: GLESInternalTex);
        get offsetScale(): Vector4;
        set offsetScale(value: Vector4);
        get element(): GLESRenderElement3D;
        set element(value: GLESRenderElement3D);
        constructor();
    }
    class GLESDrawElementCMDData extends DrawElementCMDData {
        type: RenderCMDType;
        private _elemets;
        constructor();
        setRenderelements(value: GLESRenderElement3D[]): void;
    }
    class GLESSetViewportCMD extends SetViewportCMD {
        type: RenderCMDType;
        protected _viewport: Viewport;
        protected _scissor: Vector4;
        get viewport(): Viewport;
        set viewport(value: Viewport);
        get scissor(): Vector4;
        set scissor(value: Vector4);
        constructor();
    }
    class GLESSetRenderTargetCMD extends SetRenderTargetCMD {
        type: RenderCMDType;
        protected _rt: GLESInternalRT;
        protected _clearFlag: number;
        protected _clearColorValue: Color;
        protected _clearDepthValue: number;
        protected _clearStencilValue: number;
        get rt(): GLESInternalRT;
        set rt(value: GLESInternalRT);
        get clearFlag(): number;
        set clearFlag(value: number);
        get clearColorValue(): Color;
        set clearColorValue(value: Color);
        get clearDepthValue(): number;
        set clearDepthValue(value: number);
        get clearStencilValue(): number;
        set clearStencilValue(value: number);
        constructor();
    }
    class GLESSetRenderData extends SetRenderDataCMD {
        type: RenderCMDType;
        protected _dataType: ShaderDataType;
        protected _propertyID: number;
        protected _dest: GLESShaderData;
        protected _value: ShaderDataItem;
        data_v4: Vector4;
        data_v3: Vector3;
        data_v2: Vector2;
        data_mat: Matrix4x4;
        data_number: number;
        data_texture: BaseTexture;
        data_Color: Color;
        data_Buffer: Float32Array;
        get dataType(): ShaderDataType;
        set dataType(value: ShaderDataType);
        get propertyID(): number;
        set propertyID(value: number);
        get dest(): GLESShaderData;
        set dest(value: GLESShaderData);
        get value(): ShaderDataItem;
        set value(value: ShaderDataItem);
        constructor();
    }
    class GLESSetShaderDefine extends SetShaderDefineCMD {
        type: RenderCMDType;
        protected _define: RTShaderDefine;
        protected _dest: GLESShaderData;
        protected _add: boolean;
        get define(): RTShaderDefine;
        set define(value: RTShaderDefine);
        get dest(): GLESShaderData;
        set dest(value: GLESShaderData);
        get add(): boolean;
        set add(value: boolean);
        constructor();
    }
    class GLESRenderContext3D implements IRenderContext3D {
        private _globalShaderData;
        get globalShaderData(): GLESShaderData;
        set globalShaderData(value: GLESShaderData);
        private _sceneData;
        get sceneData(): GLESShaderData;
        set sceneData(value: GLESShaderData);
        private _sceneModuleData;
        get sceneModuleData(): RTSceneNodeData;
        set sceneModuleData(value: RTSceneNodeData);
        private _cameraModuleData;
        get cameraModuleData(): RTCameraNodeData;
        set cameraModuleData(value: RTCameraNodeData);
        private _cameraData;
        get cameraData(): GLESShaderData;
        set cameraData(value: GLESShaderData);
        get sceneUpdataMask(): number;
        set sceneUpdataMask(value: number);
        get cameraUpdateMask(): number;
        set cameraUpdateMask(value: number);
        get pipelineMode(): string;
        set pipelineMode(value: string);
        get invertY(): boolean;
        set invertY(value: boolean);
        _nativeObj: any;
        constructor();
        setRenderTarget(value: GLESInternalRT, clearFlag: RenderClearFlag): void;
        setViewPort(value: Viewport): void;
        setScissor(value: Vector4): void;
        setClearData(clearFlag: number, color: Color, depth: number, stencil: number): number;
        private _tempList;
        drawRenderElementList(list: FastSinglelist<GLESRenderElement3D>): number;
        drawRenderElementOne(node: IRenderElement3D): number;
        runOneCMD(cmd: IRenderCMD): void;
        runCMDList(cmds: IRenderCMD[]): void;
    }
    enum RenderElementType {
        Base = 0,
        Skin = 1,
        Instance = 2
    }
    class GLESRenderElement3D implements IRenderElement3D {
        private _geometry;
        private _materialShaderData;
        private _renderShaderData;
        private _transform;
        set geometry(data: GLESRenderGeometryElement);
        get geometry(): GLESRenderGeometryElement;
        set materialShaderData(data: GLESShaderData);
        get materialShaderData(): GLESShaderData;
        set renderShaderData(data: GLESShaderData);
        get renderShaderData(): GLESShaderData;
        set transform(data: RTTransform3D);
        get transform(): RTTransform3D;
        get isRender(): boolean;
        set isRender(data: boolean);
        get materialRenderQueue(): number;
        set materialRenderQueue(value: number);
        private _owner;
        get owner(): RTBaseRenderNode;
        set owner(value: RTBaseRenderNode);
        private _subShader;
        get subShader(): SubShader;
        set subShader(value: SubShader);
        get canDynamicBatch(): boolean;
        set canDynamicBatch(value: boolean);
        get materialId(): number;
        set materialId(value: number);
        _nativeObj: any;
        constructor();
        destroy(): void;
        protected init(): void;
    }
    class GLESSkinRenderElement3D extends GLESRenderElement3D implements ISkinRenderElement3D {
        _skinnedData: Float32Array[];
        constructor();
        get skinnedData(): Float32Array[];
        set skinnedData(data: Float32Array[]);
        init(): void;
    }
    class GLESSpotLightShadowRP {
        private _light;
        get light(): SpotLightCom;
        set light(value: SpotLightCom);
        private _destTarget;
        get destTarget(): GLESInternalRT;
        set destTarget(value: GLESInternalRT);
        _nativeObj: any;
        constructor();
        destroy(): void;
    }
    class GLESBufferState implements IBufferState {
        _bindedIndexBuffer: IIndexBuffer;
        _vertexBuffers: IVertexBuffer[];
        _nativeObj: any;
        constructor();
        applyState(vertexBuffers: IVertexBuffer[], indexBuffer: IIndexBuffer): void;
        destroy(): void;
    }
    class GLESCommandUniformMap extends CommandUniformMap {
        _nativeObj: any;
        constructor(stateName: string);
        /**
         * 增加一个UniformArray参数
         * @param propertyID
         * @param propertyName
         */
        addShaderUniformArray(propertyID: number, propertyName: string, uniformtype: ShaderDataType, arrayLength: number, block?: string): void;
        /**
         * 增加一个Uniform
         */
        addShaderBlockUniform(propertyID: number, blockname: string, blockProperty: UniformProperty[]): void;
    }
    /**
     * WebGL mode.
     */
    enum GLESMode {
        /** Auto, use WebGL2.0 if support, or will fallback to WebGL1.0. */
        Auto = 0,
        /** WebGL2.0. */
        WebGL2 = 1,
        /** WebGL1.0, */
        WebGL1 = 2
    }
    /**
     * @private 封装Webgl
     */
    class GLESEngine implements IRenderEngine {
        _context: any;
        _isShaderDebugMode: boolean;
        _renderOBJCreateContext: IRenderEngineFactory;
        _nativeObj: any;
        private _GLTextureContext;
        constructor(config: WebGLConfig, webglMode?: GLESMode);
        endFrame(): void;
        _remapZ: boolean;
        _screenInvertY: boolean;
        _lodTextureSample: boolean;
        _breakTextureSample: boolean;
        get _enableStatistics(): boolean;
        set _enableStatistics(value: boolean);
        resizeOffScreen(width: number, height: number): void;
        getDefineByName(name: string): RTShaderDefine;
        getNamesByDefineData(defineData: IDefineDatas, out: Array<string>): void;
        addTexGammaDefine(key: number, value: RTShaderDefine): void;
        initRenderEngine(canvas: any): void;
        copySubFrameBuffertoTex(texture: InternalTexture, level: number, xoffset: number, yoffset: number, x: number, y: number, width: number, height: number): void;
        propertyNameToID(name: string): number;
        propertyIDToName(id: number): string;
        getParams(params: RenderParams): number;
        getCapable(capatableType: RenderCapable): boolean;
        getTextureContext(): ITextureContext;
        getCreateRenderOBJContext(): IRenderEngineFactory;
        clearStatisticsInfo(): void;
        getStatisticsInfo(info: GPUEngineStatisticsInfo): number;
        viewport(x: number, y: number, width: number, height: number): void;
        scissor(x: number, y: number, width: number, height: number): void;
    }
    class GLESIndexBuffer implements IIndexBuffer {
        destroy(): void;
        _setIndexDataLength(data: number): void;
        _setIndexData(data: Uint32Array | Uint16Array | Uint8Array, bufferOffset: number): void;
        get indexType(): IndexFormat;
        set indexType(value: IndexFormat);
        get indexCount(): number;
        set indexCount(value: number);
        _nativeObj: any;
        constructor(targetType: BufferTargetType, bufferUsageType: BufferUsage);
    }
    class GLESInternalRT implements InternalRenderTarget {
        _texturesRef: InternalTexture[];
        _depthTextureRef: InternalTexture;
        _nativeObj: any;
        constructor(nativeObj: any);
        get _isCube(): boolean;
        set _isCube(value: boolean);
        get _samples(): number;
        set _samples(value: number);
        get _generateMipmap(): boolean;
        set _generateMipmap(value: boolean);
        get colorFormat(): RenderTargetFormat;
        set colorFormat(value: RenderTargetFormat);
        get depthStencilFormat(): RenderTargetFormat;
        set depthStencilFormat(value: RenderTargetFormat);
        get isSRGB(): boolean;
        set isSRGB(value: boolean);
        get gpuMemory(): number;
        set gpuMemory(value: number);
        get _textures(): InternalTexture[];
        get _depthTexture(): InternalTexture;
        dispose(): void;
    }
    class GLESRenderDeviceFactory implements IRenderDeviceFactory {
        createShaderData(ownerResource: Resource): ShaderData;
        private globalBlockMap;
        createGlobalUniformMap(blockName: string): GLESCommandUniformMap;
        createShaderInstance(shaderProcessInfo: ShaderProcessInfo, shaderPass: ShaderPass): IShaderInstance;
        createIndexBuffer(bufferUsage: BufferUsage): IIndexBuffer;
        createVertexBuffer(bufferUsageType: BufferUsage): IVertexBuffer;
        createBufferState(): IBufferState;
        createRenderGeometryElement(mode: MeshTopology, drawType: DrawType): IRenderGeometryElement;
        createEngine(config: Config, canvas: any): Promise<void>;
    }
    class GLESRenderEngineFactory implements IRenderEngineFactory {
        _nativeObj: any;
        createUniformBufferObject(glPointer: number, name: string, bufferUsage: BufferUsage, byteLength: number, isSingle: boolean): UniformBufferObject;
        createEngine(config: Config, canvas: any): Promise<void>;
        afterInit(): void;
        private static _setVertexDec;
    }
    class GLESRenderGeometryElement implements IRenderGeometryElement {
        _nativeObj: any;
        clearRenderParams(): void;
        set bufferState(value: IBufferState);
        get bufferState(): IBufferState;
        set mode(value: MeshTopology);
        get mode(): MeshTopology;
        set drawType(value: DrawType);
        get drawType(): DrawType;
        set instanceCount(value: number);
        get instanceCount(): number;
        set indexFormat(value: IndexFormat);
        get indexFormat(): IndexFormat;
    }
    class GLESShaderData extends ShaderData {
        nativeObjID: number;
        _nativeObj: any;
        _defineDatas: RTDefineDatas;
        _textureData: {
            [key: number]: BaseTexture;
        };
        _bufferData: {
            [key: number]: Float32Array;
        };
        /**
        *
        * @param index
        * @param value
        */
        setUniformBuffer(index: number, value: UniformBufferObject): void;
        getUniformBuffer(index: number): UniformBufferObject;
        getDefineData(): RTDefineDatas;
        /**
         * 增加Shader宏定义。
         */
        addDefine(define: RTShaderDefine): void;
        addDefines(define: RTDefineDatas): void;
        /**
         * 移除Shader宏定义。
         */
        removeDefine(define: RTShaderDefine): void;
        /**
         * 是否包含Shader宏定义。
         */
        hasDefine(define: RTShaderDefine): boolean;
        /**
         * 清空宏定义。
         */
        clearDefine(): void;
        /**
         * 获取布尔。
         * @param	index shader索引。
         * @return  布尔。
         */
        getBool(index: number): boolean;
        /**
         * 设置布尔。
         * @param	index shader索引。
         * @param	value 布尔。
         */
        setBool(index: number, value: boolean): void;
        /**
         * 获取整形。
         * @param	index shader索引。
         * @return  整形。
         */
        getInt(index: number): number;
        /**
         * 设置整型。
         * @param	index shader索引。
         * @param	value 整形。
         */
        setInt(index: number, value: number): void;
        /**
         * 获取浮点。
         * @param	index shader索引。
         * @return	浮点。
         */
        getNumber(index: number): number;
        /**
         * 设置浮点。
         * @param	index shader索引。
         * @param	value 浮点。
         */
        setNumber(index: number, value: number): void;
        /**
         * 获取Vector2向量。
         * @param	index shader索引。
         * @return Vector2向量。
         */
        getVector2(index: number): Vector2;
        /**
         * 设置Vector2向量。
         * @param	index shader索引。
         */
        setVector2(index: number, value: Vector2): void;
        /**
         * 获取Vector3向量。
         * @param	index shader索引。
         * @return Vector3向量。
         */
        getVector3(index: number): Vector3;
        /**
         * 设置Vector3向量。
         * @param	index shader索引。
         * @param	value Vector3向量。
         */
        setVector3(index: number, value: Vector3): void;
        /**
         * 获取颜色。
         * @param 	index shader索引。
         * @return  向量。
         */
        getVector(index: number): Vector4;
        /**
         * 设置向量。
         * @param	index shader索引。
         * @param	value 向量。
         */
        setVector(index: number, value: Vector4): void;
        /**
         * 获取颜色
         * @param index 索引
         * @returns 颜色
         */
        getColor(index: number): Color;
        /**
         * 设置颜色
         * @param index 索引
         * @param value 颜色值
         */
        setColor(index: number, value: Color): void;
        /**
         * 获取矩阵。
         * @param	index shader索引。
         * @return  矩阵。
         */
        getMatrix4x4(index: number): Matrix4x4;
        /**
         * 设置矩阵。
         * @param	index shader索引。
         * @param	value  矩阵。
         */
        setMatrix4x4(index: number, value: Matrix4x4): void;
        /**
         * 获取矩阵
         * @param index
         * @returns
         */
        getMatrix3x3(index: number): Matrix3x3;
        /**
         * 设置矩阵。
         * @param index
         * @param value
         */
        setMatrix3x3(index: number, value: Matrix3x3): void;
        /**
         * 获取Buffer。
         * @param	index shader索引。
         * @return
         */
        getBuffer(index: number): Float32Array;
        /**
         * 设置Buffer。
         * @param	index shader索引。
         * @param	value  buffer数据。
         */
        setBuffer(index: number, value: Float32Array): void;
        /**
         * 设置纹理。
         * @param	index shader索引。
         * @param	value 纹理。
         */
        setTexture(index: number, value: BaseTexture): void;
        /**
         * 获取纹理。
         * @param	index shader索引。
         * @return  纹理。
         */
        getTexture(index: number): BaseTexture;
        cloneTo(destObject: GLESShaderData): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
        destroy(): void;
    }
    class GLESTextureContext implements ITextureContext {
        needBitmap: boolean;
        protected _native: any;
        constructor(native: any);
        createTextureInternal(dimension: TextureDimension, width: number, height: number, format: TextureFormat, generateMipmap: boolean, sRGB: boolean, premultipliedAlpha: boolean): GLESInternalTex;
        setTextureImageData(texture: GLESInternalTex, source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexturePixelsData(texture: GLESInternalTex, source: ArrayBufferView, premultiplyAlpha: boolean, invertY: boolean): void;
        initVideoTextureData(texture: GLESInternalTex): void;
        setTextureSubPixelsData(texture: GLESInternalTex, source: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, width: number, height: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureSubImageData(texture: GLESInternalTex, source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, x: number, y: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DImageData(texture: GLESInternalTex, source: HTMLImageElement[] | HTMLCanvasElement[] | ImageBitmap[], depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        createTexture3DInternal(dimension: TextureDimension, width: number, height: number, depth: number, format: TextureFormat, generateMipmap: boolean, sRGB: boolean, premultipliedAlpha: boolean): GLESInternalTex;
        setTexture3DPixelsData(texture: GLESInternalTex, source: ArrayBufferView, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DSubPixelsData(texture: GLESInternalTex, source: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, zOffset: number, width: number, height: number, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureHDRData(texture: GLESInternalTex, hdrInfo: HDRTextureInfo): void;
        setTextureDDSData(texture: GLESInternalTex, ddsInfo: DDSTextureInfo): void;
        setTextureKTXData(texture: GLESInternalTex, ktxInfo: KTXTextureInfo): void;
        setCubeImageData(texture: GLESInternalTex, sources: (HTMLImageElement | HTMLCanvasElement | ImageBitmap)[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubePixelsData(texture: GLESInternalTex, source: ArrayBufferView[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubeSubPixelData(texture: GLESInternalTex, source: ArrayBufferView[], mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, width: number, height: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setCubeDDSData(texture: GLESInternalTex, ddsInfo: DDSTextureInfo): void;
        setCubeKTXData(texture: GLESInternalTex, ktxInfo: KTXTextureInfo): void;
        setTextureCompareMode(texture: GLESInternalTex, compareMode: TextureCompareMode): TextureCompareMode;
        bindRenderTarget(renderTarget: GLESInternalRT, faceIndex?: number): void;
        bindoutScreenTarget(): void;
        unbindRenderTarget(renderTarget: GLESInternalRT): void;
        createRenderTargetInternal(width: number, height: number, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number): GLESInternalRT;
        createRenderTargetCubeInternal(size: number, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number): GLESInternalRT;
        createRenderTextureCubeInternal(dimension: TextureDimension, size: number, format: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean): GLESInternalTex;
        createRenderTargetDepthTexture(renderTarget: GLESInternalRT, dimension: TextureDimension, width: number, height: number): GLESInternalTex;
        /**
         * @deprecated 请使用readRenderTargetPixelDataAsync函数代替
         * @param renderTarget
         * @param xOffset
         * @param yOffset
         * @param width
         * @param height
         * @param out
         * @returns
         */
        readRenderTargetPixelData(renderTarget: GLESInternalRT, xOffset: number, yOffset: number, width: number, height: number, out: ArrayBufferView): ArrayBufferView;
        readRenderTargetPixelDataAsync(renderTarget: GLESInternalRT, xOffset: number, yOffset: number, width: number, height: number, out: ArrayBufferView): Promise<ArrayBufferView>;
        updateVideoTexture(texture: GLESInternalTex, video: HTMLVideoElement, premultiplyAlpha: boolean, invertY: boolean): void;
    }
    class GLESVertexBuffer implements IVertexBuffer {
        _instanceBuffer: boolean;
        _nativeObj: any;
        constructor(targetType: BufferTargetType, bufferUsageType: BufferUsage);
        private _vertexDeclaration;
        get vertexDeclaration(): VertexDeclaration;
        set vertexDeclaration(value: VertexDeclaration);
        get instanceBuffer(): boolean;
        set instanceBuffer(value: boolean);
        setData(buffer: ArrayBuffer, bufferOffset: number, dataStartIndex: number, dataCount: number): void;
        setDataLength(byteLength: number): void;
        destroy(): void;
    }
    enum BaseRenderType {
        BaseRender = 0,
        MeshRender = 1,
        ParticleRender = 2,
        TrailRender = 3,
        LineRender = 4,
        TerrainRender = 5,
        SkyRender = 7,
        SimpleSkinRender = 8,
        SkinnedMeshRender = 9
    }
    interface IBaseRenderNode {
        renderNodeType: number;
        transform: Transform3D;
        distanceForSort: number;
        sortingFudge: number;
        castShadow: boolean;
        receiveShadow: boolean;
        enable: boolean;
        renderbitFlag: number;
        layer: number;
        bounds: Bounds;
        baseGeometryBounds: Bounds;
        boundsChange: boolean;
        staticMask: number;
        shaderData: ShaderData;
        lightmapIndex: number;
        lightmap: ILightMapData;
        probeReflection: IReflectionProbeData;
        probeReflectionUpdateMark: number;
        reflectionMode: number;
        volumetricGI: IVolumetricGIData;
        lightProbUpdateMark: number;
        irradientMode: IrradianceMode;
        set_renderUpdatePreCall(call: any, fun: any): void;
        set_caculateBoundingBox(call: any, fun: any): void;
        _applyLightProb(): void;
        _applyReflection(): void;
    }
    interface IMeshRenderNode extends IBaseRenderNode {
    }
    interface ISkinRenderNode extends IBaseRenderNode {
        computeSkinnedData(): void;
        setRootBoneTransfom(value: Sprite3D): void;
        setOwnerTransform(value: Sprite3D): void;
        setCacheMesh(cacheMesh: Mesh): void;
        setBones(value: Sprite3D[]): void;
        setSkinnedData(value: any[]): void;
    }
    interface ISimpleSkinRenderNode extends IBaseRenderNode {
        setSimpleAnimatorParams(value: Vector4): void;
    }
    interface IDirectLightData {
        transform: Transform3D;
        shadowResolution: number;
        shadowDistance: number;
        shadowMode: ShadowMode;
        shadowStrength: number;
        shadowDepthBias: number;
        shadowNormalBias: number;
        shadowNearPlane: number;
        shadowCascadesMode: ShadowCascadesMode;
        shadowTwoCascadeSplits: number;
        setShadowFourCascadeSplits(value: Vector3): void;
        setDirection(value: Vector3): void;
    }
    interface ISpotLightData {
        transform: Transform3D;
        shadowResolution: number;
        shadowDistance: number;
        shadowMode: ShadowMode;
        shadowStrength: number;
        shadowDepthBias: number;
        shadowNormalBias: number;
        shadowNearPlane: number;
        spotRange: number;
        spotAngle: number;
        setDirection(value: Vector3): void;
    }
    interface IPointLightData {
        transform: Transform3D;
        range: number;
        shadowResolution: number;
        shadowDistance: number;
        shadowMode: ShadowMode;
        shadowStrength: number;
        shadowDepthBias: number;
        shadowNormalBias: number;
        shadowNearPlane: number;
    }
    interface ILightMapData {
    }
    interface IReflectionProbeData {
    }
    interface IVolumetricGIData {
        _id: number;
        irradiance: InternalTexture;
        distance: InternalTexture;
        bound: Bounds;
        intensity: number;
        updateMark: number;
        setProbeCounts(value: Vector3): void;
        setProbeStep(value: Vector3): void;
        setParams(value: Vector4): void;
    }
    interface ICameraNodeData {
        transform: Transform3D;
        farplane: number;
        nearplane: number;
        fieldOfView: number;
        aspectRatio: number;
        setProjectionViewMatrix(value: Matrix4x4): void;
    }
    interface ISceneNodeData {
        lightmapDirtyFlag: number;
    }
    interface I3DRenderModuleFactory {
        createTransform(owner: Sprite3D): Transform3D;
        createBounds(min: Vector3, max: Vector3): any;
        createVolumetricGI(): IVolumetricGIData;
        createReflectionProbe(): IReflectionProbeData;
        createLightmapData(): ILightMapData;
        createDirectLight(): IDirectLightData;
        createSpotLight(): ISpotLightData;
        createPointLight(): IPointLightData;
        createCameraModuleData(): ICameraNodeData;
        createSceneModuleData(): ISceneNodeData;
        createBaseRenderNode(): IBaseRenderNode;
        createMeshRenderNode(): IMeshRenderNode;
        createSkinRenderNode(): ISkinRenderNode;
        createSimpleSkinRenderNode(): ISimpleSkinRenderNode;
    }
    interface IDefineDatas {
        add(define: ShaderDefine): void;
        remove(define: ShaderDefine): void;
        addDefineDatas(define: IDefineDatas): void;
        removeDefineDatas(define: IDefineDatas): void;
        has(define: ShaderDefine): boolean;
        clear(): void;
        cloneTo(destObject: IDefineDatas): void;
        clone(): IDefineDatas;
        destroy(): void;
    }
    interface IShaderPassData {
        is2D: boolean;
        pipelineMode: string;
        statefirst: boolean;
        validDefine: IDefineDatas;
        renderState: RenderState;
        nodeCommonMap: string[];
        setCacheShader(defines: IDefineDatas, shaderInstance: IShaderInstance): void;
        getCacheShader(defines: IDefineDatas): IShaderInstance;
        destroy(): void;
    }
    interface ISubshaderData {
        addShaderPass(pass: IShaderPassData): void;
        enableInstance: boolean;
        destroy(): void;
    }
    interface IUnitRenderModuleDataFactory {
        createRenderState(): RenderState;
        createDefineDatas(): IDefineDatas;
        createSubShader(): ISubshaderData;
        createShaderPass(pass: ShaderPass): IShaderPassData;
    }
    /**
     * <code>RenderState</code> 类用于控制渲染状态。
     */
    class RenderState {
        /**剔除枚举_不剔除。*/
        static CULL_NONE: number;
        /**剔除枚举_剔除正面。*/
        static CULL_FRONT: number;
        /**剔除枚举_剔除背面。*/
        static CULL_BACK: number;
        /**混合枚举_禁用。*/
        static BLEND_DISABLE: number;
        /**混合枚举_启用_RGB和Alpha统一混合。*/
        static BLEND_ENABLE_ALL: number;
        /**混合枚举_启用_RGB和Alpha单独混合。*/
        static BLEND_ENABLE_SEPERATE: number;
        /**混合参数枚举_零,例：RGB(0,0,0),Alpha:(1)。*/
        static BLENDPARAM_ZERO: number;
        /**混合参数枚举_一,例：RGB(1,1,1),Alpha:(1)。*/
        static BLENDPARAM_ONE: number;
        /**混合参数枚举_源颜色,例：RGB(Rs, Gs, Bs)，Alpha(As)。*/
        static BLENDPARAM_SRC_COLOR: number;
        /**混合参数枚举_一减源颜色,例：RGB(1-Rs, 1-Gs, 1-Bs)，Alpha(1-As)。*/
        static BLENDPARAM_ONE_MINUS_SRC_COLOR: number;
        /**混合参数枚举_目标颜色,例：RGB(Rd, Gd, Bd),Alpha(Ad)。*/
        static BLENDPARAM_DST_COLOR: number;
        /**混合参数枚举_一减目标颜色,例：RGB(1-Rd, 1-Gd, 1-Bd)，Alpha(1-Ad)。*/
        static BLENDPARAM_ONE_MINUS_DST_COLOR: number;
        /**混合参数枚举_源透明,例:RGB(As, As, As),Alpha(1-As)。*/
        static BLENDPARAM_SRC_ALPHA: number;
        /**混合参数枚举_一减源阿尔法,例:RGB(1-As, 1-As, 1-As),Alpha(1-As)。*/
        static BLENDPARAM_ONE_MINUS_SRC_ALPHA: number;
        /**混合参数枚举_目标阿尔法，例：RGB(Ad, Ad, Ad),Alpha(Ad)。*/
        static BLENDPARAM_DST_ALPHA: number;
        /**混合参数枚举_一减目标阿尔法,例：RGB(1-Ad, 1-Ad, 1-Ad),Alpha(Ad)。*/
        static BLENDPARAM_ONE_MINUS_DST_ALPHA: number;
        /**混合参数枚举_阿尔法饱和，例：RGB(min(As, 1 - Ad), min(As, 1 - Ad), min(As, 1 - Ad)),Alpha(1)。*/
        static BLENDPARAM_SRC_ALPHA_SATURATE: number;
        /**混合参数枚举_混合设置颜色 */
        static BLENDPARAM_BLENDCOLOR: number;
        /**很合参数枚举_混合颜色取反 */
        static BLENDPARAM_BLEND_ONEMINUS_COLOR: number;
        /**混合方程枚举_加法,例：source + destination*/
        static BLENDEQUATION_ADD: number;
        /**混合方程枚举_减法，例：source - destination*/
        static BLENDEQUATION_SUBTRACT: number;
        /**混合方程枚举_反序减法，例：destination - source*/
        static BLENDEQUATION_REVERSE_SUBTRACT: number;
        /**混合方程枚举_取最小 TODO */
        static BLENDEQUATION_MIN: number;
        /**混合方程枚举_取最大 TODO*/
        static BLENDEQUATION_MAX: number;
        /**深度测试函数枚举_关闭深度测试。*/
        static DEPTHTEST_OFF: number;
        /**深度测试函数枚举_从不通过。*/
        static DEPTHTEST_NEVER: number;
        /**深度测试函数枚举_小于时通过。*/
        static DEPTHTEST_LESS: number;
        /**深度测试函数枚举_等于时通过。*/
        static DEPTHTEST_EQUAL: number;
        /**深度测试函数枚举_小于等于时通过。*/
        static DEPTHTEST_LEQUAL: number;
        /**深度测试函数枚举_大于时通过。*/
        static DEPTHTEST_GREATER: number;
        /**深度测试函数枚举_不等于时通过。*/
        static DEPTHTEST_NOTEQUAL: number;
        /**深度测试函数枚举_大于等于时通过。*/
        static DEPTHTEST_GEQUAL: number;
        /**深度测试函数枚举_总是通过。*/
        static DEPTHTEST_ALWAYS: number;
        static STENCILTEST_OFF: number;
        /**深度测试函数枚举_从不通过。*/
        static STENCILTEST_NEVER: number;
        /**深度测试函数枚举_小于时通过。*/
        static STENCILTEST_LESS: number;
        /**深度测试函数枚举_等于时通过。*/
        static STENCILTEST_EQUAL: number;
        /**深度测试函数枚举_小于等于时通过。*/
        static STENCILTEST_LEQUAL: number;
        /**深度测试函数枚举_大于时通过。*/
        static STENCILTEST_GREATER: number;
        /**深度测试函数枚举_不等于时通过。*/
        static STENCILTEST_NOTEQUAL: number;
        /**深度测试函数枚举_大于等于时通过。*/
        static STENCILTEST_GEQUAL: number;
        /**深度测试函数枚举_总是通过。*/
        static STENCILTEST_ALWAYS: number;
        /**保持当前值*/
        static STENCILOP_KEEP: number;
        /**将模板缓冲区值设置为0*/
        static STENCILOP_ZERO: number;
        /**将模具缓冲区值设置为指定的参考值*/
        static STENCILOP_REPLACE: number;
        /**增加当前模具缓冲区值+1 */
        static STENCILOP_INCR: number;
        /**增加当前模具缓冲区值,超过最大值的时候循环*/
        static STENCILOP_INCR_WRAP: number;
        /**递减当前模板缓冲区的值*/
        static STENCILOP_DECR: number;
        /**递减当前模板缓冲去的值，小于0时会循环*/
        static STENCILOP_DECR_WRAP: number;
        /**按位反转当前的模板缓冲区的值*/
        static STENCILOP_INVERT: number;
        /**渲染剔除状态。*/
        private _cull;
        get cull(): number;
        set cull(value: number);
        /**透明混合。*/
        private _blend;
        get blend(): number;
        set blend(value: number);
        /**源混合参数,在blend为BLEND_ENABLE_ALL时生效。*/
        private _srcBlend;
        get srcBlend(): number;
        set srcBlend(value: number);
        /**目标混合参数,在blend为BLEND_ENABLE_ALL时生效。*/
        private _dstBlend;
        get dstBlend(): number;
        set dstBlend(value: number);
        /**RGB源混合参数,在blend为BLEND_ENABLE_SEPERATE时生效。*/
        private _srcBlendRGB;
        get srcBlendRGB(): number;
        set srcBlendRGB(value: number);
        /**RGB目标混合参数,在blend为BLEND_ENABLE_SEPERATE时生效。*/
        private _dstBlendRGB;
        get dstBlendRGB(): number;
        set dstBlendRGB(value: number);
        /**Alpha源混合参数,在blend为BLEND_ENABLE_SEPERATE时生效。*/
        private _srcBlendAlpha;
        get srcBlendAlpha(): number;
        set srcBlendAlpha(value: number);
        /**Alpha目标混合参数,在blend为BLEND_ENABLE_SEPERATE时生效。*/
        private _dstBlendAlpha;
        get dstBlendAlpha(): number;
        set dstBlendAlpha(value: number);
        /**混合方程。*/
        private _blendEquation;
        get blendEquation(): number;
        set blendEquation(value: number);
        /**RGB混合方程。*/
        private _blendEquationRGB;
        get blendEquationRGB(): number;
        set blendEquationRGB(value: number);
        /**Alpha混合方程。*/
        private _blendEquationAlpha;
        get blendEquationAlpha(): number;
        set blendEquationAlpha(value: number);
        /**深度测试函数。*/
        private _depthTest;
        get depthTest(): number;
        set depthTest(value: number);
        /**是否深度测试。*/
        private _depthWrite;
        get depthWrite(): boolean;
        set depthWrite(value: boolean);
        /**是否模板写入 */
        private _stencilWrite;
        get stencilWrite(): boolean;
        set stencilWrite(value: boolean);
        /**是否开启模板测试 */
        private _stencilTest;
        get stencilTest(): number;
        set stencilTest(value: number);
        /**模板值 一般会在0-255*/
        private _stencilRef;
        get stencilRef(): number;
        set stencilRef(value: number);
        /**模板设置值 */
        private _stencilOp;
        get stencilOp(): Vector3;
        set stencilOp(value: Vector3);
        protected createObj(): void;
        /**
         * 创建一个 <code>RenderState</code> 实例。
         */
        constructor();
        /**
         * 克隆
         * @param dest
         */
        cloneTo(dest: RenderState): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): RenderState;
    }
    /**
     * <code>ShaderDefine</code> 类用于定义宏数据。
     */
    class ShaderDefine {
        /**
         * 创建一个宏定义的实例`
         * @param index 宏索引
         * @param value 宏值
         */
        constructor(index: number, value: number);
    }
    class NativeBounds implements IClone {
        /**native Share Memory */
        static MemoryBlock_size: number;
        get min(): Vector3;
        set min(value: Vector3);
        get max(): Vector3;
        set max(value: Vector3);
        /**
         * 设置包围盒的最小点。
         * @param value	包围盒的最小点。
         */
        setMin(value: Vector3): void;
        /**
         * 获取包围盒的最小点。
         * @return	包围盒的最小点。
         */
        getMin(): Vector3;
        /**
         * 设置包围盒的最大点。
         * @param value	包围盒的最大点。
         */
        setMax(value: Vector3): void;
        /**
         * 获取包围盒的最大点。
         * @return	包围盒的最大点。
         */
        getMax(): Vector3;
        /**
         * 设置包围盒的中心点。
         * @param value	包围盒的中心点。
         */
        setCenter(value: Vector3): void;
        /**
         * 获取包围盒的中心点。
         * @return	包围盒的中心点。
         */
        getCenter(): Vector3;
        /**
         * 设置包围盒的范围。
         * @param value	包围盒的范围。
         */
        setExtent(value: Vector3): void;
        /**
         * 获取包围盒的范围。
         * @return	包围盒的范围。
         */
        getExtent(): Vector3;
        /**
         * 创建一个 <code>Bounds</code> 实例。
         * @param	min  min 最小坐标
         * @param	max  max 最大坐标。
         */
        constructor(min?: Vector3, max?: Vector3);
        _getBoundBox(): BoundBox;
        /**
         * @returns -1为不相交 不为0的时候返回值为相交体积
         */
        calculateBoundsintersection(bounds: Bounds): number;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: NativeBounds): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    class RTCameraNodeData implements ICameraNodeData {
        private _transform;
        get transform(): RTTransform3D;
        set transform(value: RTTransform3D);
        get farplane(): number;
        set farplane(value: number);
        get nearplane(): number;
        set nearplane(value: number);
        get fieldOfView(): number;
        set fieldOfView(value: number);
        get aspectRatio(): number;
        set aspectRatio(value: number);
        _nativeObj: any;
        constructor();
        setProjectionViewMatrix(value: Matrix4x4): void;
    }
    class RTSceneNodeData implements ISceneNodeData {
        get lightmapDirtyFlag(): number;
        set lightmapDirtyFlag(value: number);
        _nativeObj: any;
        constructor();
    }
    class RT3DRenderModuleFactory implements I3DRenderModuleFactory {
        createTransform(owner: Sprite3D): RTTransform3D;
        createBounds(min: Vector3, max: Vector3): NativeBounds;
        createVolumetricGI(): RTVolumetricGI;
        createReflectionProbe(): RTReflectionProb;
        createLightmapData(): RTLightmapData;
        createDirectLight(): RTDirectLight;
        createSpotLight(): RTSpotLight;
        createPointLight(): IPointLightData;
        createCameraModuleData(): RTCameraNodeData;
        createSceneModuleData(): RTSceneNodeData;
        createBaseRenderNode(): RTBaseRenderNode;
        createMeshRenderNode(): RTMeshRenderNode;
        createSkinRenderNode(): ISkinRenderNode;
        createSimpleSkinRenderNode(): ISimpleSkinRenderNode;
    }
    class RTBaseRenderNode implements IBaseRenderNode {
        renderelements: IRenderElement3D[];
        private _transform;
        get transform(): RTTransform3D;
        set transform(value: RTTransform3D);
        get distanceForSort(): number;
        set distanceForSort(value: number);
        get sortingFudge(): number;
        set sortingFudge(value: number);
        get castShadow(): boolean;
        set castShadow(value: boolean);
        get enable(): boolean;
        set enable(value: boolean);
        get renderbitFlag(): number;
        set renderbitFlag(value: number);
        get layer(): number;
        set layer(value: number);
        private _bounds;
        get bounds(): Bounds;
        set bounds(value: Bounds);
        private _baseGeometryBounds;
        get baseGeometryBounds(): Bounds;
        set baseGeometryBounds(value: Bounds);
        get boundsChange(): boolean;
        set boundsChange(value: boolean);
        get customCull(): boolean;
        set customCull(value: boolean);
        get customCullResoult(): boolean;
        set customCullResoult(value: boolean);
        get staticMask(): number;
        set staticMask(value: number);
        private _shaderData;
        get shaderData(): ShaderData;
        set shaderData(value: ShaderData);
        get lightmapIndex(): number;
        set lightmapIndex(value: number);
        private _lightmap;
        get lightmap(): RTLightmapData;
        set lightmap(value: RTLightmapData);
        private _probeReflection;
        get probeReflection(): RTReflectionProb;
        set probeReflection(value: RTReflectionProb);
        get probeReflectionUpdateMark(): number;
        set probeReflectionUpdateMark(value: number);
        get reflectionMode(): number;
        set reflectionMode(value: number);
        private _volumetricGI;
        get volumetricGI(): RTVolumetricGI;
        set volumetricGI(value: RTVolumetricGI);
        get lightProbUpdateMark(): number;
        set lightProbUpdateMark(value: number);
        private _irradientMode;
        get irradientMode(): IrradianceMode;
        set irradientMode(value: IrradianceMode);
        private _caculateBoundingBoxbindFun;
        private _renderUpdatePrebindFun;
        /**
         * 设置更新数据
         * @param call
         * @param fun
         */
        set_renderUpdatePreCall(call: any, fun: any): void;
        /**
         * 设置更新包围盒方法
         * @param call
         * @param fun
         */
        set_caculateBoundingBox(call: any, fun: any): void;
        _nativeObj: any;
        protected _getNativeObj(): void;
        constructor();
        get renderNodeType(): number;
        set renderNodeType(value: number);
        get receiveShadow(): boolean;
        set receiveShadow(value: boolean);
        _applyLightProb(): void;
        _applyReflection(): void;
        setRenderelements(value: IRenderElement3D[]): void;
        setLightmapScaleOffset(value: Vector4): void;
        setCommonUniformMap(value: string[]): void;
        setOneMaterial(index: number, mat: Material): void;
        destroy(): void;
    }
    class RTDirectLight implements IDirectLightData {
        get shadowNearPlane(): number;
        set shadowNearPlane(value: number);
        get shadowCascadesMode(): ShadowCascadesMode;
        set shadowCascadesMode(value: ShadowCascadesMode);
        private _transform;
        get transform(): RTTransform3D;
        set transform(value: RTTransform3D);
        get shadowResolution(): number;
        set shadowResolution(value: number);
        get shadowDistance(): number;
        set shadowDistance(value: number);
        get shadowMode(): ShadowMode;
        set shadowMode(value: ShadowMode);
        get shadowStrength(): number;
        set shadowStrength(value: number);
        get shadowDepthBias(): number;
        set shadowDepthBias(value: number);
        get shadowNormalBias(): number;
        set shadowNormalBias(value: number);
        get shadowTwoCascadeSplits(): number;
        set shadowTwoCascadeSplits(value: number);
        setShadowFourCascadeSplits(value: Vector3): void;
        setDirection(value: Vector3): void;
        _nativeObj: any;
        constructor();
    }
    class RTLightmapData implements ILightMapData {
        _nativeObj: any;
        constructor();
        get lightmapColor(): InternalTexture;
        set lightmapColor(value: InternalTexture);
        get lightmapDirection(): InternalTexture;
        set lightmapDirection(value: InternalTexture);
        destroy(): void;
    }
    class RTMeshRenderNode extends RTBaseRenderNode implements RTMeshRenderNode {
    }
    class RTPointLight implements IPointLightData {
        _nativeObj: any;
        private _transform;
        get transform(): RTTransform3D;
        set transform(value: RTTransform3D);
        get range(): number;
        set range(value: number);
        get shadowResolution(): number;
        set shadowResolution(value: number);
        get shadowDistance(): number;
        set shadowDistance(value: number);
        get shadowMode(): ShadowMode;
        set shadowMode(value: ShadowMode);
        get shadowStrength(): number;
        set shadowStrength(value: number);
        get shadowDepthBias(): number;
        set shadowDepthBias(value: number);
        get shadowNormalBias(): number;
        set shadowNormalBias(value: number);
        get shadowNearPlane(): number;
        set shadowNearPlane(value: number);
        constructor();
    }
    class RTReflectionProb implements IReflectionProbeData {
        private static _idCounter;
        get boxProjection(): boolean;
        set boxProjection(value: boolean);
        private _bound;
        get bound(): Bounds;
        set bound(value: Bounds);
        get ambientMode(): AmbientMode;
        set ambientMode(value: AmbientMode);
        get ambientIntensity(): number;
        set ambientIntensity(value: number);
        get reflectionIntensity(): number;
        set reflectionIntensity(value: number);
        private _reflectionTexture;
        get reflectionTexture(): InternalTexture;
        set reflectionTexture(value: InternalTexture);
        private _iblTex;
        get iblTex(): InternalTexture;
        set iblTex(value: InternalTexture);
        get updateMark(): number;
        set updateMark(value: number);
        get iblTexRGBD(): boolean;
        set iblTexRGBD(value: boolean);
        setProbePosition(value: Vector3): void;
        setAmbientColor(value: Color): void;
        setAmbientSH(value: Float32Array): void;
        _nativeObj: any;
        constructor();
        destroy(): void;
    }
    class RTScene3DRenderManager implements ISceneRenderManager {
        _nativeObj: any;
        /**
        * @en The list of render objects.
        * @zh 渲染对象列表。
        */
        get list(): SingletonList<BaseRender>;
        set list(value: SingletonList<BaseRender>);
        private _addBaseRenderNode;
        private _removeBaseRenderNode;
        private _clearBaseRenderNode;
        addRenderObject(object: BaseRender): void;
        removeRenderObject(object: BaseRender): void;
        removeMotionObject(object: BaseRender): void;
        addMotionObject(object: BaseRender): void;
        updateMotionObjects(): void;
        destroy(): void;
        constructor();
    }
    class RTSimpleSkinRenderNode extends RTBaseRenderNode implements ISimpleSkinRenderNode {
        private _nativeMemory;
        private _float32Array;
        setSimpleAnimatorParams(value: Vector4): void;
        protected _getNativeObj(): void;
        constructor();
    }
    /**
     * 骨骼动画渲染节点，包含骨骼数据计算
     */
    class RTSkinRenderNode extends RTBaseRenderNode implements ISkinRenderNode {
        private boneNums;
        protected _getNativeObj(): void;
        constructor();
        computeSkinnedData(): void;
        setRootBoneTransfom(value: Sprite3D): void;
        setOwnerTransform(value: Sprite3D): void;
        setCacheMesh(cacheMesh: Mesh): void;
        setBones(value: Sprite3D[]): void;
        setSkinnedData(value: Array<Float32Array[]>): void;
    }
    class RTSpotLight implements ISpotLightData {
        private _transform;
        get transform(): RTTransform3D;
        set transform(value: RTTransform3D);
        get shadowResolution(): number;
        set shadowResolution(value: number);
        get shadowDistance(): number;
        set shadowDistance(value: number);
        get shadowMode(): ShadowMode;
        set shadowMode(value: ShadowMode);
        get shadowStrength(): number;
        set shadowStrength(value: number);
        get shadowDepthBias(): number;
        set shadowDepthBias(value: number);
        get shadowNormalBias(): number;
        set shadowNormalBias(value: number);
        get shadowNearPlane(): number;
        set shadowNearPlane(value: number);
        get spotRange(): number;
        set spotRange(value: number);
        get spotAngle(): number;
        set spotAngle(value: number);
        _nativeObj: any;
        constructor();
        setDirection(value: Vector3): void;
    }
    class RTTransform3D extends Transform3D {
        /**native Share Memory */
        private _nativeMemory;
        private _nativeFloat32Buffer;
        private _nativeUInt32Buffer;
        _nativeObj: any;
        constructor(owner: Sprite3D);
        protected _initProperty(): void;
        /**
         * 是否未DefaultMatrix
         */
        get isDefaultMatrix(): boolean;
        protected _setRTSyncFlag(type: number, value: boolean): void;
        get _RTtransformFlag(): number;
        /**
         * 局部位置X轴分量。
         */
        get localPositionX(): number;
        set localPositionX(x: number);
        /**
         * 局部位置Y轴分量。
         */
        get localPositionY(): number;
        set localPositionY(y: number);
        /**
         * 局部位置Z轴分量。
         */
        get localPositionZ(): number;
        set localPositionZ(z: number);
        /**
         * 局部位置。
         */
        get localPosition(): Vector3;
        set localPosition(value: Vector3);
        /**
         * 局部旋转。
         */
        get localRotation(): Quaternion;
        set localRotation(value: Quaternion);
        /**
         * 局部缩放X。
         */
        get localScaleX(): number;
        set localScaleX(value: number);
        /**
         * 局部缩放Y。
         */
        get localScaleY(): number;
        set localScaleY(value: number);
        /**
         * 局部缩放Z。
         */
        get localScaleZ(): number;
        set localScaleZ(value: number);
        /**
         * 局部缩放。
         */
        get localScale(): Vector3;
        set localScale(value: Vector3);
        /**
         * 局部空间欧拉角。
         */
        get localRotationEuler(): Vector3;
        set localRotationEuler(value: Vector3);
        /**
         * 局部矩阵。
         */
        get localMatrix(): Matrix4x4;
        set localMatrix(value: Matrix4x4);
        /**
         * 世界位置。
         */
        get position(): Vector3;
        set position(value: Vector3);
        /**
         * 世界旋转。
         */
        get rotation(): Quaternion;
        set rotation(value: Quaternion);
        /**
         * 世界空间的旋转角度，顺序为x、y、z。
         */
        get rotationEuler(): Vector3;
        set rotationEuler(value: Vector3);
        /**
         * 世界矩阵。
         */
        get worldMatrix(): Matrix4x4;
        set worldMatrix(value: Matrix4x4);
        /**
         * 平移变换。
         * @param 	translation 移动距离。
         * @param 	isLocal 是否局部空间。
         */
        translate(translation: Vector3, isLocal?: boolean): void;
        /**
         * 旋转变换。
         * @param rotation 旋转幅度。
         * @param isLocal 是否局部空间。
         * @param isRadian 是否弧度制。
         */
        rotate(rotation: Vector3, isLocal?: boolean, isRadian?: boolean): void;
        getWorldLossyScale(): Vector3;
        setWorldLossyScale(value: Vector3): void;
    }
    class RTVolumetricGI implements IVolumetricGIData {
        private static _idCounter;
        _id: number;
        private _irradiance;
        get irradiance(): InternalTexture;
        set irradiance(value: InternalTexture);
        private _distance;
        get distance(): InternalTexture;
        set distance(value: InternalTexture);
        private _bound;
        get bound(): Bounds;
        set bound(value: Bounds);
        get intensity(): number;
        set intensity(value: number);
        get updateMark(): number;
        set updateMark(value: number);
        constructor();
        setParams(value: Vector4): void;
        setProbeCounts(value: Vector3): void;
        setProbeStep(value: Vector3): void;
    }
    /**
     * 共享内存分配,并且绑定Native共享Buffer
     */
    class CommonMemoryAllocater {
        /**
         * 创建内存，并绑定为共享内存
         * @param size
         * @returns
         */
        static creatBlock(size: number): ArrayBuffer;
        /**
         * 释放共享内存
         * @param buffer
         */
        static freeMemoryBlock(buffer: ArrayBuffer): void;
    }
    class NativeMemory {
        static NativeSourceID: number;
        protected _uidata: Uint32Array;
        protected _fdata: Float32Array;
        protected _f64data: Float64Array;
        protected _byteArray: Uint8Array;
        /**数据长度 */
        protected _byteLength: number;
        /**销毁标记 */
        protected _destroyed: boolean;
        /**数据资源 */
        protected _id: number;
        /**
         * 实例化一个共享内存
         * @param size byteLength
         */
        constructor(size: number, shared: boolean);
        /**
         * Float32Array Data
         */
        get float32Array(): Float32Array;
        get float64Array(): Float64Array;
        /**
         * Uint16Array Data
         */
        /**
         * Uint8Array Data
         */
        get uint8Array(): Uint8Array;
        /**
         * Int32Array Data
         */
        get int32Array(): Int32Array;
        get Uint32Array(): Uint32Array;
        /**
         * 设置数据
         * @param data 数据
         * @param stride 字节偏移
         * //TODO 字节对齐
         */
        /**
         * 设置多个参数
         * @param offset
         * @param args
         * 考虑字节对齐
         */
        /**
         * 扩充buffer
         * @param size
         * @returns
         */
        /**
         * 删除
         * @returns
         */
        destroy(): void;
        /**
         * 清楚
         */
        clear(): void;
    }
    class RTDefineDatas implements IDefineDatas {
        _nativeObj: any;
        constructor();
        get _length(): number;
        set _length(value: number);
        get _mask(): number[];
        set _mask(value: number[]);
        add(define: RTShaderDefine): void;
        remove(define: RTShaderDefine): void;
        addDefineDatas(define: RTDefineDatas): void;
        removeDefineDatas(define: RTDefineDatas): void;
        has(define: RTShaderDefine): boolean;
        clear(): void;
        cloneTo(destObject: RTDefineDatas): void;
        clone(): RTDefineDatas;
        destroy(): void;
    }
    class RTRenderState extends RenderState {
        _nativeObj: any;
        set cull(value: number);
        get cull(): number;
        set blend(value: number);
        get blend(): number;
        set srcBlend(value: number);
        get srcBlend(): number;
        set dstBlend(value: number);
        get dstBlend(): number;
        set srcBlendRGB(value: number);
        get srcBlendRGB(): number;
        set dstBlendRGB(value: number);
        get dstBlendRGB(): number;
        set srcBlendAlpha(value: number);
        get srcBlendAlpha(): number;
        set dstBlendAlpha(value: number);
        get dstBlendAlpha(): number;
        set blendEquation(value: number);
        get blendEquation(): number;
        set blendEquationRGB(value: number);
        get blendEquationRGB(): number;
        set blendEquationAlpha(value: number);
        get blendEquationAlpha(): number;
        set depthTest(value: number);
        get depthTest(): number;
        set depthWrite(value: boolean);
        get depthWrite(): boolean;
        set stencilWrite(value: boolean);
        get stencilWrite(): boolean;
        set stencilTest(value: number);
        get stencilTest(): number;
        set stencilRef(value: number);
        get stencilRef(): number;
        set stencilOp(value: Vector3);
        get stencilOp(): Vector3;
        setNull(): void;
        protected createObj(): void;
        constructor();
        cloneTo(dest: RTRenderState): void;
        clone(): RenderState;
    }
    class RTShaderDefine extends ShaderDefine {
        constructor(index: number, value: number);
    }
    class RTShaderPass implements IShaderPassData {
        private _validDefine;
        private _createShaderInstanceFun;
        _nativeObj: any;
        static _globalCompileDefine: RTDefineDatas;
        is2D: boolean;
        private _pass;
        constructor(pass: ShaderPass);
        private _nodeCommonMap;
        get nodeCommonMap(): string[];
        set nodeCommonMap(value: string[]);
        get statefirst(): boolean;
        set statefirst(value: boolean);
        private _renderState;
        get renderState(): RenderState;
        set renderState(value: RenderState);
        get pipelineMode(): string;
        set pipelineMode(value: string);
        get validDefine(): RTDefineDatas;
        set validDefine(value: RTDefineDatas);
        nativeCreateShaderInstance(): any;
        destroy(): void;
        setCacheShader(defines: IDefineDatas, shaderInstance: IShaderInstance): void;
        getCacheShader(defines: IDefineDatas): IShaderInstance;
    }
    class RTSubShader implements ISubshaderData {
        _nativeObj: any;
        constructor();
        get enableInstance(): boolean;
        set enableInstance(value: boolean);
        destroy(): void;
        addShaderPass(pass: RTShaderPass): void;
    }
    class RTUintRenderModuleDataFactory implements IUnitRenderModuleDataFactory {
        createSubShader(): RTSubShader;
        createShaderPass(pass: ShaderPass): RTShaderPass;
        createRenderState(): RTRenderState;
        createDefineDatas(): RTDefineDatas;
    }
    class Web3DRenderModuleFactory implements I3DRenderModuleFactory {
        createSimpleSkinRenderNode(): ISimpleSkinRenderNode;
        createTransform(owner: Sprite3D): Transform3D;
        createBounds(min: Vector3, max: Vector3): BoundsImpl;
        createVolumetricGI(): WebVolumetricGI;
        createReflectionProbe(): WebReflectionProbe;
        createLightmapData(): WebLightmap;
        createDirectLight(): WebDirectLight;
        createSpotLight(): WebSpotLight;
        createPointLight(): IPointLightData;
        createCameraModuleData(): WebCameraNodeData;
        createSceneModuleData(): WebSceneNodeData;
        createBaseRenderNode(): WebBaseRenderNode;
        createMeshRenderNode(): WebMeshRenderNode;
        createSkinRenderNode(): ISkinRenderNode;
    }
    class WebBaseRenderNode implements IBaseRenderNode {
        renderNodeType: number;
        boundsChange: boolean;
        distanceForSort: number;
        sortingFudge: number;
        castShadow: boolean;
        receiveShadow: boolean;
        enable: boolean;
        renderbitFlag: number;
        layer: number;
        customCull: boolean;
        customCullResoult: boolean;
        staticMask: number;
        lightmapIndex: number;
        lightmapDirtyFlag: number;
        probeReflectionUpdateMark: number;
        reflectionMode: number;
        lightProbUpdateMark: number;
        irradientMode: IrradianceMode;
        renderelements: IRenderElement3D[];
        lightmapScaleOffset: Vector4;
        lightmap: WebLightmap;
        probeReflection: WebReflectionProbe;
        volumetricGI: WebVolumetricGI;
        shaderData: ShaderData;
        baseGeometryBounds: Bounds;
        transform: Transform3D;
        _worldParams: Vector4;
        _commonUniformMap: string[];
        private _bounds;
        private _caculateBoundingBoxCall;
        private _caculateBoundingBoxFun;
        private _renderUpdatePreCall;
        private _renderUpdatePreFun;
        private _updateMark;
        _calculateBoundingBox(): void;
        /**
         * get bounds
         */
        get bounds(): Bounds;
        set bounds(value: Bounds);
        constructor();
        /**
         * 设置更新数据
         * @param call
         * @param fun
         */
        set_renderUpdatePreCall(call: any, fun: any): void;
        /**
         * 设置更新包围盒方法
         * @param call
         * @param fun
         */
        set_caculateBoundingBox(call: any, fun: any): void;
        /**
         * 视锥检测包围盒
         * @param boundFrustum
         * @returns
         */
        _needRender(boundFrustum: BoundFrustum): boolean;
        /**
        * apply lightProb
        * @returns
        */
        _applyLightProb(): void;
        /**
         * apply reflection
         * @returns
         */
        _applyReflection(): void;
        /**
         * destroy
         */
        destroy(): void;
    }
    class WebDirectLight implements IDirectLightData {
        shadowNearPlane: number;
        shadowCascadesMode: ShadowCascadesMode;
        transform: Transform3D;
        shadowResolution: number;
        shadowDistance: number;
        shadowMode: ShadowMode;
        shadowStrength: number;
        shadowDepthBias: number;
        shadowNormalBias: number;
        shadowTwoCascadeSplits: number;
        _shadowFourCascadeSplits: Vector3;
        _direction: Vector3;
        constructor();
        setShadowFourCascadeSplits(value: Vector3): void;
        setDirection(value: Vector3): void;
    }
    class WebLightmap implements ILightMapData {
    }
    class WebMeshRenderNode extends WebBaseRenderNode implements IMeshRenderNode {
        constructor();
    }
    class WebCameraNodeData implements ICameraNodeData {
        transform: Transform3D;
        farplane: number;
        nearplane: number;
        fieldOfView: number;
        aspectRatio: number;
        _projectViewMatrix: Matrix4x4;
        constructor();
        setProjectionViewMatrix(value: Matrix4x4): void;
    }
    class WebSceneNodeData implements ISceneNodeData {
        lightmapDirtyFlag: number;
    }
    class WebPointLight implements IPointLightData {
        transform: Transform3D;
        range: number;
        shadowResolution: number;
        shadowDistance: number;
        shadowMode: ShadowMode;
        shadowStrength: number;
        shadowDepthBias: number;
        shadowNormalBias: number;
        shadowNearPlane: number;
    }
    class WebReflectionProbe implements IReflectionProbeData {
        private static _idCounter;
    }
    /**
     * @en The `WebSceneRenderManager` class is used to manage the rendering nodes of a scene.
     * @zh `WebSceneRenderManager` 类用于管理场景的渲染节点。
     */
    class WebSceneRenderManager implements ISceneRenderManager {
        /** @ignore */
        constructor();
        /**
         * @en The base render list.
         * @zh 基础渲染节点列表。
         */
        baseRenderList: SingletonList<WebBaseRenderNode>;
        /**
         * @en The list of render objects.
         * @zh 渲染对象列表。
         */
        get list(): SingletonList<BaseRender>;
        set list(value: SingletonList<BaseRender>);
        /**
         * @en Adds a render object to the render list.
         * @param object The render object to add.
         * @zh 向渲染列表添加渲染对象。
         * @param object 要添加的渲染对象。
         */
        addRenderObject(object: BaseRender): void;
        /**
         * @en Removes a render object from the render list and the base render list.
         * @param object The render object to remove.
         * @zh 从渲染列表和基础渲染列表中移除渲染对象。
         * @param object 要移除的渲染对象。
         */
        removeRenderObject(object: BaseRender): void;
        /**
         * @en Removes a motion render object.
         * @param object The motion render object to remove.
         * @zh 移除运动渲染对象。
         * @param object  要移除的运动渲染对象。
         */
        removeMotionObject(object: BaseRender): void;
        /**
         * @en Updates all motion render objects.
         * @zh 更新所有运动渲染对象。
         */
        updateMotionObjects(): void;
        /**
         * @en Adds a motion render object.
         * @param object The motion render object to add.
         * @zh 向管理器添加运动渲染对象。
         * @param object 要添加的运动渲染对象。
         */
        addMotionObject(object: BaseRender): void;
        /**
         * @en Destroys the render objects and cleans up resources.
         * @zh 销毁渲染对象并清理资源。
         */
        destroy(): void;
    }
    class WebSimpleSkinRenderNode extends WebBaseRenderNode implements ISimpleSkinRenderNode {
        _simpleAnimatorParams: Vector4;
        constructor();
        setSimpleAnimatorParams(value: Vector4): void;
        _renderUpdate(context3D: IRenderContext3D): void;
    }
    class WebSkinRenderNode extends WebBaseRenderNode implements ISkinRenderNode {
        constructor();
        setRootBoneTransfom(value: Sprite3D): void;
        setOwnerTransform(value: Sprite3D): void;
        setCacheMesh(cacheMesh: Mesh): void;
        setBones(value: Sprite3D[]): void;
        setSkinnedData(value: any[]): void;
        /**
         * 计算动画数据
         */
        computeSkinnedData(): void;
        _renderUpdate(context3D: IRenderContext3D): void;
    }
    class WebSpotLight implements ISpotLightData {
        transform: Transform3D;
        shadowResolution: number;
        shadowDistance: number;
        shadowMode: ShadowMode;
        shadowStrength: number;
        shadowDepthBias: number;
        shadowNormalBias: number;
        shadowNearPlane: number;
        spotRange: number;
        spotAngle: number;
        _direction: Vector3;
        setDirection(value: Vector3): void;
        getWorldMatrix(out: Matrix4x4): Matrix4x4;
    }
    class WebVolumetricGI implements IVolumetricGIData {
        private static _idCounter;
        _id: number;
        private _probeCounts;
        private _probeStep;
        irradiance: InternalTexture;
        distance: InternalTexture;
        bound: Bounds;
        intensity: number;
        updateMark: number;
        constructor();
        setParams(value: Vector4): void;
        setProbeCounts(value: Vector3): void;
        setProbeStep(value: Vector3): void;
        applyRenderData(data: ShaderData): void;
    }
    /**
     * <code>DefineDatas</code> 类用于创建宏定义数据集合。
     */
    class WebDefineDatas implements IDefineDatas {
        /**
         * 创建一个 <code>DefineDatas</code> 实例。
         */
        constructor();
        /**
         * 添加宏定义值。
         * @param define 宏定义值。
         */
        add(define: ShaderDefine): void;
        /**
         * 移除宏定义。
         * @param define 宏定义。
         */
        remove(define: ShaderDefine): void;
        /**
         * 添加宏定义集合。
         * @param define 宏定义集合。
         */
        addDefineDatas(define: WebDefineDatas): void;
        /**
         * 移除宏定义集合。
         * @param define 宏定义集合。
         */
        removeDefineDatas(define: WebDefineDatas): void;
        /**
         * 是否有宏定义。
         * @param define 宏定义。
         */
        has(define: ShaderDefine): boolean;
        /**
         * 清空宏定义。
         */
        clear(): void;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: WebDefineDatas): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
        destroy(): void;
    }
    /**
     * 着色器数据类。
     */
    class WebGLShaderData extends ShaderData {
        get uniformBuffersMap(): Map<number, UniformBufferObject>;
        _releaseUBOData(): void;
        applyUBOData(): void;
        /**
         * 增加Shader宏定义。
         */
        addDefine(define: ShaderDefine): void;
        addDefines(define: WebDefineDatas): void;
        /**
         * 移除Shader宏定义。
         */
        removeDefine(define: ShaderDefine): void;
        /**
         * 是否包含Shader宏定义。
         */
        hasDefine(define: ShaderDefine): boolean;
        /**
         * 清空宏定义。
         */
        clearDefine(): void;
        /**
         * 获取布尔。
         * @param	index shader索引。
         * @return  布尔。
         */
        getBool(index: number): boolean;
        /**
         * 设置布尔。
         * @param	index shader索引。
         * @param	value 布尔。
         */
        setBool(index: number, value: boolean): void;
        /**
         * 获取整形。
         * @param	index shader索引。
         * @return  整形。
         */
        getInt(index: number): number;
        /**
         * 设置整型。
         * @param	index shader索引。
         * @param	value 整形。
         */
        setInt(index: number, value: number): void;
        /**
         * 获取浮点。
         * @param	index shader索引。
         * @return	浮点。
         */
        getNumber(index: number): number;
        /**
         * 设置浮点。
         * @param	index shader索引。
         * @param	value 浮点。
         */
        setNumber(index: number, value: number): void;
        /**
         * 获取Vector2向量。
         * @param	index shader索引。
         * @return Vector2向量。
         */
        getVector2(index: number): Vector2;
        /**
         * 设置Vector2向量。
         * @param	index shader索引。
         * @param	value Vector2向量。
         */
        setVector2(index: number, value: Vector2): void;
        /**
         * 获取Vector3向量。
         * @param	index shader索引。
         * @return Vector3向量。
         */
        getVector3(index: number): Vector3;
        /**
         * 设置Vector3向量。
         * @param	index shader索引。
         * @param	value Vector3向量。
         */
        setVector3(index: number, value: Vector3): void;
        /**
         * 获取颜色。
         * @param 	index shader索引。
         * @return  向量。
         */
        getVector(index: number): Vector4;
        /**
         * 设置向量。
         * @param	index shader索引。
         * @param	value 向量。
         */
        setVector(index: number, value: Vector4): void;
        /**
         * 获取颜色
         * @param index 索引
         * @returns 颜色
         */
        getColor(index: number): Color;
        /**
         * 设置颜色
         * @param index 索引
         * @param value 颜色值
         */
        setColor(index: number, value: Color): void;
        /**
         * 获取矩阵。
         * @param	index shader索引。
         * @return  矩阵。
         */
        getMatrix4x4(index: number): Matrix4x4;
        /**
         * 设置矩阵。
         * @param	index shader索引。
         * @param	value  矩阵。
         */
        setMatrix4x4(index: number, value: Matrix4x4): void;
        /**
         * 获取矩阵
         * @param index
         * @returns
         */
        getMatrix3x3(index: number): Matrix3x3;
        /**
         * 设置矩阵。
         */
        setMatrix3x3(index: number, value: Matrix3x3): void;
        /**
         * 获取Buffer。
         * @param	index shader索引。
         * @return
         */
        getBuffer(index: number): Float32Array;
        /**
         * 设置Buffer。
         * @param	index shader索引。
         * @param	value  buffer数据。
         */
        setBuffer(index: number, value: Float32Array): void;
        /**
         * 设置纹理。
         * @param	index shader索引。
         * @param	value 纹理。
         */
        setTexture(index: number, value: BaseTexture): void;
        _setInternalTexture(index: number, value: InternalTexture): void;
        /**
         * 获取纹理。
         * @param	index shader索引。
         * @return  纹理。
         */
        getTexture(index: number): BaseTexture;
        getSourceIndex(value: any): number;
        setUniformBuffer(index: number, value: UniformBufferObject): void;
        getUniformBuffer(index: number): UniformBufferObject;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: WebGLShaderData): void;
        getDefineData(): WebDefineDatas;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
        reset(): void;
        destroy(): void;
    }
    class WebShaderPass implements IShaderPassData {
        is2D: boolean;
        pipelineMode: string;
        statefirst: boolean;
        private _validDefine;
        private _renderState;
        get renderState(): RenderState;
        set renderState(value: RenderState);
        get validDefine(): WebDefineDatas;
        set validDefine(value: WebDefineDatas);
        constructor(pass: ShaderPass);
        nodeCommonMap: string[];
        setCacheShader(compileDefine: WebDefineDatas, shader: IShaderInstance): void;
        getCacheShader(compileDefine: WebDefineDatas): IShaderInstance;
        destroy(): void;
    }
    class WebSubShader implements ISubshaderData {
        enableInstance: boolean;
        destroy(): void;
        addShaderPass(pass: WebShaderPass): void;
    }
    class WebUnitRenderModuleDataFactory implements IUnitRenderModuleDataFactory {
        createSubShader(): WebSubShader;
        createShaderPass(pass: ShaderPass): IShaderPassData;
        createRenderState(): RenderState;
        createDefineDatas(): WebDefineDatas;
    }
    class WebGLRender2DProcess implements I2DRenderPassFactory {
        createRenderElement2D(): IRenderElement2D;
        createRenderContext2D(): IRenderContext2D;
    }
    class WebglRenderContext2D implements IRenderContext2D {
        static isCreateBlitScreenELement: boolean;
        static blitScreenElement: WebGLRenderelement2D;
        static blitContext: WebglRenderContext2D;
        private _clearColor;
        _destRT: WebGLInternalRT;
        invertY: boolean;
        pipelineMode: string;
        sceneData: WebGLShaderData;
        _globalConfigShaderData: WebDefineDatas;
        private _offscreenWidth;
        private _offscreenHeight;
        constructor();
        /**
         * 兼容ConchWebGL
         */
        private setBlitScreenElement;
        drawRenderElementList(list: FastSinglelist<WebGLRenderelement2D>): number;
        setOffscreenView(width: number, height: number): void;
        setRenderTarget(value: WebGLInternalRT, clear: boolean, clearColor: Color): void;
        drawRenderElementOne(node: WebGLRenderelement2D): void;
    }
    class WebGLRenderelement2D implements IRenderElement2D {
        renderStateIsBySprite: boolean;
        protected _shaderInstances: FastSinglelist<WebGLShaderInstance>;
        geometry: WebGLRenderGeometryElement;
        materialShaderData: WebGLShaderData;
        value2DShaderData: WebGLShaderData;
        subShader: SubShader;
        protected _compileShader(context: WebglRenderContext2D): void;
        _prepare(context: WebglRenderContext2D): void;
        _render(context: WebglRenderContext2D): void;
        renderByShaderInstance(shader: WebGLShaderInstance, context: WebglRenderContext2D): void;
        destroy(): void;
    }
    class InstanceRenderElementOBJ extends WebGLRenderElement3D {
        private _updateData;
        private _updateDataNum;
        drawCount: number;
        updateNums: number;
        /**
         * 增加UpdateBuffer
         * @param vb
         * @param length 每个instance属性的数据长度
         */
        addUpdateBuffer(vb: VertexBuffer3D, length: number): void;
        /**
         *
         * @param index index of Buffer3D
         * @param length length of array
         */
        getUpdateData(index: number, length: number): Float32Array;
        constructor();
        /**
         * draw geometry
         * @param shaderIns
         */
        drawGeometry(shaderIns: IShaderInstance): void;
        clear(): void;
    }
    class WebGL3DRenderPassFactory implements I3DRenderPassFactory {
        createInstanceBatch(): IInstanceRenderBatch;
        createSetRenderDataCMD(): WebGLSetRenderData;
        createSetShaderDefineCMD(): WebGLSetShaderDefine;
        createDrawNodeCMDData(): WebGLDrawNodeCMDData;
        createBlitQuadCMDData(): WebGLBlitQuadCMDData;
        createDrawElementCMDData(): WebGLDrawElementCMDData;
        createSetViewportCMD(): WebGLSetViewportCMD;
        createSetRenderTargetCMD(): WebGLSetRenderTargetCMD;
        createSceneRenderManager(): WebSceneRenderManager;
        createSkinRenderElement(): WebGLSkinRenderElement3D;
        createRenderContext3D(): WebGLRenderContext3D;
        createRenderElement3D(): WebGLRenderElement3D;
        createInstanceRenderElement3D(): WebGLInstanceRenderElement3D;
        createRender3DProcess(): WebGLRender3DProcess;
    }
    class WebGLDirectLightShadowRP {
        camera: WebCameraNodeData;
        destTarget: WebGLInternalRT;
        private _shadowCasterCommanBuffer;
        get shadowCasterCommanBuffer(): CommandBuffer[];
        set shadowCasterCommanBuffer(value: CommandBuffer[]);
        /**light */
        private _light;
        set light(value: WebDirectLight);
        get light(): WebDirectLight;
        constructor();
        /**
         * @param context
         */
        update(context: WebGLRenderContext3D): void;
        /**
         * @param context
         * @param list
         * @param count
         */
        render(context: WebGLRenderContext3D, list: WebBaseRenderNode[], count: number): void;
        destroy(): void;
        /**
         * set shaderData after Render shadow
         * @param scene
         * @param camera
         */
        private _applyRenderData;
        /**
         * apply shadowCast cmd array
         */
        private _applyCasterPassCommandBuffer;
        private getShadowBias;
    }
    class WebGLForwardAddClusterRP {
        /**enable */
        enableOpaque: boolean;
        enableCMD: boolean;
        enableTransparent: boolean;
        opaqueTexture: InternalRenderTarget;
        blitOpaqueBuffer: CommandBuffer;
        private _enableOpaqueTexture;
        get enableOpaqueTexture(): boolean;
        set enableOpaqueTexture(value: boolean);
        clearColor: Color;
        clearFlag: number;
        private _viewPort;
        setViewPort(value: Viewport): void;
        private _scissor;
        setScissor(value: Vector4): void;
        private opaqueList;
        private transparent;
        private _zBufferParams;
        private _defaultNormalDepthColor;
        constructor();
        setCameraCullInfo(value: Camera): void;
        setBeforeForwardCmds(value: CommandBuffer[]): void;
        setBeforeSkyboxCmds(value: CommandBuffer[]): void;
        setBeforeTransparentCmds(value: CommandBuffer[]): void;
        /**
         * 渲染主流程（TODO:其他两个pass合并MulTargetRT）
         * @param context
         * @param list
         */
        render(context: WebGLRenderContext3D, list: WebBaseRenderNode[], count: number): void;
        /**
         * 渲染深度Pass
         * @param context
         * @param list
         */
        private _renderDepthPass;
        /**
         * @param context
         * @private
         */
        private _transparentListRender;
        /**
         * 渲染非透明物体Pass
         * @param context
         * @param list
         */
        private _opaqueListRender;
        /**
         * 渲染法线深度Pass
         * @param context
         * @param list
         */
        private _renderDepthNormalPass;
        private opaqueTexturePass;
        private _mainPass;
        /**
         * @param cmds
         * @param context
         * @private
         */
        private _rendercmd;
        private _recoverRenderContext3D;
        destroy(): void;
    }
    class WebGLForwardAddRP {
        /**是否开启阴影 */
        shadowCastPass: boolean;
        /**directlight shadow */
        directLightShadowPass: WebGLDirectLightShadowRP;
        /**enable directlight */
        enableDirectLightShadow: boolean;
        /**spot shadow */
        spotLightShadowPass: WebGLSpotLightShadowRP;
        /**enable spot */
        enableSpotLightShadowPass: boolean;
        shadowParams: Vector4;
        enablePostProcess: boolean;
        /**main pass */
        renderpass: WebGLForwardAddClusterRP;
        finalize: CommandBuffer;
        constructor();
        setBeforeImageEffect(value: CommandBuffer[]): void;
        setAfterEventCmd(value: CommandBuffer[]): void;
        destroy(): void;
    }
    /**
     * 动态合批通用类（目前由WebGPU专用）
     */
    class WebGLInstanceRenderBatch {
        static MaxInstanceCount: number;
        private recoverList;
        private _batchOpaqueMarks;
        private _updateCountMark;
        constructor();
        getBatchMark(element: IRenderElement3D): any;
        batch(elements: SingletonList<IRenderElement3D>): void;
        clearRenderData(): void;
        recoverData(): void;
    }
    interface WebGLInstanceStateInfo {
        state: WebGLBufferState;
        worldInstanceVB?: WebGLVertexBuffer;
        lightmapScaleOffsetVB?: WebGLVertexBuffer;
        simpleAnimatorVB?: WebGLVertexBuffer;
    }
    class WebGLInstanceRenderElement3D extends WebGLRenderElement3D implements IInstanceRenderElement3D {
        /**
         * get Instance BufferState
         */
        private static _instanceBufferStateMap;
        static getInstanceBufferState(geometry: WebGLRenderGeometryElement, renderType: number, spriteDefine: WebDefineDatas): WebGLInstanceStateInfo;
        /**
         * max instance count
         */
        static MaxInstanceCount: number;
        static create(): WebGLInstanceRenderElement3D;
        static _instanceBufferCreate(length: number): Float32Array;
        instanceElementList: FastSinglelist<WebGLRenderElement3D>;
        private _vertexBuffers;
        private _updateData;
        private _updateDataNum;
        private _instanceStateInfo;
        drawCount: number;
        updateNums: number;
        constructor();
        addUpdateData(vb: WebGLVertexBuffer, elementLength: number, maxInstanceCount: number): Float32Array;
        protected _compileShader(context: WebGLRenderContext3D): void;
        private _updateInstanceData;
        /**
         * get correct geometry
         * @param geometry
         */
        setGeometry(geometry: WebGLRenderGeometryElement): void;
        /**
        * render RenderElement
        * context:GLESRenderContext3D
        */
        _render(context: WebGLRenderContext3D): void;
        /**
         * 清理单次渲染生成的数据
         */
        clearRenderData(): void;
        /**
         * 回收
         */
        recover(): void;
        destroy(): void;
    }
    class WebGLRender3DProcess implements IRender3DProcess {
        render3DManager: WebSceneRenderManager;
        private renderpass;
        initRenderpass(camera: Camera, context: WebGLRenderContext3D): void;
        renderDepth(camera: Camera): void;
        fowardRender(context: WebGLRenderContext3D, camera: Camera): void;
        renderFowarAddCameraPass(context: WebGLRenderContext3D, renderpass: WebGLForwardAddRP, list: WebBaseRenderNode[], count: number): void;
        /**
         * @param cmds
         * @param context
         * @private
         */
        private _rendercmd;
        /**
         * @param postprocessCMD
         * @param context
         * @private
         */
        private _renderPostProcess;
        destroy(): void;
    }
    class WebGLDrawNodeCMDData extends DrawNodeCMDData {
        type: RenderCMDType;
        protected _node: WebBaseRenderNode;
        protected _destShaderData: WebGLShaderData;
        protected _destSubShader: SubShader;
        protected _subMeshIndex: number;
        get node(): WebBaseRenderNode;
        set node(value: WebBaseRenderNode);
        get destShaderData(): WebGLShaderData;
        set destShaderData(value: WebGLShaderData);
        get destSubShader(): SubShader;
        set destSubShader(value: SubShader);
        get subMeshIndex(): number;
        set subMeshIndex(value: number);
        constructor();
        apply(context: WebGLRenderContext3D): void;
    }
    class WebGLBlitQuadCMDData extends BlitQuadCMDData {
        type: RenderCMDType;
        private _sourceTexelSize;
        protected _dest: WebGLInternalRT;
        protected _viewport: Viewport;
        protected _source: InternalTexture;
        protected _scissor: Vector4;
        protected _offsetScale: Vector4;
        protected _element: WebGLRenderElement3D;
        get dest(): WebGLInternalRT;
        set dest(value: WebGLInternalRT);
        get viewport(): Viewport;
        set viewport(value: Viewport);
        get scissor(): Vector4;
        set scissor(value: Vector4);
        get source(): InternalTexture;
        set source(value: InternalTexture);
        get offsetScale(): Vector4;
        set offsetScale(value: Vector4);
        get element(): WebGLRenderElement3D;
        set element(value: WebGLRenderElement3D);
        constructor();
        apply(context: WebGLRenderContext3D): void;
    }
    class WebGLDrawElementCMDData extends DrawElementCMDData {
        type: RenderCMDType;
        private _elemets;
        constructor();
        setRenderelements(value: WebGLRenderElement3D[]): void;
        apply(context: WebGLRenderContext3D): void;
    }
    class WebGLSetViewportCMD extends SetViewportCMD {
        type: RenderCMDType;
        protected _viewport: Viewport;
        protected _scissor: Vector4;
        get viewport(): Viewport;
        set viewport(value: Viewport);
        get scissor(): Vector4;
        set scissor(value: Vector4);
        constructor();
        apply(context: WebGLRenderContext3D): void;
    }
    class WebGLSetRenderTargetCMD extends SetRenderTargetCMD {
        type: RenderCMDType;
        protected _rt: InternalRenderTarget;
        protected _clearFlag: number;
        protected _clearColorValue: Color;
        protected _clearDepthValue: number;
        protected _clearStencilValue: number;
        get rt(): InternalRenderTarget;
        set rt(value: InternalRenderTarget);
        get clearFlag(): number;
        set clearFlag(value: number);
        get clearColorValue(): Color;
        set clearColorValue(value: Color);
        get clearDepthValue(): number;
        set clearDepthValue(value: number);
        get clearStencilValue(): number;
        set clearStencilValue(value: number);
        constructor();
        apply(context: WebGLRenderContext3D): void;
    }
    class WebGLSetRenderData extends SetRenderDataCMD {
        type: RenderCMDType;
        protected _dataType: ShaderDataType;
        protected _propertyID: number;
        protected _dest: WebGLShaderData;
        protected _value: ShaderDataItem;
        data_v4: Vector4;
        data_v3: Vector3;
        data_v2: Vector2;
        data_mat: Matrix4x4;
        data_number: number;
        data_texture: BaseTexture;
        data_Color: Color;
        data_Buffer: Float32Array;
        get dataType(): ShaderDataType;
        set dataType(value: ShaderDataType);
        get propertyID(): number;
        set propertyID(value: number);
        get dest(): WebGLShaderData;
        set dest(value: WebGLShaderData);
        get value(): ShaderDataItem;
        set value(value: ShaderDataItem);
        constructor();
        apply(context: WebGLRenderContext3D): void;
    }
    class WebGLSetShaderDefine extends SetShaderDefineCMD {
        type: RenderCMDType;
        protected _define: ShaderDefine;
        protected _dest: WebGLShaderData;
        protected _add: boolean;
        get define(): ShaderDefine;
        set define(value: ShaderDefine);
        get dest(): WebGLShaderData;
        set dest(value: WebGLShaderData);
        get add(): boolean;
        set add(value: boolean);
        constructor();
        apply(context: WebGLRenderContext3D): void;
    }
    class WebGLRenderContext3D implements IRenderContext3D {
        _globalConfigShaderData: WebDefineDatas;
        private _globalShaderData;
        private _cameraModuleData;
        get sceneData(): WebGLShaderData;
        set sceneData(value: WebGLShaderData);
        get cameraData(): WebGLShaderData;
        set cameraData(value: WebGLShaderData);
        get sceneModuleData(): WebSceneNodeData;
        set sceneModuleData(value: WebSceneNodeData);
        get cameraModuleData(): WebCameraNodeData;
        set cameraModuleData(value: WebCameraNodeData);
        get globalShaderData(): WebGLShaderData;
        set globalShaderData(value: WebGLShaderData);
        setRenderTarget(value: InternalRenderTarget, clearFlag: RenderClearFlag): void;
        setViewPort(value: Viewport): void;
        setScissor(value: Vector4): void;
        get sceneUpdataMask(): number;
        set sceneUpdataMask(value: number);
        get cameraUpdateMask(): number;
        set cameraUpdateMask(value: number);
        get pipelineMode(): PipelineMode;
        set pipelineMode(value: PipelineMode);
        get invertY(): boolean;
        set invertY(value: boolean);
        /**
         * <code>GLESRenderContext3D<code/>
         */
        constructor();
        runOneCMD(cmd: IRenderCMD): void;
        runCMDList(cmds: IRenderCMD[]): void;
        setClearData(clearFlag: number, color: Color, depth: number, stencil: number): number;
        drawRenderElementList(list: FastSinglelist<WebGLRenderElement3D>): number;
        drawRenderElementOne(node: WebGLRenderElement3D): number;
        drawRenderElementList_StatUse(list: FastSinglelist<WebGLRenderElement3D>): number;
        drawRenderElementOne_StatUse(node: WebGLRenderElement3D): number;
        private _bindRenderTarget;
        private _start;
    }
    class WebGLRenderElement3D implements IRenderElement3D {
        protected _shaderInstances: FastSinglelist<WebGLShaderInstance>;
        geometry: WebGLRenderGeometryElement;
        subShader: SubShader;
        materialId: number;
        canDynamicBatch: boolean;
        materialShaderData: WebGLShaderData;
        materialRenderQueue: number;
        renderShaderData: WebGLShaderData;
        transform: Transform3D;
        isRender: boolean;
        owner: WebBaseRenderNode;
        protected _invertFront: boolean;
        constructor();
        _addShaderInstance(shader: WebGLShaderInstance): void;
        _clearShaderInstance(): void;
        _preUpdatePre(context: WebGLRenderContext3D): void;
        protected _getInvertFront(): boolean;
        /**
         * render RenderElement
         * context:GLESRenderContext3D
         */
        _render(context: WebGLRenderContext3D): void;
        protected _compileShader(context: WebGLRenderContext3D): void;
        drawGeometry(shaderIns: WebGLShaderInstance): void;
        destroy(): void;
    }
    class WebGLSkinRenderElement3D extends WebGLRenderElement3D implements ISkinRenderElement3D {
        skinnedData: Float32Array[];
        constructor();
        /** 更新数据并且 */
        drawGeometry(shaderIns: WebGLShaderInstance): void;
    }
    class WebGLSpotLightShadowRP {
        destTarget: InternalRenderTarget;
        private _renderQueue;
        set light(value: WebSpotLight);
        get light(): WebSpotLight;
        constructor();
        /**
        * 更新阴影数据
        */
        update(context: WebGLRenderContext3D): void;
        /**
         * render
         * @param context
         * @param list
         */
        render(context: WebGLRenderContext3D, list: WebBaseRenderNode[], count: number): void;
        destroy(): void;
        /**
         * get shadow bias
         * @param shadowResolution
         * @param out
         */
        private _getShadowBias;
        private _setupShadowCasterShaderValues;
        /**
         * apply shadowCast cmd array
         */
        private _applyCasterPassCommandBuffer;
    }
    /**
     * 将继承修改为类似 WebGLRenderingContextBase, WebGLRenderingContextOverloads 多继承 ?
     */
    class GL2TextureContext extends GLTextureContext implements ITextureContext {
        protected _gl: WebGL2RenderingContext;
        constructor(engine: WebGLEngine);
        protected getTarget(dimension: TextureDimension): number;
        glTextureParam(format: TextureFormat, useSRGB: boolean): {
            internalFormat: number;
            format: number;
            type: number;
        };
        glRenderBufferParam(format: RenderTargetFormat, useSRGB: boolean): {
            internalFormat: number;
            attachment: number;
        };
        glRenderTextureParam(format: RenderTargetFormat, useSRGB: boolean): {
            internalFormat: number;
            format: number;
            type: number;
        };
        getGLtexMemory(tex: WebGLInternalTex, depth?: number): number;
        supportSRGB(format: TextureFormat | RenderTargetFormat, mipmap: boolean): boolean;
        setTextureImageData(texture: WebGLInternalTex, source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureSubImageData(texture: WebGLInternalTex, source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, x: number, y: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexturePixelsData(texture: WebGLInternalTex, source: ArrayBufferView, premultiplyAlpha: boolean, invertY: boolean): void;
        createTexture3DInternal(dimension: TextureDimension, width: number, height: number, depth: number, format: TextureFormat, generateMipmap: boolean, sRGB: boolean, premultipliedAlpha: boolean): InternalTexture;
        setTexture3DImageData(texture: WebGLInternalTex, sources: HTMLImageElement[] | HTMLCanvasElement[] | ImageBitmap[], depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DPixelsData(texture: WebGLInternalTex, source: ArrayBufferView, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DSubPixelsData(texture: WebGLInternalTex, source: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, zOffset: number, width: number, height: number, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureHDRData(texture: WebGLInternalTex, hdrInfo: HDRTextureInfo): void;
        setTextureKTXData(texture: WebGLInternalTex, ktxInfo: KTXTextureInfo): void;
        setCubeImageData(texture: WebGLInternalTex, sources: (HTMLImageElement | HTMLCanvasElement | ImageBitmap)[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubePixelsData(texture: WebGLInternalTex, source: ArrayBufferView[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubeKTXData(texture: WebGLInternalTex, ktxInfo: KTXTextureInfo): void;
        getCubeKTXRGBMData(texture: WebGLInternalTex, ktxInfo: KTXTextureInfo): void;
        setTextureCompareMode(texture: WebGLInternalTex, compareMode: TextureCompareMode): TextureCompareMode;
        createRenderbuffer(width: number, height: number, internalFormat: number, samples: number): WebGLRenderbuffer;
        protected createRenderTextureInternal(dimension: TextureDimension, width: number, height: number, format: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean): WebGLInternalTex;
        createRenderTargetInternal(width: number, height: number, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number): WebGLInternalRT;
        createRenderTargetCubeInternal(size: number, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number): WebGLInternalRT;
        createRenderTextureCubeInternal(dimension: TextureDimension, size: number, format: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean): WebGLInternalTex;
        bindRenderTarget(renderTarget: WebGLInternalRT, faceIndex?: number): void;
        unbindRenderTarget(renderTarget: WebGLInternalRT): void;
    }
    class GLTextureContext extends GLObject implements ITextureContext {
        protected _sRGB: any;
        protected _oesTextureHalfFloat: any;
        protected _compressdTextureS3tc_srgb: any;
        protected _compressedTextureEtc1: any;
        protected _compressedTextureS3tc: any;
        protected _compressedTextureETC: any;
        protected _compressedTextureASTC: any;
        protected _webgl_depth_texture: any;
        needBitmap: boolean;
        constructor(engine: WebGLEngine);
        createTexture3DInternal(dimension: TextureDimension, width: number, height: number, depth: number, format: TextureFormat, generateMipmap: boolean, sRGB: boolean, premultipliedAlpha: boolean): InternalTexture;
        setTexture3DImageData(texture: InternalTexture, source: HTMLImageElement[] | HTMLCanvasElement[] | ImageBitmap[], depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DPixelsData(texture: InternalTexture, source: ArrayBufferView, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DSubPixelsData(texture: InternalTexture, source: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, zOffset: number, width: number, height: number, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        _glParam: {
            internalFormat: number;
            format: number;
            type: number;
        };
        glTextureParam(format: TextureFormat, useSRGB: boolean): {
            internalFormat: number;
            format: number;
            type: number;
        };
        glRenderTextureParam(format: RenderTargetFormat, useSRGB: boolean): {
            internalFormat: number;
            format: number;
            type: number;
        };
        glRenderBufferParam(format: RenderTargetFormat, useSRGB: boolean): {
            internalFormat: number;
            attachment: number;
        };
        glRenderTargetAttachment(format: RenderTargetFormat): 36096 | 33306 | 36128 | 36064;
        protected getTarget(dimension: TextureDimension): number;
        getFormatPixelsParams(format: TextureFormat): {
            channels: number;
            bytesPerPixel: number;
            dataTypedCons: any;
            typedSize: number;
        };
        /**
         * caculate texture memory
         * @param tex
         * @returns
         */
        getGLtexMemory(tex: WebGLInternalTex, depth?: number): number;
        getGLRTTexMemory(width: number, height: number, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, multiSamples: number, cube: boolean): number;
        /**
         * 根据 format 判断是否支持 SRGBload
         * @param format
         * @returns
         */
        supportSRGB(format: TextureFormat | RenderTargetFormat, mipmap: boolean): boolean;
        supportGenerateMipmap(format: TextureFormat | RenderTargetFormat): boolean;
        /**
         * 判断 纹理格式 本身是否是 SRGB格式
         * @param format
         * @returns
         */
        isSRGBFormat(format: TextureFormat | RenderTargetFormat): boolean;
        createTextureInternal(dimension: TextureDimension, width: number, height: number, format: TextureFormat, generateMipmap: boolean, sRGB: boolean, premultipliedAlpha: boolean): InternalTexture;
        setTextureImageData(texture: WebGLInternalTex, source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureSubImageData(texture: WebGLInternalTex, source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, x: number, y: number, premultiplyAlpha: boolean, invertY: boolean): void;
        initVideoTextureData(texture: WebGLInternalTex): void;
        setTexturePixelsData(texture: WebGLInternalTex, source: ArrayBufferView, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureSubPixelsData(texture: WebGLInternalTex, source: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, width: number, height: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureDDSData(texture: WebGLInternalTex, ddsInfo: DDSTextureInfo): void;
        setTextureKTXData(texture: WebGLInternalTex, ktxInfo: KTXTextureInfo): void;
        setTextureHDRData(texture: WebGLInternalTex, hdrInfo: HDRTextureInfo): void;
        setCubeImageData(texture: WebGLInternalTex, sources: (HTMLImageElement | HTMLCanvasElement | ImageBitmap)[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubePixelsData(texture: WebGLInternalTex, source: ArrayBufferView[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubeSubPixelData(texture: WebGLInternalTex, source: ArrayBufferView[], mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, width: number, height: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setCubeDDSData(texture: WebGLInternalTex, ddsInfo: DDSTextureInfo): void;
        setCubeKTXData(texture: WebGLInternalTex, ktxInfo: KTXTextureInfo): void;
        setTextureCompareMode(texture: WebGLInternalTex, compareMode: TextureCompareMode): TextureCompareMode;
        currentActiveRT: WebGLInternalRT;
        bindRenderTarget(renderTarget: WebGLInternalRT, faceIndex?: number): void;
        bindoutScreenTarget(): void;
        unbindRenderTarget(renderTarget: WebGLInternalRT): void;
        createRenderTextureCubeInternal(dimension: TextureDimension, size: number, format: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean): WebGLInternalTex;
        createRenderTargetInternal(width: number, height: number, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number): WebGLInternalRT;
        createRenderTargetCubeInternal(size: number, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number): WebGLInternalRT;
        createRenderbuffer(width: number, height: number, internalFormat: number, samples: number): WebGLRenderbuffer;
        protected createRenderTextureInternal(dimension: TextureDimension, width: number, height: number, format: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean): WebGLInternalTex;
        createRenderTargetDepthTexture(renderTarget: WebGLInternalRT, dimension: TextureDimension, width: number, height: number): WebGLInternalTex;
        /**
         * @deprecated 请使用readRenderTargetPixelDataAsync函数代替
         * @param renderTarget
         * @param xOffset
         * @param yOffset
         * @param width
         * @param height
         * @param out
         * @returns
         */
        readRenderTargetPixelData(renderTarget: WebGLInternalRT, xOffset: number, yOffset: number, width: number, height: number, out: ArrayBufferView): ArrayBufferView;
        readRenderTargetPixelDataAsync(renderTarget: WebGLInternalRT, xOffset: number, yOffset: number, width: number, height: number, out: ArrayBufferView): Promise<ArrayBufferView>;
        updateVideoTexture(texture: WebGLInternalTex, video: HTMLVideoElement, premultiplyAlpha: boolean, invertY: boolean): void;
    }
    class WebGLBufferState implements IBufferState {
        static _curBindedBufferState: WebGLBufferState;
        _glVertexState: GLVertexState;
        _bindedIndexBuffer: WebGLIndexBuffer;
        _vertexBuffers: WebGLVertexBuffer[];
        constructor();
        private applyVertexBuffers;
        protected applyIndexBuffers(): void;
        applyState(vertexBuffers: WebGLVertexBuffer[], indexBuffer: WebGLIndexBuffer): void;
        /**
         * @private
         */
        bind(): void;
        /**
         * @private
         */
        unBind(): void;
        isBind(): boolean;
        destroy(): void;
    }
    class WebGLCommandUniformMap extends CommandUniformMap {
        _stateName: string;
        constructor(stateName: string);
        hasPtrID(propertyID: number): boolean;
        /**
         * 增加一个Uniform
         */
        addShaderBlockUniform(propertyID: number, blockname: string, blockProperty: UniformProperty[]): void;
    }
    /**
     * 封装Webgl
     */
    class WebGLEngine extends EventDispatcher implements IRenderEngine {
        static _lastFrameBuffer: WebGLInternalRT;
        static _lastFrameBuffer_WebGLOBJ: WebGLFramebuffer;
        _context: WebGLRenderingContext | WebGL2RenderingContext;
        private _lost;
        get lost(): boolean;
        private _config;
        private _isWebGL2;
        private _webglMode;
        _enableStatistics: boolean;
        private _GLBufferBindMap;
        private _curUBOPointer;
        private _GLUBOPointerMap;
        private _GLBindPointerUBOMap;
        private _lastViewport;
        private _lastScissor;
        private _scissorState;
        private _lastClearColor;
        private _lastClearDepth;
        private _globalWidth;
        private _globalHeight;
        private _GLParams;
        private _GLTextureContext;
        private _GLRenderDrawContext;
        _remapZ: boolean;
        _screenInvertY: boolean;
        _lodTextureSample: boolean;
        _breakTextureSample: boolean;
        _GLRenderState: GLRenderState;
        private _GLStatisticsInfo;
        static instance: WebGLEngine;
        constructor(config: WebGLConfig, webglMode?: WebGLMode);
        endFrame(): void;
        getInnerWidth(): any;
        getInnerHeight(): any;
        resizeOffScreen(width: number, height: number): void;
        addTexGammaDefine(key: number, value: ShaderDefine): void;
        /**
         * GL Context
         */
        get gl(): WebGLRenderingContext | WebGL2RenderingContext;
        get isWebGL2(): boolean;
        get webglConfig(): WebGLConfig;
        private _initStatisticsInfo;
        /**
         * create GL
         * @param canvas
         */
        initRenderEngine(canvas: any): void;
        webglContextLost(e: any): void;
        private _initBindBufferMap;
        _getbindBuffer(target: BufferTargetType): GLBuffer;
        _setbindBuffer(target: BufferTargetType, buffer: GLBuffer | null): void;
        getCapable(capatableType: RenderCapable): boolean;
        viewport(x: number, y: number, width: number, height: number): void;
        scissor(x: number, y: number, width: number, height: number): void;
        scissorTest(value: boolean): void;
        clearRenderTexture(clearFlag: RenderClearFlag, clearcolor?: Color, clearDepth?: number, clearStencilValue?: number): void;
        copySubFrameBuffertoTex(texture: WebGLInternalTex, level: number, xoffset: number, yoffset: number, x: number, y: number, width: number, height: number): void;
        colorMask(r: boolean, g: boolean, b: boolean, a: boolean): void;
        getParams(params: RenderParams): number;
        createBuffer(targetType: BufferTargetType, bufferUsageType: BufferUsage): GLBuffer;
        createShaderInstance(vs: string, ps: string, attributeMap: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        }): GLShaderInstance;
        createVertexState(): GLVertexState;
        getUBOPointer(name: string): number;
        getTextureContext(): ITextureContext;
        getDrawContext(): GLRenderDrawContext;
        getCreateRenderOBJContext(): IRenderEngineFactory;
        /**
       * 通过Shader属性名称获得唯一ID。
       * @param name Shader属性名称。
       * @return 唯一ID。
       */
        propertyNameToID(name: string): number;
        propertyIDToName(id: number): string;
        getNamesByDefineData(defineData: IDefineDatas, out: Array<string>): void;
        /**
        * 注册宏定义。
        * @param name
        */
        getDefineByName(name: string): ShaderDefine;
        unbindVertexState(): void;
    }
    class GLBuffer extends GLObject {
        _glBuffer: WebGLBuffer;
        _glTarget: number;
        _glUsage: number;
        _glTargetType: BufferTargetType;
        _glBufferUsageType: BufferUsage;
        _byteLength: number;
        constructor(engine: WebGLEngine, targetType: BufferTargetType, bufferUsageType: BufferUsage);
        private _getGLUsage;
        private _getGLTarget;
        private _memorychange;
        bindBuffer(): boolean;
        unbindBuffer(): void;
        orphanStorage(): void;
        setDataLength(srcData: number): void;
        setData(srcData: ArrayBuffer | ArrayBufferView, offset: number): void;
        setDataEx(srcData: ArrayBuffer | ArrayBufferView, offset: number, length: number): void;
        bindBufferBase(glPointer: number): void;
        bindBufferRange(glPointer: number, offset: number, byteCount: number): void;
        resizeBuffer(dataLength: number): void;
        destroy(): void;
    }
    class GlCapable {
        constructor(glEngine: WebGLEngine);
        private initCapable;
        private initExtension;
        getCapable(type: RenderCapable): boolean;
        getExtension(type: WebGLExtension): any;
    }
    enum WebGLExtension {
        OES_vertex_array_object = 0,
        ANGLE_instanced_arrays = 1,
        OES_texture_half_float = 2,
        OES_texture_half_float_linear = 3,
        OES_texture_float = 4,
        OES_element_index_uint = 5,
        OES_texture_float_linear = 6,
        EXT_color_buffer_half_float = 7,
        EXT_shader_texture_lod = 8,
        WEBGL_depth_texture = 9,
        EXT_sRGB = 10,
        EXT_color_buffer_float = 11,
        EXT_texture_filter_anisotropic = 12,
        WEBGL_compressed_texture_s3tc = 13,
        WEBGL_compressed_texture_s3tc_srgb = 14,
        WEBGL_compressed_texture_pvrtc = 15,
        WEBGL_compressed_texture_etc1 = 16,
        WEBGL_compressed_texture_etc = 17,
        WEBGL_compressed_texture_astc = 18,
        OES_standard_derivatives = 19
    }
    /**
     * WebGL mode.
     */
    enum WebGLMode {
        /** Auto, use WebGL2.0 if support, or will fallback to WebGL1.0. */
        Auto = 0,
        /** WebGL2.0. */
        WebGL2 = 1,
        /** WebGL1.0, */
        WebGL1 = 2
    }
    /**
     * WebglObject 基类
     */
    class GLObject {
        protected _engine: WebGLEngine;
        protected _gl: WebGLRenderingContext | WebGL2RenderingContext;
        protected _id: number;
        protected _destroyed: boolean;
        constructor(engine: WebGLEngine);
        get destroyed(): boolean;
        /**
         * destroy
         * @override
         * @returns
         */
        destroy(): void;
    }
    /**
     *
     */
    class GLParams {
        _engine: WebGLEngine;
        _gl: WebGLRenderingContext | WebGL2RenderingContext;
        _glParamsData: Map<RenderParams, number>;
        constructor(engine: WebGLEngine);
        private _initParams;
        getParams(params: RenderParams): number;
    }
    class GLRenderDrawContext extends GLObject {
        constructor(engine: WebGLEngine);
    }
    class GLRenderState {
        /**
         * intance glRenderState
         * @param engine
         */
        constructor(engine: WebGLEngine);
        /**
         * init
         */
        private _initState;
        /**
         * get gl blend factor
         * @param factor
         * @returns
         */
        _getBlendFactor(factor: BlendFactor): 0 | 1 | 768 | 769 | 774 | 775 | 770 | 771 | 772 | 773 | 776 | 32769 | 32770;
        /**
         * get gl blend operation
         * @param factor
         * @returns
         */
        _getBlendOperation(factor: BlendEquationSeparate): 32774 | 32778 | 32779;
        /**
         * get gl compare fun factor
         * @param compareFunction
         * @returns
         */
        _getGLCompareFunction(compareFunction: CompareFunction): number;
        /**
         * get gl stencil operation
         * @param compareFunction
         * @returns
         */
        _getGLStencilOperation(compareFunction: StencilOperation): number;
        /**
         * get gl frontface factor
         * @param cullmode
         * @returns
         */
        _getGLFrontfaceFactor(cullmode: CullMode): 2305 | 2304;
        /**
         * 模板写入开关
         * @param value
         */
        setStencilMask(value: boolean): void;
    }
    class GLShaderInstance extends GLObject {
        _engine: WebGLEngine;
        _gl: WebGLRenderingContext | WebGL2RenderingContext;
        constructor(engine: WebGLEngine, vs: string, ps: string, attributeMap: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        });
        private _create;
        private _legalUBObyteLength;
        getUniformMap(): ShaderVariable[];
        _uniform_sampler2DArray(one: any, texture: BaseTexture): number;
        _uniform_sampler3D(one: any, texture: BaseTexture): number;
        destroy(): void;
    }
    class GLVertexState extends GLObject {
        private _angleInstancedArrays;
        private _vaoExt;
        private _vao;
        _vertexDeclaration: {
            [key: number]: VertexStateContext;
        }[];
        _bindedIndexBuffer: WebGLIndexBuffer;
        _vertexBuffers: WebGLVertexBuffer[];
        constructor(engine: WebGLEngine);
        applyVertexBuffer(vertexBuffer: WebGLVertexBuffer[]): void;
        clearVAO(): void;
        applyIndexBuffer(indexBuffer: WebGLIndexBuffer | null): void;
    }
    class VertexArrayObject {
        constructor();
    }
    /**
     * init Webgl option
     */
    class WebGLConfig {
        stencil: boolean;
        alpha: boolean;
        depth: boolean;
        antialias: boolean;
        failIfMajorPerformanceCaveat: boolean;
        premultipliedAlpha: boolean;
        preserveDrawingBuffer: boolean;
        powerPreference: WebGLPowerPreference;
    }
    class WebGLIndexBuffer implements IIndexBuffer {
        _glBuffer: GLBuffer;
        indexType: IndexFormat;
        indexCount: number;
        constructor(targetType: BufferTargetType, bufferUsageType: BufferUsage);
        private _changeMemory;
        _setIndexDataLength(data: number): void;
        _setIndexData(data: Uint32Array | Uint16Array | Uint8Array, bufferOffset: number): void;
        destroy(): void;
    }
    class WebGLInternalRT extends GLObject implements InternalRenderTarget {
        _gl: WebGLRenderingContext | WebGL2RenderingContext;
        _framebuffer: WebGLFramebuffer;
        _depthbuffer: WebGLRenderbuffer;
        _msaaFramebuffer: WebGLFramebuffer;
        _msaaRenderbuffer: WebGLRenderbuffer;
        _isCube: boolean;
        _samples: number;
        _generateMipmap: boolean;
        _textures: InternalTexture[];
        _depthTexture: InternalTexture;
        colorFormat: RenderTargetFormat;
        depthStencilFormat: RenderTargetFormat;
        isSRGB: boolean;
        /**bytelength */
        _gpuMemory: number;
        get gpuMemory(): number;
        set gpuMemory(value: number);
        private _changeTexMemory;
        constructor(engine: WebGLEngine, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, isCube: boolean, generateMipmap: boolean, samples: number);
        dispose(): void;
    }
    class WebGLRenderDeviceFactory implements IRenderDeviceFactory {
        createShaderData(ownerResource?: Resource): ShaderData;
        createShaderInstance(shaderProcessInfo: ShaderProcessInfo, shaderPass: ShaderPass): IShaderInstance;
        createIndexBuffer(bufferUsageType: BufferUsage): IIndexBuffer;
        createVertexBuffer(bufferUsageType: BufferUsage): IVertexBuffer;
        createBufferState(): IBufferState;
        createRenderGeometryElement(mode: MeshTopology, drawType: DrawType): IRenderGeometryElement;
        private globalBlockMap;
        createGlobalUniformMap(blockName: string): WebGLCommandUniformMap;
        createEngine(config: Config, canvas: any): Promise<void>;
        /**@private test function*/
        private _replaceWebglcall;
    }
    class WebGLRenderEngineFactory implements IRenderEngineFactory {
        createUniformBufferObject(glPointer: number, name: string, bufferUsage: BufferUsage, byteLength: number, isSingle: boolean): UniformBufferObject;
        createEngine(config: any, canvas: any): Promise<void>;
        /**@private test function*/
        private _replaceWebglcall;
    }
    class WebGLRenderGeometryElement implements IRenderGeometryElement {
        private static _idCounter;
        /**
         * index format
         */
        get indexFormat(): IndexFormat;
        set indexFormat(value: IndexFormat);
        /**
         * Mesh Topology mode
         */
        get mode(): MeshTopology;
        set mode(value: MeshTopology);
        cloneTo(obj: WebGLRenderGeometryElement): void;
    }
    /**
     * <code>ShaderInstance</code> 类用于实现ShaderInstance。
     */
    class WebGLShaderInstance implements IShaderInstance {
        private _renderShaderInstance;
        /**
         * 创建一个 <code>ShaderInstance</code> 实例。
         */
        constructor();
        /**
         * get complete
         */
        get complete(): boolean;
        _create(shaderProcessInfo: ShaderProcessInfo, shaderPass: ShaderPass): void;
        private hasSpritePtrID;
        /**
         * @inheritDoc
         * @override
         */
        _disposeResource(): void;
        /**
         * apply shader programe
         * @returns
         */
        bind(): boolean;
        /**
         * upload uniform data
         * @param shaderUniform
         * @param shaderDatas
         * @param uploadUnTexture
         */
        uploadUniforms(shaderUniform: CommandEncoder, shaderDatas: WebGLShaderData, uploadUnTexture: boolean): void;
        /**
         * set blend depth stencil RenderState
         * @param shaderDatas
         */
        uploadRenderStateBlendDepth(shaderDatas: WebGLShaderData): void;
        /**
         * set blend depth stencil RenderState frome Shader
         * @param shaderDatas
         */
        uploadRenderStateBlendDepthByShader(shaderDatas: WebGLShaderData): void;
        /**
         * set blend depth stencil RenderState frome Material
         * @param shaderDatas
         */
        uploadRenderStateBlendDepthByMaterial(shaderDatas: ShaderData): void;
    }
    class WebGLVertexBuffer implements IVertexBuffer {
        _glBuffer: GLBuffer;
        private _vertexDeclaration;
        get vertexDeclaration(): VertexDeclaration;
        set vertexDeclaration(value: VertexDeclaration);
        instanceBuffer: boolean;
        constructor(targetType: BufferTargetType, bufferUsageType: BufferUsage);
        private _changeMemory;
        setDataLength(byteLength: number): void;
        setData(buffer: ArrayBuffer, bufferOffset: number, dataStartIndex: number, dataCount: number): void;
        /**
         * @private
         */
        bind(): boolean;
        unbind(): void;
        /**
         * 剥离内存块存储。
         */
        orphanStorage(): void;
        destroy(): void;
    }
    class WebGPURender2DProcess implements I2DRenderPassFactory {
        createRenderElement2D(): IRenderElement2D;
        createRenderContext2D(): IRenderContext2D;
    }
    /**
     * WebGPU渲染上下文（2D）
     */
    class WebGPURenderContext2D implements IRenderContext2D {
        device: GPUDevice;
        destRT: WebGPUInternalRT;
        invertY: boolean;
        pipelineMode: string;
        sceneData: WebGPUShaderData;
        cameraData: WebGPUShaderData;
        _globalConfigShaderData: WebDefineDatas;
        renderCommand: WebGPURenderCommandEncoder;
        pipelineCache: any[];
        private _offscreenWidth;
        private _offscreenHeight;
        private _needClearColor;
        private _needStart;
        private _viewport;
        private _clearColor;
        constructor();
        drawRenderElementList(list: FastSinglelist<WebGPURenderElement2D>): number;
        setOffscreenView(width: number, height: number): void;
        setRenderTarget(value: WebGPUInternalRT, clear: boolean, clearColor: Color): void;
        drawRenderElementOne(node: WebGPURenderElement2D): void;
        /**
         * 提交渲染命令
         */
        private _submit;
        /**
         * 设置屏幕渲染目标
         */
        private _setScreenRT;
        /**
         * 准备录制渲染命令
         */
        private _start;
    }
    class WebGPURenderElement2D implements IRenderElement2D, IRenderPipelineInfo {
        static _sceneShaderData: WebGPUShaderData;
        static _value2DShaderData: WebGPUShaderData;
        static _materialShaderData: WebGPUShaderData;
        static _compileDefine: WebDefineDatas;
        static _defineStrings: Array<string>;
        protected _sceneData: WebGPUShaderData;
        protected _cameraData: WebGPUShaderData;
        materialShaderData: WebGPUShaderData;
        value2DShaderData: WebGPUShaderData;
        subShader: SubShader;
        geometry: WebGPURenderGeometry;
        blendState: WebGPUBlendStateCache;
        depthStencilState: WebGPUDepthStencilStateCache;
        cullMode: CullMode;
        frontFace: FrontFace;
        protected _stateKey: string[];
        protected _pipeline: GPURenderPipeline[];
        protected _shaderInstances: WebGPUShaderInstance[];
        protected _passNum: number;
        protected _passName: string;
        protected _passIndex: number[];
        protected _shaderDataState: {
            [key: string]: number[];
        };
        protected _shaderDataObject: {
            [key: string]: number[];
        };
        bundleId: number;
        needClearBundle: boolean;
        static bundleIdCounter: number;
        isStatic: boolean;
        staticChange: boolean;
        globalId: number;
        objectName: string;
        constructor();
        renderStateIsBySprite: boolean;
        /**
         * 获取渲染通道的uniform
         * @param shaderpass
         * @param defineData
         */
        private _getShaderPassUniform;
        /**
         * 收集uniform
         * @param compileDefine
         */
        protected _collectUniform(compileDefine: WebDefineDatas): {
            uniformMap: WebGPUUniformMapType;
            arrayMap: NameNumberMap;
        };
        /**
         * 编译着色器
         * @param context
         */
        protected _compileShader(context: WebGPURenderContext2D): void;
        /**
         * 计算状态值
         * @param shaderInstance
         * @param dest
         * @param context
         */
        protected _calcStateKey(shaderInstance: WebGPUShaderInstance, dest: WebGPUInternalRT, context: WebGPURenderContext2D): string;
        /**
         * 获取渲染管线
         * @param shaderInstance
         * @param dest
         * @param context
         * @param entries
         * @param stateKey
         */
        protected _getWebGPURenderPipeline(shaderInstance: WebGPUShaderInstance, dest: WebGPUInternalRT, context: WebGPURenderContext2D, entries: any, stateKey?: string): GPURenderPipeline;
        /**
         * 获取混合状态
         * @param shaderInstance
         */
        private _getBlendState;
        private _getRenderStateBlendByShader;
        private _getRenderStateBlendByMaterial;
        /**
         * 获取深度缓存状态
         * @param shaderInstance
         * @param dest
         */
        private _getDepthStencilState;
        private _getRenderStateDepthByShader;
        private _getRenderStateDepthByMaterial;
        private _getCullFrontMode;
        /**
         * 着色器数据是否改变
         * @param context
         */
        protected _isShaderDataChange(context: WebGPURenderContext2D): boolean;
        /**
         * 创建绑定组布局
         * @param shaderInstance
         */
        protected _createBindGroupLayout(shaderInstance: WebGPUShaderInstance): any[];
        /**
         * 绑定资源组
         * @param shaderInstance
         * @param command
         */
        protected _bindGroup(shaderInstance: WebGPUShaderInstance, command: WebGPURenderCommandEncoder): void;
        /**
         * 上传uniform数据
         */
        protected _uploadUniform(): void;
        /**
         * 上传几何数据
         * @param command
         */
        protected _uploadGeometry(command: WebGPURenderCommandEncoder): number;
        /**
         * 用于创建渲染管线的函数
         * @param index
         * @param context
         * @param shaderInstance
         * @param command
         * @param stateKey
         */
        protected _createPipeline(index: number, context: WebGPURenderContext2D, shaderInstance: WebGPUShaderInstance, command: WebGPURenderCommandEncoder, stateKey?: string): GPURenderPipeline;
        /**
         * 提取当前渲染通道
         * @param pipelineMode
         */
        private _takeCurPass;
        /**
         * 准备渲染
         * @param context
         */
        prepare(context: WebGPURenderContext2D): boolean;
        /**
         * 渲染
         * @param context
         * @param command
         */
        render(context: WebGPURenderContext2D, command: WebGPURenderCommandEncoder): number;
        /**
         * 销毁
         */
        destroy(): void;
    }
    class WebGPU3DRenderPass implements IRender3DProcess {
        private _renderPass;
        globalId: number;
        objectName: string;
        constructor();
        render3DManager: WebSceneRenderManager;
        /**
         * 初始化渲染流程
         * @param camera
         * @param context
         */
        private _initRenderPass;
        /**
         * 渲染深度图设置
         * @param camera
         */
        private _renderDepth;
        /**
         * 前向渲染流程
         * @param context
         * @param renderPass
         * @param list
         * @param count
         */
        private _renderForwardAddCameraPass;
        /**
         * 渲染命令
         * @param cmds
         * @param context
         */
        private _renderCmd;
        /**
         * 渲染后处理效果
         * @param postprocessCMD
         * @param context
         */
        private _renderPostProcess;
        /**
         * 前向渲染
         * @param context
         * @param camera
         */
        fowardRender(context: WebGPURenderContext3D, camera: Camera): void;
        /**
         * 销毁
         */
        destroy(): void;
    }
    /**
     * WebGPU渲染工厂类
     */
    class WebGPU3DRenderPassFactory implements I3DRenderPassFactory {
        createInstanceBatch(): IInstanceRenderBatch;
        createRender3DProcess(): IRender3DProcess;
        createRenderContext3D(): IRenderContext3D;
        createRenderElement3D(): IRenderElement3D;
        createInstanceRenderElement3D(): WebGPUInstanceRenderElement3D;
        createSkinRenderElement(): ISkinRenderElement3D;
        createSceneRenderManager(): WebSceneRenderManager;
        createDrawNodeCMDData(): DrawNodeCMDData;
        createBlitQuadCMDData(): BlitQuadCMDData;
        createDrawElementCMDData(): DrawElementCMDData;
        createSetViewportCMD(): SetViewportCMD;
        createSetRenderTargetCMD(): SetRenderTargetCMD;
        createSetRenderDataCMD(): SetRenderDataCMD;
        createSetShaderDefineCMD(): SetShaderDefineCMD;
    }
    /**
     * WebGPU全局上下文
     */
    class WebGPUContext {
        static lastBundle: WebGPURenderBundle;
        static lastCommand: WebGPURenderCommandEncoder;
        static lastBundlePipeline: GPURenderPipeline;
        static lastCommandPipeline: GPURenderPipeline;
        static lastBundleGeometry: WebGPURenderGeometry;
        static lastCommandGeometry: WebGPURenderGeometry;
        /**
         * 开始渲染（清空历史数据）
         */
        static startRender(): void;
        /**
         * 清空上次打包数据
         */
        static clearLastBundle(): void;
        /**
         * 清空上次命令数据
         */
        static clearLastCommand(): void;
        /**
         * 设置打包管线
         * @param bundle
         * @param pipeline
         */
        static setBundlePipeline(bundle: WebGPURenderBundle, pipeline: GPURenderPipeline): void;
        /**
         * 设置命令管线
         * @param command
         * @param pipeline
         */
        static setCommandPipeline(command: WebGPURenderCommandEncoder, pipeline: GPURenderPipeline): void;
        /**
         * 设置打包几何数据
         * @param bundle
         * @param geometry
         */
        static applyBundleGeometry(bundle: WebGPURenderBundle, geometry: WebGPURenderGeometry): number;
        /**
         * 设置打包几何数据（部分）
         * @param bundle
         * @param geometry
         * @param part
         */
        static applyBundleGeometryPart(bundle: WebGPURenderBundle, geometry: WebGPURenderGeometry, part: number): number;
        /**
         * 设置命令几何数据
         * @param command
         * @param geometry
         */
        static applyCommandGeometry(command: WebGPURenderCommandEncoder, geometry: WebGPURenderGeometry): number;
        /**
         * 设置命令几何数据（部分）
         * @param command
         * @param geometry
         * @param part
         */
        static applyCommandGeometryPart(command: WebGPURenderCommandEncoder, geometry: WebGPURenderGeometry, part: number): number;
    }
    /**
     * 线性光源阴影渲染流程
     */
    class WebGPUDirectLightShadowRP {
        camera: WebCameraNodeData;
        destTarget: InternalRenderTarget;
        private _shadowCasterCommanBuffer;
        get shadowCasterCommanBuffer(): CommandBuffer[];
        set shadowCasterCommanBuffer(value: CommandBuffer[]);
        set light(value: WebDirectLight);
        get light(): WebDirectLight;
        constructor();
        /**
         * 更新
         * @param context
         */
        update(context: WebGPURenderContext3D): void;
        /**
         * 渲染
         * @param context
         * @param list
         * @param count
         */
        render(context: WebGPURenderContext3D, list: WebBaseRenderNode[], count: number): void;
        /**
         * 设置渲染数据
         * @param sceneData
         * @param cameraData
         */
        private _applyRenderData;
        /**
         * 应用阴影渲染命令
         * @param context
         */
        private _applyCasterPassCommandBuffer;
        /**
         * 获取阴影偏移
         * @param shadowProjectionMatrix
         * @param shadowResolution
         * @param out
         */
        private _getShadowBias;
        /**
         * 设置阴影级联数据模式
         * @param shaderData
         * @param shadowSliceData
         * @param lightParam
         * @param shadowBias
         */
        private _setupShadowCasterShaderValues;
    }
    /**
     * WebGPU前向渲染流程
     */
    class WebGPUForwardAddClusterRP extends ForwardAddClusterRP {
        /**
         * 主渲染流程
         * @param context
         */
        protected _mainPass(context: IRenderContext3D): void;
    }
    class WebGPUForwardAddRP {
        /**是否开启阴影 */
        shadowCastPass: boolean;
        enablePostProcess: boolean;
        /**main pass */
        renderPass: WebGPUForwardAddClusterRP;
        /**directlight shadow */
        directLightShadowPass: WebGPUDirectLightShadowRP;
        /**enable directlight */
        enableDirectLightShadow: boolean;
        /**spot shadow */
        spotLightShadowPass: WebGPUSpotLightShadowRP;
        /**enable spot */
        enableSpotLightShadowPass: boolean;
        shadowParams: Vector4;
        finalize: CommandBuffer;
        constructor();
        /**
         * 设置后处理之前绘制的渲染命令
         */
        setBeforeImageEffect(value: CommandBuffer[]): void;
        /**
         * 设置所有渲染都结束后绘制的渲染命令
         */
        setAfterEventCmd(value: CommandBuffer[]): void;
    }
    /**
     * 动态合批
     */
    class WebGPUInstanceRenderBatch implements IInstanceRenderBatch {
        static MaxInstanceCount: number;
        private recoverList;
        private _batchOpaqueMarks;
        private _updateCountMark;
        constructor();
        getBatchMark(element: IRenderElement3D): any;
        batch(elements: SingletonList<IRenderElement3D>): void;
        clearRenderData(): void;
        recoverData(): void;
    }
    interface WebGPUInstanceStateInfo {
        state: WebGPUBufferState;
        worldInstanceVB?: WebGPUVertexBuffer;
        simpleAnimatorVB?: WebGPUVertexBuffer;
        lightmapScaleOffsetVB?: WebGPUVertexBuffer;
    }
    class WebGPUInstanceRenderElement3D extends WebGPURenderElement3D implements IInstanceRenderElement3D {
        static getInstanceBufferState(stateinfo: WebGPUInstanceStateInfo, geometry: WebGPURenderGeometry, renderType: number, spriteDefine: WebDefineDatas): WebGPUInstanceStateInfo;
        static MaxInstanceCount: number;
        private static _pool;
        static create(): WebGPUInstanceRenderElement3D;
        private static _bufferPool;
        static _instanceBufferCreate(length: number): Float32Array;
        instanceElementList: SingletonList<IRenderElement3D>;
        private _vertexBuffers;
        private _updateData;
        private _updateDataNum;
        private _instanceStateInfo;
        drawCount: number;
        updateNums: number;
        constructor();
        addUpdateBuffer(vb: WebGPUVertexBuffer, length: number): void;
        getUpdateData(index: number, length: number): Float32Array;
        /**
         * 计算状态值
         * @param shaderInstance
         * @param dest
         * @param context
         */
        protected _calcStateKey(shaderInstance: WebGPUShaderInstance, dest: WebGPUInternalRT, context: WebGPURenderContext3D): string;
        /**
         * 着色器数据是否改变
         * @param context
         */
        protected _isShaderDataChange(context: WebGPURenderContext3D): boolean;
        protected _compileShader(context: WebGPURenderContext3D): void;
        /**
         * 创建绑定组布局
         * @param shaderInstance
         */
        protected _createBindGroupLayout(shaderInstance: WebGPUShaderInstance): any[];
        /**
         * 绑定资源组
         * @param shaderInstance
         * @param command
         * @param bundle
         */
        protected _bindGroup(shaderInstance: WebGPUShaderInstance, command: WebGPURenderCommandEncoder, bundle: WebGPURenderBundle): void;
        /**
         * 上传uniform数据
         */
        protected _uploadUniform(): void;
        private _updateInstanceData;
        /**
         * 设置几何对象
         * @param geometry
         */
        setGeometry(geometry: WebGPURenderGeometry): void;
        /**
         * 上传几何数据
         * @param command
         * @param bundle
         */
        protected _uploadGeometry(command: WebGPURenderCommandEncoder, bundle: WebGPURenderBundle): number;
        /**
         * 清理单次渲染生成的数据
         */
        clearRenderData(): void;
        /**
         * 回收
         */
        recover(): void;
    }
    class WebGPUBlitQuadCMDData extends BlitQuadCMDData {
        type: RenderCMDType;
        private _sourceTexelSize;
        protected _dest: WebGPUInternalRT;
        protected _viewport: Viewport;
        protected _source: InternalTexture;
        protected _scissor: Vector4;
        protected _offsetScale: Vector4;
        protected _element: WebGPURenderElement3D;
        get dest(): WebGPUInternalRT;
        set dest(value: WebGPUInternalRT);
        get viewport(): Viewport;
        set viewport(value: Viewport);
        get scissor(): Vector4;
        set scissor(value: Vector4);
        get source(): InternalTexture;
        set source(value: InternalTexture);
        get offsetScale(): Vector4;
        set offsetScale(value: Vector4);
        get element(): WebGPURenderElement3D;
        set element(value: WebGPURenderElement3D);
        constructor();
        apply(context: WebGPURenderContext3D): void;
    }
    class WebGPUDrawElementCMDData extends DrawElementCMDData {
        type: RenderCMDType;
        private _elemets;
        constructor();
        setRenderelements(value: WebGPURenderElement3D[]): void;
        apply(context: WebGPURenderContext3D): void;
    }
    class WebGPUDrawNodeCMDData extends DrawNodeCMDData {
        type: RenderCMDType;
        protected _node: WebBaseRenderNode;
        protected _destShaderData: WebGPUShaderData;
        protected _destSubShader: SubShader;
        protected _subMeshIndex: number;
        get node(): WebBaseRenderNode;
        set node(value: WebBaseRenderNode);
        get destShaderData(): WebGPUShaderData;
        set destShaderData(value: WebGPUShaderData);
        get destSubShader(): SubShader;
        set destSubShader(value: SubShader);
        get subMeshIndex(): number;
        set subMeshIndex(value: number);
        constructor();
        apply(context: WebGPURenderContext3D): void;
    }
    class WebGPUSetRenderData extends SetRenderDataCMD {
        type: RenderCMDType;
        protected _dataType: ShaderDataType;
        protected _propertyID: number;
        protected _dest: WebGPUShaderData;
        protected _value: ShaderDataItem;
        data_v2: Vector2;
        data_v3: Vector3;
        data_v4: Vector4;
        data_mat3: Matrix3x3;
        data_mat4: Matrix4x4;
        data_color: Color;
        data_number: number;
        data_texture: BaseTexture;
        data_buffer: Float32Array;
        get dataType(): ShaderDataType;
        set dataType(value: ShaderDataType);
        get propertyID(): number;
        set propertyID(value: number);
        get dest(): WebGPUShaderData;
        set dest(value: WebGPUShaderData);
        get value(): ShaderDataItem;
        set value(value: ShaderDataItem);
        constructor();
        apply(context: WebGPURenderContext3D): void;
    }
    class WebGPUSetRenderTargetCMD extends SetRenderTargetCMD {
        type: RenderCMDType;
        protected _rt: WebGPUInternalRT;
        protected _clearFlag: number;
        protected _clearColorValue: Color;
        protected _clearDepthValue: number;
        protected _clearStencilValue: number;
        get rt(): WebGPUInternalRT;
        set rt(value: WebGPUInternalRT);
        get clearFlag(): number;
        set clearFlag(value: number);
        get clearColorValue(): Color;
        set clearColorValue(value: Color);
        get clearDepthValue(): number;
        set clearDepthValue(value: number);
        get clearStencilValue(): number;
        set clearStencilValue(value: number);
        constructor();
        apply(context: WebGPURenderContext3D): void;
    }
    class WebGPUSetShaderDefine extends SetShaderDefineCMD {
        type: RenderCMDType;
        protected _define: ShaderDefine;
        protected _dest: WebGPUShaderData;
        protected _add: boolean;
        get define(): ShaderDefine;
        set define(value: ShaderDefine);
        get dest(): WebGPUShaderData;
        set dest(value: WebGPUShaderData);
        get add(): boolean;
        set add(value: boolean);
        constructor();
        apply(context: WebGPURenderContext3D): void;
    }
    class WebGPUSetViewportCMD extends SetViewportCMD {
        type: RenderCMDType;
        protected _viewport: Viewport;
        protected _scissor: Vector4;
        get viewport(): Viewport;
        set viewport(value: Viewport);
        get scissor(): Vector4;
        set scissor(value: Vector4);
        constructor();
        apply(context: WebGPURenderContext3D): void;
    }
    /**
     * WebGPU渲染上下文
     */
    class WebGPURenderContext3D implements IRenderContext3D {
        globalConfigShaderData: WebDefineDatas;
        device: GPUDevice;
        frameCount: number;
        bundleHit: number;
        needRemoveBundle: number[];
        bundleManagerSets: Map<string, WebGPURenderBundleManagerSet>;
        destRT: WebGPUInternalRT;
        blitFrameCount: number;
        blitScreen: boolean;
        renderCommand: WebGPURenderCommandEncoder;
        pipelineCache: any[];
        private _viewScissorSaved;
        private _viewPortSave;
        private _scissorSave;
        globalId: number;
        objectName: string;
        constructor();
        get sceneData(): WebGPUShaderData;
        set sceneData(value: WebGPUShaderData);
        get cameraData(): WebGPUShaderData;
        set cameraData(value: WebGPUShaderData);
        get sceneModuleData(): WebSceneNodeData;
        set sceneModuleData(value: WebSceneNodeData);
        get cameraModuleData(): WebCameraNodeData;
        set cameraModuleData(value: WebCameraNodeData);
        get globalShaderData(): WebGPUShaderData;
        set globalShaderData(value: WebGPUShaderData);
        get sceneUpdataMask(): number;
        set sceneUpdataMask(value: number);
        get cameraUpdateMask(): number;
        set cameraUpdateMask(value: number);
        get pipelineMode(): PipelineMode;
        set pipelineMode(value: PipelineMode);
        get invertY(): boolean;
        set invertY(value: boolean);
        /**
         * 设置渲染目标
         * @param rt
         * @param clearFlag
         */
        setRenderTarget(rt: WebGPUInternalRT, clearFlag: RenderClearFlag): void;
        /**
         * 设置视口
         * @param value
         */
        setViewPort(value: Viewport): void;
        /**
         * 设置裁剪
         * @param value
         */
        setScissor(value: Vector4): void;
        /**
         * 保存视口
         */
        saveViewPortAndScissor(): void;
        /**
         * 恢复视口
         */
        restoreViewPortAndScissor(): void;
        /**
         * 设置清除参数
         * @param flag
         * @param color
         * @param depth
         * @param stencil
         */
        setClearData(flag: number, color: Color, depth: number, stencil: number): number;
        /**
         * 得到GPUBuffer改变的通知
         */
        notifyGPUBufferChange(): void;
        /**
         * 获取指令缓存组的key
         */
        getBundleManagerKey(): string;
        /**
         * 渲染一组节点
         * @param list
         */
        drawRenderElementList(list: FastSinglelist<WebGPURenderElement3D>): number;
        /**
         * 渲染一个节点
         * @param node
         */
        drawRenderElementOne(node: WebGPURenderElement3D): number;
        /**
         * 执行命令列表
         * @param cmds
         */
        runCMDList(cmds: IRenderCMD[]): void;
        /**
         * 执行单个命令
         * @param cmd
         */
        runOneCMD(cmd: IRenderCMD): void;
        /**
         * 清除渲染目标（空白绘制，用于清除颜色或深度缓存）
         */
        clearRenderTarget(): void;
        /**
         * 设置屏幕渲染目标
         */
        private _setScreenRT;
        /**
         * 准备录制渲染命令
         * @param viewPortAndScissor
         */
        private _start;
        /**
         * 提交渲染命令
         */
        private _submit;
        /**
         * 销毁
         */
        destroy(): void;
    }
    /**
     * 基本渲染单元
     */
    class WebGPURenderElement3D implements IRenderElement3D, IRenderPipelineInfo {
        static _renderShaderData: WebGPUShaderData;
        static _compileDefine: WebDefineDatas;
        static _defineStrings: Array<string>;
        protected _sceneData: WebGPUShaderData;
        protected _cameraData: WebGPUShaderData;
        renderShaderData: WebGPUShaderData;
        materialShaderData: WebGPUShaderData;
        materialRenderQueue: number;
        materialId: number;
        transform: Transform3D;
        canDynamicBatch: boolean;
        isRender: boolean;
        owner: WebBaseRenderNode;
        subShader: SubShader;
        geometry: WebGPURenderGeometry;
        blendState: WebGPUBlendStateCache;
        depthStencilState: WebGPUDepthStencilStateCache;
        cullMode: CullMode;
        frontFace: FrontFace;
        protected _invertFrontFace: boolean;
        protected _stencilParam: {
            [key: string]: any;
        };
        protected _stateKey: string[];
        protected _pipeline: GPURenderPipeline[];
        protected _shaderInstances: WebGPUShaderInstance[];
        protected _passNum: number;
        protected _passName: string;
        protected _passIndex: number[];
        protected _shaderDataState: {
            [key: string]: number[];
        };
        bundleId: number;
        needClearBundle: boolean;
        static bundleIdCounter: number;
        isStatic: boolean;
        staticChange: boolean;
        globalId: number;
        objectName: string;
        constructor();
        /**
         * 是否反转面片
         */
        protected _getInvertFront(): boolean;
        /**
         * 获取渲染通道的uniform
         * @param shaderpass
         * @param defineData
         */
        private _getShaderPassUniform;
        /**
         * 收集uniform
         * @param compileDefine
         */
        protected _collectUniform(compileDefine: WebDefineDatas): {
            uniformMap: WebGPUUniformMapType;
            arrayMap: NameNumberMap;
        };
        /**
         * 提取当前渲染通道
         * @param pipelineMode
         */
        private _takeCurPass;
        /**
         * 渲染前更新
         * @param context
         */
        _preUpdatePre(context: WebGPURenderContext3D): boolean;
        /**
         * 编译着色器
         * @param context
         */
        protected _compileShader(context: WebGPURenderContext3D): void;
        /**
         * 计算状态值
         * @param shaderInstance
         * @param dest
         * @param context
         */
        protected _calcStateKey(shaderInstance: WebGPUShaderInstance, dest: WebGPUInternalRT, context: WebGPURenderContext3D): string;
        /**
         * 获取渲染管线
         * @param shaderInstance
         * @param dest
         * @param context
         * @param entries
         * @param stateKey
         */
        protected _getWebGPURenderPipeline(shaderInstance: WebGPUShaderInstance, dest: WebGPUInternalRT, context: WebGPURenderContext3D, entries: any, stateKey?: string): GPURenderPipeline;
        /**
         * 获取混合状态
         * @param shaderInstance
         */
        private _getBlendState;
        private _getRenderStateBlendByShader;
        private _getRenderStateBlendByMaterial;
        /**
         * 获取深度缓存状态
         * @param shaderInstance
         * @param dest
         */
        private _getDepthStencilState;
        private _getRenderStateDepthByShader;
        private _getRenderStateDepthByMaterial;
        private _getCullFrontMode;
        /**
         * 着色器数据是否改变
         * @param context
         */
        protected _isShaderDataChange(context: WebGPURenderContext3D): boolean;
        /**
         * 创建绑定组布局
         * @param shaderInstance
         */
        protected _createBindGroupLayout(shaderInstance: WebGPUShaderInstance): any[];
        /**
         * 绑定资源组
         * @param shaderInstance
         * @param command
         * @param bundle
         */
        protected _bindGroup(shaderInstance: WebGPUShaderInstance, command: WebGPURenderCommandEncoder, bundle: WebGPURenderBundle): void;
        /**
         * 上传uniform数据
         */
        protected _uploadUniform(): void;
        /**
         * 上传模板参考值
         * @param command
         */
        protected _uploadStencilReference(command: WebGPURenderCommandEncoder): void;
        /**
         * 上传几何数据
         * @param command
         * @param bundle
         */
        protected _uploadGeometry(command: WebGPURenderCommandEncoder, bundle: WebGPURenderBundle): number;
        /**
         * 用于创建渲染管线的函数
         * @param index
         * @param context
         * @param shaderInstance
         * @param command
         * @param bundle
         * @param stateKey
         */
        protected _createPipeline(index: number, context: WebGPURenderContext3D, shaderInstance: WebGPUShaderInstance, command: WebGPURenderCommandEncoder, bundle: WebGPURenderBundle, stateKey?: string): GPURenderPipeline;
        /**
         * 转换数据格式
         */
        protected _changeDataFormat(): void;
        /**
         * 渲染
         * @param context
         * @param command
         * @param bundle
         */
        _render(context: WebGPURenderContext3D, command: WebGPURenderCommandEncoder, bundle: WebGPURenderBundle): number;
        /**
         * 销毁
         */
        destroy(): void;
    }
    /**
     * 带骨骼的基本渲染单元
     */
    class WebGPUSkinRenderElement3D extends WebGPURenderElement3D implements ISkinRenderElement3D {
        skinnedData: Float32Array[];
        renderShaderDatas: WebGPUShaderData[];
        globalId: number;
        objectName: string;
        constructor();
        /**
         * 编译着色器
         * @param context
         */
        protected _compileShader(context: WebGPURenderContext3D): void;
        /**
         * 销毁renderShaderDatas数据
         */
        private _destroyRenderShaderDatas;
        /**
         * 绑定资源组
         * @param shaderInstance
         * @param command
         * @param bundle
         * @param index
         */
        protected _bindGroupEx(shaderInstance: WebGPUShaderInstance, command: WebGPURenderCommandEncoder, bundle: WebGPURenderBundle, index: number): void;
        /**
         * 上传uniform数据
         * @param index
         */
        protected _uploadUniformEx(index: number): void;
        /**
         * 上传几何数据
         * @param command
         * @param bundle
         * @param index
         */
        protected _uploadGeometryEx(command: WebGPURenderCommandEncoder, bundle: WebGPURenderBundle, index: number): number;
        /**
         * 渲染
         * @param context
         * @param command
         * @param bundle
         */
        _render(context: WebGPURenderContext3D, command: WebGPURenderCommandEncoder, bundle: WebGPURenderBundle): number;
    }
    /**
     * 聚光灯阴影渲染流程
     */
    class WebGPUSpotLightShadowRP {
        protected static _invertYScaleMatrix: Matrix4x4;
        destTarget: InternalRenderTarget;
        set light(value: WebSpotLight);
        get light(): WebSpotLight;
        constructor();
        /**
         * 更新阴影数据
         * @param context
         */
        update(context: WebGPURenderContext3D): void;
        /**
         * 渲染
         * @param context
         * @param list
         * @param count
         */
        render(context: WebGPURenderContext3D, list: WebBaseRenderNode[], count: number): void;
        /**
         * get shadow bias
         * @param shadowResolution
         * @param out
         */
        private _getShadowBias;
        /**
         * 设置阴影级联数据模式
         * @param shaderData
         * @param shadowSliceData
         * @param shadowParams
         * @param shadowBias
         */
        private _setupShadowCasterShaderValues;
        /**
         * 应用阴影渲染命令
         * @param context
         */
        private _applyCasterPassCommandBuffer;
        /**
         * 设置聚光接受阴影的模式
         * @param shaderData 渲染数据
         * @param cameraData 相机数据
         */
        private _applyRenderData;
    }
    class WebGPU_GLSLCommon {
        /**
         * 替换字符串的一部分
         * @param str 输入字符串
         * @param replace 替换项
         * @param start 替换开始位置（包含）
         * @param end 替换结束位置（不包含）
         */
        static replaceStringPart(str: string, replace: string, start: number, end: number): string;
        /**
         * 在第一对括号内查找参数，查找以逗号分割的参数，括号可以嵌套，不在第一对括号内的逗号不会被分割
         * @param input 输入字符串（带括号）
         * @param start 从哪个位置开始查找
         * @param bracket 指定括号（默认为小括号）
         */
        static findParamInBracket(input: string, start: number, bracket?: string): {
            full: string;
            elements: string[];
            index: number;
        } | null;
        /**
         * 根据函数类型替换指定实参
         * @param code 要替换的代码
         * @param variableName 要查找的变量名
         * @param functionNames 包含特定函数名称的数组
         * @param replacementInCategory 替换字符串，如果函数名称在提供的数组中
         * @param replacementOutOfCategory 替换字符串，如果函数名称不在提供的数组中
         * @return 返回替换后的代码
         */
        static replaceArgumentByFunctionCategory(code: string, variableName: string, functionNames: string[], replacementInCategory: string, replacementOutOfCategory: string): string;
        /**
         * 移除括号内的空格
         * @param str 输入字符串
         * @param bracket 指定括号（默认为小括号）
         */
        static removeSpacesInBracket(str: string, bracket?: string): string;
    }
    /**
     * 函数参数
     */
    interface Parameter {
        name: string;
        type: string;
        inout?: string;
        precision?: string;
        isArray: boolean;
        arrayLength?: number;
        isStruct: boolean;
    }
    /**
     * 函数调用
     */
    interface FunctionCall {
        name: string;
        params: string[];
    }
    /**
     * GLSL函数定义
     */
    class WebGPU_GLSLFunction {
        name: string;
        return: string;
        precision: string;
        all: string;
        head: string;
        body: string;
        params: Parameter[];
        calls: FunctionCall[];
        samplerProcessed: boolean;
        samplerParams: Parameter[];
        samplerBody: string;
        samplerOutput: string;
        static variableType: string[];
        constructor(all: string);
        /**
         * 获取函数头和函数体
         */
        private _getHeadAndBody;
        /**
         * 解析函数定义
         */
        private _parse;
        /**
         * 查找函数调用
         * @param glslCode
         */
        private _findFunctionCalls;
        /**
         * 对函数进行处理，将sampler转换为texture和sampler
         * @param textureNames
         */
        processSampler(textureNames: string[]): void;
    }
    /**
     * GLSL宏定义
     */
    class WebGPU_GLSLMacro {
        all: string;
        name: string;
        params?: string[];
        replace?: string;
        constructor(all: string);
        /**
         * 解析
         */
        private _parse;
        /**
         * 替换GLSL代码中的宏
         * @param glslCode 原始GLSL代码
         * @returns 替换后的GLSL代码
         */
        replaceMacros(glslCode: string): string;
    }
    /**
     * GLSL代码处理
     */
    class WebGPU_GLSLProcess {
        glInter: string[];
        globals: string[];
        macros: WebGPU_GLSLMacro[];
        structs: WebGPU_GLSLStruct[];
        uniforms: WebGPU_GLSLUniform[];
        functions: WebGPU_GLSLFunction[];
        textureNames: string[];
        glslCode: string;
        haveVertexID: boolean;
        /**
         * 处理GLSL代码
         * @param glslCode GLSL代码
         * @param textureNames 所有的贴图名称
         */
        process(glslCode: string, textureNames: string[]): void;
        /**
         * 获取Uniform信息
         * @param glslCode
         */
        getUniforms(glslCode: string): WebGPU_GLSLUniform[];
        /**
         * 移除注释
         * @param glslCode
         */
        private _removeComments;
        /**
         * 移除不必要的空格
         * @param glslCode
         */
        private _removeSpaces;
        /**
         * 提取宏定义
         * @param glslCode
         */
        private _extractMacros;
        /**
         * 执行宏替换
         * @param glslCode
         */
        private _replaceMacros;
        /**
         * 提取内置变量
         * @param glslCode
         */
        private _extractInternals;
        /**
         * 提取全局变量
         * @param glslCode
         */
        private _extractGlobals;
        /**
         * 提取结构体定义
         * @param glslCode
         */
        private _extractStructs;
        /**
         * 提取Uniform定义
         * @param glslCode
         */
        private _extractUniforms;
        /**
         * 提取函数定义
         * @param glslCode
         */
        private _extractFunctions;
        /**
         * 查找被使用的函数
         */
        private _findUsedFunctions;
        /**
         * 输出处理后的GLSL代码
         */
        private _outputGLSL;
        /**
         * 获取一个变量
         * @param name
         * @param isArray
         */
        private _getVariable;
        /**
         * 打印调试信息
         */
        debugInfo(): void;
    }
    /**
     * 结构体字段
     */
    interface StructField {
        type: string;
        name: string;
        precision?: string;
        isArray?: boolean;
        arrayLength?: number;
    }
    /**
     * GLSL结构体定义
     */
    class WebGPU_GLSLStruct {
        all: string;
        name: string;
        fields: StructField[];
        constructor(all: string);
        /**
         * 解析结构体定义
         * @param all
         */
        private _parse;
        /**
         * 获取字段
         * @param name 字段名称
         * @param isArray 是否是数组
         * @returns 字段
         */
        getArrayField(name: string, isArray?: boolean): StructField;
    }
    /**
     * uniform字段
     */
    interface UniformField {
        type: string;
        name: string;
        precision?: string;
        isArray: boolean;
        arrayLength?: number;
    }
    /**
     * GLSLUniform块定义
     */
    class WebGPU_GLSLUniform {
        all: string;
        name: string;
        fields: UniformField;
        constructor(all: string);
        /**
         * 解析uniform定义
         * @param all
         */
        private _parse;
    }
    class NagaWASM {
        /**
         * 初始化wasm库
         */
        init(): Promise<void>;
        /**
         * 将GLSL4.5转译成WGSL
         */
        compileGLSL2WGSL(code: string, type: string): any;
    }
    /**
     * Converts a `GPUExtent3D` into an array of numbers
     *
     * `GPUExtent3D` has two forms `[width, height?, depth?]` or
     * `{width: number, height?: number, depthOrArrayLayers?: number}`
     *
     * You pass one of those in here and it returns an array of 3 numbers
     * so that your code doesn't have to deal with multiple forms.
     *
     * @param size
     * @returns an array of 3 numbers, [width, height, depthOrArrayLayers]
     */
    function normalizeGPUExtent3D(size: GPUExtent3D): number[];
    /**
     * Given a GPUExtent3D returns the number of mip levels needed
     *
     * @param size
     * @returns number of mip levels needed for the given size
     */
    function numMipLevels(size: GPUExtent3D, dimension?: GPUTextureDimension): number;
    /**
     * Generates mip levels from level 0 to the last mip for an existing texture
     *
     * The texture must have been created with TEXTURE_BINDING and RENDER_ATTACHMENT
     * and been created with mip levels
     *
     * @param device A GPUDevice
     * @param texture The texture to create mips for
     * @param textureBindingViewDimension This is only needed in compatibility mode
     *   and it is only needed when the texture is going to be used as a cube map.
     */
    function genMipmap(device: GPUDevice, texture: GPUTexture, textureBindingViewDimension?: GPUTextureViewDimension): void;
    /**
     * 对贴图中的像素做预乘处理
     *
     * @param device A GPUDevice
     * @param tex The texture to premultiply Alpha
     * @param xOffset horizon offset
     * @param yOffset vertical offset
     * @param width
     * @param height
     */
    function doPremultiplyAlpha(device: GPUDevice, tex: WebGPUInternalTex, xOffset: number, yOffset: number, width: number, height: number): void;
    class WebGPUBuffer {
        _source: GPUBuffer;
        _usage: GPUBufferUsageFlags;
        _size: number;
        private _isCreate;
        private _mappedAtCreation;
        globalId: number;
        objectName: string;
        constructor(usage: GPUBufferUsageFlags, byteSize?: number, mappedAtCreation?: boolean);
        /**
         * @param length
         */
        setDataLength(length: number): void;
        private _create;
        setData(srcData: ArrayBuffer | ArrayBufferView, srcOffset: number): void;
        setDataEx(srcData: ArrayBuffer | ArrayBufferView, srcOffset: number, byteLength: number, dstOffset?: number): void;
        readDataFromBuffer(): Promise<Uint8Array>;
        readFromBuffer(buffer: GPUBuffer, size: number): Promise<Float32Array>;
        release(): void;
    }
    enum WebGPUVertexStepMode {
        vertex = "vertex",
        instance = "instance"
    }
    class WebGPUBufferState implements IBufferState {
        static idCounter: number;
        id: number;
        stateId: string;
        updateBufferLayoutFlag: number;
        vertexState: GPUVertexBufferLayout[];
        _bindedIndexBuffer: WebGPUIndexBuffer;
        _vertexBuffers: WebGPUVertexBuffer[];
        globalId: number;
        objectName: string;
        /**
         * 是否需要转换顶点数据格式
         */
        isNeedChangeFormat(): boolean;
        applyState(vertexBuffers: WebGPUVertexBuffer[], indexBuffer: WebGPUIndexBuffer): void;
        constructor();
        private _getVertexBufferLayoutArray;
        private _getvertexAttributeFormat;
        private _getvertexAttributeSymbol;
        destroy(): void;
    }
    /**
     * 渲染指令缓存
     * 用于缓存渲染指令，提高渲染效率
     * 一个渲染指令缓存对象缓存了若干个渲染节点的渲染指令
     * 如果下一帧渲染流程中，缓存的渲染节点命中率高于一定的程度，则可以直接使用缓存的渲染指令
     * 对于动态节点，要求命中率为100%，对于静态节点，要求命中率可低于100%（比如70%）
     */
    class WebGPURenderBundle {
        private _engine;
        private _encoder;
        private _elements;
        private _shotNum;
        private _shotCount;
        private _shotRateSet;
        private _shotEstimate;
        renderBundle: GPURenderBundle;
        renderTimeStamp: number;
        renderTriangles: number;
        id: number;
        static idCounter: number;
        constructor(device: GPUDevice, dest: WebGPUInternalRT, shotRateSet: number);
        /**
         * 添加渲染节点，将节点的渲染指令添加到命令缓存中
         * @param context
         * @param element
         */
        render(context: WebGPURenderContext3D, element: WebGPURenderElement3D): void;
        /**
         * 结束渲染指令的编码，生成渲染命令缓存对象
         */
        finish(): void;
        /**
         * 判断是否包含某个渲染节点
         * @param elementId
         */
        hasElement(elementId: number): boolean;
        /**
         * 增加命中的渲染节点数量
         */
        addShot(): void;
        /**
         * 把本缓存对象的所有渲染节点从总体渲染节点集合中移除
         * @param elements 总体渲染节点集合
         */
        removeMyIds(elements: Map<number, WebGPURenderBundle>): void;
        /**
         * 清除命中的渲染节点数量
         */
        clearShotNum(): void;
        /**
         * 判断是否是低命中率
         */
        isLowShotRate(): boolean;
        /**
         * 设置渲染管线
         * @param pipeline
         */
        setPipeline(pipeline: GPURenderPipeline): void;
        /**
         * 设置索引缓冲区
         * @param buffer
         * @param indexFormat
         * @param byteSize
         * @param offset
         */
        setIndexBuffer(buffer: GPUBuffer, indexFormat: GPUIndexFormat, byteSize: number, offset?: number): void;
        /**
         * 设置顶点缓冲区
         * @param slot
         * @param buffer
         * @param offset
         * @param size
         */
        setVertexBuffer(slot: number, buffer: GPUBuffer, offset?: number, size?: number): void;
        /**
         * 设置绑定组
         * @param index
         * @param bindGroup
         * @param dynamicOffsets
         */
        setBindGroup(index: GPUIndex32, bindGroup: GPUBindGroup, dynamicOffsets?: Iterable<GPUBufferDynamicOffset>): void;
        /**
         * 上传几何数据
         * @param geometry
         * @param setBuffer
         */
        applyGeometry(geometry: WebGPURenderGeometry, setBuffer?: boolean): number;
        /**
         * 上传几何数据
         * @param geometry
         * @param part
         * @param setBuffer
         */
        applyGeometryPart(geometry: WebGPURenderGeometry, part: number, setBuffer?: boolean): number;
        /**
         * 销毁
         */
        destroy(): void;
    }
    /**
     * 渲染指令缓存管理器
     */
    class WebGPURenderBundleManager {
        elementsMaxPerBundleStatic: number;
        elementsMaxPerBundleDynamic: number;
        bundles: WebGPURenderBundle[];
        renderTimeStamp: number;
        private _triangles;
        private _elementsMap;
        private _renderBundles;
        private _needUpdateRenderBundles;
        /**
         * 提交缓存渲染命令
         * @param passEncoder
         */
        renderBundles(passEncoder: GPURenderPassEncoder): void;
        /**
         * 渲染元素是否在缓存中
         * @param elementId
         */
        has(elementId: number): boolean;
        /**
         * 根据渲染元素id查找渲染缓存对象
         * @param elementId
         */
        getBundle(elementId: number): WebGPURenderBundle;
        /**
         * 通过渲染元素组创建渲染缓存对象
         * @param context
         * @param elements
         * @param shotRateSet
         */
        createBundle(context: WebGPURenderContext3D, elements: WebGPURenderElement3D[], shotRateSet: number): void;
        /**
         * 移除渲染缓存对象
         * @param bundle
         */
        removeBundle(bundle: WebGPURenderBundle): void;
        /**
         * 通过指定元素id移除渲染缓存对象
         * @param elementId
         */
        removeBundleByElement(elementId: number): void;
        /**
         * 清除所有渲染缓存对象
         */
        clearBundle(): void;
        /**
         * 清除所有渲染缓存对象的命中计数
         */
        clearShot(): void;
        /**
         * 移除命中率低的渲染缓存对象
         */
        removeLowShotBundle(): boolean;
        /**
         * 销毁
         */
        destroy(): void;
    }
    class WebGPURenderBundleManagerSet {
        key: string;
        bundleManager: WebGPURenderBundleManager;
        elementsToBundleStatic: WebGPURenderElement3D[];
        elementsToBundleDynamic: WebGPURenderElement3D[];
        /**
         * 清除渲染指令缓存
         */
        clearBundle(): void;
    }
    class WebGPUCapable {
        constructor(descriptor: GPUDeviceDescriptor);
        initCapable(descriptor: GPUDeviceDescriptor): void;
        getCapable(type: RenderCapable): boolean;
    }
    /**
     * attribute列表
     */
    type WebGPUAttributeMapType = {
        [key: string]: [
            number,
            ShaderDataType
        ];
    };
    /**
     * uniform列表
     */
    type WebGPUUniformMapType = {
        [key: string]: {
            name: string;
            type: ShaderDataType;
            shadow?: boolean;
        };
    };
    /**
     * 绑定类型（uniformBlock，texture或sampler）
     */
    enum WebGPUBindingInfoType {
        buffer = 0,
        texture = 1,
        sampler = 2
    }
    /**
     * uniform详细内容（可能是uniformBlock，texture或sampler）
     */
    interface WebGPUUniformPropertyBindingInfo {
        id: number;
        set: number;
        binding: number;
        name: string;
        propertyId: number;
        visibility: GPUShaderStageFlags;
        type: WebGPUBindingInfoType;
        uniform?: WebGPUUniformBlockInfo;
        buffer?: GPUBufferBindingLayout;
        texture?: GPUTextureBindingLayout;
        sampler?: GPUSamplerBindingLayout;
    }
    /**
     * WGSL代码转译
     */
    class WebGPUCodeGenerator {
        static naga: NagaWASM;
        static inited: boolean;
        static forNaga: boolean;
        /**
         * 初始化nageWASM库
         * @param next
         */
        static init(next?: Function): Promise<void>;
        /**
         * 生成attribute字符串
         * @param attributeMap
         */
        private static _attributeString;
        /**
         * 生成varying字符串
         * @param varyingMap
         * @param io 'in' or 'out'
         */
        private static _varyingString;
        /**
         * 生成uniform字符串
         * @param uniformMap
         * @param arrayMap 数组uniform映射表（表示哪些uniform是数组，长度是多少）
         */
        private static _uniformString2D;
        /**
         * 生成uniform字符串
         * @param uniformMap
         * @param arrayMap 数组uniform映射表（表示哪些uniform是数组，长度是多少）
         */
        private static _uniformString3D;
        /**
         * 生成sampler和texuture字符串
         */
        private static _textureString;
        /**
         * 去除naga转译报错的代码
         * @param code
         */
        private static _changeUnfitCode;
        /**
         * 生成a_WorldMat拼合代码
         */
        private static _genAWorldMat;
        /**
         * 生成inverse函数（因为WGSL缺乏内置的inverse函数）
         */
        private static _genInverseFunc;
        /**
         * 生成Uniform数据块信息
         * @param name
         * @param binding
         * @param uniforms
         * @param arrayMap
         */
        private static _genUniformBlockInfo;
        /**
         * 转译Attribute类型（Type到String）
         * @param type
         */
        private static _getAttributeT2S;
        /**
         * 转译Attribute类型（String到Type）
         * @param name
         */
        private static _getAttributeS2T;
        /**
         * 转译Attribute类型（String到Number），用于分组
         * @param name
         */
        private static _getAttributeS2N;
        /**
         * 执行WGSL转译
         * @param defineString
         * @param attributeMap
         * @param uniformMap
         * @param VS
         * @param FS
         * @param is2D
         */
        static shaderLanguageProcess(defineString: string[], attributeMap: WebGPUAttributeMapType, uniformMap: WebGPUUniformMapType, arrayMap: NameNumberMap, VS: ShaderNode, FS: ShaderNode, is2D: boolean): {
            glsl_vs: string;
            glsl_fs: string;
            vs: any;
            fs: any;
            uniformInfo: WebGPUUniformPropertyBindingInfo[];
        };
        /**
         * 收集Uniform信息
         * @param defineString
         * @param uniformMap
         * @param VS
         * @param FS
         */
        static collectUniform(defineString: string[], uniformMap: UniformMapType, VS: ShaderNode, FS: ShaderNode): {
            uniform: WebGPUUniformMapType;
            arr: NameNumberMap;
        };
    }
    class WebGPUCommandUniformMap extends CommandUniformMap {
        _stateName: string;
        constructor(stateName: string);
        hasPtrID(propertyID: number): boolean;
        /**
         * 增加一个UniformArray参数
         * @param propertyID
         * @param propertyName
         */
        addShaderUniformArray(propertyID: number, propertyName: string, uniformtype: ShaderDataType, arrayLength: number, block?: string): void;
        /**
         * 增加一个Uniform
         */
        addShaderBlockUniform(propertyID: number, blockname: string, blockProperty: UniformProperty[]): void;
    }
    type OffsetAndSize = {
        offset: number;
        size: number;
    };
    type NameAndType = {
        name: string;
        type: string;
        set: number;
    };
    type NameStringMap = Record<string, string>;
    type NameNumberMap = Record<string, number>;
    type NameBooleanMap = Record<string, boolean>;
    /**
     * 向上圆整到align的整数倍
     * @param n
     * @param align
     */
    function roundUp(n: number, align: number): number;
    /**
     * 向下圆整到align的整数倍
     * @param n
     * @param align
     */
    function roundDown(n: number, align: number): number;
    /**
     * 是否是TypedArray
     * @param arr
     */
    const isTypedArray: (arr: any) => boolean;
    class WebGPUIndexBuffer implements IIndexBuffer {
        source: WebGPUBuffer;
        indexType: IndexFormat;
        indexCount: number;
        globalId: number;
        objectName: string;
        constructor(targetType: BufferTargetType, bufferUsageType: BufferUsage);
        _setIndexDataLength(length: number): void;
        _setIndexData(data: Uint8Array | Uint16Array | Uint32Array, bufferOffset: number): void;
        destroy(): void;
    }
    class WebGPUInternalRT implements InternalRenderTarget {
        _isCube: boolean;
        _samples: number;
        _generateMipmap: boolean;
        _textures: WebGPUInternalTex[];
        _texturesResolve: WebGPUInternalTex[];
        _depthTexture: WebGPUInternalTex;
        colorFormat: RenderTargetFormat;
        depthStencilFormat: RenderTargetFormat;
        isSRGB: boolean;
        gpuMemory: number;
        formatId: string;
        _colorStates: GPUColorTargetState[];
        _depthState: GPUColorTargetState;
        _renderPassDescriptor: GPURenderPassDescriptor;
        _renderBundleDescriptor: GPURenderBundleEncoderDescriptor;
        globalId: number;
        objectName: string;
        constructor(colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, isCube: boolean, generateMipmap: boolean, samples: number, sRGB: boolean);
        dispose(): void;
    }
    class WebGPUInternalTex implements InternalTexture {
        resource: GPUTexture;
        dimension: TextureDimension;
        width: number;
        height: number;
        depth: number;
        isPotSize: boolean;
        mipmap: boolean;
        mipmapCount: number;
        baseMipmapLevel: number;
        maxMipmapLevel: number;
        useSRGBLoad: boolean;
        gammaCorrection: number;
        multiSamplers: number;
        _webGPUFormat: WebGPUTextureFormat;
        private _engine;
        private _statistics_M_TextureX;
        private _statistics_M_TextureA;
        private _statistics_RC_TextureX;
        private _statistics_RC_TextureA;
        globalId: number;
        objectName: string;
        private _filterMode;
        get filterMode(): FilterMode;
        set filterMode(value: FilterMode);
        private _wrapU;
        get wrapU(): WrapMode;
        set wrapU(value: WrapMode);
        private _wrapV;
        get wrapV(): WrapMode;
        set wrapV(value: WrapMode);
        private _wrapW;
        get wrapW(): WrapMode;
        set wrapW(value: WrapMode);
        private _anisoLevel;
        get anisoLevel(): number;
        set anisoLevel(value: number);
        private _compareMode;
        get compareMode(): TextureCompareMode;
        set compareMode(value: TextureCompareMode);
        private _webGPUSamplerParams;
        private _webgpuSampler;
        get sampler(): WebGPUSampler;
        private _gpuMemory;
        get gpuMemory(): number;
        set gpuMemory(value: number);
        constructor(width: number, height: number, depth: number, dimension: TextureDimension, mipmap: boolean, multiSamples: number, useSRGBLoader: boolean, gammaCorrection: number);
        statisAsRenderTexture(): void;
        getTextureView(): GPUTextureView;
        private _changeTexMemory;
        dispose(): void;
    }
    class WebGPURenderCommandEncoder {
        _commandEncoder: GPUCommandEncoder;
        _encoder: GPURenderPassEncoder;
        _engine: WebGPURenderEngine;
        _device: GPUDevice;
        globalId: number;
        objectName: string;
        constructor();
        startRender(renderPassDesc: GPURenderPassDescriptor): void;
        setPipeline(pipeline: GPURenderPipeline): void;
        setIndexBuffer(buffer: GPUBuffer, indexFormat: GPUIndexFormat, byteSize: number, offset?: number): void;
        setVertexBuffer(slot: number, buffer: GPUBuffer, offset?: number, size?: number): void;
        drawIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64): void;
        drawIndexedIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64): void;
        setBindGroup(index: GPUIndex32, bindGroup: GPUBindGroup, dynamicOffsets?: Iterable<GPUBufferDynamicOffset>): void;
        setBindGroupByDataOffaset(index: GPUIndex32, bindGroup: GPUBindGroup, dynamicOffsetsData: Uint32Array, dynamicOffsetsDataStart: GPUSize64, dynamicOffsetsDataLength: GPUSize32): void;
        setViewport(x: number, y: number, width: number, height: number, minDepth: number, maxDepth: number): void;
        setScissorRect(x: GPUIntegerCoordinate, y: GPUIntegerCoordinate, width: GPUIntegerCoordinate, height: GPUIntegerCoordinate): void;
        setStencilReference(ref: number): void;
        end(): void;
        finish(): GPUCommandBuffer;
        playBundle(bundles: GPURenderBundle[]): void;
        /**
         * 上传几何数据
         * @param geometry
         * @param setBuffer
         */
        applyGeometry(geometry: WebGPURenderGeometry, setBuffer?: boolean): number;
        /**
         * 上传几何数据
         * @param geometry
         * @param part
         * @param setBuffer
         */
        applyGeometryPart(geometry: WebGPURenderGeometry, part: number, setBuffer?: boolean): number;
        destroy(): void;
    }
    class WebGPURenderDeviceFactory implements IRenderDeviceFactory {
        createShaderInstance(shaderProcessInfo: ShaderProcessInfo, shaderPass: ShaderCompileDefineBase): IShaderInstance;
        createIndexBuffer(bufferUsage: BufferUsage): IIndexBuffer;
        createVertexBuffer(bufferUsageType: BufferUsage): IVertexBuffer;
        createBufferState(): IBufferState;
        createRenderGeometryElement(mode: MeshTopology, drawType: DrawType): IRenderGeometryElement;
        createEngine(config: Config, canvas: any): Promise<void>;
        static globalBlockMap: {
            [key: string]: WebGPUCommandUniformMap;
        };
        createGlobalUniformMap(blockName: string): WebGPUCommandUniformMap;
        createShaderData(ownerResource?: Resource): ShaderData;
    }
    class WebGPUConfig {
        /**
         * Defines the category of adapter to use.
         */
        powerPreference: GPUPowerPreference;
        /**
         * Defines the device descriptor used to create a device.
         */
        deviceDescriptor?: GPUDeviceDescriptor;
        /**
         * context params
         */
        swapChainFormat?: WebGPUTextureFormat;
        /**
         * canvans alpha mode
         */
        alphaMode: GPUCanvasAlphaMode;
        /**
         * attach canvans usage
         */
        usage?: GPUTextureUsageFlags;
        /**
         * color space
         */
        colorSpace?: string;
        /**
         * depth and stencil
         */
        depthStencilFormat: WebGPUTextureFormat;
        /**
         * multi sample（msaa = 4x）
         */
        msaa: boolean;
    }
    /**
     * WebGPU渲染引擎
     */
    class WebGPURenderEngine implements IRenderEngine {
        static _offscreenFormat: GPUTextureFormat;
        static _instance: WebGPURenderEngine;
        _isShaderDebugMode: boolean;
        _renderOBJCreateContext: IRenderEngineFactory;
        _canvas: HTMLCanvasElement;
        _context: GPUCanvasContext;
        _config: WebGPUConfig;
        screenResized: boolean;
        _screenRT: WebGPUInternalRT;
        _remapZ: boolean;
        _screenInvertY: boolean;
        _lodTextureSample: boolean;
        _breakTextureSample: boolean;
        _enableStatistics: boolean;
        private _adapter;
        private _device;
        private _supportCapatable;
        private _textureContext;
        private _adapterSupportedExtensions;
        private _deviceEnabledExtensions;
        private _GPUStatisticsInfo;
        gpuBufferMgr: WebGPUBufferManager;
        globalId: number;
        objectName: string;
        /**
         * 实例化一个webgpuEngine
         */
        constructor(config: WebGPUConfig, canvas: any);
        /**
         * 获取适配器
         */
        private _getAdapter;
        /**
         * 初始化适配器
         * @param adapter
         */
        private _initAdapter;
        /**
         * 获取WebGPU设备
         * @param deviceDescriptor
         */
        private _getGPUdevice;
        /**
         * 显示错误信息
         * @param event
         */
        private _unCapturedErrorCall;
        /**
         * 设备丢失
         * @param info
         */
        private _deviceLostCall;
        /**
         * 初始化WebGPU设备
         * @param device
         */
        private _initDevice;
        /**
         * 初始化WebGPU
         */
        _initAsync(): Promise<void>;
        /**
         * 画布尺寸改变
         * @param width
         * @param height
         */
        resizeOffScreen(width: number, height: number): void;
        getDevice(): GPUDevice;
        /**
         * 开始新的一帧
         */
        startFrame(): void;
        /**
         * 上传数据
         */
        upload(): void;
        /**
         * 设置WebGPU画图上下文
         */
        private _initContext;
        /**
         * 初始化渲染引擎
         */
        initRenderEngine(): Promise<void>;
        copySubFrameBuffertoTex(texture: InternalTexture, level: number, xoffset: number, yoffset: number, x: number, y: number, width: number, height: number): void;
        propertyNameToID(name: string): number;
        propertyIDToName(id: number): string;
        getDefineByName(name: string): ShaderDefine;
        getNamesByDefineData(defineData: IDefineDatas, out: string[]): void;
        _texGammaDefine: {
            [key: number]: ShaderDefine;
        };
        addTexGammaDefine(key: number, value: ShaderDefine): void;
        /**获得各个参数 */
        getParams(params: RenderParams): number;
        /**获得是否支持某种能力 */
        getCapable(capatableType: RenderCapable): boolean;
        getTextureContext(): ITextureContext;
        getCreateRenderOBJContext(): WebGPURenderEngineFactory;
        private _initStatisticsInfo;
        /**
         * 创建屏幕渲染目标
         */
        createScreenRT(): void;
        endFrame(): void;
    }
    class WebGPURenderEngineFactory implements IRenderEngineFactory {
        createUniformBufferObject(glPointer: number, name: string, bufferUsage: BufferUsage, byteLength: number, isSingle: boolean): UniformBufferObject;
        createEngine(config: Config, canvas: any): Promise<void>;
    }
    enum WebGPUPrimitiveTopology {
        point_list = "point-list",
        line_list = "line-list",
        line_strip = "line-strip",
        triangle_list = "triangle-list",
        triangle_strip = "triangle-strip"
    }
    class WebGPURenderGeometry implements IRenderGeometryElement {
        checkDataFormat: boolean;
        gpuIndexFormat: GPUIndexFormat;
        gpuIndexByte: number;
        _id: number;
        static _idCounter: number;
        get instanceCount(): number;
        set instanceCount(value: number);
        get mode(): MeshTopology;
        set mode(value: MeshTopology);
        get indexFormat(): IndexFormat;
        set indexFormat(value: IndexFormat);
        globalId: number;
        objectName: string;
        setDrawArrayParams(first: number, count: number): void;
        setDrawElemenParams(count: number, offset: number): void;
        setInstanceRenderOffset(offset: number, instanceCount: number): void;
        clearRenderParams(): void;
        cloneTo(obj: WebGPURenderGeometry): void;
        destroy(): void;
    }
    class WebGPURenderPassHelper {
        static getDescriptor(rt: WebGPUInternalRT, clearflag: RenderClearFlag, clearColor?: Color, clearDepthValue?: number, clearStencilValue?: number): GPURenderPassDescriptor;
        static getBundleDescriptor(rt: WebGPUInternalRT): GPURenderBundleEncoderDescriptor;
        static setColorAttachments(desc: GPURenderPassDescriptor, rt: WebGPUInternalRT, clear: boolean, clearColor?: Color): void;
        static setDepthAttachments(desc: GPURenderPassDescriptor, rt: WebGPUInternalRT, clear: boolean, clearDepthValue?: number, clearStencilValue?: number): void;
    }
    interface WebGPUBlendStateCache {
        state: GPUBlendState;
        key: number;
        id: number;
    }
    class WebGPUBlendState {
        private static _idCounter;
        private static _pointer_BlendType;
        private static _pointer_OperationRGB_BlendEquationSeparate;
        private static _pointer_OperationAlpha_BlendEquationSeparate;
        private static _pointer_srcBlendRGB_BlendFactor;
        private static _pointer_dstBlendRGB_BlendFactor;
        private static _pointer_srcBlendAlpha_BlendFactor;
        private static _pointer_dstBlendAlpha_BlendFactor;
        private static _cache;
        static getBlendState(blend: BlendType, operationRGB: BlendEquationSeparate, srcBlendRGB: BlendFactor, dstBlendRGB: BlendFactor, operationAlpha: BlendEquationSeparate, srcBlendAlpha: BlendFactor, dstBlendAlpha: BlendFactor): WebGPUBlendStateCache;
        private static _getBlendStateCacheID;
        private static _createBlendState;
        private static _getFactor;
        private static _getComponent;
    }
    interface WebGPUDepthStencilStateCache {
        state: GPUDepthStencilState;
        key: number;
        id: number;
    }
    class WebGPUDepthStencilState {
        private static _idCounter;
        private static _pointer_DepthWriteEnable;
        private static _pointer_DepthCompare;
        private static _pointer_DepthFormat;
        private static _pointer_StencilTest;
        private static _pointer_StencilOp1;
        private static _pointer_StencilOp2;
        private static _pointer_StencilOp3;
        private static _cache;
        static getDepthStencilState(format: RenderTargetFormat, depthWriteEnabled: boolean, depthCompare: CompareFunction, stencilParam?: any, depthBiasParam?: any): WebGPUDepthStencilStateCache;
        private static _getDepthStencilCacheID;
        private static _createDepthStencilState;
    }
    interface WebGPUPrimitiveStateCache {
        state: GPUPrimitiveState;
        key: number;
        id: number;
    }
    class WebGPUPrimitiveState {
        private static _idCounter;
        private static _pointer_Topology;
        private static _pointer_FrontFace;
        private static _pointer_CullMode;
        private static _cache;
        static getGPUPrimitiveState(topology: MeshTopology, frontFace: FrontFace, cullMode: CullMode): WebGPUPrimitiveStateCache;
        private static _getGPUPrimitiveStateID;
        private static _createPrimitiveState;
    }
    interface IRenderPipelineInfo {
        geometry: WebGPURenderGeometry;
        blendState: WebGPUBlendStateCache;
        depthStencilState: WebGPUDepthStencilStateCache;
        cullMode: CullMode;
        frontFace: FrontFace;
    }
    class WebGPURenderPipeline {
        static idCounter: number;
        /**
         * 获取渲染管线，如果缓存中存在，直接取出，否则创建一个，放入缓存
         * @param info
         * @param shaderInstance
         * @param renderTarget
         * @param entries
         * @param stateKey
         */
        static getRenderPipeline(info: IRenderPipelineInfo, shaderInstance: WebGPUShaderInstance, renderTarget: WebGPUInternalRT, entries: any, stateKey: string): GPURenderPipeline;
        /**
         * 创建渲染管线
         * @param blendState
         * @param depthState
         * @param primitiveState
         * @param vertexBuffers
         * @param shaderInstance
         * @param renderTarget
         * @param entries
         * @param stateKey
         */
        private static _createRenderPipeline;
    }
    /**
     * WebGPU内存回收（需要延迟一帧回收的内存）
     */
    class WebGPUResourceRecover {
        recoverList: WebGPUBuffer[];
        frameCount: number;
        needRecover(res: WebGPUBuffer): void;
        recover(): void;
    }
    interface WebGPUSamplerParams {
        comparedMode: TextureCompareMode;
        wrapU: WrapMode;
        warpV: WrapMode;
        warpW: WrapMode;
        mipmapFilter: FilterMode;
        filterMode: FilterMode;
        anisoLevel: number;
    }
    class WebGPUSampler {
        static pointer_wrapU: number;
        static pointer_warpV: number;
        static pointer_warpW: number;
        static pointer_filterMode: number;
        static pointer_mipmapFilter: number;
        static pointer_comparedMode: number;
        static pointer_anisoLevel: number;
        private static _cacheMap;
        private _descriptor;
        source: GPUSampler;
        globalId: number;
        objectName: string;
        constructor(obj: WebGPUSamplerParams);
        static getWebGPUSampler(params: WebGPUSamplerParams): WebGPUSampler;
        private static _getCacheSamplerKey;
        private _createGPUSampler;
        private _getSamplerDescriptor;
        private _getSamplerAddressMode;
        private _getFilterMode;
        private _getGPUCompareFunction;
    }
    /**
     * 着色器数据
     */
    class WebGPUShaderData extends ShaderData {
        private static _bindGroupCounter;
        private static _dummyTexture2D;
        private static _dummyTextureCube;
        stateKey: string;
        static _stateKeyMap: Set<number>;
        private _destroyed;
        private _infoId;
        private _uniformBuffer;
        private _bindGroupMap;
        private _bindGroup;
        private _bindGroupLayoutEntries;
        private _bindGroupResourceSet;
        private _bindGroupKey;
        skinShaderData: WebGPUShaderData[];
        instShaderData: WebGPUShaderData;
        private _isShare;
        get isShare(): boolean;
        set isShare(value: boolean);
        private _isStatic;
        get isStatic(): boolean;
        set isStatic(value: boolean);
        changeMark: number;
        globalId: number;
        objectName: string;
        static objectCount: number;
        static __init__(): void;
        constructor(ownerResource?: Resource);
        /**
         * 创建UniformBuffer
         * @param info
         * @param single
         * @param inst
         */
        createUniformBuffer(info: WebGPUUniformPropertyBindingInfo, single?: boolean, inst?: boolean): void;
        /**
         * 将数据更新到UniformBuffer中
         */
        private _updateUniformData;
        /**
         * 删除包含指定资源的缓存
         * @param index 资源id
         */
        removeBindGroup(index: number): void;
        /**
         * 清理缓存的BindGroup
         */
        clearBindGroup(): void;
        /**
         * 创建绑定组项
         * @param info
         */
        createBindGroupLayoutEntry(info: WebGPUUniformPropertyBindingInfo[]): ({
            binding: number;
            visibility: number;
            buffer: GPUBufferBindingLayout;
            texture?: undefined;
            sampler?: undefined;
        } | {
            binding: number;
            visibility: number;
            texture: GPUTextureBindingLayout;
            buffer?: undefined;
            sampler?: undefined;
        } | {
            binding: number;
            visibility: number;
            sampler: GPUSamplerBindingLayout;
            buffer?: undefined;
            texture?: undefined;
        })[];
        /**
         * 绑定资源组
         * @param groupId
         * @param name
         * @param info
         * @param command
         * @param bundle
         */
        bindGroup(groupId: number, name: string, info: WebGPUUniformPropertyBindingInfo[], command: WebGPURenderCommandEncoder, bundle?: WebGPURenderBundle): GPUBindGroupLayoutEntry[] | ({
            binding: number;
            visibility: number;
            buffer: GPUBufferBindingLayout;
            texture?: undefined;
            sampler?: undefined;
        } | {
            binding: number;
            visibility: number;
            texture: GPUTextureBindingLayout;
            buffer?: undefined;
            sampler?: undefined;
        } | {
            binding: number;
            visibility: number;
            sampler: GPUSamplerBindingLayout;
            buffer?: undefined;
            texture?: undefined;
        })[];
        /**
         * 上传数据
         */
        uploadUniform(): void;
        /**
         * 获取数据对象
         */
        getData(): any;
        /**
         * 获取宏定义数据
         */
        getDefineData(): WebDefineDatas;
        /**
         * 增加Shader宏定义
         */
        addDefine(define: ShaderDefine): void;
        addDefines(defines: WebDefineDatas): void;
        /**
         * 移除Shader宏定义
         */
        removeDefine(define: ShaderDefine): void;
        /**
         * 是否包含Shader宏定义
         */
        hasDefine(define: ShaderDefine): boolean;
        /**
         * 清空宏定义
         */
        clearDefine(): void;
        /**
         * 获取布尔
         * @param index shader索引
         * @return 布尔
         */
        getBool(index: number): boolean;
        /**
         * 设置布尔
         * @param index shader索引
         * @param value 布尔
         */
        setBool(index: number, value: boolean): void;
        /**
         * 获取整型
         * @param index shader索引
         * @return 整型
         */
        getInt(index: number): number;
        /**
         * 设置整型
         * @param index shader索引
         * @param value 整型
         */
        setInt(index: number, value: number): void;
        /**
         * 获取浮点
         * @param index shader索引
         * @return 浮点
         */
        getNumber(index: number): number;
        /**
         * 设置浮点
         * @param index shader索引
         * @param value 浮点
         */
        setNumber(index: number, value: number): void;
        /**
         * 获取Vector2向量
         * @param index shader索引
         * @return Vector2向量
         */
        getVector2(index: number): Vector2;
        /**
         * 设置Vector2向量
         * @param index shader索引
         * @param value Vector2向量
         */
        setVector2(index: number, value: Vector2): void;
        /**
         * 获取Vector3向量
         * @param index shader索引
         * @return Vector3向量
         */
        getVector3(index: number): Vector3;
        /**
         * 设置Vector3向量
         * @param index shader索引
         * @param value Vector3向量
         */
        setVector3(index: number, value: Vector3): void;
        /**
         * 获取向量
         * @param index shader索引
         * @return 向量
         */
        getVector(index: number): Vector4;
        /**
         * 设置向量
         * @param index shader索引
         * @param value 向量
         */
        setVector(index: number, value: Vector4): void;
        /**
         * 获取颜色
         * @param index 索引
         * @returns 颜色
         */
        getColor(index: number): Color;
        /**
         * 设置颜色
         * @param index 索引
         * @param value 颜色值
         */
        setColor(index: number, value: Color): void;
        /**
         * 获取矩阵
         * @param index
         * @returns
         */
        getMatrix3x3(index: number): Matrix3x3;
        /**
         * 设置矩阵
         * @param index
         * @param value
         */
        setMatrix3x3(index: number, value: Matrix3x3): void;
        /**
         * 获取矩阵
         * @param index shader索引
         * @return 矩阵
         */
        getMatrix4x4(index: number): Matrix4x4;
        /**
         * 设置矩阵
         * @param index shader索引
         * @param value 矩阵
         */
        setMatrix4x4(index: number, value: Matrix4x4): void;
        /**
         * 获取Buffer
         * @param index shader索引
         * @return
         */
        getBuffer(index: number): Float32Array;
        /**
         * 设置Buffer
         * @param index shader索引
         * @param value buffer数据
         */
        setBuffer(index: number, value: Float32Array): void;
        /**
         * 设置纹理
         * @param index shader索引
         * @param value 纹理
         */
        setTexture(index: number, value: BaseTexture): void;
        /**
         * 设置内部纹理
         * @param index shader索引
         * @param value 纹理
         */
        _setInternalTexture(index: number, value: InternalTexture): void;
        /**
         * 获取纹理
         * @param index shader索引
         * @return 纹理
         */
        getTexture(index: number): BaseTexture;
        getSourceIndex(value: any): number;
        /**
         * 克隆
         * @param dest
         */
        cloneTo(dest: WebGPUShaderData): void;
        /**
         * 克隆
         */
        clone(): WebGPUShaderData;
        _releaseUBOData(): void;
        /**
         * 清理
         */
        clear(): void;
        /**
         * 销毁
         */
        destroy(): void;
    }
    /**
     * WebGPU着色器实例
     */
    class WebGPUShaderInstance implements IShaderInstance {
        static idCounter: number;
        _id: number;
        _shaderPass: ShaderPass;
        private _vsShader;
        private _fsShader;
        destroyed: boolean;
        name: string;
        complete: boolean;
        renderPipelineMap: Map<string, any>;
        uniformInfo: WebGPUUniformPropertyBindingInfo[];
        uniformSetMap: {
            [set: number]: WebGPUUniformPropertyBindingInfo[];
        };
        globalId: number;
        objectName: string;
        constructor(name: string);
        /**
         * 获取渲染管线描述
         */
        getRenderPipelineDescriptor(): GPURenderPipelineDescriptor;
        /**
         * 创建ShaderInstance
         * @param shaderProcessInfo
         * @param shaderPass
         */
        _create(shaderProcessInfo: ShaderProcessInfo, shaderPass: ShaderPass): void;
        /**
         * 基于WebGPUUniformPropertyBindingInfo创建PipelineLayout
         * @param device
         * @param name
         * @param entries
         */
        createPipelineLayout(device: GPUDevice, name: string, entries?: any): GPUPipelineLayout;
        /**
         * 销毁
         */
        _disposeResource(): void;
    }
    class WebGPUGlobal {
        static debug: boolean;
        static useCache: boolean;
        static useBundle: boolean;
        static useBigBuffer: boolean;
        static useGlobalContext: boolean;
        private static _idCounter;
        private static _uniformInfoIdCounter;
        static getUniformInfoId(): number;
        static getId(object?: any): number;
        static releaseId(object: any): void;
        static action(object: any, action: string, memory?: number): void;
        static reset(): void;
        static get idCounter(): number;
    }
    class WebGPUStatis {
        private static _start;
        private static _totalStatis;
        private static _frameStatis;
        private static _dataTiming;
        private static _dataCreate;
        private static _dataRelease;
        private static _textureStatis;
        static startFrame(): void;
        static addUploadNum(n?: number): void;
        static addUploadBytes(n?: number): void;
        static addRenderElement(n?: number): void;
        static addSubmit(n?: number): void;
        static addTexture(texture: any): void;
        static trackObjectCreation(name: string, id: number, object?: any, memory?: number): void;
        static trackObjectRelease(name: string, id: number, object?: any, memory?: number): void;
        static trackObjectAction(name: string, id: number, action: string, object?: any, memory?: number): void;
        static printStatisticsAsTable(): void;
        static printTotalStatis(): void;
        static printFrameStatis(): void;
        static printTextureStatis(): void;
    }
    enum WebGPUTextureDimension {
        D1D = "1d",
        D2D = "2d",
        D3D = "3d"
    }
    enum WebGPUTextureFormat {
        r8unorm = "r8unorm",
        r8snorm = "r8snorm",
        r8uint = "r8uint",
        r8sint = "r8sint",
        r16uint = "r16uint",
        r16sint = "r16sint",
        r16float = "r16float",
        rg8unorm = "rg8unorm",
        rg8snorm = "rg8snorm",
        rg8uint = "rg8uint",
        rg8sint = "rg8sint",
        r32uint = "r32uint",
        r32sint = "r32sint",
        r32float = "r32float",
        rg16uint = "rg16uint",
        rg16sint = "rg16sint",
        rg16float = "rg16float",
        rgba8unorm = "rgba8unorm",
        rgba8unorm_srgb = "rgba8unorm-srgb",
        rgba8snorm = "rgba8snorm",
        rgba8uint = "rgba8uint",
        rgba8sint = "rgba8sint",
        bgra8unorm = "bgra8unorm",
        bgra8unorm_srgb = "bgra8unorm-srgb",
        rgb9e5ufloat = "rgb9e5ufloat",
        rgb10a2unorm = "rgb10a2unorm",
        rg11b10ufloat = "rg11b10ufloat",
        rg32uint = "rg32uint",
        rg32sint = "rg32sint",
        rg32float = "rg32float",
        rgba16uint = "rgba16uint",
        rgba16sint = "rgba16sint",
        rgba16float = "rgba16float",
        rgba32uint = "rgba32uint",
        rgba32sint = "rgba32sint",
        rgba32float = "rgba32float",
        stencil8 = "stencil8",
        depth16unorm = "depth16unorm",
        depth24plus = "depth24plus",
        depth24plus_stencil8 = "depth24plus-stencil8",
        depth32float = "depth32float",
        depth32float_stencil8 = "depth32float-stencil8",
        bc1_rgba_unorm = "bc1-rgba-unorm",
        bc1_rgba_unorm_srgb = "bc1-rgba-unorm-srgb",
        bc2_rgba_unorm = "bc2-rgba-unorm",
        bc2_rgba_unorm_srgb = "bc2-rgba-unorm-srgb",
        bc3_rgba_unorm = "bc3-rgba-unorm",
        bc3_rgba_unorm_srgb = "bc3-rgba-unorm-srgb",
        bc4_r_unorm = "bc4-r-unorm",
        bc4_r_snorm = "bc4-r-snorm",
        bc5_rg_unorm = "bc5-rg-unorm",
        bc5_rg_snorm = "bc5-rg-snorm",
        bc6h_rgb_ufloat = "bc6h-rgb-ufloat",
        bc6h_rgb_float = "bc6h-rgb-float",
        bc7_rgba_unorm = "bc7-rgba-unorm",
        bc7_rgba_unorm_srgb = "bc7-rgba-unorm-srgb",
        etc2_rgb8unorm = "etc2-rgb8unorm",
        etc2_rgb8unorm_srgb = "etc2-rgb8unorm-srgb",
        etc2_rgb8a1unorm = "etc2-rgb8a1unorm",
        etc2_rgb8a1unorm_srgb = "etc2-rgb8a1unorm-srgb",
        etc2_rgba8unorm = "etc2-rgba8unorm",
        etc2_rgba8unorm_srgb = "etc2-rgba8unorm-srgb",
        astc_4x4_unorm = "astc-4x4-unorm",
        astc_4x4_unorm_srgb = "astc-4x4-unorm-srgb",
        astc_5x4_unorm = "astc-5x4-unorm",
        astc_5x4_unorm_srgb = "astc-5x4-unorm-srgb",
        astc_5x5_unorm = "astc-5x5-unorm",
        astc_5x5_unorm_srgb = "astc-5x5-unorm-srgb",
        astc_6x5_unorm = "astc-6x5-unorm",
        astc_6x5_unorm_srgb = "astc-6x5-unorm-srgb",
        astc_6x6_unorm = "astc-6x6-unorm",
        astc_6x6_unorm_srgb = "astc-6x6-unorm-srgb",
        astc_8x5_unorm = "astc-8x5-unorm",
        astc_8x5_unorm_srgb = "astc-8x5-unorm-srgb",
        astc_8x6_unorm = "astc-8x6-unorm",
        astc_8x6_unorm_srgb = "astc-8x6-unorm-srgb",
        astc_8x8_unorm = "astc-8x8-unorm",
        astc_8x8_unorm_srgb = "astc-8x8-unorm-srgb",
        astc_10x5_unorm = "astc-10x5-unorm",
        astc_10x5_unorm_srgb = "astc-10x5-unorm-srgb",
        astc_10x6_unorm = "astc-10x6-unorm",
        astc_10x6_unorm_srgb = "astc-10x6-unorm-srgb",
        astc_10x8_unorm = "astc-10x8-unorm",
        astc_10x8_unorm_srgb = "astc-10x8-unorm-srgb",
        astc_10x10_unorm = "astc-10x10-unorm",
        astc_10x10_unorm_srgb = "astc-10x10-unorm-srgb",
        astc_12x10_unorm = "astc-12x10-unorm",
        astc_12x10_unorm_srgb = "astc-12x10-unorm-srgb",
        astc_12x12_unorm = "astc-12x12-unorm",
        astc_12x12_unorm_srgb = "astc-12x12-unorm-srgb"
    }
    class WebGPUTextureContext implements ITextureContext {
        private _engine;
        constructor(engine: WebGPURenderEngine);
        needBitmap: boolean;
        createTexture3DInternal(dimension: TextureDimension, width: number, height: number, depth: number, format: TextureFormat, generateMipmap: boolean, sRGB: boolean, premultipliedAlpha: boolean): InternalTexture;
        setTexture3DImageData(texture: InternalTexture, source: HTMLImageElement[] | HTMLCanvasElement[] | ImageBitmap[], depth: number, premultiplyAlpha: boolean, invertY: boolean): Promise<void>;
        setTexture3DPixelsData(texture: WebGPUInternalTex, source: ArrayBufferView, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DSubPixelsData(texture: WebGPUInternalTex, source: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, zOffset: number, width: number, height: number, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        private _getGPUTexturePixelByteSize;
        private _getGPURenderTexturePixelByteSize;
        private _getGPUTextureFormat;
        private _getGPURenderTargetFormat;
        private isCompressTexture;
        getFormatPixelsParams(format: TextureFormat): {
            channels: number;
            bytesPerPixel: number;
            dataTypedCons: any;
            typedSize: number;
        };
        private _getGPUTextureDescriptor;
        createTextureInternal(dimension: TextureDimension, width: number, height: number, format: TextureFormat, generateMipmap: boolean, sRGB: boolean, premultipliedAlpha: boolean): InternalTexture;
        setTextureImageData(texture: InternalTexture, source: HTMLCanvasElement | HTMLImageElement | ImageBitmap, premultiplyAlpha: boolean, invertY: boolean): Promise<void>;
        setTextureSubImageData(texture: InternalTexture, source: HTMLCanvasElement | HTMLImageElement | ImageBitmap, x: number, y: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexturePixelsData(texture: WebGPUInternalTex, source: ArrayBufferView, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureSubPixelsData(texture: WebGPUInternalTex, source: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, width: number, height: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureDDSData(texture: WebGPUInternalTex, ddsInfo: DDSTextureInfo): void;
        setTextureKTXData(texture: WebGPUInternalTex, ktxInfo: KTXTextureInfo): void;
        setTextureHDRData(texture: WebGPUInternalTex, hdrInfo: HDRTextureInfo): void;
        setCubeImageData(texture: InternalTexture, source: (HTMLCanvasElement | HTMLImageElement | ImageBitmap)[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubePixelsData(texture: WebGPUInternalTex, source: ArrayBufferView[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubeSubPixelData(texture: WebGPUInternalTex, source: ArrayBufferView[], mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, width: number, height: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setCubeKTXData(texture: WebGPUInternalTex, ktxInfo: KTXTextureInfo): void;
        setCubeDDSData(texture: WebGPUInternalTex, ddsInfo: DDSTextureInfo): void;
        setTextureCompareMode(texture: InternalTexture, compareMode: TextureCompareMode): TextureCompareMode;
        createRenderTextureInternal(dimension: TextureDimension, width: number, height: number, format: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean): InternalTexture;
        /**
         * 判断 纹理格式 本身是否是 SRGB格式
         * @param format
         * @returns
         */
        isSRGBFormat(format: TextureFormat | RenderTargetFormat): boolean;
        supportSRGB(format: TextureFormat | RenderTargetFormat, mipmap: boolean): boolean;
        supportGenerateMipmap(format: TextureFormat | RenderTargetFormat): boolean;
        createRenderTargetInternal(width: number, height: number, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number): InternalRenderTarget;
        createRenderTargetDepthTexture(renderTarget: WebGPUInternalRT, dimension: TextureDimension, width: number, height: number): WebGPUInternalTex;
        createRenderTargetCubeInternal(size: number, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number): InternalRenderTarget;
        bindRenderTarget(renderTarget: InternalRenderTarget, faceIndex?: number): void;
        bindoutScreenTarget(): void;
        unbindRenderTarget(renderTarget: InternalRenderTarget): void;
        /**
         * @deprecated 请使用readRenderTargetPixelDataAsync函数代替
         * @param renderTarget
         * @param xOffset
         * @param yOffset
         * @param width
         * @param height
         * @param out
         */
        readRenderTargetPixelData(renderTarget: InternalRenderTarget, xOffset: number, yOffset: number, width: number, height: number, out: ArrayBufferView): ArrayBufferView;
        readRenderTargetPixelDataAsync(renderTarget: InternalRenderTarget, xOffset: number, yOffset: number, width: number, height: number, out: ArrayBufferView): Promise<ArrayBufferView>;
        initVideoTextureData(texture: WebGPUInternalTex): void;
        updateVideoTexture(texture: InternalTexture, video: HTMLVideoElement, premultiplyAlpha: boolean, invertY: boolean): Promise<void>;
        getRenderTextureDataAsync(internalTex: InternalRenderTarget, x: number, y: number, width: number, height: number): Promise<ArrayBufferView>;
    }
    /**
     * 单独的UniformBuffer
     */
    class WebGPUBufferAlone extends UniformBufferAlone {
        globalId: number;
        objectName: string;
        constructor(size: number, manager: WebGPUBufferManager);
        /**
         * 销毁
         */
        destroy(): boolean;
    }
    /**
     * Uniform内存块（小内存块）
     */
    class WebGPUBufferBlock extends UniformBufferBlock {
        globalId: number;
        objectName: string;
        constructor(sn: number, buffer: WebGPUBufferCluster, index: number, size: number, alignedSize: number, user: WebGPUUniformBuffer);
        /**
         * 销毁
         */
        destroy(): boolean;
    }
    /**
     * Uniform内存块（大内存块）
     */
    class WebGPUBufferCluster extends UniformBufferCluster {
        globalId: number;
        objectName: string;
        constructor(blockSize: number, blockNum: number, manager: WebGPUBufferManager);
        /**
         * 销毁
         */
        destroy(): boolean;
    }
    /**
     * Uniform内存块管理
     */
    class WebGPUBufferManager extends UniformBufferManager {
        globalId: number;
        objectName: string;
        constructor(useBigBuffer: boolean);
        /**
         * 销毁
         */
        destroy(): boolean;
        /**
         * 创建GPU内存对象
         * @param size 字节长度
         * @param name 名称
         */
        createGPUBuffer(size: number, name?: string): any;
        /**
         * 将数据写入GPU内存
         * @param buffer GPU内存对象
         * @param data CPU数据对象
         * @param offset 数据在大内存中的偏移量（字节）
         * @param size 写入的数据长度（字节）
         */
        writeBuffer(buffer: any, data: ArrayBuffer, offset: number, size: number): void;
        /**
         * 统计GPU内存使用量
         * @param bytes 字节
         */
        statisGPUMemory(bytes: number): void;
        /**
         * 统计上传次数
         * @param count 上传次数
         * @param bytes 上传字节
         */
        statisUpload(count: number, bytes: number): void;
    }
    /**
     * 每一个Uniform变量的具体信息
     */
    type WebGPUUniformBlockItemType = {
        propertyId: number;
        name: string;
        type: string;
        size: number;
        align: number;
        offset: number;
        element: number;
        count: number;
    };
    /**
     * UniformBlock信息
     */
    class WebGPUUniformBlockInfo {
        name: string;
        size: number;
        items: WebGPUUniformBlockItemType[];
        globalId: number;
        objectName: string;
        constructor(name: string, size: number);
        /**
         * 添加uniform字段
         * @param name
         * @param type
         * @param offset
         * @param align
         * @param size
         * @param element
         * @param count
         */
        addUniform(name: string, type: string, offset: number, align: number, size: number, element: number, count: number): void;
        /**
         * 是否具有指定的uniform
         * @param propertyId
         */
        hasUniform(propertyId: number): boolean;
        /**
         * 输出调试信息
         */
        debugInfo(): void;
        /**
         * 销毁
         */
        destroy(): void;
    }
    class WebGPUUniformBuffer extends UniformBufferUser {
        set: number;
        binding: number;
        uniformStr: string;
        globalId: number;
        objectName: string;
        private _gpuBuffer;
        private _gpuBindGroupEntry;
        constructor(name: string, set: number, binding: number, size: number, manager: WebGPUBufferManager, data: WebGPUShaderData);
        /**
         * 通知GPUBuffer改变
         */
        notifyGPUBufferChange(): void;
        /**
         * 清除GPUBuffer绑定
         */
        clearGPUBufferBind(): void;
        /**
         * 获取WebGPU绑定资源入口
         */
        getGPUBindEntry(): GPUBindGroupEntry;
        /**
         * 获取uniform名称列表
         */
        getUniformNameStr(): string;
        /**
         * 输出调试信息
         */
        debugInfo(): void;
        /**
         * 销毁
         */
        destroy(): boolean;
    }
    class WebGPUVertexBuffer implements IVertexBuffer {
        source: WebGPUBuffer;
        vertexDeclaration: VertexDeclaration;
        instanceBuffer: boolean;
        buffer: ArrayBuffer;
        globalId: number;
        objectName: string;
        constructor(targetType: BufferTargetType, bufferUsageType: BufferUsage);
        setData(buffer: ArrayBuffer, bufferOffset?: number, dataStartIndex?: number, dataCount?: number): void;
        setDataLength(byteLength: number): void;
        destroy(): void;
    }
    enum enumInOut {
        in = 0,
        out = 1,
        inout = 2
    }
    enum enumDescribe {
        uniform = 0,
        varying = 1,
        const = 2,
        mediump = 3,
        highp = 4,
        lowp = 5,
        attribute = 6
    }
    enum enumOperator {
        "!=" = 0,
        "==" = 1,
        "<=" = 2,
        ">=" = 3,
        "||" = 4,
        "&&" = 5,
        ">>" = 6,
        "<<" = 7,
        "++" = 8,
        "^^" = 9,
        "--" = 10,
        "!" = 11,
        "+" = 12,
        "-" = 13,
        "*" = 14,
        "/" = 15,
        "=" = 16,
        "<" = 17,
        ">" = 18,
        "&" = 19,
        "|" = 20,
        "^" = 21,
        "%" = 22
    }
    const boolCheck: string[];
    const _clearCR: RegExp;
    type TypeOut = {
        type: string;
        struct?: WebGPUShaderToken;
        length?: number[];
        blockName?: string;
    };
    type TypeOutData = {
        uniform?: Record<string, TypeOut>;
        varying?: Record<string, TypeOut>;
        attribute?: Record<string, TypeOut>;
        variable?: Set<String>;
    };
    class WebGPUShaderCompileCode {
        /**如果parameterNode有值，则代表当前正在解析参数，可能是函数也可能是函数调用 */
        private static _parameterNode;
        /**当前的父节点，一般都是往父节点里面添加节点 */
        private static _parentNode;
        /**是否当前正在检测Type */
        private static _isCheckType;
        /**当前正在处理中的Node节点，一般是parameterNode的child的最后一个或者——parentNode的child最后一个节点 */
        private static __currNode;
        /**当前刚刚设置过名字的Node，如果后面发现是个函数的话，直接给該node这是parameter属性 */
        private static _currNameNode;
        /**当前的函数参数，或者函数调用的参数 */
        private static _currParame;
        /**用户当前checkBodyName的函数体，如果未写大括号会临时放到这里面 */
        private static _currTmpBody;
        private static _isCheckBody3;
        private static _uniform;
        private static _attribute;
        private static _varying;
        private static _variable;
        private static _struct;
        private static _varUniform;
        /**宏替换参数 */
        private static _define;
        static compile(code: string): WebGPUShaderToken;
        private static get _currNode();
        private static set _currNode(value);
        private static get isCheckType();
        private static set isCheckType(value);
        private static get currNode();
        /**
         * 当退出一个函数参数，需要更新currNode为当前_parentNode的最后一个或者_parameterNode的最后一个节点
         */
        private static updateCurrNode;
        /**
         * @param parameterType 0为(),1为[]
         */
        private static newParameterNode;
        static isEmptyNode(node: WebGPUShaderToken, isCheckParent?: boolean): boolean;
        /**
         *
         * @param isForceCreate 设置force以后，自动会给当前的_parameterNode节点或者_parentNode节点下面增加一个新的节点并且返回
         * @returns
         */
        private static nextCurrNode;
        private static _compileToTree;
        private static _checkStructDef;
        private static _checkTypeByString;
        private static get _isFor();
        private static _parseParameter;
        private static _addParam;
        private static _checkParameter;
        private static _body3Fin;
        /** 这里是对类似if，for，while没有加{}做判断的逻辑 */
        private static _checkBody3;
        private static _checkBody;
        private static _splitTextCheck;
        private static _childFin;
        private static _checkType;
        /**对于等号的检测 */
        private static _checkEqual;
        /**这是给当前节点设置nodeName，一般是在checktype里面调用,也可以确定value里面不会存在表达式的时候直接调用*/
        private static _setNodeName;
        /**分解运算符等等,设置函数名，变量名或者常量理论上这里不应该出现函数嵌套,设置node的Name也应该用setNodeName */
        private static _checkBody2;
        private static _checkOperator;
        private static _parseNode;
        /**
         * 移除代码中的所有注释
         * @param text
         * @returns
         */
        private static removeAnnotation;
    }
    class WebGPUShaderCompileDef {
        /**当前的父节点，一般都是往父节点里面添加节点 */
        private static _parentNode;
        /**当前正在处理中的Node节点，一般是parameterNode的child的最后一个或者——parentNode的child最后一个节点 */
        private static _currNode;
        private static _defs;
        static compile(code: string, defs?: Set<string>): WebGPUShaderToken;
        static isEmptyNode(node: WebGPUShaderToken): boolean;
        /**
         *
         * @param isForceCreate 设置force以后，自动会给当前的_parameterNode节点或者_parentNode节点下面增加一个新的节点并且返回
         * @returns
         */
        private static nextCurrNode;
        private static get currNode();
        private static _compileToTree;
        private static _parseNode;
    }
    class WebGPUShaderCompileUtil {
        static checkDef(node: WebGPUShaderToken, _defs: Set<string>): void;
        /**
         * 提取宏定义
         * @param code
         */
        static extractMacros(code: string): WebGPU_GLSLMacro[];
        static macrosToVariable(macros: WebGPU_GLSLMacro[]): Set<string>;
        static toScript(root: WebGPUShaderToken, def?: Record<string, boolean>, outData?: TypeOutData): string;
        static removeUniform(code: string): string;
        static removeVarying(code: string): string;
        static checkCondition(st: WebGPUShaderToken, def: Record<string, boolean>): boolean;
        private static _parseChilds;
    }
    class WebGPUShaderDefine {
        /**
         * 查找代码中的数字宏定义
         * @param code
         * @param map
         */
        static findNumberDefine(code: string, map?: Map<string, string>): Map<string, string>;
    }
    class WebGPUShaderToken {
        uniform: Record<string, TypeOut>;
        variable: Set<string>;
        structs: Record<string, WebGPUShaderToken>;
        varying: Record<string, TypeOut>;
        attribute: Record<string, TypeOut>;
        /**是否是赋值状态 */
        assign: boolean;
        /**类似于+=、-=、/=、*=、>>=、<<=这种逻辑 */
        assignLeft: enumOperator;
        includefiles: any[];
        describe: enumDescribe;
        childs: WebGPUShaderToken[];
        parent: WebGPUShaderToken;
        inOrOut: enumInOut;
        /**如果是函数，这里就是函数名，否则是变量名,或者是精度定义 */
        name: string;
        /**原始未解析的代码 */
        code: string;
        /**用原始code分析出来的语法树 */
        root: WebGPUShaderToken;
        /**节点的类型，例如vec4，float...如果是函数，则是函数的返回值,还有可能是参数的分隔符,或者?或者: */
        type: string;
        /**操作符，例如=、+、-、*、/ */
        operator: enumOperator;
        /**操作符是在name的左侧还是右侧，通常是用于++和--，但是有时也会用于= */
        operatorRight: boolean;
        /**函数类型的话会有这些参数数据 */
        parameter: WebGPUShaderToken;
        /**这里是数组参数a[][]这种，支持多维数组 */
        parameterArr: WebGPUShaderToken[];
        /**参数数据的数据源 */
        owner: WebGPUShaderToken;
        /**ifdef的参数 */
        defParam: string[] | WebGPUShaderToken;
        /**这里是uniform或者struct后面默认追加变量定义的地方 */
        varNames: string[];
        z: number;
        constructor(includefiles?: any[]);
        condition(def: Record<string, boolean>): boolean;
        addParameterArr(param: WebGPUShaderToken, parent?: WebGPUShaderToken): void;
        setParameter(param: WebGPUShaderToken, parent?: WebGPUShaderToken): void;
        addBody(body: WebGPUShaderToken): void;
        setParent(parent: WebGPUShaderToken): void;
        private _parseShaderNode;
        private _getParameter;
        private _getParameterArr;
        toscript(def?: Record<string, boolean>, out?: string[]): string[];
    }
    class BlendState {
        static _blend_All_pool: any;
        static _blend_seperate_pool: any;
        static create(blendType: number, colorBlendhash: BlendComponent, alphaBlendComponent: BlendComponent): void;
        /** Whether to enable blend. */
        blendType: BlendType;
        colorBlendComponent: BlendComponent;
        alphaBlendComponent: BlendComponent;
        constructor(blendType: number);
    }
    class BlendComponent {
        static _pool: any;
        static getHash(blendOperationGLData: number, sourceBlendFactor: number, destinationFactor: number): number;
        static getBlendComponent(blendOperationGLData: number, sourceBlendFactor: number, destinationFactor: number): any;
        _blendOperation: BlendEquationSeparate;
        _blendOperationGLData: number;
        _sourceBlendFactor: BlendFactor;
        _sourceBlendFactorGLData: number;
        _destinationFactor: BlendFactor;
        _destinationFactorGLData: number;
        _hashIndex: number;
        constructor(blendOperationGLData: BlendEquationSeparate, sourceBlendFactor: BlendFactor, destinationFactor: BlendFactor, hashindex: number);
    }
    class Buffer {
        _buffer: Float32Array | Uint16Array | Uint8Array | Uint32Array;
        _bufferType: number;
        _bufferUsage: number;
        _byteLength: number;
        get bufferUsage(): number;
        constructor(targetType: BufferTargetType, bufferUsageType: BufferUsage);
        /**
         * @private
         */
        destroy(): void;
    }
    /**
     * dds 未存储 color space 需要手动指定
     */
    class DDSTextureInfo {
        width: number;
        height: number;
        mipmapCount: number;
        isCube: boolean;
        bpp: number;
        blockBytes: number;
        format: TextureFormat;
        compressed: boolean;
        dataOffset: number;
        source: ArrayBuffer;
        constructor(width: number, height: number, mipmapCount: number, isCube: boolean, bpp: number, blockBytes: number, dataOffset: number, format: TextureFormat, compressed: boolean, sourceData: ArrayBuffer);
        static getDDSTextureInfo(source: ArrayBuffer): DDSTextureInfo;
    }
    class DepthState {
    }
    /**
     * https://floyd.lbl.gov/radiance/framer.html
     */
    class HDRTextureInfo {
        source: ArrayBuffer;
        byteOffset: number;
        decreaseX: boolean;
        decreaseY: boolean;
        width: number;
        height: number;
        format: TextureFormat;
        static HDRTEXTURE: string;
        static _parseHDRTexture(data: ArrayBuffer, propertyParams?: any, constructParams?: any[]): Texture2D;
        /**
         *
         * @param source
         */
        static getHDRInfo(source: ArrayBuffer): HDRTextureInfo;
        private static getLineString;
        constructor(source: ArrayBuffer, byteOffset: number, decreaseX: boolean, decreaseY: boolean, width: number, height: number, format: TextureFormat);
        get_32_bit_rle_rgbe(): ArrayBufferView;
        /**
         * https://www.radiance-online.org/archived/radsite/radiance/refer/Notes/picture_format.html
         */
        readScanLine(): ArrayBufferView;
        readcolors(scanlineArray: Uint8Array, getc: () => number, wrong: () => void): void;
        olddreadcolors(scanlineArray: Uint8Array, getc: () => number, r: number, g: number, b: number, e: number): void;
        color_color(col: Vector4, clr: Vector4): void;
    }
    class IndexBuffer extends Buffer {
        constructor(targetType: BufferTargetType, bufferUsageType: BufferUsage);
    }
    /**
     * https://www.khronos.org/registry/KTX/specs/1.0/ktxspec_v1.html
     * https://www.khronos.org/registry/KTX/specs/2.0/ktxspec_v2.html
     */
    class KTXTextureInfo {
        source: ArrayBuffer;
        compress: boolean;
        sRGB: boolean;
        dimension: TextureDimension;
        width: number;
        height: number;
        format: TextureFormat;
        mipmapCount: number;
        bytesOfKeyValueData: number;
        headerOffset: number;
        static getLayaFormat(glFormat: number, glInternalFormat: number, glType: number, glTypeSize: number): {
            format: TextureFormat;
            sRGB: boolean;
        };
        static getKTXTextureInfo(source: ArrayBuffer): KTXTextureInfo;
        static createKTX1Info(source: ArrayBuffer): KTXTextureInfo;
        constructor(source: ArrayBuffer, compress: boolean, sRGB: boolean, dimension: TextureDimension, width: number, height: number, format: TextureFormat, mipmapCount: number, bytesOfKeyValueData: number, headerOffset: number);
    }
    enum BlendEquationSeparate {
        ADD = 0,
        SUBTRACT = 1,
        REVERSE_SUBTRACT = 2,
        MIN = 3,
        MAX = 4
    }
    enum BlendFactor {
        /** (0, 0, 0, 0)*/
        Zero = 0,
        /** (1, 1, 1, 1)*/
        One = 1,
        /** (Rs, Gs, Bs, As) */
        SourceColor = 2,
        /** (1 - Rs, 1 - Gs, 1 - Bs, 1 - As)*/
        OneMinusSourceColor = 3,
        /** (Rd, Gd, Bd, Ad)*/
        DestinationColor = 4,
        /** (1 - Rd, 1 - Gd, 1 - Bd, 1 - Ad)*/
        OneMinusDestinationColor = 5,
        /** (As, As, As, As)*/
        SourceAlpha = 6,
        /** (1 - As, 1 - As, 1 - As, 1 - As)*/
        OneMinusSourceAlpha = 7,
        /** (Ad, Ad, Ad, Ad)*/
        DestinationAlpha = 8,
        /** (1 - Ad, 1 - Ad, 1 - Ad, 1 - Ad)*/
        OneMinusDestinationAlpha = 9,
        /** (min(As, 1 - Ad), min(As, 1 - Ad), min(As, 1 - Ad), 10)*/
        SourceAlphaSaturate = 10,
        /** (Rc, Gc, Bc, Ac)*/
        BlendColor = 11,
        /** (1 - Rc, 1 - Gc, 1 - Bc, 1 - Ac)*/
        OneMinusBlendColor = 12
    }
    enum BlendType {
        /**混合枚举_禁用。*/
        BLEND_DISABLE = 0,
        /**混合枚举_启用_RGB和Alpha统一混合。*/
        BLEND_ENABLE_ALL = 1,
        /**混合枚举_启用_RGB和Alpha单独混合。*/
        BLEND_ENABLE_SEPERATE = 2
    }
    enum BufferTargetType {
        ARRAY_BUFFER = 0,
        ELEMENT_ARRAY_BUFFER = 1,
        UNIFORM_BUFFER = 2,
        COPY_READ_BUFFER = 3,
        COPY_WRITE_BUFFER = 4,
        TRANSFORM_FEEDBACK_BUFFER = 5
    }
    /**
     * Buffer usage.
     */
    enum BufferUsage {
        /** The buffer content are intended to be specified once, and used many times */
        Static = 0,
        /** The buffer contents are intended to be respecified repeatedly, and used many times */
        Dynamic = 1,
        /** The buffer contents are intended to be specified once, and used at most a few times */
        Stream = 2
    }
    enum CompareFunction {
        /** never pass. */
        Never = 0,
        /** pass if the incoming value is less than the depth/stencil buffer value. */
        Less = 1,
        /** pass if the incoming value equals the depth/stencil buffer value. */
        Equal = 2,
        /** pass if the incoming value is less than or equal to the depth/stencil buffer value. */
        LessEqual = 3,
        /** pass if the incoming value is greater than the depth/stencil buffer value. */
        Greater = 4,
        /** pass if the incoming value is not equal to the depth/stencil buffer value. */
        NotEqual = 5,
        /** pass if the incoming value is greater than or equal to the depth/stencil buffer value. */
        GreaterEqual = 6,
        /** always pass. */
        Always = 7,
        /** off */
        Off = 8
    }
    enum CullMode {
        /** Disable culling. */
        Off = 0,
        /** cut the front-face of the polygons. */
        Front = 1,
        /** cut the back-face of the polygons. */
        Back = 2
    }
    enum FrontFace {
        /** Clockwise front faces. */
        CW = 0,
        /** Counter-clockwise front faces. */
        CCW = 1
    }
    enum DrawType {
        DrawArray = 0,
        DrawArrayInstance = 1,
        DrawElement = 2,
        DrawElementInstance = 3
    }
    /**
     * 纹理的过滤模式。
     */
    enum FilterMode {
        /**点过滤。*/
        Point = 0,
        /**双线性过滤。*/
        Bilinear = 1,
        /**三线性过滤。*/
        Trilinear = 2
    }
    enum HDREncodeFormat {
        NONE = 0,
        RGBM = 1,
        RGBD = 2
    }
    enum IndexFormat {
        /** 8 位无符号整型索引格式。*/
        UInt8 = 0,
        /** 16 位无符号整型索引格式。*/
        UInt16 = 1,
        /** 32 位无符号整型索引格式。*/
        UInt32 = 2
    }
    enum RenderCapable {
        Element_Index_Uint32 = 0,
        TextureFormat_R32G32B32A32 = 1,
        TextureFormat_R16G16B16A16 = 2,
        Texture_anisotropic = 3,
        RenderTextureFormat_R16G16B16A16 = 4,
        RenderTextureFormat_R32G32B32A32 = 5,
        RenderTextureFormat_Depth = 6,
        RenderTextureFormat_ShadowMap = 7,
        Vertex_VAO = 8,
        DrawElement_Instance = 9,
        Shader_TextureLod = 10,
        COMPRESS_TEXTURE_S3TC = 11,
        COMPRESS_TEXTURE_S3TC_SRGB = 12,
        COMPRESS_TEXTURE_PVRTC = 13,
        COMPRESS_TEXTURE_ETC1 = 14,
        COMPRESS_TEXTURE_ETC = 15,
        COMPRESS_TEXTURE_ASTC = 16,
        Texture_SRGB = 17,
        MSAA = 18,
        UnifromBufferObject = 19,
        Texture3D = 20,
        Texture_FloatLinearFiltering = 21,
        Texture_HalfFloatLinearFiltering = 22
    }
    enum RenderClearFlag {
        Nothing = 0,
        Color = 1,
        Depth = 2,
        Stencil = 4
    }
    enum RenderDrawMode {
        TRIANGLES = 0,
        POINTS = 1,
        LINES = 2
    }
    enum RenderIndexMode {
        UNSIGNED_BYTE = 0,
        UNSIGNED_SHORT = 1,
        UNSIGNED_INT = 2
    }
    enum RenderParams {
        Max_Active_Texture_Count = 0,
        Max_Uniform_Count = 1,
        Max_AnisoLevel_Count = 2,
        MAX_Texture_Size = 3,
        MAX_Texture_Image_Uint = 4,
        SHADER_CAPAILITY_LEVEL = 5,
        FLOAT = 6,
        UNSIGNED_BYTE = 7,
        BYTE = 8,
        UNSIGNED_SHORT = 9
    }
    /**
     * Mesh topology.
     */
    enum MeshTopology {
        /** Draws a single dot */
        Points = 0,
        /** Draws a line between a pair of vertices */
        Lines = 1,
        /** Draws a straight line to the next vertex, and connects the last vertex back to the first */
        LineLoop = 2,
        /** Draws a straight line to the next vertex. */
        LineStrip = 3,
        /** Draws a triangle for a group of three vertices */
        Triangles = 4,
        /** Draws a triangle strip */
        TriangleStrip = 5,
        /** Draws a triangle fan */
        TriangleFan = 6
    }
    enum RenderStateType {
        DepthTest = 0,
        DepthMask = 1,
        DepthFunc = 2,
        StencilTest = 3,
        StencilMask = 4,
        StencilFunc = 5,
        StencilOp = 6,
        BlendType = 7,
        BlendEquation = 8,
        BlendEquationSeparate = 9,
        BlendFunc = 10,
        BlendFuncSeperate = 11,
        CullFace = 12,
        FrontFace = 13
    }
    /**
     * 渲染统计数据
     */
    enum GPUEngineStatisticsInfo {
        C_UniformBufferUploadCount = 0,
        C_GeometryBufferUploadCount = 1,
        C_TriangleCount = 2,
        C_SetRenderPassCount = 3,
        C_DrawCallCount = 4,
        C_Instancing_DrawCallCount = 5,
        C_ShaderCompile = 6,
        T_ShaderCompile = 7,
        FrameClearCount = 8,
        M_GPUMemory = 9,
        M_GPUBuffer = 10,
        M_VertexBuffer = 11,
        M_IndexBuffer = 12,
        M_UniformBlockBuffer = 13,
        RC_GPUBuffer = 14,
        RC_VertexBuffer = 15,
        RC_IndexBuffer = 16,
        RC_UniformBlockBuffer = 17,
        M_ALLTexture = 18,
        M_Texture2D = 19,
        M_TextureCube = 20,
        M_Texture3D = 21,
        M_Texture2DArray = 22,
        RC_ALLTexture = 23,
        RC_Texture2D = 24,
        RC_TextureCube = 25,
        RC_Texture3D = 26,
        RC_Texture2DArray = 27,
        M_ALLRenderTexture = 28,
        RC_ALLRenderTexture = 29,
        Count = 30
    }
    /**
     * 渲染流程统计数据
     */
    enum RenderPassStatisticsInfo {
        T_CameraRender = 0,
        T_Render_OpaqueRender = 1,
        T_Render_TransparentRender = 2,
        T_Render_PostProcess = 3,
        T_Render_CameraEventCMD = 4,
        T_Render_ShadowPassMode = 5,
        T_Render_CameraOtherDest = 6,
        T_RenderPreUpdate = 7,
        T_OtherRender = 8,
        T_OnlyMeshRender = 9,
        T_OnlySkinnedMeshRender = 10,
        T_OnlyShurikenParticleRender = 11,
        T_CameraMainCull = 12,
        T_ShadowMapCull = 13,
        RenderPassStatisticCount = 14
    }
    enum RenderTargetFormat {
        None = -1,
        /**使用RGB的纹理，不可设置SRGB参数 */
        R8G8B8 = 0,
        R8G8B8A8 = 1,
        R16G16B16A16 = 17,
        R32G32B32 = 30,
        R32G32B32A32 = 15,
        R16G16B16 = 31,
        DEPTH_16 = 35,
        STENCIL_8 = 36,
        DEPTHSTENCIL_24_8 = 37,
        DEPTH_32 = 38,
        DEPTHSTENCIL_24_Plus = 39
    }
    enum StencilOperation {
        /** Keeps the current value. */
        Keep = 0,
        /** Sets the stencil buffer value to 0. */
        Zero = 1,
        /** Sets the stencil buffer value to the reference value. */
        Replace = 2,
        /** Increments the current stencil buffer value. Clamps to the maximum representable unsigned value. */
        IncrementSaturate = 3,
        /** Decrements the current stencil buffer value. Clamps to 0. */
        DecrementSaturate = 4,
        /** Inverts the current stencil buffer value bitwise. */
        Invert = 5,
        /** Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the maximum representable unsigned value. */
        IncrementWrap = 6,
        /** Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable unsigned value when decrementing a stencil buffer value of 0. */
        DecrementWrap = 7
    }
    enum TextureCompareMode {
        None = 0,
        LEQUAL = 1,
        GEQUAL = 2,
        LESS = 3,
        GREATER = 4,
        EQUAL = 5,
        NOTEQUAL = 6,
        ALWAYS = 7,
        NEVER = 8
    }
    /**
     * 纹理解码格式。
     */
    enum TextureDecodeFormat {
        /** 常规解码方式,直接采样纹理颜色。*/
        Normal = 0,
        /** 按照RGBM方式解码并计算最终RGB颜色。 */
        RGBM = 1
    }
    enum TextureDimension {
        Tex2D = 0,
        Cube = 1,
        Tex3D = 2,
        Texture2DArray = 3,
        CubeArray = 4,
        Unkonw = 5,
        None = 6
    }
    /**
     * 纹理格式
     */
    enum TextureFormat {
        /**纹理格式_R8G8B8。*/
        R8G8B8 = 0,
        /**纹理格式_R8G8B8A8。*/
        R8G8B8A8 = 1,
        /**RGB格式纹理,R通道5位，G通道6位，B通道5位。*/
        R5G6B5 = 16,
        /**纹理格式_ALPHA8。*/
        Alpha8 = 2,
        /**纹理格式_DXT1。*/
        DXT1 = 3,
        /**纹理格式_DXT3 */
        DXT3 = 29,
        /**纹理格式_DXT5。*/
        DXT5 = 4,
        /**纹理格式_ETC2RGB。*/
        ETC1RGB = 5,
        ETC2RGB = 6,
        ETC2RGBA = 7,
        /**纹理格式_ETC2RGB_PUNCHTHROUGHALPHA。*/
        /**纹理格式_PVRTCRGB_2BPPV。*/
        ETC2SRGB_Alpha8 = 8,
        /** 纹理格式_ETC2SRGB*/
        ETC2SRGB = 28,
        /** 纹理格式 RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
        ETC2RGB_Alpha1 = 32,
        /** 纹理格式 SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
        ETC2SRGB_Alpha1 = 33,
        /** 纹理格式_PVRTCRGB_2BPPV*/
        PVRTCRGB_2BPPV = 9,
        /**纹理格式_PVRTCRGBA_2BPPV。*/
        PVRTCRGBA_2BPPV = 10,
        /**纹理格式_PVRTCRGB_4BPPV。*/
        PVRTCRGB_4BPPV = 11,
        /**纹理格式_PVRTCRGBA_4BPPV。*/
        PVRTCRGBA_4BPPV = 12,
        /**RGBA格式纹理,每个通道32位浮点数。*/
        R32G32B32A32 = 15,
        /**R32G32B32 */
        R32G32B32 = 30,
        /**RGBA格式纹理，每个通道16位浮点数。 */
        R16G16B16A16 = 17,
        /**R16 G16 B6 */
        R16G16B16 = 31,
        /**ASTC 4x4*/
        ASTC4x4 = 18,
        /**ASTC sRGB 4x4 */
        ASTC4x4SRGB = 23,
        /**ASTC 6x6*/
        ASTC6x6 = 19,
        /**ASTC  6x6*/
        ASTC6x6SRGB = 24,
        /**ASTC 8x8 */
        ASTC8x8 = 20,
        /**ASTC srgb 8x8 */
        ASTC8x8SRGB = 25,
        /**ASTC 10x10 */
        ASTC10x10 = 21,
        /**ASTC srgb 10x10 */
        ASTC10x10SRGB = 26,
        /**ASTC 12x12 */
        ASTC12x12 = 22,
        /**ASTC srgb 12x12 */
        ASTC12x12SRGB = 27,
        /**ktx图片 */
        KTXTEXTURE = -1,
        /**pvr图片 */
        PVRTEXTURE = -2
    }
    /**
     * 纹理寻址模式。
     */
    enum WrapMode {
        /** 循环平铺。*/
        Repeat = 0,
        /** 超过UV边界后采用最后一个像素。*/
        Clamp = 1,
        /** 镜像采样 */
        Mirrored = 2
    }
    interface IShaderObjStructor {
        name: string;
        enableInstancing: boolean;
        supportReflectionProbe: boolean;
        surportVolumetricGI: boolean;
        attributeMap: any;
        uniformMap: any;
        defaultValue: any;
        shaderPass: Array<any>;
    }
    interface IShaderpassStructor {
        VS?: string;
        FS?: string;
        VSPath?: string;
        FSPath?: string;
        pipeline?: string;
        statefirst?: boolean;
        renderState?: Record<string, string | boolean | number | string[]>;
    }
    enum ShaderFeatureType {
        DEFAULT = 0,
        D3 = 1,
        D2 = 2,
        PostProcess = 3,
        Sky = 4,
        Effect = 5
    }
    /**
     * <code>Shader3D</code> 类用于创建Shader3D。
     */
    class Shader3D {
        static _configDefineValues: IDefineDatas;
        /**渲染状态_剔除。*/
        static CULL: number;
        /**渲染状态_混合。*/
        static BLEND: number;
        /**渲染状态_混合源。*/
        static BLEND_SRC: number;
        /**渲染状态_混合目标。*/
        static BLEND_DST: number;
        /**渲染状态_混合源RGB。*/
        static BLEND_SRC_RGB: number;
        /**渲染状态_混合目标RGB。*/
        static BLEND_DST_RGB: number;
        /**渲染状态_混合源ALPHA。*/
        static BLEND_SRC_ALPHA: number;
        /**渲染状态_混合目标ALPHA。*/
        static BLEND_DST_ALPHA: number;
        /**渲染状态_混合方程。*/
        static BLEND_EQUATION: number;
        /**渲染状态_混合方程。*/
        static BLEND_EQUATION_RGB: number;
        /**渲染状态_ALPHA混合方程。*/
        static BLEND_EQUATION_ALPHA: number;
        /**渲染状态_深度测试。*/
        static DEPTH_TEST: number;
        /**渲染状态_深度写入。*/
        static DEPTH_WRITE: number;
        /**渲染状态_模板测试。*/
        static STENCIL_TEST: number;
        /**渲染状态_模板写入 */
        static STENCIL_WRITE: number;
        /**渲染状态_模板写入值 */
        static STENCIL_Ref: number;
        /**渲染状态_模板写入设置 */
        static STENCIL_Op: number;
        /**shader变量提交周期，自定义。*/
        static PERIOD_CUSTOM: number;
        /**shader变量提交周期，逐材质。*/
        static PERIOD_MATERIAL: number;
        /**shader变量提交周期，逐精灵和相机，注：因为精灵包含MVP矩阵，为复合属性，所以摄像机发生变化时也应提交。*/
        static PERIOD_SPRITE: number;
        /**shader变量提交周期，逐相机。*/
        static PERIOD_CAMERA: number;
        /**shader变量提交周期，逐场景。*/
        static PERIOD_SCENE: number;
        /**是否开启调试模式。 */
        static debugMode: boolean;
        static init(): void;
        /**
         * 注册宏定义。
         * @param name
         */
        static getDefineByName(name: string): ShaderDefine;
        /**
         * 通过Shader属性名称获得唯一ID。
         * @param name Shader属性名称。
         * @return 唯一ID。
         */
        static propertyNameToID(name: string): number;
        static propertyIDToName(id: number): string;
        /**
         * 添加函数库引用。
         * @param fileName 文件名字。
         * @param txt 文件内容
         */
        static addInclude(fileName: string, txt: string): void;
        /**
         * 通过宏定义名字编译shader。
         * @param	shaderName Shader名称。
         * @param   subShaderIndex 子着色器索引。
         * @param   passIndex  通道索引。
         * @param	defineNames 宏定义名字集合。
         */
        static compileShaderByDefineNames(shaderName: string, subShaderIndex: number, passIndex: number, defineNames: string[], nodeCommonMap: string[]): boolean;
        /**
         * 添加预编译shader文件，主要是处理宏定义
         */
        static add(name: string, enableInstancing?: boolean, supportReflectionProbe?: boolean): Shader3D;
        /**
         * 获取ShaderCompile3D。
         * @param	name
         * @return ShaderCompile3D。
         */
        static find(name: string): Shader3D;
        static parse(data: IShaderObjStructor, basePath: string): Shader3D;
        shaderType: ShaderFeatureType;
        /**
         * 名字。
         */
        get name(): string;
        /**
         * 创建一个 <code>Shader3D</code> 实例。
         */
        constructor(name: string, enableInstancing: boolean, supportReflectionProbe: boolean);
        /**
         * 添加子着色器。
         */
        addSubShader(subShader: SubShader): void;
        /**
         * 在特定索引获取子着色器。
         * @param	index 索引。
         * @return 子着色器。
         */
        getSubShaderAt(index: number): SubShader;
    }
    /**
     * <code>ShaderPass</code> 类用于实现ShaderPass。
     */
    class ShaderPass extends ShaderCompileDefineBase {
        get pipelineMode(): string;
        set pipelineMode(value: string);
        set nodeCommonMap(value: Array<string>);
        get nodeCommonMap(): Array<string>;
        /** 优先 ShaderPass 渲染状态 */
        private _statefirst;
        get statefirst(): boolean;
        set statefirst(value: boolean);
        moduleData: IShaderPassData;
        /**
         * 渲染状态。
         */
        get renderState(): RenderState;
        constructor(owner: SubShader, compiledObj: IShaderCompiledObj);
    }
    /**
     *  <code>shaderVariable</code> 类用于保存shader变量上传相关信息。
     */
    class ShaderVariable {
        static pointID: number;
        /**
         * 创建一个 <code>shaderVariable</code> 实例。
         */
        constructor();
    }
    /**
     * 着色器变种。
     */
    class ShaderVariant {
        /**
         * 着色器。
         */
        get shader(): Shader3D;
        /**
         * 子着色器索引。
         */
        get subShaderIndex(): number;
        /**
         * 通道索引。
         */
        get passIndex(): number;
        /**
         * 宏定义集合。
         */
        get defineNames(): Readonly<string[]>;
        /**
         * 创建着色器变种。
         * @param shader 着色器
         * @param subShaderIndex 子着色器索引
         * @param passIndex 通道索引
         * @param defines 宏定义集合
         */
        constructor(shader: Shader3D, subShaderIndex: number, passIndex: number, defines: string[]);
        /**
         * 给着色器变种赋值。
         * @param shader 着色器
         * @param subShaderIndex 子着色器索引
         * @param passIndex 通道索引
         * @param defineNames 宏定义集合
         */
        setValue(shader: Shader3D, subShaderIndex: number, passIndex: number, defineNames: string[]): void;
        /**
         * 是否相等。
         * @param other 其它着色器变种
         * @return 是否相等。
         */
        equal(other: ShaderVariant): boolean;
        /**
         * 克隆。
         * @return 着色器变种。
         */
        clone(): ShaderVariant;
    }
    interface IShaderVariant {
        subShaderIndex: number;
        passIndex: number;
        defines: string[];
        nodeCommonMap: string[];
    }
    /**
     * 着色器变种集合。
     */
    class ShaderVariantCollection {
        static active: ShaderVariantCollection;
        items: Record<string, IShaderVariant[]>;
        constructor(items?: Record<string, IShaderVariant[]>);
        add(shaderPass: ShaderPass, defines: ReadonlyArray<string>): void;
        compileAll(): void;
    }
    type UniformMapType = {
        [blockName: string]: {
            [uniformName: string]: ShaderDataType;
        } | ShaderDataType;
    };
    type AttributeMapType = {
        [name: string]: [
            number,
            ShaderDataType
        ];
    };
    /**
     * <code>SubShader</code> 类用于创建SubShader。
     */
    class SubShader {
        static IncludeUniformMap: any;
        /**
         * 注册glsl所用到的Uniform
         * 会在生成Uniformmap的时候根据包含的Include文件，添加所需要的uniform因素
         */
        static regIncludeBindUnifrom(includeName: string, uniformMap: {
            [name: string]: ShaderDataType;
        }, defaultValue: {
            [key: string]: any;
        }): void;
        static readonly DefaultAttributeMap: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        };
        moduleData: ISubshaderData;
        /**
         * 创建一个 <code>SubShader</code> 实例。
         * @param	attributeMap  顶点属性表。
         * @param	uniformMap  uniform属性表。
         */
        constructor(attributeMap?: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        }, uniformMap?: UniformMapType, uniformDefaultValue?: {
            [name: string]: ShaderDataItem;
        });
        /**
         * 添加着色器Pass
         * @param vs
         * @param ps
         * @param pipelineMode 渲染管线模式。
         */
        addShaderPass(vs: string, ps: string, pipelineMode?: string): ShaderPass;
        _addShaderPass(compiledObj: IShaderCompiledObj, pipelineMode?: string): ShaderPass;
        private _addIncludeUniform;
    }
    /**
     * ...
     * @author ...
     */
    class VertexMesh {
        /**顶点位置数据 */
        static MESH_POSITION0: number;
        /**顶点顶点色数据 */
        static MESH_COLOR0: number;
        /**顶点UV0数据 */
        static MESH_TEXTURECOORDINATE0: number;
        /**顶点法线数据 */
        static MESH_NORMAL0: number;
        /**顶点切线数据 */
        static MESH_TANGENT0: number;
        /**顶点骨骼索引数据 */
        static MESH_BLENDINDICES0: number;
        /**顶点骨骼权重数据 */
        static MESH_BLENDWEIGHT0: number;
        /**顶点UV1数据 */
        static MESH_TEXTURECOORDINATE1: number;
        /**顶点世界矩阵数据Row0 */
        static MESH_WORLDMATRIX_ROW0: number;
        /**顶点世界矩阵数据Row1 */
        static MESH_WORLDMATRIX_ROW1: number;
        /**顶点世界矩阵数据Row2 */
        static MESH_WORLDMATRIX_ROW2: number;
        /**顶点世界矩阵数据Row3 */
        static MESH_WORLDMATRIX_ROW3: number;
        /**简单数据动画数据 */
        static MESH_SIMPLEANIMATOR: number;
        /**光照贴图的缩放和偏移 */
        static MESH_LIGHTMAPSCALEOFFSET: number;
        /**instanceworld顶点描述 */
        static instanceWorldMatrixDeclaration: VertexDeclaration;
        /**instanceSimple动画数据顶点描述 */
        static instanceSimpleAnimatorDeclaration: VertexDeclaration;
        /**instanceLightMap光照贴图的缩放和偏移顶点描述 */
        static instanceLightMapScaleOffsetDeclaration: VertexDeclaration;
        /**自定义attribute instance 预留位*/
        /**顶点自定义数据0 */
        static MESH_CUSTOME0: number;
        /**顶点自定义数据1 */
        static MESH_CUSTOME1: number;
        /**顶点自定义数据2 */
        static MESH_CUSTOME2: number;
        /**顶点自定义数据3 */
        static MESH_CUSTOME3: number;
        /**
         * 获取顶点声明。
         * @param vertexFlag 顶点声明标记字符,格式为:"POSITION,NORMAL,COLOR,UV,UV1,BLENDWEIGHT,BLENDINDICES,TANGENT"。
         * @return 顶点声明。
         */
        static getVertexDeclaration(vertexFlag: string, compatible?: boolean): VertexDeclaration;
    }
    /**
     * @private
     */
    class RenderStateContext {
        /**
         * 模板写入开关
         * @param gl
         * @param value
         */
        static setStencilMask(value: boolean): void;
    }
    class StencilState {
    }
    class SubUniformBufferData extends UnifromBufferData {
        /**
         * create UniformBufferData Instance
         * @param uniformParamsStat Params describe
         */
        constructor(uniformParamsStat: Map<number, UniformBufferParamsType>, bufferOffset: number);
    }
    /**
     * 管理
     */
    class UniformBufferBase {
    }
    /**
     *描述UniformBuffer参数类型
     */
    enum UniformBufferParamsType {
        Number = 0,
        Vector2 = 1,
        Vector3 = 2,
        Vector4 = 3,
        Matrix4x4 = 4,
        Vector4Array = 5,
        MatrixArray = 6
    }
    /**
     * 实例化UniformBuffer数据
     * 注：要与glsl中Uniform block结构相同
     */
    class UnifromBufferData {
        /**
         * Buffer Data
         */
        _buffer: Float32Array;
        /**
         * create UniformBufferData Instance
         * @param uniformParamsStat Params describe
         */
        constructor(uniformParamsStat: Map<number, UniformBufferParamsType>);
        /**
         * get Buffer byte length
         * @returns
         */
        getbyteLength(): number;
        /**
         * set Vector4Array by paramsName
         * @param name uniform params name
         * @param value vector4Array data
         */
        setVector4Array(name: string, value: Vector4[]): void;
        /**
         * set Vector4Array by paramsIndex
         * @param uniformID uniform params index
         * @param value vector4Array data
         * @returns
         */
        setVector4ArraybyIndex(uniformID: number, value: Vector4[]): void;
        /**
         * set MatrixArray by paramsName
         * @param name uniform params name
         * @param value MatrixArray data
         */
        setMatrixArray(name: string, value: Matrix4x4[]): void;
        /**
         * set MatrixArray by paramsIndex
         * @param uniformID uniform params index
         * @param value MatrixArray data
         * @returns
         */
        setMatrixArraybyIndex(uniformID: number, value: Matrix4x4[]): void;
        /**
         * set Number by paramsName
         * @param name uniform params name
         * @param value Number data
         */
        setNumber(name: string, value: number): void;
        /**
         * set Number by paramsIndex
         * @param uniformID uniform params index
         * @param value Number data
         * @returns
         */
        setNumberbyIndex(uniformID: number, value: number): void;
        /**
         * set Vector2 by paramsName
         * @param name uniform params name
         * @param value Vector2 data
         */
        setVector2(name: string, value: Vector2): void;
        /**
         * set Vector2 by paramsIndex
         * @param uniformID uniform params index
         * @param value Vector2 data
         * @returns
         */
        setVector2byIndex(uniformID: number, value: Vector2): void;
        /**
         * set Vector3 by paramsName
         * @param name uniform params name
         * @param value Vector3 data
         */
        setVector3(name: string, value: Vector3): void;
        /**
         * set Vector3 by uniformID
         * @param uniformID uniform params index
         * @param value Vector3 data
         * @returns
         */
        setVector3byIndex(uniformID: number, value: Vector3): void;
        /**
         * set Vector4 by paramsName
         * @param name uniform params name
         * @param value Vector4 data
         */
        setVector4(name: string, value: Vector4): void;
        /**
         * set Vector4 by paramsIndex
         * @param uniformID uniform params index
         * @param value Vector4 data
         * @returns
         */
        setVector4byIndex(uniformID: number, value: Vector4): void;
        /**
         * set Color by paramsName
         * @param name uniform params name
         * @param value Color data
         */
        setColor(name: string, value: Color): void;
        setColorbyIndex(uniformID: number, value: Color): void;
        /**
         * set Matrix by paramsName
         * @param name uniform params name
         * @param value Matrix data
         */
        setMatrix(name: string, value: Matrix4x4): void;
        /**
         * set Matrix by paramsIndex
         * @param uniformID uniform params index
         * @param value Matrix data
         * @returns
         */
        setMatrixbyIndex(uniformID: number, value: Matrix4x4): void;
        clone(): UnifromBufferData;
        cloneTo(destObject: UnifromBufferData): void;
    }
    /**
     * 类封装WebGL2UniformBufferObect
     */
    class UniformBufferObject {
        static UBONAME_SCENE: string;
        static UBONAME_CAMERA: string;
        static UBONAME_SPRITE3D: string;
        static UBONAME_SHADOW: string;
        /**
         * create Uniform Buffer Base
         * @param name Uniform block name(must pitch Shader)
         * @param bufferUsage config usage
         * @param bytelength byte length
         * @returns
         */
        static create(name: string, bufferUsage: number, bytelength: number, isSingle?: boolean): UniformBufferObject;
        /**
         * get Uniform Buffer by name
         * @param name Uniform block name(must pitch Shader)
         * @returns
         */
        static getBuffer(name: string, index: number): UniformBufferObject;
        _glBuffer: GLBuffer;
        /**buffer name */
        _name: string;
        /**all byte length */
        byteLength: number;
        bufferType: BufferTargetType;
        bufferUsage: BufferUsage;
        /**
         * 重置buffer长度
         * @param bytelength
         */
        _reset(bytelength: number): void;
        /**
         * @inheritDoc
         * @override
         */
        bind(): boolean;
        /**
         * set UniformBuffer data by UniformBufferData
         * @param buffer Float32Array data
         * @param bufferOffset byteOffset
         * @param byteCount  byteCount
         * @returns
         */
        setData(buffer: Float32Array, bufferOffset?: number, byteCount?: number): void;
        /**
         * set UniformBuffer data by UniformBufferData
         * @param bufferData
         */
        setDataByUniformBufferData(bufferData: UnifromBufferData): void;
        /**
         * set Data by subUniformBufferData
         * @param bufferData sub UniformBufferData
         * @param offset
         */
        setDataByByUniformBufferDataOffset(bufferData: SubUniformBufferData, offset: number): void;
        /**
         * @private
         */
        destroy(): void;
    }
    interface VAElement {
        format: string;
        stride: number;
        shaderLocation: number;
    }
    class VertexAttributeLayout {
        static IPoint: number;
        static _pool: {
            [key: number]: VertexAttributeLayout;
        };
        static getVertexLayoutByPool(vertexs: VertexBuffer[]): VertexAttributeLayout;
        /**
         * vertex attribute byte size Array
         */
        attributeByteSize: Array<number>;
        /**
         * vertex Layout des
         */
        VAElements: Array<VAElement[]>;
        instanceMode: Array<boolean>;
        /**
         * pool index
         */
        id: number;
        /**
         * instance one VertexAttributeLayout
         * @param vertexs
         */
        constructor(vertexs: VertexBuffer[]);
    }
    class VertexBuffer extends Buffer {
        private _instanceBuffer;
        _buffer: Float32Array | Uint16Array | Uint8Array | Uint32Array;
        /**
         * 获取顶点声明。
         */
        get vertexDeclaration(): VertexDeclaration | null;
        set vertexDeclaration(value: VertexDeclaration | null);
        get instanceBuffer(): boolean;
        set instanceBuffer(value: boolean);
        constructor(targetType: BufferTargetType, bufferUsageType: BufferUsage);
    }
    class VertexStateContext {
        elementCount: number;
        elementType: number;
        normalized: number;
        vertexStride: number;
        elementOffset: number;
        elementString: string;
    }
    /**
     * <code>VertexDeclaration</code> 类用于生成顶点声明。
     */
    class VertexDeclaration {
        /**
         * 获取唯一标识ID(通常用于优化或识别)。
         * @return 唯一标识ID
         */
        get id(): number;
        /**
         * 顶点跨度，以字节为单位。
         */
        get vertexStride(): number;
        /**
         * 顶点元素的数量。
         */
        get vertexElementCount(): number;
        /**
         * 创建一个 <code>VertexDeclaration</code> 实例。
         * @param	vertexStride 顶点跨度。
         * @param	vertexElements 顶点元素集合。
         */
        constructor(vertexStride: number, vertexElements: Array<VertexElement>);
        /**
         * 通过索引获取顶点元素。
         * @param index 索引。
         */
        getVertexElementByIndex(index: number): VertexElement;
        /**
         * get vertexElement by usage
         */
        getVertexElementByUsage(usage: number): VertexElement;
    }
    interface IGraphicCMD {
        run(context: Context, gx: number, gy: number): void;
        recover(): void;
        get cmdID(): string;
        percent?: boolean;
        pivotX?: number;
        pivotY?: number;
        scaleX?: number;
        scaleY?: number;
        angle?: number;
        tx?: number;
        ty?: number;
        matrix?: Matrix;
        x?: number;
        y?: number;
        width?: number;
        height?: number;
        points?: any;
    }
    /**
     * @private
     */
    class Context {
        private static _MAXVERTNUM;
        static MAXCLIPRECT: Rectangle;
        private _alpha;
        private static SEGNUM;
        private static _contextcount;
        private _drawTexToDrawTri_Vert;
        private _drawTexToDrawTri_Index;
        private _tempUV;
        private _drawTriUseAbsMatrix;
        private _other;
        private _path;
        private _width;
        private _height;
        private _renderCount;
        private _meshQuatTex;
        private _meshVG;
        private _meshTex;
        private _transedPoints;
        private _temp4Points;
        private _clipID_Gen;
        private _lastMat_a;
        private _lastMat_b;
        private _lastMat_c;
        private _lastMat_d;
        /**
         * 所cacheAs精灵
         * 对于cacheas bitmap的情况，如果图片还没准备好，需要有机会重画，所以要保存sprite。例如在图片
         * 加载完成后，调用repaint
         */
        sprite: Sprite | null;
        private _fillColor;
        private _flushCnt;
        private defTexture;
        drawTexAlign: boolean;
        private _isMain;
        private _render2D;
        private _clearColor;
        private _clear;
        private _shaderValueNeedRelease;
        _render2DManager: RenderManager2D;
        static __init__(): void;
        constructor();
        copyState(ctx: Context): void;
        set isMain(v: boolean);
        get isMain(): boolean;
        set render2D(render: Render2D);
        get render2D(): Render2D;
        /**@private */
        get lineJoin(): string;
        /**@private */
        set lineJoin(value: string);
        /**@private */
        get lineCap(): string;
        /**@private */
        set lineCap(value: string);
        /**@private */
        get miterLimit(): string;
        /**@private */
        set miterLimit(value: string);
        /**
         * 添加需要touch的资源
         * @param res
         */
        touchRes(res: IAutoExpiringResource): void;
        transformByMatrix(matrix: Matrix, tx: number, ty: number): void;
        drawRect(x: number, y: number, width: number, height: number, fillColor: any, lineColor: any, lineWidth: number): void;
        alpha(value: number): void;
        drawCurves(x: number, y: number, points: any[], lineColor: any, lineWidth: number): void;
        private _fillAndStroke;
        static set2DRenderConfig(): void;
        clearBG(r: number, g: number, b: number, a: number): void;
        /**
         * 释放占用内存
         */
        private _releaseMem;
        /**
         * 释放所有资源
         */
        destroy(): void;
        clear(): void;
        /**
         * 设置ctx的size，这个不允许直接设置，必须是canvas调过来的。所以这个函数里也不用考虑canvas相关的东西
         * @param	w
         * @param	h
         */
        size(w: number, h: number): void;
        get width(): number;
        set width(w: number);
        get height(): number;
        set height(h: number);
        /**
         * 获得当前矩阵的缩放值
         * 避免每次都计算getScaleX
         * @return
         */
        getMatScaleX(): number;
        getMatScaleY(): number;
        getFillColor(): number;
        set fillStyle(value: any);
        get fillStyle(): any;
        set globalAlpha(value: number);
        get globalAlpha(): number;
        set textAlign(value: string);
        get textAlign(): string;
        set textBaseline(value: string);
        get textBaseline(): string;
        set globalCompositeOperation(value: string);
        get globalCompositeOperation(): string;
        set strokeStyle(value: any);
        get strokeStyle(): any;
        translate(x: number, y: number): void;
        set lineWidth(value: number);
        get lineWidth(): number;
        save(): void;
        restore(): void;
        fillText(txt: string | WordText, x: number, y: number, fontStr: string, color: string, align: string, lineWidth?: number, borderColor?: string): void;
        drawText(text: string | WordText, x: number, y: number, font: string, color: string, textAlign: string): void;
        strokeWord(text: string | WordText, x: number, y: number, font: string, color: string, lineWidth: number, textAlign: string): void;
        fillBorderText(txt: string | WordText, x: number, y: number, font: string, color: string, borderColor: string, lineWidth: number, textAlign: string): void;
        private _fillRect;
        fillRect(x: number, y: number, width: number, height: number, fillStyle: any): void;
        fillTexture(texture: Texture, x: number, y: number, width: number, height: number, type: string, offset: Point, color: number): void;
        /**
         * 反正只支持一种filter，就不要叫setFilter了，直接叫setColorFilter
         * @param	value
         */
        setColorFilter(filter: ColorFilter): void;
        drawTexture(tex: Texture, x: number, y: number, width: number, height: number, color?: number): void;
        drawTextures(tex: Texture, pos: ArrayLike<number>, tx: number, ty: number, colors: number[]): void;
        private isStopMerge;
        drawCallOptimize(enable: boolean): boolean;
        private _drawToRender2D;
        private _drawMesh;
        private fillShaderValue;
        /**
         * pt所描述的多边形完全在clip外边，整个被裁掉了
         * @param	pt
         * @return
         */
        private clipedOff;
        /**
         * 应用当前矩阵。把转换后的位置放到输出数组中。
         * @param	x
         * @param	y
         * @param	w
         * @param	h
         * @param   italicDeg 倾斜角度，单位是度。0度无，目前是下面不动。以后要做成可调的
         */
        private transformQuad;
        /**
         * 强制拒绝submit合并
         * 例如切换rt的时候
         */
        breakNextMerge(): void;
        private _repaintSprite;
        /**
         *
         * @param	tex
         * @param	x
         * @param	y
         * @param	width
         * @param	height
         * @param	transform	图片本身希望的矩阵
         * @param	tx			节点的位置
         * @param	ty
         * @param	alpha
         */
        drawTextureWithTransform(tex: Texture, x: number, y: number, width: number, height: number, transform: Matrix | null, tx: number, ty: number, alpha: number, blendMode: string | null, uv?: number[], color?: number): void;
        drawGeo(geo: IRenderGeometryElement, material: Material, x: number, y: number): void;
        drawGeos(geo: IRenderGeometryElement, elements: [
            Material,
            number,
            number
        ][], x: number, y: number): void;
        drawTriangles(tex: Texture, x: number, y: number, vertices: Float32Array, uvs: Float32Array, indices: Uint16Array, matrix: Matrix, alpha: number | null, blendMode: string, colorNum?: number): void;
        transform(a: number, b: number, c: number, d: number, tx: number, ty: number): void;
        rotate(angle: number): void;
        scale(scaleX: number, scaleY: number): void;
        clipRect(x: number, y: number, width: number, height: number, escape?: boolean): void;
        startRender(): void;
        endRender(): void;
        drawLeftData(): void;
        flush(): void;
        beginPath(convex?: boolean): void;
        closePath(): void;
        /**
         * 添加一个path。
         * @param	points [x,y,x,y....]	这个会被保存下来，所以调用者需要注意复制。
         * @param	close	是否闭合
         * @param   convex 是否是凸多边形。convex的优先级是这个最大。fill的时候的次之。其实fill的时候不应该指定convex，因为可以多个path
         * @param	dx  需要添加的平移。这个需要在应用矩阵之前应用。
         * @param	dy
         */
        addPath(points: any[], close: boolean, convex: boolean, dx: number, dy: number): void;
        fill(): void;
        private addVGSubmit;
        stroke(): void;
        moveTo(x: number, y: number): void;
        /**
         *
         * @param	x
         * @param	y
         * @param	b 是否应用矩阵
         */
        lineTo(x: number, y: number): void;
        arcTo(x1: number, y1: number, x2: number, y2: number, r: number): void;
        arc(cx: number, cy: number, rx: number, ry: number, startAngle: number, endAngle: number, counterclockwise?: boolean, b?: boolean, minNum?: number): void;
        quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
        /**
         * 把颜色跟当前设置的alpha混合
         * @return
         */
        mixRGBandAlpha(color: number): number;
        strokeRect(x: number, y: number, width: number, height: number, parameterLineWidth: number): void;
        /*******************************************end矢量绘制***************************************************/
        drawParticle(x: number, y: number, pt: any): void;
        private _getPath;
        /**获取canvas*/
        get canvas(): HTMLCanvas;
        /**
         * 专用函数。通过循环创建来水平填充
         * @param	tex
         * @param	bmpid
         * @param	uv		希望循环的部分的uv
         * @param	oriw
         * @param	orih
         * @param	x
         * @param	y
         * @param	w
         */
        private _fillTexture_h;
        /**
         * 专用函数。通过循环创建来垂直填充
         * @param	tex
         * @param	imgid
         * @param	uv
         * @param	oriw
         * @param	orih
         * @param	x
         * @param	y
         * @param	h
         */
        private _fillTexture_v;
        private static tmpUVRect;
        drawTextureWithSizeGrid(tex: Texture, tx: number, ty: number, width: number, height: number, sizeGrid: any[], gx: number, gy: number, color: number): void;
    }
    class DefferTouchResContext extends Context {
        cache: CachePage;
        mustTouchRes: IAutoExpiringResource[];
        randomTouchRes: IAutoExpiringResource[];
        genID: number;
        /**
         * 添加需要touch的资源
         * @param res
         */
        touchRes(res: IAutoExpiringResource): void;
    }
    /**
     * <code>Render</code> 是渲染管理类。它是一个单例，可以使用 Laya.render 访问。
     */
    class Render {
        /** 表示是否是 3D 模式。*/
        static is3DMode: boolean;
        /**自定义帧循环 */
        static _customRequestAnimationFrame: any;
        /**帧循环函数 */
        static _loopFunction: any;
        /** 当前的帧数 */
        private static lastFrm;
        /** 第一次运行标记 */
        private _first;
        /** 刚启动的时间。由于微信的rAF不标准，传入的stamp参数不对，因此自己计算一个从启动开始的相对时间 */
        private _startTm;
        static _Render: Render;
        static customRequestAnimationFrame(value: any, loopFun: any): void;
        private static _customEngine;
        static set customRenderEngine(engine: IRenderEngine);
        static get customRenderEngine(): IRenderEngine;
        static gc(): void;
        /**
         * 初始化引擎。
         * @param	width 游戏窗口宽度。
         * @param	height	游戏窗口高度。
         */
        constructor(width: number, height: number, mainCanv: HTMLCanvas);
        /**@private */
        private _timeId;
        /**@private */
        /**
         * @performanceTool  func count
         */
        private _onVisibilitychange;
        /**
         * 获取帧对齐的时间。
         * 用这个做动画的时间参数会更平滑。
         * 从render构造开始算起。
         * @returns
         */
        static vsyncTime(): number;
        initRender(canvas: HTMLCanvas, w: number, h: number): boolean;
        /**@private */
        private _enterFrame;
        /** 目前使用的渲染器。*/
        static get context(): Context;
        /** 渲染使用的原生画布引用。 */
        static get canvas(): any;
    }
    interface ISprite2DGeometry {
        readonly vertexDeclarition: VertexDeclaration;
        vbBuffer: ArrayBuffer;
        ibBuffer: ArrayBuffer;
    }
    abstract class Render2D {
        protected _renderTexture: RenderTexture2D;
        constructor(out?: RenderTexture2D);
        setRenderTarget(rt: RenderTexture2D): void;
        abstract clone(out: RenderTexture2D): Render2D;
        get out(): RenderTexture2D;
        abstract renderStart(clear: boolean, clearColor: Color): void;
        abstract draw(mesh: ISprite2DGeometry, vboff: number, vblen: number, iboff: number, iblen: number, mtl: Value2D, customMaterial: Material): void;
        abstract drawMesh(mesh: IRenderGeometryElement, mtl: Material): void;
        abstract drawElement(ele: IRenderElement2D): void;
        abstract renderEnd(): void;
    }
    /**
     * 直接渲染，不攒submit
     */
    class Render2DSimple extends Render2D {
        static rendercontext2D: IRenderContext2D;
        private _renderElement;
        private static _geoMap;
        constructor(out?: RenderTexture2D);
        clone(out: RenderTexture2D): Render2D;
        private _createMesh;
        private getGeo;
        renderStart(clear: boolean, clearColor: Color): void;
        setRenderTarget(rt: RenderTexture2D): void;
        drawMesh(geo: IRenderGeometryElement, mtl: Material): void;
        drawElement(ele: IRenderElement2D): void;
        draw(mesh2d: ISprite2DGeometry, vboff: number, vblen: number, iboff: number, iblen: number, mtl: Value2D, customMaterial: Material): void;
        renderEnd(): void;
    }
    /**
     *
     * @author laya
     */
    class RenderInfo {
        /**当前帧的开始时间 */
        static loopStTm: number;
        /**主舞台 <code>Stage</code> 渲染次数计数。 */
        static loopCount: number;
    }
    /**
     * @ignore
     */
    interface _RenderFunction {
        (sp: Sprite, ctx: Context, x: number, y: number): void;
    }
    /**
     * @ignore
     * @en Sprite renderer.
     * @zh 精灵渲染器
     */
    class RenderSprite {
        /** @private*/
        static cacheNormalEnable: boolean;
        /** @private */
        static renders: RenderSprite[];
        /** @private */
        protected static NORENDER: RenderSprite;
        private static _initRenderFun;
        private static _getTypeRender;
        constructor(type: number, next: RenderSprite | null);
        _renderNode2D(sprite: Sprite, context: Context, x: number, y: number): void;
        /**
         * 把sprite的下一步渲染到缓存的rt上
         * 要求外面可以直接使用，不用考虑图集的偏移之类的问题
         * @param sprite
         * @param context
         * @returns
         */
        _renderNextToCacheRT(sprite: Sprite, context: Context, marginLeft?: number, marginTop?: number, marginRight?: number, marginBottom?: number): boolean;
        /**
         * @en Renders a sprite to a RenderTexture2D. Determines the render target based on the provided parameters. If a render texture is provided, it uses that. Otherwise, it creates a new one based on the sprite's cache rect and other factors. Optionally, can draw a render rectangle based on the isDrawRenderRect parameter.
         * @param sprite The sprite to be rendered.
         * @param context The context for rendering.
         * @param x The x-coordinate for rendering.
         * @param y The y-coordinate for rendering.
         * @param renderTexture The optional RenderTexture2D to render to. If not provided, a new one will be created if needed.
         * @param isDrawRenderRect A boolean indicating whether to draw the render rectangle. When true, it starts drawing from (0,0) of the render texture and subtracts the offset of the cache rectangle. When false, it keeps the sprite's original relative position for drawing.
         * @returns The RenderTexture2D that the sprite is rendered to.
         * @zh 将一个精灵渲染到一个渲染纹理上。根据提供的参数确定渲染目标。如果提供了渲染纹理，则使用该纹理。否则，根据精灵的缓存矩形和其他因素创建一个新的。可以根据 isDrawRenderRect 参数选择是否绘制渲染矩形。
         * @param sprite 要被渲染的精灵。
         * @param context 用于渲染的上下文。
         * @param x 渲染的 x 坐标。
         * @param y 渲染的 y 坐标。
         * @param renderTexture 可选的渲染纹理。如果未提供，在需要时会创建一个新的。
         * @param isDrawRenderRect 一个布尔值，表示是否绘制渲染矩形。为 true 时，从渲染纹理的(0,0)点开始绘制，但要减去缓存矩形的偏移；为 false 时，保持精灵的原始相对位置进行绘制。
         * @returns 渲染的 RenderTexture2D。
         */
        static RenderToRenderTexture(sprite: Sprite, context: Context | null, x: number, y: number, renderTexture?: RenderTexture2D, isDrawRenderRect?: boolean): RenderTexture2D;
        /**
         * @en Renders a sprite to a cache texture. Checks if the sprite needs repainting or if the cache texture is missing or if there is a global repaint. If so, creates a new cache texture by rendering the sprite to a RenderTexture2D.
         * @param sprite The sprite to be rendered.
         * @param context The context for rendering.
         * @param x The x-coordinate for rendering.
         * @param y The y-coordinate for rendering.
         * @param isDrawRenderRect A boolean indicating whether to draw the render rectangle. When true, it starts drawing from (0,0) of the render texture and subtracts the offset of the cache rectangle. When false, it keeps the sprite's original relative position for drawing.
         * @returns A boolean indicating whether a new cache texture was created (true for repaint, false otherwise).
         * @zh 将精灵画在当前贴图的 x,y 位置。检查精灵是否需要重绘、缓存纹理是否缺失或者是否有全局重绘。如果是，则通过将精灵渲染到一个渲染纹理来创建新的缓存纹理。
         * @param sprite 要被渲染的精灵。
         * @param context 用于渲染的上下文。
         * @param x 渲染的 x 坐标。
         * @param y 渲染的 y 坐标。
         * @param isDrawRenderRect 一个布尔值，表示是否绘制渲染矩形。为 true 时，从渲染纹理的(0,0)点开始绘制，但要减去缓存矩形的偏移；为 false 时，保持精灵的原始相对位置进行绘制。
         * @returns 一个布尔值，表示是否创建了新的缓存纹理（true 表示重绘，false 表示未重绘）。
         */
        static RenderToCacheTexture(sprite: Sprite, context: Context | null, x: number, y: number, isDrawRenderRect?: boolean): boolean;
        private static _transBound;
        private _spriteRect_TextureSpace;
        private _maskRect_TextureSpace;
        _mask(sprite: Sprite, ctx: Context, x: number, y: number): void;
    }
    class RenderToCache extends Render2D {
        renderResult: RenderObject2D[];
        private _tex_vert_decl;
        constructor();
        clone(out: RenderTexture2D): RenderToCache;
        private _createMesh;
        private setVertexDecl;
        renderStart(): void;
        draw(mesh2d: ISprite2DGeometry, vboff: number, vblen: number, iboff: number, iblen: number, mtl: Value2D): void;
        drawMesh(mesh: IRenderGeometryElement, mtl: Material): void;
        drawElement(ele: IRenderElement2D): void;
        renderEnd(): void;
    }
    interface IAutoExpiringResource {
        isRandomTouch: boolean;
        touch(): void;
    }
    class RenderObject2D implements ISprite2DGeometry {
        vboff: number;
        vblen: number;
        iboff: number;
        iblen: number;
        mtl: Value2D;
        localClipMatrix: Matrix;
        dynaResourcesNeedTouch: any[];
        vertexDeclarition: VertexDeclaration;
        vbBuffer: ArrayBuffer;
        ibBuffer: ArrayBuffer;
        geo: IRenderGeometryElement;
        renderElement: IRenderElement2D;
        constructor(mesh: ISprite2DGeometry, vboff: number, vblen: number, iboff: number, iblen: number, mtl: Value2D);
        toNativeMesh(): void;
        destroyGPUResource(): void;
    }
    class Cache_Info {
        page: CachePage;
        mat: Matrix;
        alpha: number;
        blend: string;
        contextID: number;
        clipMatrix: Matrix;
        reset(): void;
    }
    class RenderPageContext {
        curMatrix: Matrix;
        alpha: number;
        render2d: Render2D;
        width: number;
        height: number;
        clipInfo: Matrix;
        blend: number;
        /**
         * 这里的xy就是渲染的xy，需要这个参数是为了正确计算当前矩阵
         * @param ctx
         * @param x
         * @param y
         */
        constructor(ctx: Context, x: number, y: number);
        _copyClipInfo(shaderValue: Value2D): void;
        clipRect(rect: Rectangle): void;
        setBlendMode(blend: string): void;
        _applyBlend(shaderValue: Value2D): void;
    }
    class CachePage {
        sprite: Sprite;
        meshes: RenderObject2D[];
        defferTouchRes: IAutoExpiringResource[];
        defferTouchResRand: IAutoExpiringResource[];
        children: Sprite[];
        reset(): void;
        private clearGPUObject;
        /**
         * 根据sprite的相对矩阵（相对于parent）画出缓存的mesh
         * 为了位置能正确，需要context中提供的矩阵是sprite的parent的世界矩阵
         * @param sprite
         * @param context
         * @param isRoot  如果为true的话，则可以直接使用当前矩阵。优化用。
         */
        render(sprite: Sprite, context: RenderPageContext, isRoot: boolean): void;
    }
    /**
     * 把渲染结果保存成mesh和材质
     */
    class SpriteCache {
        /**
         * 已知sprite和当前世界矩阵curMat, 把sprite的偏移减掉，就是得到parent的世界矩阵
         * @param sprite
         * @param curMat 当前的矩阵，这是增加了sprite自身的偏移后的矩阵
         * @param outMat 把curMat去掉sprite自身的偏移得到的结果
         */
        static curMatSubSpriteMat(sprite: Sprite, curMat: Matrix, outMat: Matrix): Matrix;
        static renderCacheAsNormal(context: Context | DefferTouchResContext, sprite: Sprite, next: RenderSprite, x: number, y: number): boolean;
    }
    /**
    * <code>VertexElement</code> 类用于创建顶点结构分配。
    */
    class VertexElement {
        /**
         * 顶点偏移
         */
        get offset(): number;
        /**
         * 顶点信息名称
         */
        get elementFormat(): string;
        /**
         * 顶点宏标记
         */
        get elementUsage(): number;
        /**
         * 创建顶点结构分配实例
         * @param offset 顶点偏移
         * @param elementFormat 顶点数据格式名称
         * @param elementUsage 顶点宏标记
         */
        constructor(offset: number, elementFormat: string, elementUsage: number);
    }
    /**
     * 类用来定义顶点元素格式
     */
    class VertexElementFormat {
        /**单精度浮点数 */
        static Single: string;
        /**vec2 数据*/
        static Vector2: string;
        /**vec3 数据*/
        static Vector3: string;
        /**vec4 数据 */
        static Vector4: string;
        /**颜色 */
        static Color: string;
        /**字节数组4 */
        static Byte4: string;
        /**字节数组3 */
        static Byte3: string;
        /**字节数组2 */
        static Byte2: string;
        /**字节数组1 */
        static ByteOne: string;
        /**半精度浮点数数组2 */
        static Short2: string;
        /**半精度浮点数数组4 */
        static Short4: string;
        /**归一化半精度浮点数组2 */
        static NormalizedShort2: string;
        /**归一化半精度浮点数组4 */
        static NormalizedShort4: string;
        /**
         * 获取顶点元素格式信息。
         * @param element 元素名称
         * @returns 返回顶点元素信息
         */
        static getElementInfos(element: string): any[];
    }
    /**
     * @en This class is used to describe resources.
     * @zh 此类用来描述资源
     */
    class AssetDb {
        /**
         * @en Default resource instance.
         * @zh 默认资源实例。
         */
        static inst: AssetDb;
        /**
         * @en UUID data.
         * @zh UUID 数据。
         */
        uuidMap: Record<string, string>;
        /**
         * @en Shader name data.
         * @zh 着色器名称数据。
         */
        shaderNameMap: Record<string, string>;
        /**
         * @en Metadata for resources.
         * @zh 资源的元数据。
         */
        metaMap: Record<string, any>;
        /**
         * @en Gets the URL from the UUID.
         * @param uuid The UUID.
         * @returns The URL corresponding to the UUID.
         * @zh 根据 UUID 获取 URL。
         * @param uuid UUID
         * @returns UUID 对应的 URL
         */
        UUID_to_URL(uuid: string): string;
        /**
         * @en Asynchronously gets the URL from the UUID.
         * @param uuid The UUID.
         * @returns A promise.
         * @zh 异步根据 uuid 获取 URL。
         * @param uuid UUID
         * @returns 一个promise。
         */
        UUID_to_URL_async(uuid: string): Promise<string>;
        /**
         * @en Asynchronously gets the UUID from the URL.
         * @param url The URL.
         * @returns A promise.
         * @zh 异步根据 URL 获取 UUID。
         * @param url URL
         * @returns 一个 promise。
         */
        URL_to_UUID_async(url: string): Promise<string>;
        /**
         * @en Resolves the real URL from a given URL.
         * @param url The original URL.
         * @param onResolve Optional callback when the URL is resolved.
         * @returns A promise that resolves to the real URL.
         * @zh 根据给定的 URL 解析真实的 URL。
         * @param url 原始 URL。
         * @param onResolve 可选的回调函数，当 URL 被解析时调用。
         * @returns 一个promise，解析为真实的 URL。
         */
        resolveURL(url: string, onResolve?: (url: string) => void): Promise<string>;
        /**
         * @en Finds the URL for a shader name.
         * @param shaderName The shader name.
         * @returns The URL corresponding to the shader name.
         * @zh 根据着色器名称查找 URL。
         * @param shaderName 着色器名称。
         * @returns 着色器名称对应的 URL。
         */
        shaderName_to_URL(shaderName: string): string;
        /**
         * @en Asynchronously finds the URL for a shader name.
         * @param shaderName The shader name.
         * @returns A promise.
         * @zh 异步根据着色器名称查找 URL。
         * @param shaderName 着色器名称。
         * @returns 一个 promise。
         */
        shaderName_to_URL_async(shaderName: string): Promise<string>;
        /**
         * @en Gets the metadata for a resource.
         * @param url The resource URL.
         * @param uuid The resource UUID.
         * @returns A promise.
         * @zh 获取资源的元数据。
         * @param url 资源的 URL。
         * @param uuid 资源的 UUID。
         * @returns 一个 promise。
         */
        getMeta(url: string, uuid: string): Promise<any>;
        /**
         * @en Gets the URL for a sub-asset.
         * @param url The base resource URL.
         * @param uuid The UUID of the base resource.
         * @param subAssetName The name of the sub-asset.
         * @param subAssetExt The file extension of the sub-asset.
         * @returns The URL for the sub-asset.
         * @zh 获取子资源的 URL。
         * @param url 基础资源的 URL。
         * @param uuid 基础资源的 UUID。
         * @param subAssetName 子资源的名称。
         * @param subAssetExt 子资源的文件扩展名。
         * @returns 子资源的 URL。
         */
        getSubAssetURL(url: string, uuid: string, subAssetName: string, subAssetExt: string): string;
    }
    /**
     * @en Resource class for managing an atlas, which is a collection of textures and their frames.
     * @zh 管理大图合集资源的类，该类包含纹理和它们的帧。
     */
    class AtlasResource extends Resource {
        /**
         * @en The directory where the atlas resource is stored.
         * @zh 存储大图合集资源的目录。
         */
        readonly dir: string;
        /**
         * @en An array of textures contained within the atlas.
         * @zh 包含在大图合集中的纹理数组。
         */
        readonly textures: Array<Texture>;
        /**
         * @en An array of texture frames, which are individual images within the atlas.
         * @zh 大图合集中的纹理帧数组，它们是大图中的单个图像。
         */
        readonly frames: Array<Texture>;
        /**
         * @en Creates a new instance of the AtlasResource class.
         * @param dir Directory of the atlas.
         * @param textures Array of textures in the atlas.
         * @param frames Array of frames corresponding to the textures.
         * @zh 创建AtlasResource类的新实例。实例化大图合集资源。
         * @param dir 大图合集的目录路径。
         * @param textures 大图合集中的纹理数组。
         * @param frames 对应纹理的帧数组。
         */
        constructor(dir: string, textures: Array<Texture>, frames: Array<Texture>);
        /**
         * @en Disposes of the resources used by the atlas, destroying all textures and frames.
         * @zh 释放大图合集使用的资源，销毁所有纹理和帧。
         */
        protected _disposeResource(): void;
    }
    /**
     * @en The `BaseTexture` class is an abstract class and serves as the base class for textures. It should not be instantiated directly.
     * @zh `BaseTexture` 类是纹理的父类，是一个抽象类，不允许直接实例化。
     */
    class BaseTexture extends Resource {
        /**
         * @en hdr encode format
         * @zh hdr编码格式
         */
        hdrEncodeFormat: HDREncodeFormat;
        protected _width: number;
        protected _height: number;
        /**
         * @en The width of the texture.
         * @zh 纹理的宽度。
         */
        get width(): number;
        set width(width: number);
        /**
         * @en The height of the texture.
         * @zh 纹理的高度。
         */
        get height(): number;
        set height(height: number);
        protected _dimension: TextureDimension;
        /**
         * @en The texture dimension.
         * @zh 纹理几何属性
         */
        get dimension(): TextureDimension;
        protected _format: TextureFormat;
        /**
         * @en The format of the texture.
         * @zh 纹理的格式。
         */
        get format(): TextureFormat;
        /**
         * @en Whether to generate mipmap
         * @zh 是否生成mipmap
         */
        get mipmap(): boolean;
        /**
         * @en The number of mipmap generated for this texture.
         * @zh 为此纹理生成的mipmap数量。
         */
        get mipmapCount(): number;
        /**
         * @en The anisotropy value of texture
         * @zh 纹理的各向异性值
         */
        get anisoLevel(): number;
        set anisoLevel(value: number);
        /**
         * @en The sampling filtering mode of the texture.
         * @zh 纹理的采样过滤模式。
         */
        get filterMode(): FilterMode;
        set filterMode(value: FilterMode);
        /**
         * @en U-direction sampling mode
         * @zh U方向采样模式
         */
        get wrapModeU(): WrapMode;
        set wrapModeU(value: WrapMode);
        /**
         * @en V-direction sampling mode
         * @zh V方向采样模式
         */
        get wrapModeV(): WrapMode;
        set wrapModeV(value: WrapMode);
        /**
         * @en W-direction sampling mode
         * @zh W方向采样模式
         */
        get wrapModeW(): WrapMode;
        set wrapModeW(value: WrapMode);
        /**
         * @en The texture compare mode.
         * @zh 贴图压缩格式
         */
        get compareMode(): TextureCompareMode;
        set compareMode(value: TextureCompareMode);
        /**
         * @en The gamma correction value of the texture. If set to 1.0, texture sampling will be linear without any correction.
         * @zh 纹理的伽马校正值。如果设置为1.0，则纹理采样将为线性，不进行任何校正。
         */
        get gammaCorrection(): number;
        /**
         * @en The base mipmap level of the texture.
         * @zh 纹理的mipmap起始等级。
         */
        get baseMipmapLevel(): number;
        set baseMipmapLevel(value: number);
        /**
         * @en The maximum mipmap level of the texture.
         * @zh 纹理的最大mipmap等级。
         */
        get maxMipmapLevel(): number;
        set maxMipmapLevel(value: number);
        /**
         * @en Gets whether the texture is using gamma space.
         * @zh 判断纹理是否使用伽马空间。
         */
        get gammaSpace(): boolean;
        /**
         * @en Creates an instance of BaseTexture.
         * @param width The width of the texture.
         * @param height The height of the texture.
         * @param format The format of the texture, specified as a number.
         * @zh 创建 BaseTexture 类的实例。
         * @param width 纹理的宽度。
         * @param height 纹理的高度。
         * @param format 纹理的格式，以数字形式指定。
         */
        constructor(width: number, height: number, format: number);
        /**
         * @en Checks if the texture is in a GPU compressed format.
         * @returns True if the texture is in a GPU compressed format, otherwise false.
         * @zh 是否是gpu压缩纹理格式
         * @returns 如果纹理是gpu压缩格式，则返回true，否则返回false。
         */
        gpuCompressFormat(): boolean;
        /**
         * @en The default texture.
         * @zh 默认贴图
         */
        get defaultTexture(): BaseTexture;
        protected _disposeResource(): void;
    }
    /**
     * @en Prefab class.
     * @zh 预制体类。
     */
    class Prefab extends Resource {
        /**
         * @readonly
         * @en The version number of the prefab resource.
         * @zh 预制体资源的版本号。
         */
        readonly version: number;
        /**
         * @en Whether the prefab is generated by the DCC tool.
         * @zh 预制体是否是由 DCC 工具生成的。
         */
        fromDCC: boolean;
        /**
         * @ignore
         * @en Create an instance of the prefab.
         * @param version The version number of the prefab resource.
         * @zh 创建一个预制体实例。
         * @param version 预制体资源的版本号。
         */
        constructor(version?: number);
        /**
         * @en Create an instance of the prefab.
         * @param options Instantiation options.
         * @param errors Error content.
         * @zh 创建一个预制体的实例。
         * @param options 实例化选项
         * @param errors 错误内容
         */
        create(options?: Record<string, any>, errors?: Array<any>): Node;
    }
    type HierarchyResource = Prefab;
    var HierarchyResource: typeof Prefab;
    /**
     * @en `HTMLCanvas` is a proxy class for the HTML Canvas, encapsulating the properties and methods of the Canvas.
     * @zh `HTMLCanvas` 是 Html Canvas 的代理类，封装了 Canvas 的属性和方法。
     */
    class HTMLCanvas extends Resource {
        private _ctx;
        protected _width: number;
        protected _height: number;
        /**
         * @en The source of the canvas element.
         * @zh Canvas 元素的源。
         */
        get source(): HTMLCanvasElement;
        /**
         * @en The width of the canvas.
         * @zh 画布宽度。
         */
        get width(): number;
        set width(width: number);
        /**
         * @en The height of the canvas.
         * @zh 画布高度。
         */
        get height(): number;
        set height(height: number);
        /**
         * @en According to the specified type, create an HTMLCanvas instance.
         * @param createCanvas If true, creates a new canvas element. If false, uses the instance itself as the canvas source.
         * @zh 根据指定的类型，创建一个 HTMLCanvas 实例。
         * @param createCanvas 如果为true，则创建一个新的画布元素。如果为 false，则使用当前实例作为画布源。
         */
        constructor(createCanvas?: boolean);
        /**
         * @en Clear the canvas content.
         * @zh 清空画布内容。
         */
        clear(): void;
        /**
         * @en Destroys the HTMLCanvas instance, releasing all associated resources.
         * @zh 销毁 HTMLCanvas 实例，释放所有相关资源。
         */
        destroy(): void;
        /**
         * @en Releases the resources of the HTMLCanvas instance.
         * @zh 释放 HTMLCanvas 实例的资源。
         */
        release(): void;
        /**
         * @en The Canvas rendering context.
         * @zh Canvas 渲染上下文。
         */
        get context(): Context;
        /**
         * @en Get the Canvas rendering context.
         * @param contextID The context ID.
         * @param other
         * @return The Canvas rendering context Context object.
         * @zh 获取 Canvas 渲染上下文。
         * @param	contextID 上下文ID.
         * @param	other
         * @return  Canvas 渲染上下文 Context 对象。
         */
        getContext(contextID: string, other?: any): Context;
        /**
         * @en Get the memory size.
         * @return The memory size.
         * @zh 获取内存大小。
         * @return 内存大小。
         */
        getMemSize(): number;
        /**
         * @en Set the width and height of the Canvas.
         * @param w The width of the Canvas.
         * @param h The height of the Canvas.
         * @zh 设置画布的宽度和高度。
         * @param w 画布的宽度。
         * @param h 画布的高度。
         */
        size(w: number, h: number): void;
        /**
         * @en Get the texture instance.
         * @zh 获取纹理实例
         */
        getTexture(): Texture | BaseTexture;
        /**
         * @en Convert the image to base64 information
         * @param type The image type "image/png"
         * @param encoderOptions quality parameter, range 0-1
         * @zh 把图片转换为base64信息
         * @param type 图片格式 "image/png"
         * @param encoderOptions 质量参数，取值范围为0-1
         */
        toBase64(type: string, encoderOptions: number): string | null;
    }
    /**
     * @en The material render mode.
     * @zh 材质渲染模式。
     */
    enum MaterialRenderMode {
        /**
         * @en RenderMode: Opaque
         * @zh 渲染状态：不透明。
         */
        RENDERMODE_OPAQUE = 0,
        /**
         * @en RenderMode: Alpha Testing
         * @zh 渲染状态：阿尔法测试。
         */
        RENDERMODE_CUTOUT = 1,
        /**
         * @en RenderMode: Transparent
         * @zh 渲染状态：透明。
         */
        RENDERMODE_TRANSPARENT = 2,
        /**
         * @en RenderMode: additive mixing
         * @zh 渲染状态：加色法混合。
         */
        RENDERMODE_ADDTIVE = 3,
        /**
         * @en RenderMode: Alpha Blending mixture
         * @zh 渲染状态：透明混合。
         */
        RENDERMODE_ALPHABLENDED = 4,
        /**
         * @en RenderMode: Custom
         * @zh 渲染状态：自定义
         */
        RENDERMODE_CUSTOME = 5
    }
    /**
     * @en The Material class is used to create materials.
     * @zh Material 类用于创建材质。
     */
    class Material extends Resource implements IClone {
        /**
         * @en RenderQueue: Opaque
         * @zh 渲染队列：不透明。
         */
        static RENDERQUEUE_OPAQUE: number;
        /**
         * @en RenderQueue: Alpha Testing
         * @zh 渲染队列：阿尔法测试。
         */
        static RENDERQUEUE_ALPHATEST: number;
        /**
         * @en RenderQueue: Transparent
         * @zh 渲染队列：透明。
         */
        static RENDERQUEUE_TRANSPARENT: number;
        /**
         * @en Shader variables, transparent test values.
         * @zh 着色器变量,透明测试值。
         */
        static ALPHATESTVALUE: number;
        /**
         * @en Material grade shader macro definition, transparency testing.
         * @zh 材质级着色器宏定义,透明测试。
         */
        static SHADERDEFINE_ALPHATEST: ShaderDefine;
        /**
         * @en Material grade shader macro definition, main texture.
         * @zh 材质级着色器宏定义,主贴图。
         */
        static SHADERDEFINE_MAINTEXTURE: ShaderDefine;
        /**
         * @en Material grade shader macro definition, additive fog.
         * @zh 材质级着色器宏定义,叠加雾效。
         */
        static SHADERDEFINE_ADDTIVEFOG: ShaderDefine;
        /**
         * @deprecated 请使用Loader.load(url:string, type: ILaya.Loader.MATERIAL)
         * @en Loads a material from a URL.
         * @param url The URL from which to load the material.
         * @param complete A callback function that is called when the material has been loaded.
         * @zh 从URL加载材质。
         * @param url 材质的URL。
         * @param complete 加载完成后的回调函数。
         */
        static load(url: string, complete: Handler): void;
        private _matRenderNode;
        private _renderQueue;
        /**
         * @en The rendering queue of the material.
         * @zh 所属渲染队列.
         */
        get renderQueue(): number;
        set renderQueue(value: number);
        /**
         * @en Owner element.
         * @zh 所属元素
         */
        ownerElements: Set<IRenderElement3D>;
        /**
         * @en The shader data.
         * @zh 着色器数据。
         */
        get shaderData(): ShaderData;
        /**
         * @en The alpha test value used for the alpha test mode of the material.
         * @zh 材质用于透明测试模式的透明测试值。
         */
        get alphaTestValue(): number;
        set alphaTestValue(value: number);
        /**
         * @en Whether the material uses alpha cut mode.
         * @zh 材质是否使用透明裁剪模式。
         */
        get alphaTest(): boolean;
        set alphaTest(value: boolean);
        /**
         * @en Adds a shader define to the material's shader data.
         * @param define The shader define to add.
         * @zh 向材质的着色器数据添加着色器宏定义。
         * @param define 要添加的着色器宏定义。
         */
        addDefine(define: ShaderDefine): void;
        /**
         * @en Removes a shader define from the material's shader data.
         * @param define The shader define to remove.
         * @zh 从材质的着色器数据移除着色器宏定义。
         * @param define 要移除的着色器宏定义。
         */
        removeDefine(define: ShaderDefine): void;
        /**
         * @en Enables or disables a shader define.
         * @param define The shader define to enable or disable.
         * @param value true to add the define, false to remove it.
         * @zh 开启或关闭着色器宏定义。
         * @param define 要开启或关闭的着色器宏定义。
         * @param value true 表示添加宏定义，false 表示移除宏定义。
         */
        setDefine(define: ShaderDefine, value: boolean): void;
        /**
         * @en Checks if a shader define is present.
         * @param define The shader define to check for.
         * @returns true if the define is present, false otherwise.
         * @zh 检查是否包含特定的着色器宏定义。
         * @param define 要检查的着色器宏定义。
         * @returns 如果存在宏定义返回 true，否则返回 false。
         */
        hasDefine(define: ShaderDefine): boolean;
        /**
         * @en Whether depth writing is enabled for this material.
         * @zh 此材质是否启用深度写入。
         */
        get depthWrite(): boolean;
        set depthWrite(value: boolean);
        /**
         * @en The culling mode for this material.
         * @zh 此材质的剔除方式。
         */
        get cull(): number;
        set cull(value: number);
        /**
         * @en The blend mode for this material.
         * @zh 此材质的混合方式。
         */
        get blend(): number;
        set blend(value: number);
        /**
         * @en The blend source for this material.
         * @zh 此材质的混合源。
         */
        get blendSrc(): number;
        set blendSrc(value: number);
        /**
         * @en The blend destination for this material.
         * @zh 此材质的混合目标。
         */
        get blendDst(): number;
        set blendDst(value: number);
        /**
         * @en The Alpha value of the blend source for this material.
         * @zh 此材质的混合源的 Alpha 值。
         */
        get blendSrcAlpha(): number;
        set blendSrcAlpha(value: number);
        /**
         * @en The RGB value of the blend source for this material.
         * @zh 此材质的混合源的 RGB 值。
         */
        get blendSrcRGB(): number;
        set blendSrcRGB(value: number);
        /**
         * @en The RGB value of the blend destination for this material.
         * @zh 此材质的混合目标的 RGB 值。
         */
        get blendDstRGB(): number;
        set blendDstRGB(value: number);
        /**
         * @en The Alpha value of the blend destination for this material.
         * @zh 此材质的混合目标的 Alpha 值。
         */
        get blendDstAlpha(): number;
        set blendDstAlpha(value: number);
        /**
         * @en The blend equation for this material.
         * @zh 此材质的混合方程。
         */
        get blendEquation(): number;
        set blendEquation(value: number);
        /**
         * @en The RGB value of the blend equation for this material.
         * @zh 此材质的混合方程的 RGB 值。
         */
        get blendEquationRGB(): number;
        set blendEquationRGB(value: number);
        /**
         * @en The Alpha value of the blend equation for this material.
         * @zh 此材质的混合方程的 Alpha 值。
         */
        get blendEquationAlpha(): number;
        set blendEquationAlpha(value: number);
        /**
         * @en The depth test mode.
         * @zh 深度测试方式。
         */
        get depthTest(): number;
        set depthTest(value: number);
        /**
         * @en The stencil test mode.
         * @zh 模板测试方式
         */
        get stencilTest(): number;
        set stencilTest(value: number);
        /**
         * @en Whether to write it into the stencil
         * @zh 是否写入模板。
         */
        get stencilWrite(): boolean;
        set stencilWrite(value: boolean);
        /**
         * @en Stencil values
         * @zh 模板值
         */
        get stencilRef(): number;
        set stencilRef(value: number);
        /**
         * @en The stencil operation settings for testing. The vector contains (fail, zfail, zpass) .
         * @zh 模板测试设置，向量包含（fail，zfail，zpass）。
         */
        get stencilOp(): Vector3;
        set stencilOp(value: Vector3);
        /**
         * @en The material properties.
         * @zh 材质属性。
         */
        get MaterialProperty(): any;
        /**
         * @en The material defines.
         * @zh 材质宏定义。
         */
        get MaterialDefine(): Array<string>;
        /**
         * @en Material rendering mode
         * @zh 材质渲染模式
         */
        get materialRenderMode(): MaterialRenderMode;
        set materialRenderMode(value: MaterialRenderMode);
        /**
         * @ignore
         * @en Creates an instance of the Material.
         * @zh 创建一个Material实例。
         */
        constructor();
        private _bindShaderInfo;
        private _releaseUBOData;
        /**
         * @en Destroys the resources.
         * @zh 销毁资源。
         */
        protected _disposeResource(): void;
        /**
         * @en The shader of the material.
         * @zh 材质的着色器。
         */
        get shader(): Shader3D;
        /**
         * @en Gets all uniform properties of the material.
         * @returns The map of uniform properties.
         * @zh 获取材质的所有uniform属性。
         * @returns uniform属性的映射表。
         */
        effectiveProperty(): Map<string, ShaderDataType>;
        /**
         * @en Sets the shader by its name.
         * @param name The name of the shader to set.
         * @zh 通过名称设置使用Shader。
         * @param name 要设置的着色器名称。
         */
        setShaderName(name: string): void;
        /**
         * @en Gets the boolean uniform value by index.
         * @param uniformIndex The index of the uniform.
         * @returns The boolean value of the property.
         * @zh 通过uniform索引获取布尔值。
         * @param uniformIndex uniform索引。
         * @returns uniform索引的布尔值。
         */
        getBoolByIndex(uniformIndex: number): boolean;
        /**
         * @en Sets the boolean value by uniform index.
         * @param uniformIndex The index of the uniform.
         * @param value The bool value to set.
         * @zh 通过uniform索引设置布尔值。
         * @param uniformIndex uniform索引。
         * @param value 要设置的布尔值。
         */
        setBoolByIndex(uniformIndex: number, value: boolean): void;
        /**
         * @en Gets a boolean value of uniformIndex by property name.
         * @param name The name of the property.
         * @returns The boolean value.
         * @zh 根据属性名称获得uniform索引的布尔值。
         * @param name 属性名称。
         * @returns uniform索引的布尔值。
         */
        getBool(name: string): boolean;
        /**
         * @en Sets a boolean value by property name.
         * @param name The name of the property.
         * @param value The value to set.
         * @zh 设置属性名称对应的布尔值。
         * @param name 属性名称。
         * @param value 要设置的值。
         */
        setBool(name: string, value: boolean): void;
        /**
         * @en Gets a float value by uniform index.
         * @param uniformIndex The index of the property.
         * @returns The float value.
         * @zh 通过属性索引获得浮点值。
         * @param uniformIndex 属性索引。
         * @returns 浮点值。
         */
        getFloatByIndex(uniformIndex: number): number;
        /**
         * @en Sets a float value by uniform index.
         * @param uniformIndex The index of the property.
         * @param value The value to set.
         * @zh 通过属性索引设置浮点值。
         * @param uniformIndex 属性索引。
         * @param value 要设置的值。
         */
        setFloatByIndex(uniformIndex: number, value: number): void;
        /**
         * @en Gets a float value by property name.
         * @param name The name of the property.
         * @returns The float value.
         * @zh 根据属性名称获得浮点值。
         * @param name 属性名称。
         * @returns 浮点值。
         */
        getFloat(name: string): number;
        /**
         * @en Sets a float value by property name.
         * @param name The name of the property.
         * @param value The value to set.
         * @zh 设置属性名称对应的浮点值。
         * @param name 属性名称。
         * @param value 要设置的值。
         */
        setFloat(name: string, value: number): void;
        /**
         * @en Gets an integer value by uniform index.
         * @param uniformIndex The index of the property.
         * @returns The integer value.
         * @zh 通过属性索引获得整数值。
         * @param uniformIndex 属性索引。
         * @returns 整数值。
         */
        getIntByIndex(uniformIndex: number): number;
        /**
         * @en Sets an integer value by uniform index.
         * @param uniformIndex The index of the property.
         * @param value The value to set.
         * @zh 通过属性索引设置整数值。
         * @param uniformIndex 属性索引。
         * @param value 要设置的值。
         */
        setIntByIndex(uniformIndex: number, value: number): void;
        /**
         * @en Gets an integer value by property name.
         * @param name The name of the property.
         * @returns The integer value.
         * @zh 根据属性名称获得整数值。
         * @param name 属性名称。
         * @returns 整数值。
         */
        getInt(name: string): number;
        /**
         * @en Sets an integer value by property name.
         * @param name The name of the property.
         * @param value The value to set.
         * @zh 设置属性名称对应的整数值。
         * @param name 属性名称。
         * @param value 要设置的值。
         */
        setInt(name: string, value: number): void;
        /**
         * @en Gets a Vector2 value by uniform index.
         * @param uniformIndex The index of the property.
         * @returns The Vector2 value.
         * @zh 通过属性索引获得Vector2值。
         * @param uniformIndex 属性索引。
         * @returns Vector2值。
         */
        getVector2ByIndex(uniformIndex: number): Vector2;
        /**
         * @en Sets a Vector2 value by uniform index.
         * @param uniformIndex The index of the property.
         * @param value The Vector2 value to set.
         * @zh 通过属性索引设置Vector2值。
         * @param uniformIndex 属性索引。
         * @param value 要设置的Vector2值。
         */
        setVector2ByIndex(uniformIndex: number, value: Vector2): void;
        /**
         * @en Gets a Vector2 value by property name.
         * @param name The name of the property.
         * @returns The Vector2 value.
         * @zh 根据属性名称获得Vector2值。
         * @param name 属性名称。
         * @returns Vector2值。
         */
        getVector2(name: string): Vector2;
        /**
         * @en Sets a Vector2 value by property name.
         * @param name The name of the property.
         * @param value The Vector2 value to set.
         * @zh 设置属性名称对应的Vector2值。
         * @param name 属性名称。
         * @param value 要设置的Vector2值。
         */
        setVector2(name: string, value: Vector2): void;
        /**
         * @en Retrieves a Vector3 value by its uniform index.
         * @param uniformIndex The index of the property.
         * @returns The retrieved Vector3 value.
         * @zh 通过属性索引获得Vector3值。
         * @param uniformIndex 属性索引。
         * @returns 检索到的Vector3值。
         */
        getVector3ByIndex(uniformIndex: number): Vector3;
        /**
         * @en Sets a Vector3 value by its uniform index.
         * @param uniformIndex The index of the property.
         * @param value The Vector3 value to set.
         * @zh 通过属性索引设置Vector3值。
         * @param uniformIndex 属性索引。
         * @param value 要设置的Vector3值。
         */
        setVector3ByIndex(uniformIndex: number, value: Vector3): void;
        /**
         * @en Retrieves a Vector3 value by its property name.
         * @param name The name of the property as defined in the shader.
         * @returns The retrieved Vector3 value.
         * @zh 根据属性名称获得Vector3值。
         * @param name 着色器中定义的属性名称。
         * @returns 检索到的Vector3值。
         */
        getVector3(name: string): Vector3;
        /**
         * @en Sets a Vector3 value by its property name.
         * @param name The name of the property as defined in the shader.
         * @param value The Vector3 value to set.
         * @zh 设置属性名称对应的Vector3值。
         * @param name 着色器中定义的属性名称。
         * @param value 要设置的Vector3值。
         */
        setVector3(name: string, value: Vector3): void;
        /**
         * @en Sets a Vector4 value by uniform index.
         * @param uniformIndex The index of the property.
         * @param value The Vector4 value to set.
         * @zh 通过属性索引设置Vector4值。
         * @param uniformIndex 属性索引。
         * @param value 要设置的Vector4值。
         */
        setVector4ByIndex(uniformIndex: number, value: Vector4): void;
        /**
         * @en Retrieves a Vector4 value by uniform index.
         * @param uniformIndex The index of the property.
         * @returns The retrieved Vector4 value.
         * @zh 通过属性索引获取Vector4值。
         * @param uniformIndex 属性索引。
         * @returns 检索到的Vector4值。
         */
        getVector4ByIndex(uniformIndex: number): Vector4;
        /**
         * @en Sets a Vector4 value by property name.
         * @param name The name of the property.
         * @param value The Vector4 value to set.
         * @zh 设置属性名称对应的Vector4值。
         * @param name 属性名称。
         * @param value 要设置的Vector4值。
         */
        setVector4(name: string, value: Vector4): void;
        /**
         * @en Retrieves a Vector4 value by property name.
         * @param name The name of the property.
         * @returns The retrieved Vector4 value.
         * @zh 根据属性名称获得Vector4值。
         * @param name 属性名称。
         * @returns 检索到的Vector4值。
         */
        getVector4(name: string): Vector4;
        /**
         * @en Retrieves a Color value by its uniform index.
         * @param uniformIndex The index of the property.
         * @returns The retrieved Color value.
         * @zh 通过属性索引获得颜色值。
         * @param uniformIndex 属性索引。
         * @returns 检索到的颜色值。
         */
        getColorByIndex(uniformIndex: number): Color;
        /**
         * @en Sets a Color value by its uniform index.
         * @param uniformIndex The index of the property.
         * @param value The Color value to set.
         * @zh 通过属性索引设置颜色值。
         * @param uniformIndex 属性索引。
         * @param value 要设置的颜色值。
         */
        setColorByIndex(uniformIndex: number, value: Color): void;
        /**
         * @en Retrieves a Color value by property name.
         * @param name The name of the property.
         * @returns The retrieved Color value.
         * @zh 根据属性名称获得颜色值。
         * @param name 属性名称。
         * @returns 检索到的颜色值。
         */
        getColor(name: string): Color;
        /**
         * @en Sets a Color value by property name.
         * @param name The name of the property.
         * @param value The Color value to set.
         * @zh 设置属性名称对应的颜色值。
         * @param name 属性名称。
         * @param value 要设置的颜色值。
         */
        setColor(name: string, value: Color): void;
        /**
         * @en Retrieves a Matrix4x4 value by its uniform index.
         * @param uniformIndex The index of the property.
         * @returns The retrieved Matrix4x4 value.
         * @zh 通过属性索引获得4x4矩阵值。
         * @param uniformIndex 属性索引。
         * @returns 检索到的4x4矩阵值。
         */
        getMatrix4x4ByIndex(uniformIndex: number): Matrix4x4;
        /**
         * @en Sets a Matrix4x4 value by its uniform index.
         * @param uniformIndex The index of the property.
         * @param value The Matrix4x4 value to set.
         * @zh 通过属性索引设置4x4矩阵值。
         * @param uniformIndex 属性索引。
         * @param value 要设置的4x4矩阵值。
         */
        setMatrix4x4ByIndex(uniformIndex: number, value: Matrix4x4): void;
        /**
         * @en Retrieves a Matrix4x4 value by property name.
         * @param name The name of the property.
         * @returns The retrieved Matrix4x4 value.
         * @zh 根据属性名称获得4x4矩阵值。
         * @param name 属性名称。
         * @returns 检索到的4x4矩阵值。
         */
        getMatrix4x4(name: string): Matrix4x4;
        /**
         * @en Sets a Matrix4x4 value by property name.
         * @param name The name of the property.
         * @param value The Matrix4x4 value to set.
         * @zh 设置属性名称对应的4x4矩阵值。
         * @param name 属性名称。
         * @param value 要设置的4x4矩阵值。
         */
        setMatrix4x4(name: string, value: Matrix4x4): void;
        /**
         * @en Retrieves a 3x3 matrix value by its index.
         * @param index The index of the matrix within the shader data.
         * @returns The retrieved 3x3 matrix value.
         * @zh 通过索引获取3x3矩阵值。
         * @param index 着色器数据中矩阵的索引。
         * @returns 检索到的3x3矩阵值。
         */
        getMatrix3x3ByIndex(index: number): Matrix3x3;
        /**
         * @en Sets a 3x3 matrix value by its index.
         * @param index The index of the matrix within the shader data.
         * @param value The 3x3 matrix value to set.
         * @zh 通过索引设置3x3矩阵值。
         * @param index 着色器数据中矩阵的索引。
         * @param value 要设置的3x3矩阵值。
         */
        setMatrix3x3ByIndex(index: number, value: Matrix3x3): void;
        /**
         * @en Retrieves a 3x3 matrix value by its property name.
         * @param name The name of the property.
         * @returns The retrieved 3x3 matrix value.
         * @zh 根据属性名称获取3x3矩阵值。
         * @param name 属性名称。
         * @returns 检索到的3x3矩阵值。
         */
        getMatrix3x3(name: string): Matrix3x3;
        /**
         * @en Sets a 3x3 matrix value by its property name.
         * @param name The name of the property.
         * @param value The 3x3 matrix value to set.
         * @zh 设置属性名称对应的3x3矩阵值。
         * @param name 属性名称。
         * @param value 要设置的3x3矩阵值。
         */
        setMatrix3x3(name: string, value: Matrix3x3): void;
        /**
         * @en Sets a texture by its uniform index.
         * @param uniformIndex The index of the property.
         * @param texture The texture to set.
         * @zh 通过属性索引设置纹理。
         * @param uniformIndex 属性索引。
         * @param texture 要设置的纹理。
         */
        setTextureByIndex(uniformIndex: number, texture: BaseTexture): void;
        private reSetTexture;
        /**
         * @en Retrieves a texture by its uniform index.
         * @param uniformIndex The index of the property.
         * @returns The retrieved texture.
         * @zh 通过属性索引获得纹理。
         * @param uniformIndex 属性索引。
         * @returns 检索到的纹理。
         */
        getTextureByIndex(uniformIndex: number): BaseTexture;
        /**
         * @en Sets a texture by property name.
         * @param name The name of the property.
         * @param texture The texture to set.
         * @zh 根据属性名称设置纹理。
         * @param name 属性名称。
         * @param texture 要设置的纹理。
         */
        setTexture(name: string, texture: BaseTexture): void;
        /**
         * @en Retrieves a texture by property name.
         * @param name The name of the property.
         * @returns The retrieved texture.
         * @zh 根据属性名称获得纹理。
         * @param name 属性名称。
         * @returns 检索到的纹理。
         */
        getTexture(name: string): BaseTexture;
        /**
         * @en Retrieves a buffer by its uniform index.
         * @param uniformIndex The index of the property.
         * @returns The retrieved buffer.
         * @zh 通过属性索引获得Buffer。
         * @param uniformIndex 属性索引。
         * @returns 检索到的Buffer。
         */
        getBufferByIndex(uniformIndex: number): Float32Array;
        /**
         * @en Sets a buffer by its uniform index.
         * @param uniformIndex The index of the property.
         * @param value The buffer to set.
         * @zh 通过属性索引设置Buffer。
         * @param uniformIndex 属性索引。
         * @param value 要设置的Buffer值。
         */
        setBufferByIndex(uniformIndex: number, value: Float32Array): void;
        /**
         * @en Retrieves a buffer by property name.
         * @param name The name of the property.
         * @returns The retrieved buffer.
         * @zh 根据属性名称获得Buffer。
         * @param name 属性名称。
         * @returns 检索到的Buffer。
         */
        getBuffer(name: string): Float32Array;
        /**
         * @en Sets a buffer by property name.
         * @param name The name of the property.
         * @param value The buffer to set.
         * @zh 根据属性名称设置Buffer。
         * @param name 属性名称。
         * @param value 要设置的Buffer值。
         */
        setBuffer(name: string, value: Float32Array): void;
        /**
         * @en Sets the attribute value of ShaderData by uniform index.
         * @param uniformIndex The index of the attribute.
         * @param type The type of the value to be set.
         * @param value The value to be set.
         * @zh 通过属性索引设置ShaderData的属性值。
         * @param uniformIndex 属性索引。
         * @param type 要设置的值的类型。
         * @param value 要设置的值。
         */
        setShaderDataByIndex(uniformIndex: number, type: ShaderDataType, value: ShaderDataItem): void;
        /**
         * @en Sets the attribute value of ShaderData by property name.
         * @param name The name of the property.
         * @param type The type of the value to be set.
         * @param value The value to be set.
         * @zh 根据属性名称设置ShaderData的属性值。
         * @param name 属性名称。
         * @param type 要设置的值的类型。
         * @param value 要设置的值。
         */
        setShaderData(name: string, type: ShaderDataType, value: ShaderDataItem): void;
        /**
         * @en Retrieves the attribute value of ShaderData by property name.
         * @param name The name of the property.
         * @param type The type of the value to be retrieved.
         * @returns The retrieved ShaderData attribute value.
         * @zh 根据属性名称获得ShaderData的属性值。
         * @param name 属性名称。
         * @param type 要检索的值的类型。
         * @returns 检索到的ShaderData属性值。
         */
        getShaderData(name: string, type: ShaderDataType): ShaderDataItem;
        /**
         * @en Retrieves the attribute value of ShaderData by uniform index.
         * @param uniformIndex The index of the attribute.
         * @param type The type of the value to be retrieved.
         * @returns The retrieved ShaderData attribute value.
         * @zh 通过属性索引获得ShaderData的属性值。
         * @param uniformIndex 属性索引。
         * @param type 要检索的值的类型。
         * @returns 检索到的ShaderData属性值。
         */
        getShaderDataByIndex(uniformIndex: number, type: ShaderDataType): ShaderDataItem;
        /**
         * @en Clones the current material to destination material object.
         * @param destObject The destination material object.
         * @zh 克隆当前材质到目标材质对象。
         * @param destObject 目标材质对象。
         */
        cloneTo(destObject: Material): void;
        /**
         * @en Creates a clone of the current material.
         * @returns A new material instance that is a clone of the current material.
         * @zh 创建当前材质的克隆副本。
         * @returns 一个克隆自当前材质的新材质实例。
         */
        clone(): any;
        /**
         * @en The material define.
         * @zh 材质宏
         */
        get _defineDatas(): IDefineDatas;
        /**
         * @en Compatible with old parsing end events
         * @zh 兼容老的解析结束事件
         */
        oldparseEndEvent(): void;
    }
    /**
     * @en Class is used to process 2D vertex meshes
     * @zh 类用于处理2D顶点网格
     */
    class VertexMesh2D {
        private static _vertexDeclarationMap;
        /**
         * @en Retrieves the vertex declaration based on the provided vertex flags.
         * @param vertexFlags An array of vertex declaration flag characters, formatted as: "POSITION,COLOR,UV,BLENDWEIGHT,BLENDINDICES".
         * @param compatible Whether to enable compatible mode.
         * @return An array of vertex declarations.
         * @zh 根据提供的顶点声明标志字符获取顶点声明。
         * @param vertexFlags 顶点声明标志字符数组，格式为："POSITION,COLOR,UV,BLENDWEIGHT,BLENDINDICES"。
         * @param compatible 是否启用兼容模式。
         * @return 顶点声明数组。
         */
        static getVertexDeclaration(vertexFlags: string[], compatible?: boolean): VertexDeclaration[];
    }
    /**
     * @en The `Mesh2D` class represents a 2D mesh in the engine.
     * @zh `Mesh2D` 类表示引擎中的2D网格。
     */
    class Mesh2D extends Resource {
        /**
         * @deprecated 请使用Loader.load(url:string, type: ILaya.Loader.MESH)
         * @en Loads a mesh template from the specified URL.
         * @param url The URL address of the mesh template.
         * @param complete A callback function that is executed when the mesh template is loaded.
         * @zh 从指定URL加载网格模板。
         * @param url 网格模板的地址。
         * @param complete 加载完成时的回调函数。
         */
        static load(url: string, complete: Handler): void;
        /**
         * @en Get the vertex buffer of the mesh.
         * @zh 获取网格的顶点缓冲。
         */
        get vertexBuffers(): IVertexBuffer[];
        /**
         * @en Get the index buffer of the mesh.
         * @zh 获取网格的索引缓冲。
         */
        get indexBuffer(): IIndexBuffer;
        /**
         * @en Get the number of vertices in the mesh.
         * @zh 获取网格中的顶点数。
         */
        get vertexCount(): number;
        /**
         * @en Get the index number of the mesh.
         * @zh 获取网格的索引数。
         */
        get indexCount(): number;
        /**
         * @en Get the number of SubMeshes in the mesh.
         * @zh 获取网格中子网格的个数。
         */
        get subMeshCount(): number;
        /**
         * @en The index format used by the mesh.
         * @zh 网格使用的索引格式。
         */
        get indexFormat(): IndexFormat;
        set indexFormat(value: IndexFormat);
        /**
         * @ignore
         * @en prohibition of use.
         * @zh 禁止使用
         */
        constructor();
        /**
         * @en Destroy the resource.
         * @zh 销毁资源
         */
        protected _disposeResource(): void;
        /**
         * @en Retrieves a SubMesh based on its index.
         * @param index The index of the SubMesh.
         * @returns The SubMesh at the specified index.
         * @zh 根据索引获取子网格。
         * @param index 子网格的索引。
         * @returns 索引指定的子网格。
         */
        getSubMesh(index: number): IRenderGeometryElement;
        /**
         * @en Sets the vertex data for the mesh.
         * @param vertices An array of ArrayBuffer objects containing vertex data.
         * @zh 设置网格的顶点数据。
         * @param vertices 顶点数据数组。
         */
        setVertices(vertices: ArrayBuffer[]): void;
        /**
         * @en Sets the indices for the mesh.
         * @param indices An array containing the mesh indices.
         * @zh 设置网格的索引。
         * @param indices 索引数据数组。
         */
        setIndices(indices: Uint8Array | Uint16Array | Uint32Array): void;
    }
    /**
     * @en Hierarchy parser API.
     * @zh 层次结构分析器 API。
     */
    interface IHierarchyParserAPI {
        /**
         * @en Collect resource links required by the data.
         * @param data The data object to process.
         * @param basePath The base path used to resolve resource links.
         * @returns An array of strings or ILoadURL objects representing the resource links.
         * @zh 收集数据所需的资源链接。
         * @param data 需要处理的数据对象。
         * @param basePath 用于解析资源链接的基础路径。
         * @returns 返回表示资源链接的字符串或 ILoadURL 对象数组。
         */
        collectResourceLinks: (data: any, basePath: string) => (string | ILoadURL)[];
        /**
         * @en Parse the data and create a hierarchy of nodes.
         * @param data The data object to parse.
         * @param options Optional settings for parsing.
         * @param errors Array to store any errors encountered during parsing.
         * @returns An array of nodes or a single node if only one is created.
         * @zh 解析数据并创建节点的层次结构。
         * @param data 需要解析的数据对象。
         * @param options 解析的可选设置。
         * @param errors 存储解析过程中遇到的错误的数组。
         * @zh 返回节点数组或如果只创建了一个节点，则返回单个节点。
         */
        parse: (data: any, options?: Record<string, any>, errors?: Array<any>) => Array<Node> | Node;
    }
    /**
     * @en This class is used to import prefabs.
     * @zh 该类用于导入预制体。
     */
    class PrefabImpl extends Prefab {
        /**
         * @en The prefab data.
         * @zh 预制体数据。
         */
        data: any;
        /**
         * @en The hierarchy parser API used to parse the prefab data.
         * @zh 用于解析预制体数据的层次结构 API。
         */
        api: IHierarchyParserAPI;
        /**
         * @en Create an instance of the PrefabImpl class.
         * @param api The hierarchy parser API.
         * @param data The data to initialize the prefab instance with.
         * @param version The version of the prefab.
         * @zh 创建 PrefabImpl 类的实例。
         * @param api 层次结构API
         * @param data 用于初始化预制体实例的数据。
         * @param version 预制体的版本。
         */
        constructor(api: IHierarchyParserAPI, data: any, version: number);
        /**
         * @en Create an instance of the prefab.
         * @param options Optional parameters for instance creation.
         * @param errors Array to store any errors encountered during instance creation.
         * @returns The prefab instance.
         * @zh 创建预制体的实例。
         * @param options 创建实例时的可选参数。
         * @param errors 存储实例创建过程中遇到的错误的数组。
         * @returns 预制体实例。
         */
        create(options?: Record<string, any>, errors?: any[]): Node;
    }
    /**
     * @en Depth texture mode
     * @zh 深度贴图模式
     */
    enum DepthTextureMode {
        /**
         * @en Do not generate depth texture.
         * @zh 不生成深度贴图。
         */
        None = 0,
        /**
         * @en Generate depth texture.
         * @zh 生成深度贴图。
         */
        Depth = 1,
        /**
         * @en Generate depth and normal textures.
         * @zh 生成深度和法线贴图。
         */
        DepthNormals = 2,
        /**
         * @en Generate depth and depth normals textures, and indicate whether motion vectors should be rendered.
         * @zh 生成深度和深度法线贴图，并指示是否应该渲染运动矢量。
         */
        DepthAndDepthNormals = 3,
        /**
         * @en Generate motion vectors texture.
         * @zh 生成运动矢量贴图。
         */
        MotionVectors = 4
    }
    /**
     * @en RenderTexture class used to create render texture.
     * @zh RenderTexture 类用于创建渲染纹理。
     */
    class RenderTexture extends BaseTexture implements IRenderTarget {
        private static _pool;
        private static _poolMemory;
        /**
         * @en Creates a RenderTexture instance from the pool.
         * @param width Width of the RenderTexture.
         * @param height Height of the RenderTexture.
         * @param colorFormat Color format of the RenderTexture.
         * @param depthFormat Depth format of the RenderTexture.
         * @param mipmap Whether to generate mipmaps for the RenderTexture.
         * @param multiSamples Number of multisamples for the RenderTexture.
         * @param depthTexture Whether to generate a depth texture.
         * @param sRGB Whether the RenderTexture is in sRGB space.
         * @returns A RenderTexture instance.
         * @zh 从对象池中创建一个RenderTexture实例。
         * @param width 宽度。
         * @param height 高度。
         * @param colorFormat 颜色格式。
         * @param depthFormat 深度格式。
         * @param mipmap 是否生成多级纹理。
         * @param multiSamples 多采样次数。
         * @param depthTexture 是否生成深度纹理。
         * @param sRGB 是否sRGB空间。
         * @returns RenderTexture实例。
         */
        static createFromPool(width: number, height: number, colorFormat: RenderTargetFormat, depthFormat: RenderTargetFormat, mipmap?: boolean, multiSamples?: number, depthTexture?: boolean, sRGB?: boolean): RenderTexture;
        /**
         * @en Recovers the RenderTexture to the pool for reuse.
         * @param rt The RenderTexture to recover.
         * @zh 回收渲染纹理到对象池以便重用。
         * @param rt 要回收的渲染纹理。
         */
        static recoverToPool(rt: RenderTexture): void;
        /**
         * @en Clears the RenderTexture pool.
         * @zh 清空渲染纹理对象池。
         */
        static clearPool(): void;
        /** 最后绑定到主画布上的结果 此值可能为null*/
        private static _bindCanvasRender;
        /**
         * @en The RenderTexture bound to the main canvas.
         * @zh 绑定到主画布上的渲染纹理。
         */
        static get bindCanvasRender(): RenderTexture;
        static set bindCanvasRender(value: RenderTexture);
        private _generateDepthTexture;
        /**
         * @en Whether to generate depth texture maps.
         * @zh 是否生成深度纹理贴图。
         */
        get generateDepthTexture(): boolean;
        set generateDepthTexture(value: boolean);
        /**
         * @en Depth and stencil removal texture mapping
         * @zh 深度与模板剔除纹理贴图
         */
        private _depthStencilTexture;
        /**
         * @en Depth and stencil removal texture mapping
         * @zh 深度与模板剔除纹理贴图
         */
        get depthStencilTexture(): BaseTexture;
        /**
         * @en Color format
         * @zh 颜色格式
         */
        get colorFormat(): RenderTargetFormat;
        /**
         * @en Depth and stencil removal format
         * @zh 深度与模板剔除的格式
         */
        protected _depthStencilFormat: RenderTargetFormat;
        /**
         * @en Depth and stencil removal format
         * @zh 深度与模板剔除的格式
         */
        get depthStencilFormat(): RenderTargetFormat;
        /**
         * @en Number of multisamples.
         * @zh 多采样次数
         */
        protected _multiSamples: number;
        /**
         * @en Number of multisamples.
         * @zh 多采样次数
         */
        get multiSamples(): number;
        /**
         * @en Whether the RenderTexture is a cube texture.
         * @zh 是否是立方体贴图
         */
        get isCube(): boolean;
        /**
         * @en Sampling times
         * @zh 采样次数
         */
        get samples(): number;
        /**
         * @en Whether to generate multi-level textures.
         * @zh 是否生成多级纹理。
         */
        get generateMipmap(): boolean;
        /**
         * @en Create an instance of the RenderTexture class.
         * @param width Width of the RenderTexture.
         * @param height Height of the RenderTexture.
         * @param colorFormat Color format for the RenderTexture.
         * @param depthFormat Depth format for the RenderTexture.
         * @param generateMipmap Whether to generate mipmaps for the RenderTexture.
         * @param multiSamples Number of multisamples for the RenderTexture.
         * @param generateDepthTexture Whether to generate a depth texture for the RenderTexture.
         * @param sRGB Whether the RenderTexture uses sRGB color space.
         * @zh 创建 RenderTexture 类的实例。
         * @param width 宽度。
         * @param height 高度。
         * @param colorFormat 颜色格式。
         * @param depthFormat 深度格式。
         * @param generateMipmap 是否生成多级纹理。
         * @param multiSamples 多采样次数。
         * @param generateDepthTexture 是否生成深度纹理。
         * @param sRGB 是否sRGB空间。
         */
        constructor(width: number, height: number, colorFormat: RenderTargetFormat, depthFormat: RenderTargetFormat, generateMipmap?: boolean, multiSamples?: number, generateDepthTexture?: boolean, sRGB?: boolean);
        /**
         * @en Recreates the RenderTexture with the specified parameters.
         * @param width New width of the RenderTexture.
         * @param height New height of the RenderTexture.
         * @param colorFormat New color format for the RenderTexture.
         * @param depthFormat New depth format for the RenderTexture.
         * @param generateMipmap Whether to regenerate mipmaps for the RenderTexture.
         * @param multiSamples New number of multisamples for the RenderTexture.
         * @param generateDepthTexture Whether to generate a new depth texture for the RenderTexture.
         * @param sRGB Whether the RenderTexture uses sRGB color space.
         * @zh 使用指定参数重新创建RenderTexture。
         * @param width 新宽度。
         * @param height 新高度。
         * @param colorFormat 新颜色格式。
         * @param depthFormat 新深度格式。
         * @param generateMipmap 是否重新生成多级纹理。
         * @param multiSamples 新多采样次数。
         * @param generateDepthTexture 是否生成新的深度纹理。
         * @param sRGB 是否sRGB空间。
         */
        recreate(width: number, height: number, colorFormat: RenderTargetFormat, depthFormat: RenderTargetFormat, generateMipmap?: boolean, multiSamples?: number, generateDepthTexture?: boolean, sRGB?: boolean): void;
        /**
         * @deprecated 请使用getDataAsync函数代替
         * 获取渲染纹理的像素数据
         * @param xOffset x偏移值
         * @param yOffset y偏移值
         * @param width 宽度
         * @param height 高度
         * @param out 输出
         * @returns 二进制数据
         */
        getData(xOffset: number, yOffset: number, width: number, height: number, out: Uint8Array | Float32Array): Uint8Array | Float32Array;
        /**
         * @en Asynchronously retrieves pixel data from the RenderTexture.
         * @param xOffset The x-offset value.
         * @param yOffset The y-offset value.
         * @param width The width of the area to retrieve.
         * @param height The height of the area to retrieve.
         * @param out The array to hold the output data.
         * @returns binary data
         * @zh 异步获取渲染纹理的像素数据。
         * @param xOffset x偏移值
         * @param yOffset y偏移值
         * @param width 要检索的区域的宽度。
         * @param height 要检索的区域的高度。
         * @param out 用于保存输出数据的数组。
         * @returns 二进制数据
         */
        getDataAsync(xOffset: number, yOffset: number, width: number, height: number, out: Uint8Array | Float32Array): Promise<ArrayBufferView>;
        /**
         * @en Destroy the Resource.
         * @zh 销毁资源
         */
        protected _disposeResource(): void;
    }
    /**
     * @en RenderTexture2D class used to create 2D render targets.
     * @zh RenderTexture2D 类用于创建2D渲染目标。
     */
    class RenderTexture2D extends BaseTexture implements IRenderTarget {
        private static _currentActive;
        static _clearColor: Color;
        static _clear: boolean;
        static _clearLinearColor: Color;
        /**
         * @en Default UV coordinates.
         * @zh 默认的UV坐标。
         */
        static defuv: any[];
        /**
         * @en Default flipped UV coordinates.
         * @zh 默认翻转的UV坐标。
         */
        static flipyuv: any[];
        /**
         * @en The currently active RenderTexture.
         * @zh 当前激活的渲染纹理。
         */
        static get currentActive(): RenderTexture2D;
        private _depthStencilFormat;
        private _colorFormat;
        /**
         * @en Depth format.
         * @zh 深度格式。
         */
        get depthStencilFormat(): number;
        /**
         * @en The default texture.
         * @zh 默认纹理。
         */
        get defaultTexture(): BaseTexture;
        /**
         * @en Checks whether the RenderTexture2D is ready.
         * @zh 检查2D渲染纹理是否准备好。
         */
        getIsReady(): boolean;
        /**
         * @en get the colorFormat from RenderInternalRT
         * @zh 得到此渲染纹理的颜色格式
         */
        getColorFormat(): RenderTargetFormat;
        /**
         * @en The source width of the RenderTexture2D.
         * @zh 2D渲染纹理的源宽度。
         */
        get sourceWidth(): number;
        /**
         * @en The source height of the RenderTexture2D.
         * @zh 2D渲染纹理的源高度。
         */
        get sourceHeight(): number;
        /**
         * @en The X-axis offset of the RenderTexture2D.
         * @zh 2D渲染纹理的X轴偏移。
         */
        get offsetX(): number;
        /**
         * @en The Y-axis offset of the RenderTexture2D.
         * @zh 2D渲染纹理的Y轴偏移。
         */
        get offsetY(): number;
        /**
         * @en Depth stencil texture
         * @zh 深度模板纹理
         */
        depthStencilTexture: BaseTexture;
        /**
         * @ignore
         * @en The RenderTarget.
         * @zh 渲染目标。
         */
        _renderTarget: InternalRenderTarget;
        /**
         * @en Whether the RenderTexture2D is a CameraTarget.
         * @zh 是否是CameraTarget
         */
        _isCameraTarget: boolean;
        /**
         * @en Creates an instance of RenderTexture2D.
         * @param width The width.
         * @param height The height.
         * @param format The texture format.
         * @param depthStencilFormat The depth format.
         * @zh 创建 RenderTexture2D 类的实例。
         * @param width  宽度。
         * @param height 高度。
         * @param format 纹理格式。
         * @param depthStencilFormat 深度格式。
         */
        constructor(width: number, height: number, format?: RenderTargetFormat, depthStencilFormat?: RenderTargetFormat);
        /**
         * @en Whether the render target is a cube render target.
         * @zh 渲染目标是否是立方体贴图渲染目标。
         */
        get isCube(): boolean;
        /**
         * @en The number of samples for the render target.
         * @zh 渲染目标的采样数。
         */
        get samples(): number;
        /**
         * @en Checks if mipmaps are generated for the render target.
         * @zh 检查是否为渲染目标生成了mipmaps。
         */
        get generateMipmap(): boolean;
        /**
         * @en Clears the render texture.
         * @param r The red component.
         * @param g The green component.
         * @param b The blue component.
         * @param a The alpha component, default is 1.0 for full opacity.
         * @zh 清理渲染纹理。
         * @param r 红色分量。
         * @param g 绿色分量。
         * @param b 蓝色分量。
         * @param a 透明度分量，默认为1.0表示完全不透明。
         */
        clear(r?: number, g?: number, b?: number, a?: number): void;
        /**
         * @en Gets the pixel data from the render texture within the specified area.
         * @param x The X coordinate of the pixel area.
         * @param y The Y coordinate of the pixel area.
         * @param width The width of the pixel area.
         * @param height The height of the pixel area.
         * @returns The pixel data from the specified area.
         * @zh 从指定区域获取渲染纹理的像素数据。
         * @param x 像素区域的X坐标。
         * @param y 像素区域的Y坐标。
         * @param width 像素区域的宽度。
         * @param height 像素区域的高度。
         * @returns 指定区域的像素数据。
         */
        getData(x: number, y: number, width: number, height: number): ArrayBufferView;
        /**
         * @en Asynchronously retrieves pixel data from the RenderTexture.
         * @param xOffset The x-offset value.
         * @param yOffset The y-offset value.
         * @param width The width of the area to retrieve.
         * @param height The height of the area to retrieve.
         * @param out The array to hold the output data.
         * @returns binary data
         * @zh 异步获取渲染纹理的像素数据。
         * @param xOffset x偏移值
         * @param yOffset y偏移值
         * @param width 要检索的区域的宽度。
         * @param height 要检索的区域的高度。
         * @param out 用于保存输出数据的数组。
         * @returns 二进制数据
         */
        getDataAsync(xOffset: number, yOffset: number, width: number, height: number, out: Uint8Array | Float32Array): Promise<ArrayBufferView>;
    }
    /**
     * @en The `RenderTextureCube` class is used for creating cube map render textures.
     * @zh `RenderTextureCube` 类用于创建立方体贴图渲染纹理。
     */
    class RenderTextureCube extends RenderTexture {
        /**
         * @en The index of the cube face, which can be +x, -x, +y, -y, +z, or -z.
         * @zh 立方体贴图的面索引，可以是 +x, -x, +y, -y, +z 或 -z。
         */
        faceIndex: number;
        /**
         * @en Create a new instance of `RenderTextureCube`.
         * @param size The size of the texture.
         * @param colorFormat The color format of the render target.
         * @param depthFormat The depth format of the render target.
         * @param generateMipmap Whether to generate mipmaps for the render texture.
         * @param multiSamples The number of samples for multi-sampling.
         * @zh 创建一个 `RenderTextureCube` 实例。
         * @param size 纹理的尺寸。
         * @param colorFormat 渲染目标的颜色格式。
         * @param depthFormat 渲染目标的深度格式。
         * @param generateMipmap 是否为渲染纹理生成 mipmaps。
         * @param multiSamples 多采样的样本数量。
         */
        constructor(size: number, colorFormat: RenderTargetFormat, depthFormat: RenderTargetFormat, generateMipmap: boolean, multiSamples: number);
    }
    /**
     * @en The `Resource` class used for resource access.
     * @zh `Resource` 类用于资源存取。
     */
    class Resource extends EventDispatcher {
        /**@ignore */
        static _idResourcesMap: any;
        /** 以字节为单位。*/
        private static _cpuMemory;
        /** 以字节为单位。*/
        private static _gpuMemory;
        /**
         * @en Whether the debug mode is enabled.
         * @zh 是否开启调试模式。
         */
        static DEBUG: boolean;
        /**
         * @en The current CPU memory, in bytes.
         * @zh 当前内存，以字节为单位。
         */
        static get cpuMemory(): number;
        /**
         * @en The current GPU memory, in bytes.
         * @zh 当前显存，以字节为单位。
         */
        static get gpuMemory(): number;
        /**
         * @en Destroy unused resources, this function will ignore resources with lock=true.
         * @zh 销毁当前没有被使用的资源,该函数会忽略lock=true的资源。
         */
        static destroyUnusedResources(): void;
        private static _destroyUnusedResources;
        private _cpuMemory;
        private _gpuMemory;
        _id: number;
        protected _destroyed?: boolean;
        protected _referenceCount: number;
        protected _obsolute: boolean;
        protected _deps: Array<Resource>;
        /** 是否建立引用跟踪链。 */
        protected _traceDeps: boolean;
        /**
         * @en Whether to lock the resource, if true, the resource cannot be automatically released.
         * @zh 是否加锁，如果true为不能使用自动释放机制。
         */
        lock?: boolean;
        /**
         * @en The name of the resource.
         * @zh 资源名称。
         */
        name?: string;
        /**
         * @en The URL of the resource.
         * @zh 获取资源的URL地址。
         */
        url: string;
        /**
         * @en The UUID of the resource.
         * @zh 获取资源的UUID。
         */
        uuid: string;
        /**
         * @en Whether to delete the resource immediately when the reference count is 0.
         * @zh 是否在引用计数为0的时候立马删除他
         */
        destroyedImmediately: boolean;
        /**
         * @en Unique identifier ID, usually used for identification.
         * @zh 唯一标识ID,通常用于识别。
         */
        get id(): number;
        /**
         * @en CPU memory size.
         * @zh 内存大小。
         */
        get cpuMemory(): number;
        /**
         * @en GPU memory size.
         * @zh 显存大小。
         */
        get gpuMemory(): number;
        /**
         * @en Whether the resource has been destroyed.
         * @zh 是否已销毁。
         */
        get destroyed(): boolean;
        /**
         * @en If a cached resource observer is set to true, then:
         * - 1) getRes will still return this resource;
         * - 2) next time loading will ignore this cached resource and reload it.
         * @zh 如果设置一个已缓存的资源obsolute为true，则
         * - 1）getRes仍然可以返回这个资源；
         * - 2）下次加载时会忽略这个缓存而去重新加载。。
         */
        get obsolute(): boolean;
        set obsolute(value: boolean);
        /**
         * @en The list of dependencies for the resource.
         * @zh 资源的依赖列表。
         */
        get deps(): ReadonlyArray<Resource>;
        /**
         * @en The reference count of the resource.
         * @zh 资源的引用计数。
         */
        get referenceCount(): number;
        /**
         * @en Creates an instance of Resource.
         * @param managed If set to true, the resource will be automatically released when the reference count is 0. Default is true.
         * @zh 创建一个 Resource 实例。
         * @param managed 如果设置为true，则在destroyUnusedResources时会检测引用计数并自动释放如果计数为0。默认为true。
         */
        protected constructor(managed?: boolean);
        /**
         * @en Adjusts the cpu memory usage by the specified value.
         * @param value The amount by which to adjust the CPU memory usage.
         * @zh 根据指定的值调整内存使用量。
         * @param value 要调整的内存使用量。
         */
        _setCPUMemory(value: number): void;
        /**
         * @en Adjusts the GPU memory usage by the specified value.
         * @param value The amount by which to adjust the GPU memory usage.
         * @zh 根据指定的值调整显存使用量。
         * @param value 要调整的显存使用量。
         */
        _setGPUMemory(value: number): void;
        /**
         * @en Sets the URL and UUID used to create this resource.
         * @param url The URL used to create the resource.
         * @param uuid The optional UUID of the resource.
         * @zh 设置用于创建此资源的 URL 和 UUID。
         * @param url 用于创建资源的 URL。
         * @param uuid 资源的可选UUID。
         */
        _setCreateURL(url: string, uuid?: string): void;
        /**
         * @en Checks if the resource is created from the specified URL.
         * @param url The URL to check against the resource's creation URL.
         * @returns True if the resource is created from the specified URL, otherwise false.
         * @zh 检查资源是否从指定的 URL 创建。
         * @param url 要检查的资源创建 URL。
         * @returns 如果资源是从指定的 URL 创建的，则返回 true，否则返回 false。
         */
        isCreateFromURL(url: string): boolean;
        /**
         * @en Increments the reference count of the resource by the specified amount.
         * @param count The amount by which to increment the reference count, default is 1.
         * @zh 按指定数量增加资源的引用计数。
         * @param count 要增加的引用计数，默认为1。
         */
        _addReference(count?: number): void;
        /**
         * @en Decrements the reference count of the resource by the specified amount. If the reference count reaches zero and certain conditions are met, the resource may be destroyed.
         * @param count The amount by which to decrement the reference count, default is 1.
         * @zh 按指定数量减少资源的引用计数。如果引用计数达到零并且满足特定条件，资源可能会被销毁。
         * @param count 要减少的引用计数，默认为1。
         */
        _removeReference(count?: number): void;
        /**
         * @en Clears the reference count of the resource.
         * @zh 清除引用
         */
        _clearReference(): void;
        /**
         * 增加一个依赖内容
         * @param res 依赖内容
         */
        addDep(res: Resource): void;
        /**
         * 增加多个依赖内容
         * @param resArr 依赖内容
         */
        addDeps(resArr: Array<Resource>): void;
        private onDepObsolute;
        protected _disposeResource(): void;
        /**
         * @en Destroys the resource, the resource cannot be recovered.
         * @zh 销毁资源,销毁后资源不能恢复。
         */
        destroy(): void;
    }
    /**
     * @en Enum for text resource formats.
     * @zh 文字资源格式的枚举类型。
     */
    enum TextResourceFormat {
        /**
         * @en Represents the buffer format.
         * @zh 表示缓冲区格式。
         */
        Buffer = 0,
        /**
         * @en Represents the plain text format.
         * @zh 表示纯文本格式。
         * TODO:
         */
        Plain = 1,
        /**
         * @en Represents the JSON format.
         * @zh 表示JSON格式。
         */
        JSON = 2,
        /**
         * @en Represents the XML format.
         * @zh 表示XML格式。
         */
        XML = 3
    }
    /**
     * @en The `TextResource` class represents a text resource.
     * @zh `TextResource` 类表示文字资源。
     */
    class TextResource extends Resource {
        /**
         * @en The data of the text resource, read-only.
         * @zh 文字资源的数据，只读。
         */
        readonly data: any;
        /**
         * @en The format of the text resource, read-only.
         * @zh 文字资源的格式，只读。
         */
        readonly format: TextResourceFormat;
        /**
         * @en Creates a new instance of the `TextResource` class.
         * @param data The data of the text resource.
         * @param format The format of the text resource.
         * @zh 创建 TextResource 类的新实例。
         * @param data 文字资源的数据。
         * @param format 文字资源的格式
         */
        constructor(data: any, format: TextResourceFormat);
    }
    /**
     * @en The Texture is a texture processing class.
     * @zh Texture 是一个纹理处理类。
     */
    class Texture extends Resource {
        /**
         * @en Default UV information.
         * @zh 默认 UV 信息。
         */
        static readonly DEF_UV: Float32Array;
        /**
         * @en No UV information.
         * @zh 无 UV 信息
         */
        static readonly NO_UV: Float32Array;
        /**
         * @en Inverse UV information.
         * @zh 反转 UV 信息。
         */
        static readonly INV_UV: Float32Array;
        /**
         * @en Range of UV
         * @zh uv的范围
         */
        uvrect: number[];
        private _bitmap;
        private _w;
        private _h;
        /**
         * @en The offset along the X-axis.
         * @zh 沿 X 轴的偏移量。
         */
        offsetX: number;
        /**
         * @en The offset along the Y-axis.
         * @zh 沿 Y 轴的偏移量。
         */
        offsetY: number;
        /**
         * @en The original width of the texture, including any transparent areas that have been cropped out.
         * @zh 包括已被裁剪掉的透明区域的纹理原始宽度。
         */
        sourceWidth: number;
        /**
         * @en The original height of the texture, including any transparent areas that have been cropped out.
         * @zh 包括已被裁剪掉的透明区域的纹理原始高度。
         */
        sourceHeight: number;
        /**
         * @en The URL of the texture image.
         * @zh 纹理图片的地址。
         */
        url: string;
        /**
         * @en The UUID of the texture.
         * @zh 纹理的 UUID。
         */
        uuid: string;
        /**
         * @en The scale rate of the texture.
         * @zh 纹理的缩放率。
         */
        scaleRate: number;
        /**
         * @en Creates a `Texture` object based on the specified source, coordinates, dimensions, and offsets.
         * @param source The source texture, either a `Texture2D` or a `Texture` object.
         * @param x The starting absolute x coordinate.
         * @param y The starting absolute y coordinate.
         * @param width The absolute width.
         * @param height The absolute height.
         * @param offsetX The offset on the X-axis (optional). It is the position of [x, y] relative to the original small image. Generally, it is positive, indicating that the size of the blank edge has been cut off. If it is negative, it usually indicates that a protective edge has been added
         * @param offsetY The offset on the Y-axis (optional).
         * @param sourceWidth The original width, including any cropped transparent areas (optional).
         * @param sourceHeight The original height, including any cropped transparent areas (optional).
         * @returns A `Texture` object.
         * @zh 根据指定的资源、坐标、宽高和偏移量等创建 `Texture` 对象。
         * @param source 资源，可以是 `Texture2D` 或 `Texture` 对象。
         * @param x 绝对坐标 x 。
         * @param y 绝对坐标 y 。
         * @param width 绝对宽度。
         * @param height 绝对高度。
         * @param offsetX X 轴偏移量（可选）。 就是[x,y]相对于原始小图片的位置。一般都是正的，表示裁掉了空白边的大小，如果是负的一般表示加了保护边
         * @param offsetY Y 轴偏移量（可选）。
         * @param sourceWidth 原始宽度，包括被裁剪的透明区域（可选）。
         * @param sourceHeight 原始高度，包括被裁剪的透明区域（可选）。
         * @return `Texture` 对象。
         */
        static create(source: Texture | BaseTexture, x: number, y: number, width: number, height: number, offsetX?: number, offsetY?: number, sourceWidth?: number, sourceHeight?: number): Texture;
        /**
         * @en Creates a new `Texture` by cropping a part of an existing `Texture`. If the two areas do not intersect, it returns null.
         * @param texture The target `Texture` to crop.
         * @param x The x position relative to the target `Texture`.
         * @param y The y position relative to the target `Texture`.
         * @param width The width to crop.
         * @param height The height to crop.
         * @returns A new `Texture` or null if the areas do not intersect.
         * @zh 截取 `Texture` 的一部分区域，生成一个新的 `Texture`，如果两个区域没有相交，则返回 null。
         * @param texture 目标 `Texture` 。
         * @param x 相对于目标 `Texture` 的 x 位置。
         * @param y 相对于目标 `Texture` 的 y 位置。
         * @param width 截取的宽度。
         * @param height 截取的高度。
         * @return 一个新的 `Texture` 或 null，如果两个区域没有相交。
         */
        static createFromTexture(texture: Texture, x: number, y: number, width: number, height: number): Texture;
        /**
         * @en The UV coordinates of the texture.
         * @zh 纹理的 UV 坐标。
         */
        get uv(): ArrayLike<number>;
        set uv(value: ArrayLike<number>);
        /**
         * @en The actual width of the texture.
         * @zh 纹理的实际宽度。
         */
        get width(): number;
        set width(value: number);
        /**
         * @en The actual height of the texture.
         * @zh 纹理的实际高度。
         */
        get height(): number;
        set height(value: number);
        /**
         * @en The bitmap of the texture.
         * @zh 纹理的位图。
         */
        get bitmap(): BaseTexture;
        set bitmap(value: BaseTexture);
        /**
         * @en Creates an instance of Texture class.
         * @param source Bitmap resource.
         * @param uv UV data information.
         * @zh 创建 Texture 类的新实例
         * @param source 位图资源。
         * @param uv UV 数据信息。
         */
        constructor(source?: Texture | BaseTexture, uv?: ArrayLike<number>, sourceWidth?: number, sourceHeight?: number);
        /**
         * @en Sets the bitmap resource and UV data information for this object.
         * @param bitmap The bitmap resource.
         * @param uv The UV data information.
         * @param sourceWidth The original width of the texture.
         * @param sourceHeight The original height of the texture.
         * @zh 设置此对象的位图资源和 UV 数据信息。
         * @param bitmap 位图资源。
         * @param uv UV 数据信息。
         * @param sourceWidth 纹理原始宽度。
         * @param sourceHeight 纹理原始高度。
         */
        setTo(bitmap?: BaseTexture, uv?: ArrayLike<number>, sourceWidth?: number, sourceHeight?: number): void;
        /**
         * @deprecated 请使用Loader.load(url:string, type: ILaya.Loader.IMAGE)
         * @en Loads an image from the specified URL.
         * @param url The URL of the image to load.
         * @param complete An optional callback function that is called when the image is loaded.
         * @returns A promise that resolves to the loaded image.
         * @zh 从指定的 URL 加载图片。
         * @param url 图片地址。
         * @param complete 加载完成回调。
         * @returns 一个 Promise 对象，解析为加载的图片。
         */
        load(url: string, complete?: Handler): Promise<void>;
        /**
         * @en Retrieves the pixel data from a region of the texture.
         * @param x The x-coordinate of the region.
         * @param y The y-coordinate of the region.
         * @param width The width of the region.
         * @param height The height of the region.
         * @returns A Uint8Array containing the pixel data.
         * @zh 从纹理的特定区域获取像素数据。
         * @param x 区域的 x 坐标。
         * @param y 区域的 y 坐标。
         * @param width 区域的宽度。
         * @param height 区域的高度。
         * @return 一个 Uint8Array 对象，包含了像素数据。
         */
        getTexturePixels(x: number, y: number, width: number, height: number): Uint8Array;
        /**
         * @en Retrieves the pixel data from a specific area of the `Texture`.
         * @param x The x-coordinate of the area.
         * @param y The y-coordinate of the area.
         * @param width The width of the area.
         * @param height The height of the area.
         * @returns A `Uint8Array` containing the pixel data.
         * @zh 从 `Texture` 的特定区域获取像素点集合。
         * @param x 区域的 x 坐标。
         * @param y 区域的 y 坐标。
         * @param width 区域的宽度。
         * @param height 区域的高度。
         * @return 一个 `Uint8Array` 对象，包含了像素点集合。
         */
        getPixels(x: number, y: number, width: number, height: number): Uint8Array;
        /**
         * @en Forces the recovery of the `bitmap` from the URL.
         * @param callback An optional callback function to call after the bitmap is recovered.
         * @zh 通过 URL 强制恢复 `bitmap`。
         * @param callback 位图恢复后调用的可选回调函数。
         */
        recoverBitmap(callback?: () => void): void;
        /**
         * @en Forces the disposal of the `bitmap`, regardless of references.
         * @zh 强制释放 `bitmap`，无论它是否被引用。
         */
        disposeBitmap(): void;
        /**
         * @en Whether the texture is valid.
         * @zh 纹理是否有效。
         */
        get valid(): boolean;
        /**
         * @en Whether the texture is considered obsolete.
         * @zh 纹理是否被认为是过时的。
         */
        get obsolute(): boolean;
        set obsolute(value: boolean);
        /**
         * @en Destroys the resource.
         * @zh 销毁资源。
         */
        protected _disposeResource(): void;
        /**
         * @en Retrieves a clipped sub-texture from this texture and caches it for future access.
         * @param x The x-coordinate of the clip area.
         * @param y The y-coordinate of the clip area.
         * @param width The width of the clip area.
         * @param height The height of the clip area.
         * @returns A `Texture` object representing the clipped sub-texture, or null if the clip area is out of bounds.
         * @zh 从当前纹理获取裁剪后的子纹理，并将其缓存以供将来访问。
         * @param x 裁剪区域的 x 坐标。
         * @param y 裁剪区域的 y 坐标。
         * @param width 裁剪区域的宽度。
         * @param height 裁剪区域的高度。
         * @return 一个 `Texture` 对象，表示裁剪后的子纹理，如果裁剪区域越界，则返回 null。
         */
        getCachedClip(x: number, y: number, width: number, height: number): Texture;
    }
    /**
     * @en Interface for texture property parameters.
     * @zh 纹理属性参数接口。
     */
    interface TexturePropertyParams {
        /**
         * @en Texture U-coordinate line break mode.
         * @zh 纹理 U 坐标换行模式。
         */
        wrapModeU?: number;
        /**
         * @en Texture V-coordinate line break mode.
         * @zh 纹理 V 坐标换行模式。
         */
        wrapModeV?: number;
        /**
         * @en The filter mode for the texture.
         * @zh 纹理的过滤模式。
         */
        filterMode?: FilterMode;
        /**
         * @en The anisotropic filtering level for the texture.
         * @zh 纹理的各向异性过滤级别。
         */
        anisoLevel?: number;
        /**
         * @en Whether to premultiply the alpha channel.
         * @zh 是否预乘alpha通道。
         */
        premultiplyAlpha?: boolean;
        /**
         * @en The HDR encoding format for the texture.
         * @zh 纹理的HDR编码格式。
         */
        hdrEncodeFormat?: HDREncodeFormat;
    }
    type TextureConstructParams = ConstructorParameters<typeof Texture2D>;
    /**
     * @en The Texture2D class is used to generate 2D textures.
     * @zh Texture2D 类用于生成2D纹理。
     */
    class Texture2D extends BaseTexture {
        /**
         * @en The identifier for Texture2D resources.
         * @zh Texture2D 资源的标识符。
         */
        static TEXTURE2D: string;
        /**
         * @en A pure gray texture.
         * @zh 纯灰色纹理。
         */
        static grayTexture: Texture2D;
        /**
         * @en A pure white texture.
         * @zh 纯白色纹理。
         */
        static whiteTexture: Texture2D;
        /**
         * @en A pure black texture.
         * @zh 纯黑色纹理。
         */
        static blackTexture: Texture2D;
        /**
         * @en The default normal map texture.
         * @zh 默认法线纹理。
         */
        static normalTexture: Texture2D;
        /**
         * @en The error texture displayed when a texture fails to load.
         * @zh 当纹理加载失败时显示的错误纹理。
         */
        static errorTexture: Texture2D;
        /**
         * @deprecated 请使用Loader.load(url:string, type: ILaya.Loader.TEXTURE2D)
         * @en Loads a texture from the specified URL.
         * @param url The path to the texture file.
         * @param complete The callback function to be called after the texture is loaded.
         * @zh 从指定的 URL 加载纹理。
         * @param url 纹理文件的路径。
         * @param complete 纹理加载完成后的回调函数。
         */
        static load(url: string, complete: Handler): void;
        /**
         * @en Creates an instance of Texture2D.
         * @param width The width of the texture.
         * @param height The height of the texture.
         * @param format The format of the texture.
         * @param mipmap Indicates whether to generate mipmaps for the texture.
         * @param canRead Indicates whether the texture data can be read.
         * @param sRGB Indicates whether the texture uses sRGB color space.
         * @param premultiplyAlpha Indicates whether the texture data is premultiplied by the alpha channel.
         * @zh 创建 Texture2D 类的实例。
         * @param width 纹理的宽度。
         * @param height 纹理的高度。
         * @param format 纹理的格式。
         * @param mipmap 是否为纹理生成mipmap。
         * @param canRead 纹理数据是否可以读取。
         * @param sRGB 纹理是否使用sRGB色彩空间。
         * @param premultiplyAlpha 纹理数据是否预乘alpha通道。
         */
        constructor(width: number, height: number, format: TextureFormat, mipmap: boolean, canRead: boolean, sRGB?: boolean, premultiplyAlpha?: boolean);
        /**
         * @en Sets the image data for the texture.
         * @param source The image source, can be an `HTMLImageElement`, `HTMLCanvasElement`, or `ImageBitmap`.
         * @param premultiplyAlpha Whether to premultiply the alpha.
         * @param invertY Whether to invert the Y-axis of the image.
         * @zh 设置纹理的图像数据。
         * @param source 图像源，可以是 `HTMLImageElement`、`HTMLCanvasElement` 或 `ImageBitmap`。
         * @param premultiplyAlpha 是否预乘 alpha。
         * @param invertY 是否反转图像的 Y 轴。
         */
        setImageData(source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, premultiplyAlpha: boolean, invertY: boolean): void;
        /**
         * @en Sets the pixel data for the texture.
         * @param source The pixel data to be set.
         * @param premultiplyAlpha Whether to premultiply the alpha.
         * @param invertY Whether to invert the Y-axis of the pixel data.
         * @zh 设置纹理的像素数据。
         * @param source 要设置的像素数据。
         * @param premultiplyAlpha 是否预乘 alpha。
         * @param invertY 是否反转像素数据的 Y 轴。
         */
        setPixelsData(source: ArrayBufferView, premultiplyAlpha: boolean, invertY: boolean): void;
        /**
         * @en Sets a sub-region of pixel data for the texture.
         * @param xOffset The x-offset for the sub-region.
         * @param yOffset The y-offset for the sub-region.
         * @param width The width of the sub-region.
         * @param height The height of the sub-region.
         * @param pixels The pixel data for the sub-region.
         * @param mipmapLevel The mipmap level to update, if mipmap is enabled.
         * @param generateMipmap Whether to generate mipmaps for the updated region.
         * @param premultiplyAlpha Whether to premultiply the alpha channel of the pixel data.
         * @param invertY Whether to invert the Y-axis of the pixel data.
         * @zh 设置纹理的子区域像素数据。
         * @param xOffset 子区域的 x 偏移。
         * @param yOffset 子区域的 y 偏移。
         * @param width 子区域的宽度。
         * @param height 子区域的高度。
         * @param pixels 子区域的像素数据。
         * @param mipmapLevel 要更新的mipmap等级，如果mipmap为true。
         * @param generateMipmap 是否为更新的区域生成mipmap。
         * @param premultiplyAlpha 是否预乘子区域的像素数据的 alpha 通道。
         * @param invertY 是否反转子区域的像素数据的 Y 轴。
         */
        setSubPixelsData(xOffset: number, yOffset: number, width: number, height: number, pixels: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, premultiplyAlpha: boolean, invertY: boolean): void;
        /**
         * @en Sets the DDS  data for the texture.
         * @param ddsInfo The DDS texture information containing the data to be set.
         * @zh 设置纹理的 DDS 数据。
         * @param ddsInfo DDS 纹理信息，包含要设置的数据。
         */
        setDDSData(ddsInfo: DDSTextureInfo): void;
        /**
         * @en Sets the KTX  data for the texture.
         * @param ktxInfo The KTX texture information containing the data to be set.
         * @zh 设置纹理的 KTX 数据。
         * @param ktxInfo KTX 纹理信息，包含要设置的数据。
         */
        setKTXData(ktxInfo: KTXTextureInfo): void;
        /**
         * @en Sets the HDR data for the texture.
         * @param hdrInfo The HDR texture information containing the data to be set.
         * @zh 设置纹理的 HDR 数据。
         * @param hdrInfo HDR 纹理信息，包含要设置的数据。
         */
        setHDRData(hdrInfo: HDRTextureInfo): void;
        /**
         * @en The default texture.
         * @zh 默认纹理。
         */
        get defaultTexture(): BaseTexture;
        /**
         * @en Retrieves the pixel data from the texture.
         * @zh 从纹理中检索像素数据。
         */
        getPixels(): Uint8Array;
        private setProperties;
    }
    /**
     * @en `Texture2DArray` represents a 2D texture array.
     * @zh `Texture2DArray` 类表示一个2D纹理数组。
     */
    class Texture2DArray extends BaseTexture {
        private static _defaultTexture;
        /**
         * @en The default texture.
         * @zh 默认纹理。
         */
        static get defaultTexture(): Texture2DArray;
        /**
         * @en The number of texture layers.
         * @zh 纹理层的数量。
         */
        depth: number;
        /**
         * @en Creates a `Texture2DArray` instance.
         * @zh Texture2DArray 的构造函数
         * @param width The width of the texture
         * @param height The height of the texture
         * @param depth The depth of the texture array
         * @param format The format of the texture
         * @param mipmap Whether to generate mipmaps
         * @param canRead Whether the texture can be read
         * @param sRGB Whether the texture is in sRGB color space
         * @zh 创建 Texture2DArray 类的实例。
         * @param width 纹理的宽度
         * @param height 纹理的高度
         * @param depth 纹理数组的深度
         * @param format 纹理的格式
         * @param mipmap 是否生成 mipmap
         * @param canRead 纹理是否可读
         * @param sRGB 纹理是否在 sRGB 颜色空间中
         */
        constructor(width: number, height: number, depth: number, format: TextureFormat, mipmap: boolean, canRead: boolean, sRGB?: boolean);
        /**
         * @en Sets the image data for the texture.
         * @param sources The array of images to set.
         * @param premultiplyAlpha Whether to premultiply the alpha channel.
         * @param invertY Whether to invert the Y-axis of the image.
         * @zh 设置纹理的图像数据。
         * @param sources 要设置的图像数组。
         * @param premultiplyAlpha 是否预乘 alpha。
         * @param invertY 是否反转图像 Y 轴。
         */
        setImageData(sources: HTMLImageElement[] | HTMLCanvasElement[] | ImageBitmap[], premultiplyAlpha: boolean, invertY: boolean): void;
        /**
         * @en Sets the pixel data for the texture.
         * @param source The pixel data to set.
         * @param premultiplyAlpha Whether to premultiply the alpha channel.
         * @param invertY Whether to invert the Y-axis of the image.
         * @zh 设置纹理的像素数据。
         * @param source 要设置的像素数据。
         * @param premultiplyAlpha 是否预乘 alpha。
         * @param invertY 是否反转图像 Y 轴。
         */
        setPixelsData(source: ArrayBufferView, premultiplyAlpha: boolean, invertY: boolean): void;
        /**
         * @en Updates the sub-pixel data for the texture.
         * @param xOffset The x-offset.
         * @param yOffset The y-offset.
         * @param zOffset The z-offset.
         * @param width The width of the data to update.
         * @param height The height of the data to update.
         * @param depth The depth level of the data to update.
         * @param pixels The pixel data to update.
         * @param mipmapLevel The mipmap level to update.
         * @param generateMipmap Whether to generate mipmaps after the update.
         * @param premultiplyAlpha Whether to premultiply the alpha channel.
         * @param invertY Whether to invert the Y-axis of the image.
         * @zh 更新纹理的子像素数据。
         * @param xOffset x 偏移
         * @param yOffset y 偏移
         * @param zOffset z 偏移
         * @param width 要更新的数据的宽度。
         * @param height 要更新的数据的高度。
         * @param depth 要更新的数据的深度。
         * @param pixels 要更新的像素数据。
         * @param mipmapLevel 要更新的 mipmap 等级。
         * @param generateMipmap 是否在更新后生成 mipmap。
         * @param premultiplyAlpha 是否预乘 alpha。
         * @param invertY 是否反转图像 Y 轴。
         */
        setSubPixelsData(xOffset: number, yOffset: number, zOffset: number, width: number, height: number, depth: number, pixels: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, premultiplyAlpha: boolean, invertY: boolean): void;
    }
    /**
     * @en The Texture3D class is used to generate 3D textures.
     * @zh Texture3D 类用于生成 3D 纹理。
     */
    class Texture3D extends BaseTexture {
        private static _defaultTexture;
        /**
         * @en The default texture for 3D textures.
         * @zh 3D纹理的默认纹理。
         */
        static get defaultTexture(): Texture3D;
        /**
         * @en The depth of the 3D texture.
         * @zh 3D纹理的深度。
         */
        depth: number;
        /**
         * @en Creates an instance of Texture3D.
         * @param width The width of the texture.
         * @param height The height of the texture.
         * @param depth The depth of the texture.
         * @param format The format of the texture.
         * @param mipmap Indicates whether to generate mipmaps for the texture.
         * @param sRGB Indicates whether the texture uses sRGB color space.
         * @zh 创建 Texture3D 类的实例。
         * @param width 纹理的宽度。
         * @param height 纹理的高度。
         * @param depth 纹理的深度。
         * @param format 纹理的格式。
         * @param mipmap 是否为纹理生成 mipmap。
         * @param sRGB 纹理是否使用 sRGB 色彩空间。
         */
        constructor(width: number, height: number, depth: number, format: TextureFormat, mipmap?: boolean, sRGB?: boolean);
        /**
         * @en Sets the pixel data for the 3D texture.
         * @param source The source pixel data to set.
         * @zh 设置3D纹理的像素数据。
         * @param source 要设置的源像素数据。
         */
        setPixelsData(source: ArrayBufferView): void;
        /**
         * @en Update pixel data of 3D texture in sub regions
         * @param xOffset The x-offset within the texture.
         * @param yOffset The y-offset within the texture.
         * @param zOffset The z-offset within the texture.
         * @param width The width of the sub-region to update.
         * @param height The height of the sub-region to update.
         * @param depth The depth of the sub-region to update.
         * @param pixels The pixel data to update.
         * @param mipmapLevel The mipmap level to update.
         * @param generateMipmap Whether to generate mipmaps after the update.
         * @zh 更新子区域3D纹理的像素数据。
         * @param xOffset 纹理内的 x 偏移。
         * @param yOffset 纹理内的 y 偏移。
         * @param zOffset 纹理内的 z 偏移。
         * @param width 要更新的子区域的宽度。
         * @param height 要更新的子区域的高度。
         * @param depth 要更新的子区域的深度。
         * @param pixels 要更新的像素数据。
         * @param mipmapLevel 要更新的 mipmap 等级。
         * @param generateMipmap 是否在更新后生成 mipmap。
         */
        setSubPixelsData(xOffset: number, yOffset: number, zOffset: number, width: number, height: number, depth: number, pixels: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean): void;
    }
    /**
     * @en Enum for the map faces of a cube texture.
     * @zh 表示立方体纹理各个面面的枚举。
     */
    enum TextureCubeFace {
        /**
         * @en The positive X face of the cube map.
         * @zh 立方体贴图的正X面。
         */
        PositiveX = 0,
        /**
         * @en The negative X face of the cube map.
         * @zh 立方体贴图的负X面。
         */
        NegativeX = 1,
        /**
         * @en The positive Y face of the cube map.
         * @zh 立方体贴图的正Y面。
         */
        PositiveY = 2,
        /**
         * @en The negative Y face of the cube map.
         * @zh 立方体贴图的负Y面。
         */
        NegativeY = 3,
        /**
         * @en The positive Z face of the cube map.
         * @zh 立方体贴图的正Z面。
         */
        PositiveZ = 4,
        /**
         * @en The negative Z face of the cube map.
         * @zh 立方体贴图的负Z面。
         */
        NegativeZ = 5
    }
    /**
     * @en TextureCube class used to generate cube texture.
     * @zh TextureCube 类用于生成立方体纹理。
     */
    class TextureCube extends BaseTexture {
        private static _blackTexture;
        private static _grayTexture;
        private static _whiteTexture;
        private static _errorTexture;
        /**
         * @en The black solid color texture.
         * @zh 黑色纯色纹理。
         */
        static get blackTexture(): TextureCube;
        /**
         * @en The gray solid color texture.
         * @zh 灰色纯色纹理。
         */
        static get grayTexture(): TextureCube;
        /**
         * @en The white solid color texture.
         * @zh 白色纯色纹理。
         */
        static get whiteTexture(): TextureCube;
        /**
         * @en The error texture used for cube textures.
         * @zh 立方体贴图的错误纹理。
         */
        static get errorTexture(): TextureCube;
        /**
         * @en Creates an instance of TextureCube.
         * @param size The size of each face of the cube texture.
         * @param format The texture format.
         * @param mipmap Indicates whether to generate mipmaps for the cube texture.
         * @param sRGB Indicates whether the texture uses sRGB color space.
         * @param premultiplyAlpha Indicates whether the texture data is premultiplied by the alpha channel.
         * @zh 创建 TextureCube 类的实例。
         * @param size 立方体纹理各个面大小。
         * @param format 纹理格式。
         * @param mipmap 是否为立方体纹理生成mipmap。
         * @param sRGB 是否使用sRGB色彩空间。
         * @param premultiplyAlpha 是否预乘Alpha。
         */
        constructor(size: number, format: TextureFormat, mipmap?: boolean, sRGB?: boolean, premultiplyAlpha?: boolean);
        /**
         * @en Sets the image data for each face of the cube texture.
         * @param source An array of image elements, one for each face of the cube.
         * @param premultiplyAlpha Whether to premultiply the alpha channel of the image data.
         * @param invertY Whether to invert the Y-axis of the image data.
         * @zh 为立方体贴图的每个面设置图像数据。
         * @param source 图像元素数组，每个面一个。
         * @param premultiplyAlpha 是否预乘Alpha通道。
         * @param invertY 是否翻转Y轴。
         */
        setImageData(source: (HTMLImageElement | HTMLCanvasElement | ImageBitmap)[], premultiplyAlpha: boolean, invertY: boolean): void;
        /**
         * @en Sets the pixel data for each face of the cube texture.
         * @param source An array of pixel data, one for each face of the cube.
         * @param premultiplyAlpha Whether to premultiply the alpha.
         * @param invertY Whether to invert the Y-axis of the pixel data.
         * @zh 为立方体贴图的每个面设置像素数据。
         * @param source 像素数据数组，每个面一个。
         * @param premultiplyAlpha 是否预乘Alpha。
         * @param invertY 是否翻转Y轴。
         */
        setPixelsData(source: ArrayBufferView[], premultiplyAlpha: boolean, invertY: boolean): void;
        /**
         * @en Updates sub-pixel data for the cube texture faces.
         * @param source An array of pixel data for each face of the cube texture.
         * @param xOffset The x-offset for the sub-pixel data.
         * @param yOffset The y-offset for the sub-pixel data.
         * @param width The width of the sub-region to update.
         * @param height The height of the sub-region to update.
         * @param mipmapLevel The mipmap level to update.
         * @param generateMipmap Whether to generate mipmaps after the update.
         * @param premultiplyAlpha Whether to premultiply the alpha.
         * @param invertY Whether to invert the Y-axis of the pixel data.
         * @zh 更新立方体贴图的子像素数据。
         * @param source 像素数据数组，每个面一个。
         * @param xOffset 子像素数据x偏移。
         * @param yOffset 子像素数据y偏移。
         * @param width 子像素数据宽度。
         * @param height 子像素数据高度。
         * @param mipmapLevel 子像素数据mipmap等级。
         * @param generateMipmap 是否生成mipmap。
         * @param premultiplyAlpha 是否预乘Alpha。
         * @param invertY 是否翻转Y轴。
         */
        updateSubPixelsData(source: ArrayBufferView[], xOffset: number, yOffset: number, width: number, height: number, mipmapLevel: number, generateMipmap: boolean, premultiplyAlpha: boolean, invertY: boolean): void;
        /**
         * @en Sets the DDS data for the cube texture.
         * @param ddsInfo The DDS texture information containing the data to be set.
         * @zh 设置立方体贴图的 DDS 数据。
         * @param ddsInfo DDS纹理信息，包含要设置的数据。
         */
        setDDSData(ddsInfo: DDSTextureInfo): void;
        /**
         * @en Sets the KTX data for the cube texture.
         * @param ktxInfo The KTX texture information containing the data to be set.
         * @zh 设置立方体贴图的 KTX 数据。
         * @param ktxInfo KTX纹理信息，包含要设置的数据。
         */
        setKTXData(ktxInfo: KTXTextureInfo): void;
        /**
         * @en The default texture for cube textures.
         * @zh 立方体贴图的默认纹理。
         */
        get defaultTexture(): BaseTexture;
    }
    /**
     * @en WebGLRTMgr is a manager for creating and recycling WebGLRenderTarget.
     * TODO The demand is not high and the management cost is high. Remove it first.
     * @zh WebGLRTMgr 管理WebGLRenderTarget的创建和回收
     * TODO 需求不大，管理成本高。先去掉。
     */
    class WebGLRTMgr {
        private static dict;
        /**
         * @en Retrieves a render target with the specified width and height. For now, the search is based strictly on size.
         * @param w The width of the render target.
         * @param h The height of the render target.
         * @returns A RenderTexture2D instance.
         * @zh 根据指定的宽度和高度获得一个渲染目标。目前，搜索是基于严格大小判断的。
         * @param w 渲染目标的宽度。
         * @param h 渲染目标的高度。
         * @returns RenderTexture2D实例。
         */
        static getRT(w: number, h: number): RenderTexture2D;
        /**
         * @en Releases a render target back to the manager for recycling.
         * @param rt The RenderTexture2D instance to be recycled.
         * @zh 将渲染目标回收至管理器以供循环使用。
         * @param rt 要回收的渲染目标。
         */
        static releaseRT(rt: RenderTexture2D): void;
    }
    /**
     * @en Class representing an external skin for a Spine skeleton.
     * @zh 表示 Spine 骨骼的外部皮肤的类。
     */
    class ExternalSkin {
        /**
         * @en The target Spine skeleton.
         * @zh 目标 Spine 骨骼。
         */
        target: ISpineSkeleton;
        /**
         * @en The source of the external skin Spine.
         * @zh 外部皮肤spine的源。
         */
        get source(): string;
        set source(value: string);
        /**
         * @en The content of the external skin.
         * @zh 要设置的外部皮肤的内容。
         */
        get items(): ExternalSkinItem[];
        set items(value: ExternalSkinItem[]);
        /**
         * @en Get the reference of the animation template.
         * @zh 得到动画模板的引用。
         */
        get templet(): SpineTemplet;
        set templet(value: SpineTemplet);
        /**
         * @en Initialize the external skin with a given template.
         * @param templet The animation template reference.
         * @zh 使用给定的模板初始化外部皮肤。
         * @param templet 动画模板的引用。
         */
        protected init(templet: SpineTemplet): void;
        /**
         * @en Replace the external skin Spine.
         * @zh 替换外部皮肤 Spine。
         */
        flush(): void;
    }
    class ExternalSkinItem {
        /**
         * @en The skin.
         * @zh 皮肤。
         */
        get skin(): string;
        set skin(value: string);
        /**
         * @en The slot.
         * @zh 槽位。
         */
        get slot(): string;
        set slot(value: string);
        /**
         * @en The attachment.
         * @zh 附件。
         */
        get attachment(): string;
        set attachment(value: string);
    }
    interface ISpineRender {
        draw(skeleton: spine.Skeleton, renderNode: Spine2DRenderNode, slotRangeStart?: number, slotRangeEnd?: number): void;
    }
    interface ISpineSkeleton {
        templet: SpineTemplet;
        getSkeleton(): spine.Skeleton;
        changeNormal(): void;
    }
    /**
     * @en SpineShaderInit class handles the initialization and management of Spine shader-related components.
     * @zh SpineShaderInit 类用于处理 Spine 着色器相关组件的初始化和管理。
     */
    class SpineShaderInit {
        /**
         * @en Vertex declaration for fast Spine rendering.
         * @zh 用于快速 Spine 渲染的顶点声明。
         */
        static SpineFastVertexDeclaration: VertexDeclaration;
        /**
         * @en Vertex declaration for normal Spine rendering.
         * @zh 用于普通 Spine 渲染的顶点声明。
         */
        static SpineNormalVertexDeclaration: VertexDeclaration;
        /**
         * @en Vertex declaration for Spine rendering with runtime blending.
         * @zh 用于运行时混合的 Spine 渲染的顶点声明。
         */
        static SpineRBVertexDeclaration: VertexDeclaration;
        /**
         * @en Vertex declaration for instance normal matrix.
         * @zh 实例法线矩阵的顶点声明。
         */
        static instanceNMatrixDeclaration: VertexDeclaration;
        /**
         * @en Vertex declaration for instance simple animator.
         * @zh 实例简单动画器的顶点声明。
         */
        static instanceSimpleAnimatorDeclaration: VertexDeclaration;
        /**
         * @en Set the blend mode for Spine material.
         * @param value The blend mode value.
         * @param mat The material to set the blend mode for.
         * @param premultipliedAlpha Whether to premultiply the alpha channel.
         * @zh 设置 Spine 材质的混合模式。
         * @param value 混合模式值。
         * @param mat 要设置混合模式的材质。
         * @param premultipliedAlpha 是否预乘alpha通道。
         */
        static SetSpineBlendMode(value: number, mat: Material, premultipliedAlpha?: boolean): void;
        /**
         * @en Initialize the Spine material with default settings.
         * @param mat The material to initialize.
         * @zh 使用默认设置初始化 Spine 材质。
         * @param mat 要初始化的材质。
         */
        static initSpineMaterial(mat: Material): void;
        /**
         * @en Property ID for bone matrix.
         * @zh 骨骼矩阵的属性 ID。
         */
        static BONEMAT: number;
        /**
         * @en Property ID for normal matrix.
         * @zh 法线矩阵的属性 ID。
         */
        static NMatrix: number;
        /**
         * @en Property ID for color.
         * @zh 颜色的属性 ID。
         */
        static Color: number;
        /**
         * @en Property ID for size.
         * @zh 尺寸的属性 ID。
         */
        static Size: number;
        /**
         * @en Property ID for Spine texture.
         * @zh Spine 纹理的属性 ID。
         */
        static SpineTexture: number;
        /**
         * @en Shader define for fast Spine rendering.
         * @zh 快速 Spine 渲染的着色器定义。
         */
        static SPINE_FAST: ShaderDefine;
        /**
         * @en Shader define for Spine rendering with runtime blending.
         * @zh 运行时混合 Spine 渲染的着色器定义。
         */
        static SPINE_RB: ShaderDefine;
        /**
         * @en Shader define for simple Spine rendering.
         * @zh 简单 Spine 渲染的着色器定义。
         */
        static SPINE_SIMPLE: ShaderDefine;
        /**
         * @en Shader define for GPU instance rendering.
         * @zh GPU 实例渲染的着色器定义。
         */
        static SPINE_GPU_INSTANCE: ShaderDefine;
        static SPINE_PREMULTIPLYALPHA: ShaderDefine;
        /**
         * @en TextureSV Mesh Descript.
         * @zh 纹理 Spine 顶点属性描述。
         */
        static readonly textureSpineAttribute: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        };
        /**
         * @en Initialize Spine shader-related components.
         * @zh 初始化 Spine 着色器相关组件。
         */
        static init(): void;
    }
    /**
     * @en Abstract base class for Spine mesh rendering.
     * @zh Spine 网格渲染的抽象基类。
     */
    abstract class SpineMeshBase {
        /**
         * @en Maximum number of vertices. Limited by 64K indexbuffer constraint.
         * @zh 最大顶点数。受64K索引缓冲区限制。
         */
        static maxVertex: number;
        /**
         * @en Render element for 2D rendering.
         * @zh 用于2D渲染的渲染元素。
         */
        element: IRenderElement2D;
        /**
         * @en Geometry element for rendering.
         * @zh 用于渲染的几何元素。
         */
        geo: IRenderGeometryElement;
        private _material;
        /**
         * @en The material of the mesh.
         * @zh 网格的材质。
         */
        get material(): Material;
        set material(value: Material);
        /**
         * @en Vertex buffer interface.
         * @zh 顶点缓冲区接口。
         */
        protected vb: IVertexBuffer;
        /**
         * @en Index buffer interface.
         * @zh 索引缓冲区接口。
         */
        protected ib: IIndexBuffer;
        /**
         * @en Vertex array.
         * @zh 顶点数组。
         */
        protected vertexArray: Float32Array;
        /**
         * @en Index array.
         * @zh 索引数组。
         */
        protected indexArray: Uint16Array;
        /**
         * @en Vertex array length.
         * @zh 顶点数组中顶点的数量。
         */
        protected verticesLength: number;
        /**
         * @en Index array length.
         * @zh 引数组中索引的数量。
         */
        protected indicesLength: number;
        /**
         * @en Create a new instance of SpineMeshBase.
         * @param material The material to use for this mesh.
         * @zh 创建 SpineMeshBase 类的新实例。
         * @param material 网格使用的材质。
         */
        constructor(material: Material);
        /**
         * @en Initialize the mesh.
         * @zh 初始化网格。
         */
        init(): void;
        /**
         * @en Get the vertex declaration for this mesh.
         * @zh 获取此网格的顶点声明。
         */
        abstract get vertexDeclarition(): VertexDeclaration;
        /**
         * @en Add the mesh to the rendering queue.
         * @zh 添加到渲染队列。
         */
        draw(): void;
        /**
         * @en Draw the mesh using provided vertex and index data.
         * @param vertices Vertex data array.
         * @param vblength Number of vertices.
         * @param indices Index data array.
         * @param iblength Number of indices.
         * @zh 使用提供的顶点和索引数据绘制网格。
         * @param vertices 顶点数据数组。
         * @param vblength 顶点数量。
         * @param indices 索引数据数组。
         * @param iblength 索引数量。
         */
        drawByData(vertices: Float32Array, vblength: number, indices: Uint16Array, iblength: number): void;
        /**
         * @en Clear the mesh data.
         * @zh 清空网格数据。
         */
        clear(): void;
    }
    /**
     * @en SpineVirtualMesh class for handling Spine skeleton mesh rendering.
     * @zh SpineVirtualMesh 类用于处理 Spine 骨骼网格渲染。
     */
    class SpineVirtualMesh extends SpineMeshBase {
        /**
         * @en Size of each vertex in the vertex array.
         * @zh 顶点数组中每个顶点的大小。
         */
        static vertexSize: number;
        /**
         * @en Size of each vertex in the vertex array with Two Color.
         * @zh 双顶点色模式顶点数组中每个顶点的大小。
         */
        static vertexSize_TwoColor: number;
        /**
         * @en Shared vertex array for all instances.
         * @zh 所有实例共享的顶点数组。
         */
        static vertexArray: Float32Array;
        /**
         * @en Shared index array for all instances.
         * @zh 所有实例共享的索引数组。
         */
        static indexArray: Uint16Array;
        /**
         * @en Create a SpineVirtualMesh instance.
         * @param material Material to be used for rendering.
         * @zh 创建 SpineVirtualMesh 实例。
         * @param material 用于渲染的材质。
         */
        constructor(material: Material);
        /**
         * @en Append clipped vertices and indices.
         * @param vertices Array of vertex data.
         * @param indices Array of index data.
         * @zh 裁剪后的顶点和索引。
         * @param vertices 顶点数据数组。
         * @param indices 索引数据数组。
         */
        appendVerticesClip(vertices: ArrayLike<number>, indices: ArrayLike<number>): void;
        /**
         * @en Check if the mesh can append more vertices and indices.
         * @param verticesLength Number of vertices to be appended.
         * @param indicesLength Number of indices to be appended.
         * @returns True if the mesh can append, false otherwise.
         * @zh 检查网格是否能够添加更多的顶点和索引。
         * @param verticesLength 要添加的顶点数量。
         * @param indicesLength 要添加的索引数量。
         * @returns 如果网格可以添加则返回 true，否则返回 false。
         */
        canAppend(verticesLength: number, indicesLength: number): boolean;
        /**
         * @en Append vertices to the mesh.
         * @param vertices Array of vertex positions.
         * @param verticesLength Number of vertices to append.
         * @param indices Array of indices.
         * @param indicesLength Number of indices to append.
         * @param finalColor Color to apply to vertices.
         * @param uvs Array of UV coordinates.
         * @zh 向网格添加顶点。
         * @param vertices 顶点位置数组。
         * @param verticesLength 要添加的顶点数量。
         * @param indices 索引数组。
         * @param indicesLength 要添加的索引数量。
         * @param finalColor 应用于顶点的颜色。
         * @param uvs UV 坐标数组。
         */
        appendVertices(vertices: ArrayLike<number>, verticesLength: number, indices: number[], indicesLength: number, finalColor: spine.Color, uvs: ArrayLike<number>): void;
        /**
         * @en The vertex declaration for the mesh.
         * @zh 网格的顶点声明。
         */
        get vertexDeclarition(): VertexDeclaration;
    }
    /**
     * @en SpineWasmVirturalMesh class for handling Spine skeleton mesh rendering using WebAssembly.
     * @zh SpineWasmVirturalMesh 类用于使用 WebAssembly 处理 Spine 骨骼网格渲染。
     */
    class SpineWasmVirturalMesh extends SpineMeshBase {
        private _renderElement2D;
        /**
         * @en Create a SpineWasmVirturalMesh instance.
         * @param material Material to be used for rendering.
         * @zh 创建 SpineWasmVirturalMesh 实例。
         * @param material 用于渲染的材质。
         */
        constructor(material: Material);
        /**
         * @en The vertex declaration for the mesh.
         * @zh 网格的顶点声明。
         */
        get vertexDeclarition(): VertexDeclaration;
    }
    /**
     * @en Abstract base class for Spine normal rendering.
     * @zh Spine 普通渲染的抽象基类。
     */
    abstract class SpineNormalRenderBase {
        /**
         * @en Array of SpineMeshBase objects.
         * @zh SpineMeshBase 对象数组。
         */
        protected vmeshs: SpineMeshBase[];
        /**
         * @en Index for the next batch.
         * @zh 下一批次的索引。
         */
        protected nextBatchIndex: number;
        /**
         * @en Clears all batches by resetting meshes and batch index.
         * @zh 通过重置网格和批次索引来清除所有批次。
         */
        protected clearBatch(): void;
        /**
         * @en Abstract method to create a mesh with the given material.
         * @param material The material to be used for the mesh.
         * @zh 创建具有给定材质的网格的抽象方法。
         * @param material 用于网格的材质。
         */
        abstract createMesh(material: Material): SpineMeshBase;
        /**
         * @en Prepares the next batch for rendering.
         * @param material The material to be used for the batch.
         * @param spineRenderNode The Spine2DRenderNode to be rendered.
         * @zh 准备下一批次用于渲染。
         * @param material 用于批次的材质。
         * @param spineRenderNode 要渲染的 Spine2DRenderNode。
         */
        protected nextBatch(material: Material, spineRenderNode: Spine2DRenderNode): SpineMeshBase;
    }
    /**
     * @en SpineSkeletonRenderer class for rendering Spine skeletons.
     * @zh SpineSkeletonRenderer 类用于渲染 Spine 骨骼。
     */
    class SpineSkeletonRenderer extends SpineNormalRenderBase implements ISpineRender {
        /**
         * @en Indicates if alpha should be premultiplied.
         * @zh 指示是否应预乘 alpha。
         */
        premultipliedAlpha: boolean;
        /**
         * @en Vertex effect to be applied during rendering.
         * @zh 渲染期间要应用的顶点效果。
         */
        vertexEffect: spine.VertexEffect;
        /**
         * @en Spine templet associated with this renderer.
         * @zh 与此渲染器关联的 Spine 模板。
         */
        templet: SpineTemplet;
        private tempColor;
        private tempColor2;
        private static vertices;
        private vertexSize;
        private twoColorTint;
        private renderable;
        private clipper;
        /**
         * @en Create a mesh with the given material.
         * @param material The material to be used for the mesh.
         * @returns A SpineMeshBase object.
         * @zh 创建具有给定材质的网格。
         * @param material 用于网格的材质。
         * @returns SpineMeshBase 对象。
         */
        createMesh(material: Material): SpineMeshBase;
        /**
         * @en Create a new instance of the SpineSkeletonRenderer class.
         * @param templet The Spine templet to use.
         * @param twoColorTint Whether to use two-color tinting.
         * @zh 创建 SpineSkeletonRenderer 类的新实例。
         * @param templet 要使用的 Spine 模板。
         * @param twoColorTint 是否使用双色调色。
         */
        constructor(templet: SpineTemplet, twoColorTint?: boolean);
        /**
         * @en Draw the skeleton.
         * @param skeleton The skeleton to draw.
         * @param renderNode The render node.
         * @param slotRangeStart The starting slot index.
         * @param slotRangeEnd The ending slot index.
         * @zh 绘制骨骼。
         * @param skeleton 要绘制的骨骼。
         * @param renderNode 渲染节点。
         * @param slotRangeStart 起始插槽索引。
         * @param slotRangeEnd 结束插槽索引。
         */
        draw(skeleton: spine.Skeleton, renderNode: Spine2DRenderNode, slotRangeStart?: number, slotRangeEnd?: number): void;
    }
    /**
     * @en SpineWasmRender class for rendering Spine skeletons using WebAssembly.
     * @zh SpineWasmRender 类用于使用 WebAssembly 渲染 Spine 骨骼。
     */
    class SpineWasmRender extends SpineNormalRenderBase implements ISpineRender {
        /**
         * @en Spine templet associated with this renderer.
         * @zh 与此渲染器关联的 Spine 模板。
         */
        templet: SpineTemplet;
        private twoColorTint;
        /**
         * @en Graphics object for rendering.
         * @zh 用于渲染的图形对象。
         */
        graphics: Graphics;
        /**
         * @en Spine render object.
         * @zh Spine 渲染对象。
         */
        spineRender: any;
        /**
         * @en Creates a new SpineWasmRender instance.
         * @param templet The Spine templet to use.
         * @param twoColorTint Whether to use two-color tinting.
         * @zh 创建 SpineWasmRender 类的新实例。
         * @param templet 要使用的 Spine 模板。
         * @param twoColorTint 是否使用双色调色。
         */
        constructor(templet: SpineTemplet, twoColorTint?: boolean);
        /**
         * @en Create a mesh with the given material.
         * @param material The material to be used for the mesh.
         * @returns A SpineMeshBase object.
         * @zh 创建具有给定材质的网格。
         * @param material 用于网格的材质。
         * @returns SpineMeshBase 对象。
         */
        createMesh(material: Material): SpineMeshBase;
        /**
         * @en Draw the skeleton.
         * @param skeleton The skeleton to draw.
         * @param renderNode The render node.
         * @param slotRangeStart The starting slot index.
         * @param slotRangeEnd The ending slot index.
         * @zh 绘制骨骼。
         * @param skeleton 要绘制的骨骼。
         * @param renderNode 渲染节点。
         * @param slotRangeStart 起始插槽索引。
         * @param slotRangeEnd 结束插槽索引。
         */
        draw(skeleton: spine.Skeleton, renderNode: Spine2DRenderNode, slotRangeStart?: number, slotRangeEnd?: number): void;
    }
    /**
     * @en Represents an animation renderer for spine animations.
     * @zh 表示骨骼动画的动画渲染器。
     */
    class AnimationRender {
        /**
         * @en Temporary IBCreator for index buffer creation.
         * @zh 用于创建索引缓冲区的临时IBCreator。
         */
        static tempIbCreate: IBCreator;
        /**
         * @en Name of the animation.
         * @zh 动画的名称。
         */
        name: string;
        /**
         * @en Map of frame numbers to arrays of IChange objects.
         * @zh 帧号到IChange对象数组的映射。
         */
        changeIB: Map<number, IChange[]>;
        /**
         * @en Array of vertex buffer changes.
         * @zh 顶点缓冲区变化的数组。
         */
        changeVB: IVBChange[];
        /**
         * @en Array of frame numbers.
         * @zh 帧号数组。
         */
        frames: number[];
        /**
         * @en Total number of frames in the animation.
         * @zh 动画中的总帧数。
         */
        frameNumber: number;
        /**
         * @en Array of skin animation render data.
         * @zh 皮肤动画渲染数据数组。
         */
        skinDataArray: SkinAniRenderData[];
        /**
         * @en Array of bone transforms for each frame.
         * @zh 每帧的骨骼变换数组。
         */
        boneFrames: Float32Array[][];
        /**
         * @en Array of events for each frame.
         * @zh 每帧的事件数组。
         */
        eventsFrames: spine.Event[][];
        /**
         * @en Indicates if the animation is cached.
         * @zh 指示动画是否已缓存。
         */
        isCache: boolean;
        /**
         * @en Creates a Float32Array representing a bone's transform.
         * @param bone The spine bone to get the transform from.
         * @zh 创建表示骨骼变换的Float32Array。
         * @param bone 要获取变换的spine骨骼。
         */
        static getFloat32Array(bone: spine.Bone): Float32Array;
        /** @ignore */
        constructor();
        private checkChangeVB;
        /**
         * @en Gets the frame index for a given time.
         * @param time The time to get the frame index for.
         * @param frameIndex The current frame index.
         * @zh 获取给定时间的帧索引。
         * @param time 要获取帧索引的时间。
         * @param frameIndex 当前帧索引。
         */
        getFrameIndex(time: number, frameIndex: number): number;
        /**
         * @en Caches bone transforms for the animation.
         * @param preRender The pre-renderer to use for caching.
         * @zh 缓存动画的骨骼变换。
         * @param preRender 用于缓存的预渲染器。
         */
        cacheBones(preRender: IPreRender): void;
        /**
         * @en Checks and prepares the animation data.
         * @param animation The spine animation to check.
         * @param preRender The pre-renderer to use.
         * @zh 检查并准备动画数据。
         * @param animation 要检查的spine动画。
         * @param preRender 要使用的预渲染器。
         */
        check(animation: spine.Animation, preRender: IPreRender): void;
        /**
         * @en Creates skin animation render data.
         * @param mainVB The main vertex buffer creator.
         * @param mainIB The main index buffer creator.
         * @param slotAttachMap Map of slot attachments.
         * @param attachMap Array of attachment parses.
         * @returns The created skin animation render data.
         * @zh 创建皮肤动画渲染数据。
         * @param mainVB 主顶点缓冲区创建器。
         * @param mainIB 主索引缓冲区创建器。
         * @param slotAttachMap 插槽附件映射。
         * @param attachMap 附件解析数组。
         * @returns 创建的皮肤动画渲染数据。
         */
        createSkinData(mainVB: VBCreator, mainIB: IBCreator, slotAttachMap: Map<number, Map<string, AttachmentParse>>, attachMap: AttachmentParse[]): SkinAniRenderData;
    }
    /**
     * @en Represents skin animation render data for spine animations.
     * @zh 表示骨骼动画的皮肤动画渲染数据。
     */
    class SkinAniRenderData {
        /**
         * @en Name of the skin animation.
         * @zh 皮肤动画的名称。
         */
        name: string;
        /**
         * @en Indicates if the skin can be instanced.
         * @zh 指示皮肤是否可以实例化。
         */
        canInstance: boolean;
        /**
         * @en Array of index buffer render data.
         * @zh 索引缓冲区渲染数据数组。
         */
        ibs: IBRenderData[];
        /**
         * @en Main index buffer render data.
         * @zh 主索引缓冲区渲染数据。
         */
        mainibRender: IBRenderData;
        /**
         * @en Vertex buffer creator.
         * @zh 顶点缓冲区创建器。
         */
        vb: VBCreator;
        /**
         * @en Main index buffer creator.
         * @zh 主索引缓冲区创建器。
         */
        mainIB: IBCreator;
        /**
         * @en Indicates if multiple render calls are possible.
         * @zh 指示是否可能进行多次渲染调用。
         */
        mutiRenderAble: boolean;
        /**
         * @en Indicates if normal rendering is required.
         * @zh 指示是否需要正常渲染。
         */
        isNormalRender: boolean;
        /**
         * @en Function to check vertex buffer changes.
         * @zh 检查顶点缓冲区变化的函数。
         */
        checkVBChange: (slots: spine.Slot[]) => boolean;
        /**
         * @en Function to update bone matrices.
         * @zh 更新骨骼矩阵的函数。
         */
        updateBoneMat: (delta: number, animation: AnimationRender, bones: spine.Bone[], state: spine.AnimationState, boneMat: Float32Array) => void;
        /**
         * @en Array of vertex buffer changes.
         * @zh 顶点缓冲区变化数组。
         */
        changeVB: IVBChange[];
        /** @ignore */
        constructor();
        /**
         * @en Empty check for vertex buffer changes.
         * @param slots Spine slots.
         * @zh 空的顶点缓冲区变化检查。
         * @param slots 骨骼插槽。
         */
        checkVBChangeEmpty(slots: spine.Slot[]): boolean;
        /**
         * @en Checks for vertex buffer changes.
         * @param slots Spine slots.
         * @zh 检查顶点缓冲区变化。
         * @param slots 骨骼插槽。
         */
        checkVBChangeS(slots: spine.Slot[]): boolean;
        /**
         * @en Gets the index buffer for a given frame index.
         * @param frameIndex The frame index.
         * @zh 获取给定帧索引的索引缓冲区。
         * @param frameIndex 帧索引。
         */
        getIB(frameIndex: number): IBRenderData;
        /**
         * @en Updates bone matrices using cached data.
         * @param delta Time delta.
         * @param animation Animation render data.
         * @param bones Spine bones.
         * @param state Spine animation state.
         * @param boneMat Bone matrix array.
         * @zh 使用缓存数据更新骨骼矩阵。
         * @param delta 时间增量。
         * @param animation 动画渲染数据。
         * @param bones 骨骼数组。
         * @param state 骨骼动画状态。
         * @param boneMat 骨骼矩阵数组。
         */
        updateBoneMatCache(delta: number, animation: AnimationRender, bones: spine.Bone[], state: spine.AnimationState, boneMat: Float32Array): void;
        /**
         * @en Updates bone matrices using cached data and handles events.
         * @param delta Time delta.
         * @param animation Animation render data.
         * @param bones Spine bones.
         * @param state Spine animation state.
         * @param boneMat Bone matrix array.
         * @zh 使用缓存数据更新骨骼矩阵并处理事件。
         * @param delta 时间增量。
         * @param animation 动画渲染数据。
         * @param bones 骨骼数组。
         * @param state 骨骼动画状态。
         * @param boneMat 骨骼矩阵数组。
         */
        updateBoneMatCacheEvent(delta: number, animation: AnimationRender, bones: spine.Bone[], state: spine.AnimationState, boneMat: Float32Array): void;
        /**
         * @en Updates bone matrices using individual bone data.
         * @param delta Time delta.
         * @param animation Animation render data.
         * @param bones Spine bones.
         * @param state Spine animation state.
         * @param boneMat Bone matrix array.
         * @zh 使用单个骨骼数据更新骨骼矩阵。
         * @param delta 时间增量。
         * @param animation 动画渲染数据。
         * @param bones 骨骼数组。
         * @param state 骨骼动画状态。
         * @param boneMat 骨骼矩阵数组。
         */
        updateBoneMatByBone(delta: number, animation: AnimationRender, bones: spine.Bone[], state: spine.AnimationState, boneMat: Float32Array): void;
        /**
         * @en Initializes the skin animation render data.
         * @param tempMap Map of frame changes.
         * @param mainVB Main vertex buffer creator.
         * @param mainIB Main index buffer creator.
         * @param tempArray Array of frame numbers.
         * @param slotAttachMap Map of slot attachments.
         * @param attachMap Array of attachment parses.
         * @param changeVB Array of vertex buffer changes.
         * @zh 初始化皮肤动画渲染数据。
         * @param tempMap 帧变化映射。
         * @param mainVB 主顶点缓冲区创建器。
         * @param mainIB 主索引缓冲区创建器。
         * @param tempArray 帧号数组。
         * @param slotAttachMap 插槽附件映射。
         * @param attachMap 附件解析数组。
         * @param changeVB 顶点缓冲区变化数组。
         */
        init(tempMap: Map<number, IChange[]>, mainVB: VBCreator, mainIB: IBCreator, tempArray: number[], slotAttachMap: Map<number, Map<string, AttachmentParse>>, attachMap: AttachmentParse[], changeVB: IVBChange[]): void;
    }
    /**
     * @en Animation rendering proxy class for managing animation state and rendering.
     * @zh 动画渲染代理类，用于管理动画状态和渲染。
     */
    class AnimationRenderProxy {
        /**
         * @en The animation state.
         * @zh 动画状态。
         */
        state: spine.AnimationState;
        /**
         * @en The current animation time.
         * @zh 当前动画时间。
         */
        currentTime: number;
        /**
         * @en The current frame index.
         * @zh 当前帧索引。
         */
        currentFrameIndex: number;
        /**
         * @en The animation renderer.
         * @zh 动画渲染器。
         */
        animator: AnimationRender;
        /**
         * @en The current skin animation render data.
         * @zh 当前皮肤动画渲染数据。
         */
        currentSKin: SkinAniRenderData;
        /**
         * @en Creates an instance of AnimationRenderProxy.
         * @param animator The animation renderer.
         * @zh 创建 AnimationRenderProxy 的实例。
         * @param animator 动画渲染器。
         */
        constructor(animator: AnimationRender);
        /**
         * @en Sets the skin index.
         * @param value The skin index to set.
         * @zh 设置皮肤索引。
         * @param value 要设置的皮肤索引。
         */
        set skinIndex(value: number);
        /**
         * @en Gets the name of the animator.
         * @returns The name of the animator.
         * @zh 获取动画器的名称。
         * @returns 动画器的名称。
         */
        get name(): string;
        /**
         * @en Resets the animation state.
         * @zh 重置动画状态。
         */
        reset(): void;
        /**
         * @en Renders the animation without matrix transformation.
         * @param slots The slots to render.
         * @param updator The VB/IB updater.
         * @param curTime The current animation time.
         * @zh 不进行矩阵变换的动画渲染。
         * @param slots 要渲染的插槽。
         * @param updator VB/IB 更新器。
         * @param curTime 当前动画时间。
         */
        renderWithOutMat(slots: spine.Slot[], updator: IVBIBUpdate, curTime: number): void;
        /**
         * @en Renders the animation with matrix transformation.
         * @param bones The bones to render.
         * @param slots The slots to render.
         * @param updator The VB/IB updater.
         * @param curTime The current animation time.
         * @param boneMat The bone matrix.
         * @zh 进行矩阵变换的动画渲染。
         * @param bones 要渲染的骨骼。
         * @param slots 要渲染的插槽。
         * @param updator VB/IB 更新器。
         * @param curTime 当前动画时间。
         * @param boneMat 骨骼矩阵。
         */
        render(bones: spine.Bone[], slots: spine.Slot[], updator: IVBIBUpdate, curTime: number, boneMat: Float32Array): void;
    }
    /**
     * @en Represents a parser for spine attachments.
     * @zh 表示一个spine附件解析器。
     */
    class AttachmentParse {
        /**
         * @en The ID of the slot.
         * @zh 插槽的ID。
         */
        slotId: number;
        /**
         * @en The name of the attachment.
         * @zh 附件的名称。
         */
        attachment: string;
        /**
         * @en The color of the attachment.
         * @zh 附件的颜色。
         */
        color: TColor;
        /**
         * @en The specific color of the attachment.
         * @zh 附件的特定颜色。
         */
        attachmentColor: TColor;
        /**
         * @en The blend mode of the attachment.
         * @zh 附件的混合模式。
         */
        blendMode: number;
        /**
         * @en The vertex array of the attachment.
         * @zh 附件的顶点数组。
         */
        vertexArray: Float32Array;
        /**
         * @en The index array of the attachment.
         * @zh 附件的索引数组。
         */
        indexArray: Array<number>;
        /**
         * @en The UV coordinates of the attachment.
         * @zh 附件的UV坐标。
         */
        uvs: spine.ArrayLike<number>;
        /**
         * @en The stride of the vertex data.
         * @zh 顶点数据的步长。
         */
        stride: number;
        /**
         * @en The index of the bone.
         * @zh 骨骼的索引。
         */
        boneIndex: number;
        /**
         * @en The name of the texture.
         * @zh 纹理的名称。
         */
        textureName: string;
        /**
         * @en Indicates if the attachment is a clipping attachment.
         * @zh 指示附件是否为裁剪附件。
         */
        isclip: boolean;
        isPath: boolean;
        /**
         * @en The source data of the attachment.
         * @zh 附件的源数据。
         */
        sourceData: spine.Attachment;
        /**
         * @en The number of vertices in the attachment.
         * @zh 附件中的顶点数量。
         */
        vertexCount: number;
        /**
         * @en The number of indices in the attachment.
         * @zh 附件中的索引数量。
         */
        indexCount: number;
        /**
         * @en Indicates if normal rendering is required.
         * @zh 指示是否需要正常渲染。
         */
        isNormalRender: boolean;
        /**
         * @en The number of bones that affect a vertex.
         * @zh 影响一个顶点的最大骨骼数。
         */
        vertexBones: number;
        /**
         * @en Initializes the attachment parser with the given parameters.
         * @param attachment The spine attachment to parse.
         * @param boneIndex The index of the bone.
         * @param slotId The ID of the slot.
         * @param deform The deformation array.
         * @param slot The slot data.
         * @zh 使用给定的参数初始化附件解析器。
         * @param attachment 要解析的spine附件。
         * @param boneIndex 骨骼的索引。
         * @param slotId 插槽的ID。
         * @param deform 变形数组。
         * @param slot 插槽数据。
         */
        init(attachment: spine.Attachment, boneIndex: number, slotId: number, deform: number[], slot: spine.SlotData): boolean;
    }
    type TColor = {
        r: number;
        g: number;
        b: number;
        a: number;
    };
    /**
     * @en Represents a change in deformation for a slot in a spine animation.
     * @zh 表示骨骼动画中一个插槽的变形变化。
     */
    class ChangeDeform implements IVBChange {
        /**
         * @en The ID of the slot affected by this deformation change.
         * @zh 受此变形变化影响的插槽ID。
         */
        slotId: number;
        /**
         * @en Map storing the attachment positions for the slot.
         * @zh 存储插槽附件位置的映射。
         */
        sizeMap: Map<string, TAttamentPos>;
        /** @ignore */
        constructor();
        /**
         * @en Initializes the change with the given VBCreator.
         * @param vb The VBCreator to initialize with.
         * @returns True if initialization is successful, false otherwise.
         * @zh 使用给定的VBCreator初始化变化。
         * @param vb 用于初始化的VBCreator。
         * @returns 如果初始化成功则返回true，否则返回false。
         */
        initChange(vb: VBCreator): boolean;
        /**
         * @en Updates the vertex buffer based on the deformation change.
         * @param vb The VBCreator to update.
         * @param slots Array of spine slots.
         * @returns True if the update is successful, false otherwise.
         * @zh 根据变形变化更新顶点缓冲区。
         * @param vb 要更新的VBCreator。
         * @param slots 骨骼插槽数组。
         * @returns 如果更新成功则返回true，否则返回false。
         */
        updateVB(vb: VBCreator, slots: spine.Slot[]): boolean;
        /**
         * @en Creates a clone of this ChangeDeform instance.
         * @returns A new IVBChange instance with the same properties as this one.
         * @zh 创建此ChangeDeform实例的克隆。
         * @returns 具有与此实例相同属性的新IVBChange实例。
         */
        clone(): IVBChange;
    }
    /**
     * @en Represents a change in draw order for spine animation.
     * @zh 表示骨骼动画中绘制顺序的变化。
     */
    class ChangeDrawOrder implements IChange {
        /**
         * @en The new draw order for slots.
         * @zh 插槽的绘制顺序。
         */
        order: number[];
        /**
         * @en Changes the draw order of attachments.
         * @param attachMap An array of AttachmentParse objects.
         * @returns The new draw order as an array of numbers, or null if no change is needed.
         * @zh 更改附件的绘制顺序。
         * @param attachMap AttachmentParse对象的数组。
         * @returns 新的绘制顺序（数字数组），如果不需要更改则返回null。
         */
        changeOrder(attachMap: AttachmentParse[]): number[] | null;
        /**
         * @en Applies the draw order change to the vertex buffer.
         * @param vb The VBCreator to update.
         * @param slotAttachMap A map of slot IDs to their attachment maps.
         * @zh 将绘制顺序变化应用到顶点缓冲区。
         * @param vb 要更新的VBCreator。
         * @param slotAttachMap 插槽ID到其附件映射的Map。
         */
        change(vb: VBCreator, slotAttachMap: Map<number, Map<string, AttachmentParse>>): boolean;
    }
    /**
     * @en Represents a change in RGBA color for a slot in a spine animation.
     * @zh 表示骨骼动画中一个插槽的RGBA颜色变化。
     */
    class ChangeRGBA implements IVBChange {
        /**
         * @en The ID of the slot affected by this color change.
         * @zh 受此颜色变化影响的插槽ID。
         */
        slotId: number;
        /**
         * @en Map storing the attachment positions for the slot.
         * @zh 存储插槽附件位置的映射。
         */
        sizeMap: Map<string, TAttamentPos>;
        /**
         * @en Creates a new instance of ChangeRGBA.
         * @param slotId The ID of the slot to change.
         * @zh 创建ChangeRGBA的新实例。
         * @param slotId 要更改的插槽ID。
         */
        constructor(slotId: number);
        /**
         * @en Initializes the change with the given VBCreator.
         * @param vb The VBCreator to initialize with.
         * @returns True if initialization is successful, false otherwise.
         * @zh 使用给定的VBCreator初始化变化。
         * @param vb 用于初始化的VBCreator。
         * @returns 如果初始化成功则返回true，否则返回false。
         */
        initChange(vb: VBCreator): boolean;
        /**
         * @en Updates the vertex buffer with new RGBA values.
         * @param vb The VBCreator to update.
         * @param slots Array of spine slots.
         * @returns True if the update is successful, false otherwise.
         * @zh 使用新的RGBA值更新顶点缓冲区。
         * @param vb 要更新的VBCreator。
         * @param slots 骨骼插槽数组。
         * @returns 如果更新成功则返回true，否则返回false。
         */
        updateVB(vb: VBCreator, slots: spine.Slot[]): boolean;
        /**
         * @en Creates a clone of this ChangeRGBA instance.
         * @returns A new IVBChange instance with the same slot ID.
         * @zh 创建此ChangeRGBA实例的克隆。
         * @returns 具有相同插槽ID的新IVBChange实例。
         */
        clone(): IVBChange;
    }
    /**
     * @en Represents a change in slot attachment for a spine animation.
     * @zh 表示骨骼动画中插槽附件的变化。
     */
    class ChangeSlot implements IChange {
        /**
         * @en The ID of the slot to change.
         * @zh 要更改的插槽ID。
         */
        slotId: number;
        /**
         * @en The name of the new attachment.
         * @zh 新附件的名称。
         */
        attachment: string;
        /**
         * @en The parsed attachment data.
         * @zh 解析后的附件数据。
         */
        attachmentParse: AttachmentParse;
        /**
         * @en Applies the slot change to the vertex buffer.
         * @param vb The VBCreator to update.
         * @param slotAttachMap A map of slot IDs to their attachment maps.
         * @zh 将插槽变化应用到顶点缓冲区。
         * @param vb 要更新的VBCreator。
         * @param slotAttachMap 插槽ID到其附件映射的Map。
         */
        change(vb: VBCreator, slotAttachMap: Map<number, Map<string, AttachmentParse>>): boolean;
        /**
         * @en Updates the attachment map with the new attachment.
         * @param attachMap An array of AttachmentParse objects.
         * @zh 使用新附件更新附件映射。
         * @param attachMap AttachmentParse对象的数组。
         */
        changeOrder(attachMap: AttachmentParse[]): number[] | null;
    }
    /**
     * @en Creator class for index buffer (IB) in spine rendering.
     * @zh Spine渲染中用于创建索引缓冲区（IB）的类。
     */
    class IBCreator {
        /**
         * @en The index buffer array.
         * @zh 索引缓冲区数组。
         */
        ib: Uint16Array | Uint32Array;
        /**
         * @en The actual length of the index buffer.
         * @zh 索引缓冲区的实际长度。
         */
        ibLength: number;
        /**
         * @en The output render data for multiple renders.
         * @zh 用于多重渲染的输出渲染数据。
         */
        outRenderData: MultiRenderData;
        /**
         * @en The Max length of the index buffer.
         * @zh 索引缓冲区的最大长度。
         */
        maxIndexCount: number;
        /**
         * @en The index type.
         * @zh 索引类型。
         */
        type: IndexFormat;
        /**
         * @en The byte count of the index type.
         * @zh 索引类型字节数量。
         */
        size: number;
        /**
         * @en The actual index buffer.
         * @zh 实际索引缓冲区。
         */
        get realIb(): Uint16Array | Uint32Array;
        /** @ignore */
        constructor();
        /**
         *
         * @zh 根据顶点长度设置索引类型
         * @param vertexCount 顶点数目
         */
        updateFormat(vertexCount: number): void;
        /**
         * @en set index buffer length.
         * @param maxIndexCount The Max length of Index count.
         * @zh 设置索引缓冲长度。
         * @param maxIndexCount 索引最大个数。
         */
        setBufferLength(maxIndexCount: number): void;
        private _updateBuffer;
        /**
         * @en Create index buffer for attachments.
         * @param attachs Array of attachment parse data.
         * @param ibCreator Index buffer creator.
         * @param order Optional draw order array.
         * @zh 为附件创建索引缓冲区。
         * @param attachs 附件解析数据数组。
         * @param ibCreator 索引缓冲区创建器。
         * @param order 可选的绘制顺序数组。
         */
        createIB(attachs: AttachmentParse[], vbCreator: VBCreator, order?: number[]): void;
        static getIndexFormat(vertexCount: number): IndexFormat.UInt16 | IndexFormat.UInt32;
    }
    interface IChange {
        change(vb: VBCreator, slotAttachMap: Map<number, Map<string, AttachmentParse>>): boolean;
        changeOrder(attachMap: AttachmentParse[]): number[] | null;
    }
    interface IGetBone {
        getBoneId(boneIndex: number): number;
    }
    interface IPreRender {
        canCache: boolean;
        _updateState(delta: number): spine.Bone[];
        _play(animationName: string): number;
    }
    interface ISpineOptimizeRender {
        init(skeleton: spine.Skeleton, templet: SpineTemplet, renderNode: BaseRenderNode2D, state: spine.AnimationState): void;
        play(animationName: string): void;
        render(time: number): void;
        setSkinIndex(index: number): void;
        initBake(obj: TSpineBakeData): void;
        changeSkeleton(skeleton: spine.Skeleton): void;
        getSpineColor(): Color;
        destroy(): void;
    }
    interface IVBChange {
        initChange(vb: VBCreator): boolean;
        updateVB(vb: VBCreator, slots: spine.Slot[]): boolean;
        clone(): IVBChange;
    }
    interface IVBIBUpdate {
        updateVB(vertexArray: Float32Array, vbLength: number): void;
        updateIB(indexArray: Uint16Array | Uint32Array, type: IndexFormat, size: number, ibLength: number, mutiRenderData: MultiRenderData, isMuti: boolean): void;
    }
    type RenderData = {
        material?: Material;
        textureName: string;
        blendMode: number;
        offset: number;
        length: number;
    };
    /**
     * @en Represents a collection of multiple render data.
     * @zh 表示多个渲染数据的集合。
     */
    class MultiRenderData {
        /**
         * @en Unique identifier for MultiRenderData instances.
         * @zh MultiRenderData 实例的唯一标识符。
         */
        static ID: number;
        id: number;
        /**
         * @en Render data array.
         * @zh 渲染数据数组。
         */
        renderData: RenderData[];
        /**
         * @en The current RenderData being processed.
         * @zh 当前正在处理的 RenderData。
         */
        currentData: RenderData;
        /** @ignore */
        constructor();
        /**
         * @en Adds new render data to the collection.
         * @param textureName The name of the texture.
         * @param blendMode The blend mode for rendering.
         * @param offset The starting offset in the vertex buffer.
         * @param length The initial length of data.
         * @zh 向集合中添加新的渲染数据。
         * @param textureName 纹理的名称。
         * @param blendMode 渲染的混合模式。
         * @param offset 顶点缓冲区中的起始偏移量。
         * @param length 数据的初始长度。
         */
        addData(textureName: string, blendMode: number, offset: number, length: number): void;
        /**
         * @en Finalizes the current render data by updating its length.
         * @param length The final length of the data.
         * @zh 通过更新长度来完成当前渲染数据的处理。
         * @param length 数据的最终长度。
         */
        endData(length: number): void;
    }
    /**
     * @en SketonOptimise class used for skeleton optimization.
     * @zh SketonOptimise 类用于骨骼优化。
     */
    class SketonOptimise implements IPreRender {
        /**
         * @en Switch for normal rendering mode.
         * @zh 普通渲染模式的开关。
         */
        static normalRenderSwitch: boolean;
        /** optimise render的最大骨骼数 */
        static MAX_BONES: number;
        /**
         * @en Switch for caching mode.
         * @zh 缓存模式的开关。
         */
        static cacheSwitch: boolean;
        /**
         * @en Indicates whether caching is possible.
         * @zh 表示是否可以缓存。
         */
        canCache: boolean;
        /**
         * @en The spine skeleton object.
         * @zh spine骨骼对象。
         */
        sketon: spine.Skeleton;
        _stateData: spine.AnimationStateData;
        _state: spine.AnimationState;
        /**
         * @en Map of blend modes.
         * @zh 混合模式的映射。
         */
        blendModeMap: Map<number, number>;
        /**
         * @en Array of animation renderers.
         * @zh 动画渲染器数组。
         */
        animators: AnimationRender[];
        /**
         * @en Array of skin attachments.
         * @zh 皮肤附件数组。
         */
        skinAttachArray: SkinAttach[];
        /**
         * @en Default skin attachment.
         * @zh 默认皮肤附件。
         */
        defaultSkinAttach: SkinAttach;
        /**
         * @en Maximum number of bones.
         * @zh 最大骨骼数量。
         */
        maxBoneNumber: number;
        /**
         * @en Baked spine data.
         * @zh 烘焙的spine数据。
         */
        bakeData: TSpineBakeData;
        /** @ignore */
        constructor();
        /**
         * @en Check and initialize the main attachment.
         * @param skeletonData The skeleton data to check.
         * @zh 检查并初始化主附件。
         * @param skeletonData 要检查的骨骼数据。
         */
        checkMainAttach(skeletonData: spine.SkeletonData): void;
        /**
         * @en Parse attachments from skeleton data.
         * @param skeletonData The skeleton data to parse.
         * @zh 从骨骼数据解析附件。
         * @param skeletonData 要解析的骨骼数据。
         */
        attachMentParse(skeletonData: spine.SkeletonData): void;
        /**
         * @en Initialize animations from the skeleton data.
         * @param animations Array of animations to initialize.
         * @zh 从骨骼数据初始化动画。
         * @param animations 要初始化的动画数组。
         */
        initAnimation(animations: spine.Animation[]): void;
        /**
         * @en Cache bone data for optimization.
         * @zh 缓存骨骼数据以进行优化。
         */
        cacheBone(): void;
        /**
         * @en Initialize the skeleton with given slots.
         * @param slots Array of spine slots.
         * @zh 使用给定的插槽初始化骨骼。
         * @param slots spine插槽数组。
         */
        init(slots: spine.Slot[]): void;
    }
    /**
     * @en SkinAttach class represents skin attachment.
     * @zh SkinAttach类表示皮肤附件。
     */
    class SkinAttach {
        /**
         * @en Name of the skin attachment.
         * @zh 皮肤附件的名称。
         */
        name: string;
        /**
         * @en Attachments for each slot
         * @zh 每个插槽的附件。
         */
        slotAttachMap: Map<number, Map<string, AttachmentParse>>;
        /**
         * @en Order of main attachments.
         * @zh 主要附件的顺序。
         */
        mainAttachMentOrder: AttachmentParse[];
        /**
         * @en Indicates if normal rendering is used.
         * @zh 表示是否使用普通渲染。
         */
        isNormalRender: boolean;
        /**
         * @en Main vertex buffer creator.
         * @zh 主顶点缓冲区创建器。
         */
        mainVB: VBCreator;
        /**
         * @en Main index buffer creator.
         * @zh 主索引缓冲区创建器。
         */
        mainIB: IBCreator;
        /**
         * @en Indicates if there's any normal rendering.
         * @zh 表示是否存在任何普通渲染。
         */
        hasNormalRender: boolean;
        /**
         * @en Type of spine rendering.
         * @zh spine渲染的类型。
         */
        type: ESpineRenderType;
        /**
         * @en The number of bones that affect a vertex.
         * @zh 影响一个顶点的最大骨骼数。
         */
        vertexBones: number;
        /** @ignore */
        constructor();
        /**
         * @en Copy data from another SkinAttach.
         * @param other The SkinAttach to copy from.
         * @zh 从另一个SkinAttach复制数据。
         * @param other 要复制的SkinAttach。
         */
        copyFrom(other: SkinAttach): void;
        /**
         * @en Check and set up the main attachment.
         * @param slots Array of spine slot data.
         * @zh 检查并设置主附件。
         * @param slots spine插槽数据数组。
         */
        checkMainAttach(slots: spine.SlotData[]): void;
        /**
         * @en Parse attachments from skin data.
         * @param skinData The spine skin data.
         * @param slots Array of spine slot data.
         * @zh 从皮肤数据解析附件。
         * @param skinData spine皮肤数据。
         * @param slots spine插槽数据数组。
         */
        attachMentParse(skinData: spine.Skin, slots: spine.SlotData[]): void;
        /**
         * @en Initialize the skin attachment.
         * @param slots Array of spine slot data.
         * @zh 初始化皮肤附件。
         * @param slots spine插槽数据数组。
         */
        init(slots: spine.SlotData[]): void;
        /**
         * @en Initialize an animator with this skin attachment.
         * @param animator The animation renderer to initialize.
         * @zh 使用此皮肤附件初始化动画器。
         * @param animator 要初始化的动画渲染器。
         */
        initAnimator(animator: AnimationRender): void;
    }
    type IBRenderData = {
        realIb: Uint16Array | Uint32Array;
        type: IndexFormat;
        size: number;
        outRenderData: MultiRenderData;
    };
    type TSpineBakeData = {
        bonesNums: number;
        aniOffsetMap: {
            [key: string]: number;
        };
        texture2d?: Texture2D;
        simpPath?: string;
    };
    /**
     * @en Utility class for Spine slot operations.
     * @zh Spine 插槽操作的实用工具类。
     */
    class SlotUtils {
        /**
         * @en Check the type of attachment and determine the appropriate render type.
         * @param attachment The spine attachment to check.
         * @zh 检查附件的类型并确定适当的渲染类型。
         * @param attachment 要检查的 Spine 附件。
         */
        static checkAttachment(attachment: spine.Attachment): ESpineRenderType;
        /**
         * @en Append index array from attachment parse to the target index array.
         * @param attachmentParse The attachment parse containing the source index array.
         * @param indexArray The target index array to append to.
         * @param size The size to offset each index by.
         * @param offset The starting offset in the target index array.
         * @zh 将附件解析中的索引数组追加到目标索引数组。
         * @param attachmentParse 包含源索引数组的附件解析。
         * @param indexArray 要追加到的目标索引数组。
         * @param size 每个索引的偏移量。
         * @param offset 目标索引数组中的起始偏移量。
         */
        static appendIndexArray(attachmentParse: AttachmentParse, indexArray: Uint16Array, size: number, offset: number): number;
    }
    /**
     * @en Script class for baking Spine animations.
     * @zh 用于烘焙 Spine 动画的脚本类。
     */
    class SpineBakeScript extends Script {
        /**
         * @en URL of the data.
         * @zh 数据的地址。
         */
        url: string;
        /**
         * @en Bake data in string format.
         * @zh 字符串格式的烘焙数据。
         */
        bakeData: string;
        /** @ignore */
        constructor();
        /**
         * @en Called when the script is enabled.
         * @zh 当脚本被启用时调用。
         */
        onEnable(): void;
        /**
         * @en Called when the script is disabled.
         * @zh 当脚本被禁用时调用。
         */
        onDisable(): void;
        /**
         * @en Attaches bake data to the spine renderer.
         * @param spine The spine optimizer renderer interface.
         * @zh 将烘焙数据附加到 Spine 渲染器。
         * @param spine Spine 优化渲染器接口。
         */
        attach(spine: ISpineOptimizeRender): Promise<void>;
        private initBake;
    }
    /**
     * @en Empty implementation of the renderer for optimizing Spine animations.
     * @zh 空实现的渲染器，用于优化 Spine 动画的渲染。
     */
    class SpineEmptyRender implements ISpineOptimizeRender {
        getSpineColor(): Color;
        /**
         * @en Changes the skeleton.
         * @param skeleton The new spine skeleton.
         * @zh 更改骨骼。
         * @param skeleton 新的 Spine 骨骼。
         */
        changeSkeleton(skeleton: spine.Skeleton): void;
        /**
         * @en Singleton instance of SpineEmptyRender.
         * @zh SpineEmptyRender 的单例实例。
         */
        static instance: SpineEmptyRender;
        /**
         * @en Initializes the renderer.
         * @param skeleton The spine skeleton.
         * @param templet The spine templet.
         * @param renderNode The base render node.
         * @param state The spine animation state.
         * @zh 初始化渲染器。
         * @param skeleton Spine 骨骼。
         * @param templet Spine 模板。
         * @param renderNode 基础渲染节点。
         * @param state Spine 动画状态。
         */
        init(skeleton: spine.Skeleton, templet: SpineTemplet, renderNode: BaseRenderNode2D, state: spine.AnimationState): void;
        /**
         * @en Plays the specified animation.
         * @param animationName The name of the animation to play.
         * @zh 播放指定的动画。
         * @param animationName 要播放的动画名称。
         */
        play(animationName: string): void;
        /**
         * @en Renders the spine animation.
         * @param time The current time for rendering.
         * @zh 渲染 Spine 动画。
         * @param time 当前渲染时间。
         */
        render(time: number): void;
        /**
         * @en Sets the skin index.
         * @param index The index of the skin to set.
         * @zh 设置皮肤索引。
         * @param index 要设置的皮肤索引。
         */
        setSkinIndex(index: number): void;
        /**
         * @en Initializes bake data.
         * @param obj The spine bake data.
         * @zh 初始化烘焙数据。
         * @param obj Spine 烘焙数据。
         */
        initBake(obj: TSpineBakeData): void;
        /**
         * @en Destroys the renderer.
         * @zh 销毁渲染器。
         */
        destroy(): void;
    }
    /**
     * @en SpineInstanceBatch used for efficient rendering Spine instances.
     * @zh SpineInstanceBatch 用于高效渲染 Spine 实例。
     */
    class SpineInstanceBatch implements IBatch2DRender {
        /**
         * @en The instance of SpineInstanceBatch.
         * @zh SpineInstanceBatch 的实例。
         */
        static instance: SpineInstanceBatch;
        _recoverList: FastSinglelist<SpineInstanceInfo>;
        /**
         * @en Check if two render elements can be merged.
         * @param left The left render element to compare.
         * @param right The right render element to compare.
         * @returns True if the elements can be merged, false otherwise.
         * @zh 检测两个渲染元素是否可以合并。
         * @param left 要比较的左侧渲染元素。
         * @param right 要比较的右侧渲染元素。
         * @returns 如果元素可以合并则返回 true，否则返回 false。
         */
        check(left: IRenderElement2D, right: IRenderElement2D): boolean;
        /**
         * @en Batch render elements.
         * @param list The list of render elements.
         * @param start The starting index in the list.
         * @param length The number of elements to process.
         * @zh 批量渲染元素。
         * @param list 渲染元素列表。
         * @param start 列表中的起始索引。
         * @param length 要处理的元素数量。
         */
        batchRenderElement(list: FastSinglelist<IRenderElement2D>, start: number, length: number): void;
        /**
         * @en Update the instance buffer with new data.
         * @param info The SpineInstanceInfo object.
         * @param nMatrixData The new matrix data.
         * @param simpleAnimatorData The new animator data.
         * @param instanceCount The number of instances.
         * @zh 使用新数据更新实例缓冲区。
         * @param info SpineInstanceInfo 对象。
         * @param nMatrixData 新的矩阵数据。
         * @param simpleAnimatorData 新的动画器数据。
         * @param instanceCount 实例数量。
         */
        updateBuffer(info: SpineInstanceInfo, nMatrixData: Float32Array, simpleAnimatorData: Float32Array, instanceCount: number): void;
        /**
         * @en Organize instance data for batching.
         * @param list The list of render elements.
         * @param start The starting index in the list.
         * @param length The number of elements to process.
         * @zh 组织实例数据以进行批处理。
         * @param list 渲染元素列表。
         * @param start 列表中的起始索引。
         * @param length 要处理的元素数量。
         */
        batch(list: FastSinglelist<IRenderElement2D>, start: number, length: number): void;
        /**
         * @en Recover instance data.
         * @zh 回收实例数据。
         */
        recover(): void;
    }
    interface SpineInstanceInfo {
        element: IRenderElement2D;
        source: IRenderGeometryElement;
        state: IBufferState;
        nMatrixInstanceVB?: IVertexBuffer;
        simpleAnimatorVB?: IVertexBuffer;
    }
    /**
     * @en Tool class for managing Spine instance elements in 2D rendering.
     * @zh 用于管理 2D 渲染中的 Spine 实例元素的工具类。
     */
    class SpineInstanceElement2DTool {
        /**
         * @en Maximum number of instances that can be batched.
         * @zh 可以批处理的最大实例数量。
         */
        static MaxInstanceCount: number;
        /**
         * get Instance BufferState
         */
        private static _instanceBufferInfoMap;
        /**
         * @en Get or create a SpineInstanceInfo for a given geometry.
         * @param geometry The render geometry element.
         * @zh 获取或创建给定几何体的 SpineInstanceInfo。
         * @param geometry 渲染几何体元素。
         */
        static getInstanceInfo(geometry: IRenderGeometryElement): SpineInstanceInfo;
        /**
         * @en Create a new SpineInstanceInfo for a given geometry.
         * @param geometry The render geometry element.
         * @zh 为给定的几何体创建一个新的 SpineInstanceInfo。
         * @param geometry 渲染几何体元素。
         */
        static createInstanceInfo(geometry: IRenderGeometryElement): SpineInstanceInfo;
        /**
         * @en Recover a SpineInstanceInfo object.
         * @param info The SpineInstanceInfo to recover.
         * @zh 回收一个 SpineInstanceInfo 对象。
         * @param info 要回收的 SpineInstanceInfo。
         */
        static recover(info: SpineInstanceInfo): void;
        static _instanceBufferCreate(length: number): Float32Array;
        static _instanceBufferRecover(float32: Float32Array): void;
    }
    /**
     * @en Class for normal Spine rendering implementation.
     * @zh 普通 Spine 渲染实现类。
     */
    class SpineNormalRender implements ISpineOptimizeRender {
        getSpineColor(): Color;
        /**
         * @en Destroys the renderer.
         * @zh 销毁渲染器。
         */
        destroy(): void;
        /**
         * @en Initializes bake data.
         * @param obj The spine bake data.
         * @zh 初始化烘焙数据。
         * @param obj Spine 烘焙数据。
         */
        initBake(obj: TSpineBakeData): void;
        /**
         * @en Initializes the renderer.
         * @param skeleton The spine skeleton.
         * @param templet The spine templet.
         * @param renderNode The Spine2DRenderNode.
         * @param state The spine animation state.
         * @zh 初始化渲染器。
         * @param skeleton Spine 骨骼。
         * @param templet Spine 模板。
         * @param renderNode Spine2DRenderNode。
         * @param state Spine 动画状态。
         */
        init(skeleton: spine.Skeleton, templet: SpineTemplet, renderNode: Spine2DRenderNode, state: spine.AnimationState): void;
        /**
         * @en Plays the specified animation.
         * @param animationName The name of the animation to play.
         * @zh 播放指定的动画。
         * @param animationName 要播放的动画名称。
         */
        play(animationName: string): void;
        /**
         * @en Sets the skin index.
         * @param index The index of the skin to set.
         * @zh 设置皮肤索引。
         * @param index 要设置的皮肤索引。
         */
        setSkinIndex(index: number): void;
        /**
         * @en Changes the skeleton.
         * @param skeleton The new spine skeleton.
         * @zh 更改骨骼。
         * @param skeleton 新的 Spine 骨骼。
         */
        changeSkeleton(skeleton: spine.Skeleton): void;
        /**
         * @en Renders the spine animation.
         * @param time The current time for rendering.
         * @zh 渲染 Spine 动画。
         * @param time 当前渲染时间。
         */
        render(time: number): void;
    }
    /**
     * @en Constants used in Spine optimization.
     * @zh Spine 优化中使用的常量。
     */
    class SpineOptimizeConst {
        /**
         * @en The number of vertices for a bone in the optimized Spine rendering.
         * @zh 优化后的 Spine 渲染中，一个骨骼的顶点数。
         */
        static BONEVERTEX: number;
        /**
         * @en The number of vertices for a rigid body in the optimized Spine rendering.
         * @zh 优化后的 Spine 渲染中，一个刚体的顶点数。
         */
        static RIGIDBODYVERTEX: number;
    }
    /**
     * @en SpineOptimizeRender used for optimized rendering of Spine animations.
     * @zh SpineOptimizeRender 类用于优化 Spine 动画的渲染。
     */
    class SpineOptimizeRender implements ISpineOptimizeRender {
        /**
         * @en Map of animation names to AnimationRenderProxy objects.
         * @zh 动画名称到 AnimationRenderProxy 对象的映射。
         */
        animatorMap: Map<string, AnimationRenderProxy>;
        /**
         * @en Current animation being rendered.
         * @zh 当前正在渲染的动画。
         */
        currentAnimation: AnimationRenderProxy;
        /**
         * @en Array of Spine bones.
         * @zh Spine 骨骼数组。
         */
        bones: spine.Bone[];
        /**
         * @en Array of Spine slots.
         * @zh Spine 插槽数组。
         */
        slots: spine.Slot[];
        /**
         * @en Array of SkinRender objects.
         * @zh SkinRender 对象数组。
         */
        skinRenderArray: SkinRender[];
        /**
         * @en Current SkinRender being used.
         * @zh 当前使用的 SkinRender。
         */
        currentRender: SkinRender;
        /**
         * @en Map of ESpineRenderType to TGeo objects.
         * @zh ESpineRenderType 到 TGeo 对象的映射。
         */
        geoMap: Map<ESpineRenderType, TGeo>;
        private _isRender;
        /**
         * @en Color of the Spine object.
         * @zh Spine 对象的颜色。
         */
        spineColor: Color;
        /**
         * @en Current render proxy.
         * @zh 当前渲染代理。
         */
        renderProxy: IRender;
        /**
         * @en Map of ERenderProxyType to IRender objects.
         * @zh ERenderProxyType 到 IRender 对象的映射。
         */
        renderProxyMap: Map<ERenderProxyType, IRender>;
        /**
         * @en Float32Array for bone matrices.
         * @zh 用于骨骼矩阵的 Float32Array。
         */
        boneMat: Float32Array;
        /**
         * @en Indicates if the animation is baked.
         * @zh 指示动画是否被烘焙。
         */
        isBake: boolean;
        /**
         * @en Bake data for the Spine animation.
         * @zh Spine 动画的烘焙数据。
         */
        bakeData: TSpineBakeData;
        private _renderProxytype;
        /**
         * @en Create a new SpineOptimizeRender instance.
         * @param spineOptimize SketonOptimise object containing optimization data.
         * @zh 创建 SpineOptimizeRender 的新实例。
         * @param spineOptimize 包含优化数据的 SketonOptimise 对象。
         */
        constructor(spineOptimize: SketonOptimise);
        getSpineColor(): Color;
        /**
         * @en Destroy the SpineOptimizeRender instance.
         * @zh 销毁 SpineOptimizeRender 实例。
         */
        destroy(): void;
        /**
         * @en Initialize bake data for the Spine animation.
         * @param obj Bake data object.
         * @zh 初始化 Spine 动画的烘焙数据。
         * @param obj 烘焙数据对象。
         */
        initBake(obj: TSpineBakeData): void;
        /**
         * @en Initialize render for a specific spine render type.
         * @param type The spine render type to initialize.
         * @zh 为特定的 spine 渲染类型初始化渲染。
         * @param type 要初始化的 spine 渲染类型。
         */
        initRender(type: ESpineRenderType): TGeo;
        /**
         * @en Change the current skeleton.
         * @param skeleton The new spine skeleton to use.
         * @zh 更改当前骨骼。
         * @param skeleton 要使用的新 spine 骨骼。
         */
        changeSkeleton(skeleton: spine.Skeleton): void;
        /**
         * @en Initialize the SpineOptimizeRender with necessary components.
         * @param skeleton The spine skeleton.
         * @param templet The spine templet.
         * @param renderNode The Spine2DRenderNode.
         * @param state The spine animation state.
         * @zh 使用必要的组件初始化 SpineOptimizeRender。
         * @param skeleton Spine 骨骼。
         * @param templet Spine 模板。
         * @param renderNode Spine2DRenderNode。
         * @param state Spine 动画状态。
         */
        init(skeleton: spine.Skeleton, templet: SpineTemplet, renderNode: Spine2DRenderNode, state: spine.AnimationState): void;
        /**
         * @en The current render proxy type.
         * @zh 当前渲染代理类型。
         */
        get renderProxytype(): ERenderProxyType;
        set renderProxytype(value: ERenderProxyType);
        /**
         * @en Begin caching the animation.
         * @zh 开始缓存动画。
         */
        beginCache(): void;
        /**
         * @en End caching the animation.
         * @zh 结束缓存动画。
         */
        endCache(): void;
        /**
         * @en Set the skin index for rendering.
         * @param index The index of the skin to set.
         * @zh 设置用于渲染的皮肤索引。
         * @param index 要设置的皮肤索引。
         */
        setSkinIndex(index: number): void;
        private _clear;
        /**
         * @en Play a specific animation.
         * @param animationName The name of the animation to play.
         * @zh 播放特定的动画。
         * @param animationName 要播放的动画名称。
         */
        play(animationName: string): void;
        /**
         * @en Render the current animation at a specific time.
         * @param time The time to render the animation at.
         * @zh 在特定时间渲染当前动画。
         * @param time 要渲染动画的时间。
         */
        render(time: number): void;
    }
    enum ERenderProxyType {
        RenderNormal = 0,
        RenderOptimize = 1,
        RenderBake = 2
    }
    interface IRender {
        change(skinRender: SkinRender, currentAnimation: AnimationRenderProxy): void;
        leave(): void;
        render(curTime: number, boneMat: Float32Array): void;
    }
    /**
     * @en SkinRender used for rendering Spine skins.
     * @zh SkinRender 类用于渲染 Spine 皮肤。
     */
    class SkinRender implements IVBIBUpdate {
        /**
         * @en The owner of this SkinRender.
         * @zh 此 SkinRender 的所有者。
         */
        owner: SpineOptimizeRender;
        /**
         * @en The name of the skin.
         * @zh 皮肤的名称。
         */
        name: string;
        /**
         * @en The geometry for rendering.
         * @zh 用于渲染的几何体。
         */
        geo: IRenderGeometryElement;
        protected vb: IVertexBuffer;
        protected ib: IIndexBuffer;
        /**
         * @en Array of rendering elements.
         * @zh 渲染元素数组。
         */
        elements: [
            Material,
            number,
            number
        ][];
        private hasNormalRender;
        /**
         * @en Map of element creators.
         * @zh 元素创建器的映射。
         */
        elementsMap: Map<number, ElementCreator>;
        /**
         * @en The Spine template.
         * @zh Spine 模板。
         */
        templet: SpineTemplet;
        /**
         * @en The type of skin attachment.
         * @zh 皮肤附件的类型。
         */
        skinAttachType: ESpineRenderType;
        currentData: {
            material?: Material;
            textureName: string;
            blendMode: number;
            offset: number;
            length: number;
        };
        /**
         * @en Array of current materials.
         * @zh 当前材质数组。
         */
        currentMaterials: Material[];
        /**
         * @en The number of bones that affect a vertex.
         * @zh 影响一个顶点的最大骨骼数。
         */
        vertexBones: number;
        /**
         * @en Create a new instance of SkinRender.
         * @param owner The SpineOptimizeRender that owns this SkinRender.
         * @param skinAttach The SkinAttach data.
         * @zh 创建 SkinRender 的新实例。
         * @param owner 拥有此 SkinRender 的 SpineOptimizeRender。
         * @param skinAttach SkinAttach 数据。
         */
        constructor(owner: SpineOptimizeRender, skinAttach: SkinAttach);
        /**
         * @en Get material by name and blend mode.
         * @param name The name of the texture.
         * @param blendMode The blend mode.
         * @zh 通过名称和混合模式获取材质。
         * @param name 纹理的名称。
         * @param blendMode 混合模式。
         */
        getMaterialByName(name: string, blendMode: number): Material;
        /**
         * @en Update the vertex buffer.
         * @param vertexArray The new vertex data.
         * @param vbLength The length of the vertex data.
         * @zh 更新顶点缓冲区。
         * @param vertexArray 新的顶点数据。
         * @param vbLength 顶点数据的长度。
         */
        updateVB(vertexArray: Float32Array, vbLength: number): void;
        /**
         * @en Update the index buffer.
         * @param indexArray The new index data.
         * @param ibLength The length of the index data.
         * @param mutiRenderData Multi-render data.
         * @param isMuti Indicates if it's multi-rendering.
         * @zh 更新索引缓冲区。
         * @param indexArray 新的索引数据。
         * @param ibLength 索引数据的长度。
         * @param mutiRenderData 多重渲染数据。
         * @param isMuti 指示是否为多重渲染。
         */
        updateIB(indexArray: Uint16Array | Uint32Array, type: IndexFormat, size: number, ibLength: number, mutiRenderData: MultiRenderData, isMuti: boolean): void;
        /**
         * @en Initialize the SkinRender.
         * @param skeleton The Spine skeleton.
         * @param templet The Spine template.
         * @param renderNode The Spine2D render node.
         * @zh 初始化 SkinRender。
         * @param skeleton Spine 骨骼。
         * @param templet Spine 模板。
         * @param renderNode Spine2D 渲染节点。
         */
        init(skeleton: spine.Skeleton, templet: SpineTemplet, renderNode: Spine2DRenderNode): void;
        /**
         * @en Render the skin at a specific time.
         * @param time The time to render at.
         * @zh 在特定时间渲染皮肤。
         * @param time 要渲染的时间。
         */
        render(time: number): void;
    }
    class ElementCreator {
        /**
         * @en Array of rendering elements.
         * @zh 渲染元素数组。
         */
        elements: [
            Material,
            number,
            number
        ][];
        /**
         * @en Array of current materials.
         * @zh 当前材质数组。
         */
        currentMaterials: Material[];
        /**
         * @en Create a new instance of ElementCreator.
         * @param mutiRenderData Multi-render data.
         * @param skinData The SkinRender data.
         * @zh 创建 ElementCreator 的新实例。
         * @param mutiRenderData 多重渲染数据。
         * @param skinData SkinRender 数据。
         */
        constructor(mutiRenderData: MultiRenderData, skinData: SkinRender);
        /**
         * @en Clone the elements to a source array.
         * @param source The source array to clone to.
         * @zh 将元素克隆到源数组。
         * @param source 要克隆到的源数组。
         */
        cloneTo(source: [
            Material,
            number,
            number
        ][]): void;
    }
    type TGeo = {
        geo: IRenderGeometryElement;
        vb: IVertexBuffer;
        ib: IIndexBuffer;
    };
    /**
     * @en Abstract class for creating vertex buffers in a spine skeleton animation system.
     * @zh 用于在spine骨骼动画系统中创建顶点缓冲区的抽象类。
     */
    abstract class VBCreator implements IGetBone {
        /**
         * @en Map of bone index to bone ID.
         * @zh 骨骼索引到骨骼ID的映射。
         */
        mapIndex: Map<number, number>;
        /**
         * @en Array of bone IDs and indices.
         * @zh 骨骼ID和索引的数组。
         */
        boneArray: number[];
        /**
         * @en Vertex buffer data.
         * @zh 顶点缓冲区数据。
         */
        vb: Float32Array;
        /**
         * @en Length of the vertex buffer.
         * @zh 顶点缓冲区的长度。
         */
        vbLength: number;
        /**
         * @en Map of slot ID to attachment position data.
         * @zh 插槽ID到附件位置数据的映射。
         */
        slotVBMap: Map<number, Map<string, TAttamentPos>>;
        /**
         * @en Bone matrix data.
         * @zh 骨骼矩阵数据。
         */
        boneMat: Float32Array;
        /**
         * @en The Max Length of the vertex buffer.
         * @zh 顶点缓冲区的最大长度。
         */
        maxVertexCount: number;
        private boneMaxId;
        /**
         * @en Create a new instance of the VBCreator.
         * @param autoNew Whether to automatically create a new vertex buffer. Default is true.
         * @parma maxVertexCount The maximum number of vertices in the vertex buffer.
         * @zh 创建 VBCreator 的新实例。
         * @param autoNew 是否自动创建新的顶点缓冲区。默认为true。
         * @param maxVertexCount 顶点缓冲区中的最大顶点数。
         */
        constructor(autoNew?: boolean, maxVertexCount?: number);
        /**
         * @en Initialize the VBCreator.
         * @param autoNew Whether to automatically create a new vertex buffer.
         * @zh 初始化VBCreator。
         * @param autoNew 是否自动创建新的顶点缓冲区。
         */
        init(autoNew: boolean): void;
        protected _updateBuffer(): void;
        /**
         * @en set vertex buffer length.
         * @param maxVertexCount The Max length of Vertex count.
         * @zh 设置顶点缓冲长度。
         * @param maxVertexCount 顶点缓存区最大个数。
         */
        setBufferLength(maxVertexCount: number): void;
        /**
         * @en The size of each vertex in the vertex buffer.
         * @zh 顶点缓冲区中每个顶点的大小。
         */
        abstract get vertexSize(): number;
        /**
         * @en Append vertex data to the vertex buffer.
         * @param attachmentParse Attachment parse data.
         * @param vertexArray Vertex array to append.
         * @param offset Offset in the vertex buffer.
         * @param boneGet Interface for getting bone data.
         * @zh 将顶点数据追加到顶点缓冲区。
         * @param attachmentParse 附件解析数据。
         * @param vertexArray 要追加的顶点数组。
         * @param offset 顶点缓冲区中的偏移量。
         * @param boneGet 获取骨骼数据的接口。
         */
        abstract appendVertexArray(attachmentParse: AttachmentParse, vertexArray: Float32Array, offset: number, boneGet: IGetBone): number;
        /**
         * @en Append deform data to the output array.
         * @param attachmentParse Attachment parse data.
         * @param deform Deform data array.
         * @param offset Offset in the output array.
         * @param out Output array.
         * @zh 将变形数据追加到输出数组。
         * @param attachmentParse 附件解析数据。
         * @param deform 变形数据数组。
         * @param offset 输出数组中的偏移量。
         * @param out 输出数组。
         */
        abstract appendDeform(attachmentParse: AttachmentParse, deform: Array<number>, offset: number, out: Float32Array): void;
        /**
         * @en Append vertex buffer and create index buffer for an attachment.
         * @param attach Attachment parse data.
         * @zh 为附件追加顶点缓冲区并创建索引缓冲区。
         * @param attach 附件解析数据。
         */
        appendAndCreateIB(attach: AttachmentParse): void;
        /**
         * @en Get the bone ID for a given bone index.
         * @param boneIndex Bone index.
         * @returns Bone ID.
         * @zh 获取给定骨骼索引的骨骼ID。
         * @param boneIndex 骨骼索引。
         * @returns 骨骼ID。
         */
        getBoneId(boneIndex: number): number;
        /**
         * @en Initialize the bone matrix.
         * @zh 初始化骨骼矩阵。
         */
        initBoneMat(): void;
        /**
         * @en Append vertex buffer data for an attachment.
         * @param attach Attachment parse data.
         * @returns Offset in the vertex buffer.
         * @zh 为附件追加顶点缓冲区数据。
         * @param attach 附件解析数据。
         * @returns 顶点缓冲区中的偏移量。
         */
        appendVB(attach: AttachmentParse): number | TAttamentPos;
        /**
         * @en Update bone matrices.
         * @param bones Array of bones.
         * @param boneMat Bone matrix array.
         * @zh 更新骨骼矩阵。
         * @param bones 骨骼数组。
         * @param boneMat 骨骼矩阵数组。
         */
        updateBone(bones: spine.Bone[], boneMat: Float32Array): void;
        /**
         * @en Update bone cache.
         * @param boneFrames Array of bone frame data.
         * @param frames Frame number.
         * @param boneMat Bone matrix array.
         * @zh 更新骨骼缓存。
         * @param boneFrames 骨骼帧数据数组。
         * @param frames 帧数。
         * @param boneMat 骨骼矩阵数组。
         */
        updateBoneCache(boneFrames: Float32Array[][], frames: number, boneMat: Float32Array): void;
        _cloneTo(target: VBCreator): void;
        abstract _create(): VBCreator;
        /**
         * @en Clone this VBCreator.
         * @zh 克隆此VBCreator。
         */
        clone(): VBCreator;
    }
    /**
     * @en VBBoneCreator class used to handle bone-specific vertex buffer creation.
     * @zh VBBoneCreator 类用于处理骨骼特定的顶点缓冲区创建。
     */
    class VBBoneCreator extends VBCreator {
        _create(): VBCreator;
        /**
         * @en The size of each vertex in the vertex buffer.
         * @zh 顶点缓冲区中每个顶点的大小。
         */
        get vertexSize(): number;
        /**
         * @en Appends vertex array data for an attachment.
         * @param attachmentParse The attachment parse data.
         * @param vertexArray The vertex array to append to.
         * @param offset The current offset in the vertex array.
         * @param boneGet The interface for getting bone IDs.
         * @zh 为附件追加顶点数组数据。
         * @param attachmentParse 附件解析数据。
         * @param vertexArray 要追加到的顶点数组。
         * @param offset 顶点数组中的当前偏移量。
         * @param boneGet 获取骨骼ID的接口。
         */
        appendVertexArray(attachmentParse: AttachmentParse, vertexArray: Float32Array, offset: number, boneGet: IGetBone): number;
        /**
         * @en Appends deform data to the output array.
         * @param attachmentParse The attachment parse data.
         * @param deform The deform data array.
         * @param offset The current offset in the output array.
         * @param out The output array to append to.
         * @zh 将变形数据追加到输出数组。
         * @param attachmentParse 附件解析数据。
         * @param deform 变形数据数组。
         * @param offset 输出数组中的当前偏移量。
         * @param out 要追加到的输出数组。
         */
        appendDeform(attachmentParse: AttachmentParse, deform: Array<number>, offset: number, out: Float32Array): void;
    }
    /**
     * @en VBRigBodyCreator class used to handle rigid body specific vertex buffer creation.
     * @zh VBRigBodyCreator 类用于处理刚体特定的顶点缓冲区创建。
     */
    class VBRigBodyCreator extends VBCreator {
        /**
         * @en Gets the size of each vertex in the vertex buffer.
         * @returns The size of each vertex.
         * @zh 获取顶点缓冲区中每个顶点的大小。
         * @returns 每个顶点的大小。
         */
        get vertexSize(): number;
        /**
         * @en Appends vertex array data for an attachment.
         * @param attachmentParse The attachment parse data.
         * @param vertexArray The vertex array to append to.
         * @param offset The current offset in the vertex array.
         * @param boneGet The interface for getting bone IDs.
         * @zh 为附件追加顶点数组数据。
         * @param attachmentParse 附件解析数据。
         * @param vertexArray 要追加到的顶点数组。
         * @param offset 顶点数组中的当前偏移量。
         * @param boneGet 获取骨骼ID的接口。
         */
        appendVertexArray(attachmentParse: AttachmentParse, vertexArray: Float32Array, offset: number, boneGet: IGetBone): number;
        /**
         * @en Appends deform data to the output array.
         * @param attachmentParse The attachment parse data.
         * @param deform The deform data array.
         * @param offset The current offset in the output array.
         * @param out The output array to append to.
         * @zh 将变形数据追加到输出数组。
         * @param attachmentParse 附件解析数据。
         * @param deform 变形数据数组。
         * @param offset 输出数组中的当前偏移量。
         * @param out 要追加到的输出数组。
         */
        appendDeform(attachmentParse: AttachmentParse, deform: Array<number>, offset: number, out: Float32Array): void;
    }
    type TAttamentPos = {
        offset: number;
        attachment: AttachmentParse;
    };
    /**
     * @en The spine animation consists of three parts: `SpineTemplet`, `SpineSkeletonRender`, and `SpineSkeleton`.
     * - Event.PLAYED Used for animation start playing dispatch
     * - Event.STOPPED Used for animation stop playing dispatch
     * - Event.PAUSED Used for animation pause playing dispatch
     * - Event.LABEL Custom events.
     * @zh spine动画由`SpineTemplet`、`SpineSkeletonRender`和`SpineSkeleton`三部分组成。
     * - Event.PLAYED 用于动画开始播放调度
     * - Event.STOPPED 用于动画停止播放调度
     * - Event.PAUSED 用于动画暂停播放调度
     * - Event.LABEL 用于自定义事件
     */
    class Spine2DRenderNode extends BaseRenderNode2D implements ISpineSkeleton {
        static _pool: IRenderElement2D[];
        /**
         * @en Create a 2D render element.
         * @zh 创建2D渲染元素。
         */
        static createRenderElement2D(): IRenderElement2D;
        /**
         * @en Recover a 2D render element.
         * @param value The 2D render element to be recovered.
         * @zh 回收2D渲染元素。
         * @param value 要回收的2D渲染元素。
         */
        static recoverRenderElement2D(value: IRenderElement2D): void;
        /**
         * @en Status - Stopped
         * @zh 状态 - 停止
         */
        static readonly STOPPED: number;
        /**
         * @en Status - Paused
         * @zh 状态 - 暂停
         */
        static readonly PAUSED: number;
        /**
         * @en Status - Playing
         * @zh 状态 - 播放中
         */
        static readonly PLAYING: number;
        private _pause;
        /** 动画播放的起始时间位置*/
        private _playStart;
        /** 动画播放的结束时间位置*/
        private _playEnd;
        /** 动画的总时间*/
        private _duration;
        /** 播放速率*/
        private _playbackRate;
        private _playAudio;
        private _soundChannelArr;
        private trackIndex;
        private _skinName;
        private _animationName;
        private _loop;
        private _externalSkins;
        private _skin;
        private _matBuffer;
        /** @ignore */
        constructor();
        /**
         * @en External skins
         * @zh 外部皮肤
         */
        get externalSkins(): ExternalSkin[];
        set externalSkins(value: ExternalSkin[]);
        /**
         * @en Add command call
         * @param context The rendering context
         * @param px X coordinate
         * @param py Y coordinate
         * @zh 添加命令调用
         * @param context 渲染上下文
         * @param px X坐标
         * @param py Y坐标
         */
        addCMDCall(context: Context, px: number, py: number): void;
        /**
         * @en Reset the style of externally loaded skins
         * @zh 重置外部加载的皮肤的样式
         */
        resetExternalSkin(): void;
        /**
         * @en Animation source
         * @zh 动画源
         */
        get source(): string;
        set source(value: string);
        /**
         * @en Skin name
         * @zh 皮肤名
         */
        get skinName(): string;
        set skinName(value: string);
        /**
         * 最大播放间隔
         */
        get maxDetlaTime(): number;
        set maxDetlaTime(value: number);
        /**
         * @en Animation name
         * @zh 动画名
         */
        get animationName(): string;
        set animationName(value: string);
        /**
         * @en Whether to loop
         * @zh 是否循环
         */
        get loop(): boolean;
        set loop(value: boolean);
        /**
         * @en Set the URL of the spine animation
         * @zh 设置spine动画的URL
         */
        set url(value: string);
        get url(): string;
        /**
         * @en The reference to the animation template.
         * @returns The animation template.
         * @zh 动画模板的引用。
         * @returns 动画模板。
         */
        get templet(): SpineTemplet;
        set templet(value: SpineTemplet);
        /**
         * @en Set the current playback position.
         * @param value Current time in milliseconds.
         * @zh 设置当前播放位置。
         * @param value 当前时间。
         */
        set currentTime(value: number);
        /**
         * @en Get the current playback state.
         * @returns The current playback state.
         * @zh 获取当前播放状态。
         * @returns 当前播放状态。
         */
        get playState(): number;
        private _useFastRender;
        /**
         * @en Whether to use fast rendering. It is enabled by default. When some complex spines are enabled, this value will render errors. For example, the number of bone controls of a vertex in the spine resource is greater than 4
         * @returns Whether to use the state of fast rendering currently.
         * @zh 是否使用快速渲染，默认开启，某些复杂的Spine开启此值会渲染错误，比如spine资源中某个顶点的骨骼控制数大于4
         * @returns 当前是否使用快速渲染的状态。
         */
        set useFastRender(value: boolean);
        get useFastRender(): boolean;
        spineItem: ISpineOptimizeRender;
        /** @ignore */
        onAwake(): void;
        /**
         * @en Initialize the Spine animation
         * @param templet The Spine template to initialize with
         * @zh 初始化Spine动画
         * @param templet 用于初始化的Spine模板
         */
        protected init(templet: SpineTemplet): void;
        /**
         * @en Play the animation.
         * @param nameOrIndex Animation name or index.
         * @param loop Whether to loop the animation.
         * @param force If false, the animation won't play if it's the same as the previous one; if true, it will force play.
         * @param start Start time.
         * @param end End time.
         * @param freshSkin Whether to refresh skin data.
         * @param playAudio Whether to play audio.
         * @zh 播放动画。
         * @param nameOrIndex 动画名字或者索引。
         * @param loop 是否循环播放。
         * @param force 如果为false，要播的动画跟上一个相同就不生效；如果为true，强制生效。
         * @param start 起始时间。
         * @param end 结束时间。
         * @param freshSkin 是否刷新皮肤数据。
         * @param playAudio 是否播放音频。
         */
        play(nameOrIndex: string | number, loop: boolean, force?: boolean, start?: number, end?: number, freshSkin?: boolean, playAudio?: boolean): void;
        private _update;
        private _flushExtSkin;
        /**
         * @en Get the number of current animations
         * @zh 获取当前动画的数量
         */
        getAnimNum(): number;
        /**
         * @en Get the name of the specified animation
         * @param index The index of the animation
         * @zh 获取指定动画的名字
         * @param index 动画的索引
         */
        getAniNameByIndex(index: number): string;
        /**
    
         * @en Get the reference of a slot by its name
         * @param slotName The name of the slot
         * @zh 通过名字获取插槽的引用
         * @param slotName 插槽的名字
         */
        getSlotByName(slotName: string): spine.Slot;
        /**
         * @en Set the animation playback rate
         * @param value 1 is the standard rate
         * @zh 设置动画播放速率
         * @param value 1为标准速率
         */
        playbackRate(value: number): void;
        /**
         * @en Show a skin by its name
         * @param name The name of the skin
         * @zh 通过名字显示一套皮肤
         * @param name 皮肤的名字
         */
        showSkinByName(name: string): void;
        /**
         * @en Show a skin by its index
         * @param skinIndex The index of the skin
         * @zh 通过索引显示一套皮肤
         * @param skinIndex 皮肤索引
         */
        showSkinByIndex(skinIndex: number): void;
        /**
         * @en Trigger an event
         * @param type The type of the event
         * @param data The data associated with the event
         * @zh 触发事件
         * @param type 事件类型
         * @param data 与事件关联的数据
         */
        event(type: string, data?: any): void;
        /**
         * @en Stop the animation
         * @zh 停止动画
         */
        stop(): void;
        private _clearUpdate;
        private _beginUpdate;
        private _needUpdate;
        /**
         * @ignore
         * @en Update method called every frame
         * @zh 每帧调用的更新方法
         */
        onUpdate(): void;
        /**
         * @en Pause the animation playback
         * @zh 暂停动画的播放
         */
        paused(): void;
        /**
         * @en Resume the animation playback
         * @zh 恢复动画的播放
         */
        resume(): void;
        /**
         * 清掉播放完成的音频
         * @param force 是否强制删掉所有的声音channel
         */
        private _onAniSoundStoped;
        /**
         * @en Reset the Spine animation component
         * @zh 重置Spine动画组件
         */
        reset(): void;
        /**
         * @en Add an animation to the queue
         * @param nameOrIndex Animation name or index
         * @param loop Whether to loop the animation
         * @param delay Delay before playing the animation (in seconds, can be negative)
         * @zh 添加一个动画到队列
         * @param nameOrIndex 动画名字或者索引
         * @param loop 是否循环播放
         * @param delay 延迟调用时间
         */
        addAnimation(nameOrIndex: string | number, loop?: boolean, delay?: number): void;
        /**
         * @en Set the duration of the mix between two animations
         * @param fromNameOrIndex Name or index of the source animation
         * @param toNameOrIndex Name or index of the target animation
         * @param duration Mix duration in seconds
         * @zh 设置当动画被改变时，存储混合(交叉淡出)的持续时间
         * @param fromNameOrIndex 源动画的名称或索引
         * @param toNameOrIndex 目标动画的名称或索引
         * @param duration 混合持续时间
         */
        setMix(fromNameOrIndex: any, toNameOrIndex: any, duration: number): void;
        /**
         * @en Get bone information (spine.Bone)
         * Note: The returned bone information is from Spine runtime (spine.Bone) and is not compatible with engine methods
         * @param boneName Name of the bone
         * @returns Bone information
         * @zh 获取骨骼信息(spine.Bone)
         * 注意: 获取到的是spine运行时的骨骼信息(spine.Bone)，不适用于引擎的方法
         * @param boneName 骨骼名称
         * @returns 骨骼信息
         */
        getBoneByName(boneName: string): spine.Bone;
        /**
         * @en Get the Skeleton (spine.Skeleton)
         * @returns Spine Skeleton
         * @zh 获取Skeleton(spine.Skeleton)
         * @returns Spine骨架
         */
        getSkeleton(): spine.Skeleton;
        /**
         * @en Replace slot attachment
         * @param slotName Name of the slot
         * @param attachmentName Name of the attachment
         * @zh 替换插槽皮肤
         * @param slotName 插槽名称
         * @param attachmentName 附件名称
         */
        setSlotAttachment(slotName: string, attachmentName: string): void;
        /**
         * @en Clear render elements
         * @zh 清除渲染元素
         */
        clear(): void;
        /**
         * @en Change to normal render mode
         * @zh 切换到普通渲染模式
         */
        changeNormal(): void;
        /**
         * @ignore
         * @en Called when the component is being destroyed
         * @zh 当组件被销毁时调用
         */
        onDestroy(): void;
        /**
         * @en Draw geometries
         * @param geo Render geometry element
         * @param elements Array of [Material, startIndex, indexCount]
         * @zh 绘制几何体
         * @param geo 渲染几何元素
         * @param elements [材质, 起始索引, 索引数量] 数组
         */
        drawGeos(geo: IRenderGeometryElement, elements: [
            Material,
            number,
            number
        ][]): void;
        /**
         * @en Update render elements
         * @param geo Render geometry element
         * @param elements Array of [Material, startIndex, indexCount]
         * @zh 更新渲染元素
         * @param geo 渲染几何元素
         * @param elements [材质, 起始索引, 索引数量] 数组
         */
        updateElements(geo: IRenderGeometryElement, elements: [
            Material,
            number,
            number
        ][]): void;
        /**
         * @en Draw a single geometry
         * @param geo Render geometry element
         * @param material Material to use for rendering
         * @param count indexCount
         * @param offset startIndex
         * @zh 绘制单个几何体
         * @param geo 渲染几何元素
         * @param material 用于渲染的材质
         * @param count 索引数量
         * @param offset 起始索引
         */
        drawGeo(geo: IRenderGeometryElement, material: Material, count: number, offset: number): void;
        /**
         * @en Get material for rendering
         * @param texture Texture to use
         * @param blendMode Blend mode
         * @returns Material for rendering
         * @zh 获取用于渲染的材质
         * @param texture 要使用的纹理
         * @param blendMode 混合模式
         * @returns 用于渲染的材质
         */
        getMaterial(texture: Texture2D, blendMode: number): Material;
    }
    enum ERenderType {
        normal = 0,
        boneGPU = 1,
        rigidBody = 2
    }
    /**
     * @en SpineAdapter is an adapter class for integrating the Spine animation system.
     * @zh SpineAdapter 是一个适配器类，用于集成 Spine 动画系统。
     */
    class SpineAdapter {
        static _vbArray: Float32Array;
        static _ibArray: Uint16Array;
        static _spine: any;
        /**
         * @en Indicates whether the Spine system is using WebAssembly.
         * @zh 指示 Spine 系统是否使用 WebAssembly。
         */
        static isWasm: boolean;
        /**
         * @en Map of state values to their corresponding string representations.
         * @zh 状态值到其对应字符串表示的映射。
         */
        static stateMap: any;
        /**
         * @en Create a normal render object for Spine animation.
         * @param templet The Spine template.
         * @param twoColorTint Whether to use two-color tinting.
         * @zh 为 Spine 动画创建一个普通渲染对象。
         * @param templet Spine 模板。
         * @param twoColorTint 是否使用两色染色。
         */
        static createNormalRender(templet: SpineTemplet, twoColorTint: boolean): SpineWasmRender | SpineSkeletonRenderer;
        /**
         * @en Perform all necessary adaptations for Spine integration.
         * @zh 执行所有必要的 Spine 集成适配。
         */
        static allAdpat(): void;
        /**
         * @en Adapt the JavaScript version of Spine.
         * @zh 适配 JavaScript 版本的 Spine。
         */
        static adaptJS(): void;
        /**
         * @en Initialize and extend the Spine animation library's AnimationState prototype.
         * @zh 初始化并扩展Spine动画库的AnimationState原型。
         */
        static initClass(): void;
        /**
         * @en Bind vertex and index buffers for Spine rendering.
         * @param maxNumVertices Maximum number of vertices.
         * @param maxNumIndices Maximum number of indices.
         * @zh 为 Spine 渲染绑定顶点和索引缓冲区。
         * @param maxNumVertices 最大顶点数量。
         * @param maxNumIndices 最大索引数量。
         */
        static bindBuffer(maxNumVertices: number, maxNumIndices: number): void;
        /**
         * @en Draw a Spine skeleton.
         * @param fun The drawing function.
         * @param skeleton The Spine skeleton to draw.
         * @param twoColorTint Whether to use two-color tinting.
         * @param slotRangeStart The starting slot index.
         * @param slotRangeEnd The ending slot index.
         * @zh 绘制 Spine 骨骼。
         * @param fun 绘制函数。
         * @param skeleton 要绘制的 Spine 骨骼。
         * @param twoColorTint 是否使用两色混色。
         * @param slotRangeStart 起始插槽索引。
         * @param slotRangeEnd 结束插槽索引。
         */
        static drawSkeleton(fun: Function, skeleton: any, twoColorTint: boolean, slotRangeStart: number, slotRangeEnd: number): void;
    }
    /**动画开始播放调度
     * @eventType Event.PLAYED
     * */
    /**动画停止播放调度
     * @eventType Event.STOPPED
     * */
    /**动画暂停播放调度
     * @eventType Event.PAUSED
     * */
    /**自定义事件。
     * @eventType Event.LABEL
     */
    /**
     * @deprecated 请使用Sprite+Spine2DRenderNode组件
     * spine动画由<code>SpineTemplet</code>，<code>SpineSkeletonRender</code>，<code>SpineSkeleton</code>三部分组成。
     */
    class SpineSkeleton extends Sprite {
        private _spineComponent;
        constructor();
        /**
         * 外部皮肤
         */
        get externalSkins(): ExternalSkin[];
        set externalSkins(value: ExternalSkin[]);
        /**
         * 重置外部加载的皮肤的样式
         */
        resetExternalSkin(): void;
        /**
         * 动画源
         */
        get source(): string;
        set source(value: string);
        /**
         * 皮肤名
         */
        get skinName(): string;
        set skinName(value: string);
        /**
         * 动画名
         */
        get animationName(): string;
        set animationName(value: string);
        /**
         * 是否循环
         */
        get loop(): boolean;
        set loop(value: boolean);
        /**
         * 得到动画模板的引用
         * @return templet
         */
        get templet(): SpineTemplet;
        /**
         * 设置动画模板的引用
         */
        set templet(value: SpineTemplet);
        /**
         * 设置当前播放位置
         * @param	value 当前时间
         */
        set currentTime(value: number);
        /**
         * 获取当前播放状态
         * @return	当前播放状态
         */
        get playState(): number;
        get spineItem(): ISpineOptimizeRender;
        set spineItem(value: ISpineOptimizeRender);
        /**
         * 播放动画
         *
         * @param	nameOrIndex	动画名字或者索引
         * @param	loop		是否循环播放
         * @param	force		false,如果要播的动画跟上一个相同就不生效,true,强制生效
         * @param	start		起始时间
         * @param	end			结束时间
         * @param	freshSkin	是否刷新皮肤数据
         * @param	playAudio	是否播放音频
         */
        play(nameOrIndex: any, loop: boolean, force?: boolean, start?: number, end?: number, freshSkin?: boolean, playAudio?: boolean): void;
        /**
         * 得到当前动画的数量
         * @return 当前动画的数量
         */
        getAnimNum(): number;
        /**
         * 得到指定动画的名字
         * @param	index	动画的索引
         */
        getAniNameByIndex(index: number): string;
        /**
         * 通过名字得到插槽的引用
         * @param slotName
         */
        getSlotByName(slotName: string): spine.Slot;
        /**
         * 设置动画播放速率
         * @param	value	1为标准速率
         */
        playbackRate(value: number): void;
        /**
         * 通过名字显示一套皮肤
         * @param	name	皮肤的名字
         */
        showSkinByName(name: string): void;
        /**
         * 通过索引显示一套皮肤
         * @param	skinIndex	皮肤索引
         */
        showSkinByIndex(skinIndex: number): void;
        /**
         * 停止动画
         */
        stop(): void;
        /**
         * 暂停动画的播放
         */
        paused(): void;
        /**
         * 恢复动画的播放
         */
        resume(): void;
        /**
         * 销毁当前动画
         * @override
         */
        destroy(destroyChild?: boolean): void;
        /**
         * 添加一个动画
         * @param nameOrIndex   动画名字或者索引
         * @param loop          是否循环播放
         * @param delay         延迟调用，可以为负数
         */
        addAnimation(nameOrIndex: any, loop?: boolean, delay?: number): void;
        /**
         * 设置当动画被改变时，存储混合(交叉淡出)的持续时间
         * @param fromNameOrIndex
         * @param toNameOrIndex
         * @param duration
         */
        setMix(fromNameOrIndex: any, toNameOrIndex: any, duration: number): void;
        /**
         * 获取骨骼信息(spine.Bone)
         * 注意: 获取到的是spine运行时的骨骼信息(spine.Bone)，不适用引擎的方法
         * @param boneName
         */
        getBoneByName(boneName: string): spine.Bone;
        /**
         * 获取Skeleton(spine.Skeleton)
         */
        getSkeleton(): spine.Skeleton;
        /**
         * 替换插槽皮肤
         * @param slotName
         * @param attachmentName
         */
        setSlotAttachment(slotName: string, attachmentName: string): void;
    }
    enum ESpineRenderType {
        boneGPU = 0,
        normal = 1,
        rigidBody = 2
    }
    /**
     * @en Base class for Spine animation template
     * @zh Spine动画模板基类
     */
    class SpineTemplet extends Resource {
        /**
         * @en Runtime version of Spine
         * @zh Spine运行时版本
         */
        static RuntimeVersion: string;
        /**
         * @en Skeleton data for the Spine animation
         * @zh Spine动画的骨骼数据
         */
        skeletonData: spine.SkeletonData;
        /**
         * @en Map of materials used in the Spine animation
         * @zh Spine动画中使用的材质映射
         */
        materialMap: Map<string, Material>;
        private _textures;
        private _basePath;
        /**
         * @en Base width of spine animation
         * @zh spine 动画基础宽度
         */
        width: number;
        /**
         * @en Base height of spine animation
         * @zh spine 动画基础高度
         */
        height: number;
        /**
         * @en X-axis offset of spine animation
         * @zh spine 动画X轴偏移
         */
        offsetX: number;
        /**
         * @en Y-axis offset of spine animation
         * @zh spine 动画Y轴偏移
         */
        offsetY: number;
        /**
         * @en Indicates if slot is needed
         * @zh 是否需要插槽
         */
        needSlot: boolean;
        /**
         * @en Skeleton optimization object
         * @zh 骨骼优化对象
         */
        sketonOptimise: SketonOptimise;
        /** @ignore */
        constructor();
        /**
         * @en The main texture of the Spine animation
         * @zh Spine动画的主纹理
         */
        mainTexture: Texture2D;
        /**
         * @en The main blend mode of the Spine animation
         * @zh Spine动画的主混合模式
         */
        mainBlendMode: number;
        private _premultipliedAlpha;
        /**
         * @en Switch for premultipliedAlpha.
         * @zh 透明预乘的开关。
         */
        get premultipliedAlpha(): boolean;
        /**
         * @en The base path of the Spine animation resources
         * @zh Spine动画资源的基础路径
         */
        get basePath(): string;
        /**
         * @en Get or create a material for the given texture and blend mode
         * @param texture The texture to use
         * @param blendMode The blend mode to use
         * @zh 获取或创建给定纹理和混合模式的材质
         * @param texture 要使用的纹理
         * @param blendMode 要使用的混合模式
         */
        getMaterial(texture: Texture2D, blendMode: number): Material;
        /**
         * @en Get a texture by its name
         * @param name The name of the texture
         * @zh 通过名称获取纹理
         * @param name 纹理的名称
         */
        getTexture(name: string): Texture2D;
        /**
         * @en Get the animation name by its index
         * @param index The index of the animation
         * @zh 通过索引获取动画名称
         * @param index 动画的索引
         */
        getAniNameByIndex(index: number): string;
        /**
         * @en Find the animation by its name
         * @param name The name of the animation to find
         * @returns The found animation index, or -1 if not found
         * @zh 通过动画名称查找动画
         * @param name 要查找的动画名称
         * @returns 找到的动画索引，如果未找到则返回-1
         */
        findAnimation(name: string): spine.Animation;
        /**
         * @en Get the skin index by its name
         * @param skinName The name of the skin
         * @zh 通过皮肤名称获取皮肤索引
         * @param skinName 皮肤名称
         */
        getSkinIndexByName(skinName: string): number;
        /**
         * @en Release textures and materials
         * @zh 释放纹理和材质
         */
        protected _disposeResource(): void;
    }
    /**
     * @en Used for adaptation to version 3.8
     * @zh 用于3.8版本适配
     */
    class SpineTexture {
        /**
         * @en The actual Texture2D object
         * @zh 实际的Texture2D对象
         */
        realTexture: Texture2D;
        /**
         * @en Creates a new SpineTexture instance.
         * @param tex The Texture2D to be wrapped
         * @zh 创建SpineTexture的新实例
         * @param tex 要被包装的Texture2D
         */
        constructor(tex: Texture2D);
        /**
         * @en Get the image dimensions
         * @zh 获取图像尺寸
         */
        getImage(): Object;
        /**
         * @en Set the texture filters
         * @param minFilter The minification filter
         * @param magFilter The magnification filter
         * @zh 设置纹理过滤器
         * @param minFilter 缩小过滤器
         * @param magFilter 放大过滤器
         */
        setFilters(minFilter: spine.TextureFilter, magFilter: spine.TextureFilter): void;
        /**
         * @en Convert Spine texture wrap mode to LayaAir wrap mode
         * @param mode The Spine texture wrap mode
         * @zh 将Spine纹理包裹模式转换为LayaAir包裹模式
         * @param mode Spine纹理包裹模式
         */
        convertWrapMode(mode: spine.TextureWrap): WrapMode;
        /**
         * @en Set the texture wrap modes
         * @param uWrap The horizontal wrap mode
         * @param vWrap The vertical wrap mode
         * @zh 设置纹理包裹模式
         * @param uWrap 水平包裹模式
         * @param vWrap 垂直包裹模式
         */
        setWraps(uWrap: spine.TextureWrap, vWrap: spine.TextureWrap): void;
    }
    /**
     * @private
     */
    class System {
        /**
         * 替换指定名称的定义。用来动态更改类的定义。
         * @param	name 属性名。
         * @param	classObj 属性值。
         */
        static changeDefinition(name: string, classObj: any): void;
    }
    function testSimple(): Promise<void>;
    class LayaTest {
        static test(): void;
    }
    function usewebgl(): void;
    class PerfTools {
        static begin(block: string): void;
        static end(block: string): void;
    }
    class PerformanceDefine {
        static T_FPS: string;
        static C_UniformBufferUploadCount: string;
        static C_GeometryBufferUploadCount: string;
        static C_overdraw: string;
        static C_trangleCount: string;
        static C_SetRenderPassCount: string;
        static C_DrawCallCount: string;
        static C_Instancing_DrawCallCount: string;
        static C_TransDrawCall: string;
        static C_OpaqueDrawCall: string;
        static C_DepthCastDrawCall: string;
        static C_ShadowDrawCall: string;
        static C_ShaderCompile: string;
        static T_ShaderCompile: string;
        static M_GPUBuffer: string;
        static M_VertexBuffer: string;
        static M_IndexBuffer: string;
        static M_UniformBlockBuffer: string;
        static RC_GPUBuffer: string;
        static RC_VertexBuffer: string;
        static RC_IndexBuffer: string;
        static RC_UniformBlockBuffer: string;
        static M_ALLTexture: string;
        static M_Texture2D: string;
        static M_TextureCube: string;
        static M_Texture3D: string;
        static M_Texture2DArray: string;
        static RC_ALLTexture: string;
        static RC_Texture2D: string;
        static RC_TextureCube: string;
        static RC_Texture3D: string;
        static RC_Texture2DArray: string;
        static M_ALLRenderTexture: string;
        static RC_ALLRenderTexture: string;
        static T_CameraRender: string;
        static T_Render_OpaqueRender: string;
        static T_Render_TransparentRender: string;
        static T_Render_PostProcess: string;
        static T_Render_CameraEventCMD: string;
        static T_Render_ShadowPassMode: string;
        static T_Render_CameraOtherDest: string;
        static T_RenderPreUpdate: string;
        static T_CameraMainCull: string;
        static T_ShadowMapCull: string;
        static T_OnlyMeshRender: string;
        static T_OnlySkinnedMeshRender: string;
        static T_OnlyShurikenParticleRender: string;
        static T_OtherRender: string;
        static C_Sprite3DCount: string;
        static C_BaseRenderCount: string;
        static C_MeshRenderCount: string;
        static C_SkinnedMeshRenderCount: string;
        static C_ShurikenParticleRenderCount: string;
        static T_AnimatorUpdate: string;
        static T_SkinBoneUpdate: string;
        static T_ShurikenUpdate: string;
        static T_Physics_Simulation: string;
        static T_Physics_UpdateNode: string;
        static T_PhysicsEvent: string;
        static C_PhysicsEventCount: string;
        static T_PhysicsCollider: string;
        static T_PhysicsTrigger: string;
        static T_PhysicsColliderEnter: string;
        static T_PhysicsColliderExit: string;
        static T_PhysicsColliderStay: string;
        static T_PhysicsTriggerEnter: string;
        static T_PhysicsTriggerExit: string;
        static T_PhysicsTriggerStay: string;
        static C_PhysicaDynamicRigidBody: string;
        static C_PhysicaStaticRigidBody: string;
        static C_PhysicaKinematicRigidBody: string;
        static C_PhysicaCharacterController: string;
        static C_PhysicsJoint: string;
        static T_LoadResourceTime: string;
        static C_LoadResourceCount: string;
        static C_LoadRequestCount: string;
        static T_LoadRequestTime: string;
        static T_UITime: string;
        static C_UICount: string;
        static C_DrawCount: string;
        static T_UIRender: string;
    }
    /**
     * 性能统计开始
     * @param block 统计标识（例如：PerformanceDefine.SCENE3D_RENDER）
     */
    function PERF_BEGIN(block: string): void;
    /**
     * 性能统计结束
     * @param block 统计标识（例如：PerformanceDefine.SCENE3D_RENDER）
     */
    function PERF_END(block: string): void;
    function PERF_FRAMECLEAR(): void;
    /**
     * @en The `AutoBitmap` class is a display object that represents bitmap images or graphics.
     * It encapsulates the handling of position, width, height, and nine-patch for UI components.
     * @zh `AutoBitmap` 类是用于表示位图图像或绘制图形的显示对象。
     * 封装了位置，宽高及九宫格的处理，供UI组件使用。
     */
    class AutoBitmap extends Graphics {
        /** 宽度*/
        private _width;
        /** 高度*/
        private _height;
        /** 源数据*/
        private _source;
        /** 纹理的九宫格数据 */
        private _sizeGrid;
        protected _isChanged: boolean;
        protected _stateIndex: number;
        protected _stateNum: number;
        private _drawGridCmd;
        uv: number[];
        /**
         * @en The size grid of the texture.
         * The size grid is a 3x3 division of the texture, allowing it to be scaled without distorting the corners and edges.
         * The array contains five values representing the top, right, bottom, and left margins, and whether to repeat the fill (0: no repeat, 1: repeat).
         * The values are separated by commas. For example: "6,6,6,6,1".
         * @zh 纹理的九宫格数据。
         * 九宫格是一种将纹理分成3x3格的方式，使得纹理缩放时保持角和边缘不失真。
         * 数组包含五个值，分别代表上边距、右边距、下边距、左边距以及是否重复填充（0：不重复填充，1：重复填充）。
         * 值以逗号分隔。例如："6,6,6,6,1"。
         */
        get sizeGrid(): number[];
        set sizeGrid(value: number[]);
        /**
         * @en The width of the display object, in pixels.
         * @zh 表示显示对象的宽度，以像素为单位。
         */
        get width(): number;
        set width(value: number);
        /**
         * @en The height of the display object, in pixels.
         * @zh 表示显示对象的高度，以像素为单位。
         */
        get height(): number;
        set height(value: number);
        /**
         * @en The texture resource of the object.
         * @zh 对象的纹理资源。
         */
        get source(): Texture;
        set source(value: Texture);
        /**
         * @en The color of the object.
         * @zh 对象的颜色。
         */
        get color(): string;
        set color(value: string);
        /**
         * @en Mark the object as changed.
         * @zh 标记对象为已更改状态。
         */
        protected _setChanged(): void;
        /**
         * @en Change the texture resource.
         * @zh 修改纹理资源。
         */
        protected changeSource(): void;
        /**
         * @en Due to the possibility of other graphic commands, the original method of directly using clear() cannot be used.
         * @zh 由于可能有其他的graphic命令，因此不能用原来的直接clear()的方法
         */
        private _setDrawGridCmd;
        /**
         * @en Destroy the object.
         * @zh 销毁对象。
         */
        destroy(): void;
    }
    /**
     * @en The `Box` class is the base class for UI containers.
     * Other container components will inherit from this class.
     * @zh `Box` 类是 UI 容器的基类。
     * 其他的容器组件都会继承于该类。
     */
    class Box extends UIComponent {
        /**
         * @en The background color.
         * @zh 背景颜色。
         */
        private _bgColor;
        set_dataSource(value: any): void;
        /**
        * @en background color
        * @zh 容器的背景颜色
        */
        get bgColor(): string;
        set bgColor(value: string);
    }
    /**
     * @en The Button component is used to represent a button with multiple states. The Button component can display a text label, an icon, or both.
     * The states can be single-state, two-state (normal, pressed), or three-state (normal, hover, pressed). By default, it is three-state.
     * @zh `Button` 组件用来表示多种状态的按钮。`Button` 组件可显示文本标签、图标或同时显示两者。
     * 多种状态，可以是单态，两态（移出、按下）和三态(移出、悬停、按下)，默认是三态。
     */
    class Button extends UIComponent implements ISelect {
        /**
         * @en Controls whether the button can toggle its display state. When the value is true, the display state can be toggled by clicking, such as switching between selected and unselected states.
         * @zh 用于控制按钮是否可切换显示状态；值为 true 时，才可以在运行后通过点击切换显示状态。例如选中状态和未选中状态。
         */
        toggle: boolean;
        /**
         * @en The text on the button.
         * @zh 按钮上的文本。
         */
        protected _text: Text;
        /**
         * @en The color value of the button's text label.
         * @zh 按钮文本标签的颜色值。
         */
        protected _labelColors: string[];
        /**
         * @en The color value of the button's text label stroke.
         * @zh 按钮文本标签描边的颜色值。
         */
        protected _strokeColors: string[];
        /**
         * @en The state value of the button.
         * @zh 按钮的状态值。
         */
        protected _state: number;
        /**
         * @en Indicates the selected state of the button.
         * @zh 表示按钮的选中状态。
         */
        protected _selected: boolean;
        /**
         * @en The skin resource of the button.
         * @zh 按钮的皮肤资源。
         */
        protected _skin: string;
        /**
         * @en Specifies whether the display object automatically calculates and changes size and other attributes.
         * @zh 指定此显示对象是否自动计算并改变大小等属性。
         */
        protected _autoSize: boolean;
        /**
         * @en The number of states for the button.
         * @zh 按钮的状态数。
         */
        protected _stateNum: number;
        /**
         * @en The click event handler of the button.
         * @zh 按钮的点击事件函数。
         */
        protected _clickHandler: Handler;
        protected _stateChanged: boolean;
        /**
         * @en The state value of the button.
         * @zh 对象的状态值。
         */
        protected get state(): number;
        protected set state(value: number);
        /**
         * @en The skin resource address of the object.
         * Supports single state, two states and three states, set with the `stateNum` property.
         * @zh 对象的皮肤资源地址。
         * 支持单态，两态和三态，用 `stateNum` 属性设置
         */
        get skin(): string;
        set skin(value: string);
        /**
         * @en The state value of the object, expressed as a number.
         * The default value is 3. This value determines how the skin resource image is sliced.
         * Values:
         * - 1: Single state. The image is not sliced, and the button has only one skin state.
         * - 2: Two states. The image will be sliced equally in the vertical direction into 2 parts, from top to bottom, the up state skin and the down and over and selected state skin, respectively.
         * - 3: Three states. The image will be sliced equally in the vertical direction into 3 parts, from top to bottom, the up state skin, the over state skin, and the down and selected state skin, respectively.
         * @zh 指定对象的状态值，以数字表示。
         * 默认值为3。此值决定皮肤资源图片的切割方式。
         * 取值：
         * - 1：单态。图片不做切割，按钮的皮肤状态只有一种。
         * - 2：两态。图片将以竖直方向被等比切割为2部分，从上向下，依次为弹起状态皮肤、按下和经过及选中状态皮肤。
         * - 3：三态。图片将以竖直方向被等比切割为3部分，从上向下，依次为弹起状态皮肤、经过状态皮肤、按下和选中状态皮肤
         */
        get stateNum(): number;
        set stateNum(value: number);
        /**
         * @en The text content of the button.
         * @zh 按钮的文本内容。
         */
        get label(): string;
        set label(value: string);
        /**
         * @en Indicates the selected state of the button.
         * If the value is true, it indicates that the object is in the selected state. Otherwise, it is not selected.
         * @zh 表示按钮的选中状态。
         * 如果值为true，表示该对象处于选中状态。否则该对象处于未选中状态。
         */
        get selected(): boolean;
        set selected(value: boolean);
        /**
          * @en The text color of the button in each state.
          * Format: "upColor,overColor,downColor".
          * @zh 表示按钮各个状态下的文本颜色。
          * 格式: "upColor,overColor,downColor"。
          */
        get labelColors(): string;
        set labelColors(value: string);
        /**
         * @en The stroke color of the button in each state.
         * Format: "upColor,overColor,downColor".
         * @zh 表示按钮各个状态下的描边颜色。
         * 格式: "upColor,overColor,downColor"。
         */
        get strokeColors(): string;
        set strokeColors(value: string);
        /**
         * @en The margins of the button's text label.
         * Format: "top,right,bottom,left".
         * @zh 表示按钮文本标签的边距。
         * 格式："上边距,右边距,下边距,左边距"。
         */
        get labelPadding(): string;
        set labelPadding(value: string);
        /**
         * @en The font size of the button's text label.
         * @zh 表示按钮文本标签的字体大小。
         */
        get labelSize(): number;
        set labelSize(value: number);
        /**
         * @en The stroke width, in pixels.
         * Default value is 0, indicating no stroke.
         * @zh 描边宽度（以像素为单位）。
         * 默认值0，表示不描边。
         */
        get labelStroke(): number;
        set labelStroke(value: number);
        /**
         * @en The stroke color, represented by a string.
         * The default value is "#000000" (black).
         * @zh 描边颜色，以字符串表示。
         * 默认值为 "#000000"（黑色）;
         * @see laya.display.Text.strokeColor()
         */
        get labelStrokeColor(): string;
        set labelStrokeColor(value: string);
        /**
         * @en Indicates whether the button's text label is bold.
         * @zh 表示按钮文本标签是否为粗体字。
         */
        get labelBold(): boolean;
        set labelBold(value: boolean);
        /**
         * @en The font name of the button's text label, expressed as a string.
         * @zh 表示按钮文本标签的字体名称，以字符串形式表示。
         */
        get labelFont(): string;
        set labelFont(value: string);
        /**
         * @en The text alignment mode.
         * @zh 标签水平对齐模式。
         */
        get labelAlign(): string;
        set labelAlign(value: string);
        /**
         * @en The vertical alignment mode.
         * @zh 标签垂直对齐模式。
         */
        get labelVAlign(): string;
        set labelVAlign(value: string);
        /**
         * @en The click event handler of the object (without default parameters).
         * @zh 对象的点击事件处理器函数（无默认参数）。
         */
        get clickHandler(): Handler;
        set clickHandler(value: Handler);
        /**
         * @en The button's text label `Text` control.
         * @zh 按钮文本标签 `Text` 控件。
         */
        get text(): Text;
        set text(value: Text);
        /**
         * @en The size grid of the texture.
         * The size grid is a 3x3 division of the texture, allowing it to be scaled without distorting the corners and edges.
         * The array contains five values representing the top, right, bottom, and left margins, and whether to repeat the fill (0: no repeat, 1: repeat).
         * The values are separated by commas. For example: "6,6,6,6,1".
         * @zh 皮肤纹理的九宫格数据。
         * 九宫格是一种将纹理分成3x3格的方式，使得纹理缩放时保持角和边缘不失真。
         * 数组包含五个值，分别代表上边距、右边距、下边距、左边距以及是否重复填充（0：不重复填充，1：重复填充）。
         * 值以逗号分隔。例如："6,6,6,6,1"。
         */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * @en The x and y offset of the icon, format: 100,100
         * @zh 图标x,y偏移，格式：100,100
         */
        get iconOffset(): string;
        set iconOffset(value: string);
        /**
         * @en Creates a new instance of the `Button` class.
         * @param skin The address of the skin resource.
         * @param label The text content of the button.
         * @zh 创建一个新的 `Button` 类实例。
         * @param skin 皮肤资源地址。
         * @param label 按钮的文本内容。
         */
        constructor(skin?: string, label?: string);
        protected measureWidth(): number;
        protected measureHeight(): number;
        /**
         * @en Destroy the object and release resources.
         * @zh 销毁
         * @param destroyChild 是否删除子节点
         */
        destroy(destroyChild?: boolean): void;
        protected createChildren(): void;
        protected createText(): void;
        protected initialize(): void;
        /**
         * @en The event listener process function for the object's `Event.MOUSE_OVER`, `Event.MOUSE_OUT`, `Event.MOUSE_DOWN`, `Event.MOUSE_UP`, and `Event.CLICK` events.
         * @param e The event object.
         * @zh 对象的 `Event.MOUSE_OVER`、`Event.MOUSE_OUT`、`Event.MOUSE_DOWN`、`Event.MOUSE_UP`、`Event.CLICK` 事件侦听处理函数。
         * @param e 事件对象
         */
        protected onMouse(e: Event): void;
        /**
         * @en The skin resource is loaded.
         * @param tex The texture resource.
         * @zh 皮肤资源加载完成后的处理。
         * @param tex 纹理资源。
         */
        protected _skinLoaded(tex: any): void;
        /**
         * @en The resource slices of the object have changed.
         * @zh 对象的资源切片发生改变。
         */
        protected changeClips(): void;
        /**
         * @en Change the state of the object.
         * @zh 改变对象的状态。
         */
        protected changeState(): void;
        protected _setStateChanged(): void;
        /**
         * @en Sets the data source.
         * @zh 设置数据源。
         */
        set_dataSource(value: any): void;
    }
    /**
     * @en The `CheckBox` component displays a small box that can have a check mark.
     * - The `CheckBox` component can also display an optional text label, which is positioned to the right of the CheckBox by default.
     * - When assigning a value to `CheckBox` using `dataSource`, the default property is `selected`.
     * - `change` event, dispatched when the button's selected state (`selected` property) changes.
     * @zh `CheckBox` 组件显示一个小方框，该方框内可以有选中标记。
     * - `CheckBox` 组件还可以显示可选的文本标签，默认该标签位于 CheckBox 右侧。
     * - 使用 `dataSource` 赋值时，`CheckBox` 的默认属性是 `selected`。
     * - `change`事件，当按钮的选中状态（ `selected` 属性）发生改变时调度。
     */
    class CheckBox extends Button {
        /**
         * @en `CheckBox` component constructor.
         * @param skin The skin resource address.
         * @param label The content of the text label.
         * @zh `CheckBox` 组件的构造函数。
         * @param skin 皮肤资源地址。
         * @param label 文本标签的内容。
         */
        constructor(skin?: string, label?: string);
        /**
         * @en Preinitialization method. Called before the object is initialized.
         * @zh 预初始化方法。在对象初始化之前调用。
         */
        protected preinitialize(): void;
        /**
         * @en Initialization method. Called when the object is initialized.
         * @zh 初始化方法。在对象初始化时调用。
         */
        protected initialize(): void;
        /**
         * @en Sets the data source of the component.
         * @param value The data source.
         * @zh 设置组件的数据源。
         * @param value 数据源。
         */
        set_dataSource(value: any): void;
    }
    /**
     * @en The `Clip` class is a bitmap slice animation.
     * `Clip` can split an image into a slice animation by horizontal split count `clipX`, vertical split count `clipY`,
     * or horizontal split width `clipWidth`, vertical split height `clipHeight`,
     * from left to right, from top to bottom.
     * The Image and Clip components are the only two components that support asynchronous loading, such as clip.skin = "abc/xxx.png". Other UI components do not support asynchronous loading.
     * @zh `Clip` 类是位图切片动画。
     * `Clip` 可将一张图片，按横向分割数量 `clipX` 、竖向分割数量 `clipY` ，
     * 或横向分割每个切片的宽度 `clipWidth` 、竖向分割每个切片的高度 `clipHeight` ，
     * 从左向右，从上到下，分割组合为一个切片动画。
     * Image和Clip组件是唯一支持异步加载的两个组件，比如clip.skin = "abc/xxx.png"，其他UI组件均不支持异步加载。
     */
    class Clip extends UIComponent {
        protected _sources: Texture[];
        protected _skin: string;
        protected _clipX: number;
        protected _clipY: number;
        protected _clipWidth: number;
        protected _clipHeight: number;
        protected _autoPlay: boolean;
        protected _interval: number;
        protected _complete: Handler;
        protected _isPlaying: boolean;
        protected _index: number;
        protected _clipChanged: boolean;
        protected _group: string;
        protected _toIndex: number;
        /**
         * @en The address of the skin resource.
         * @zh 皮肤资源地址
         */
        get skin(): string;
        set skin(value: string);
        /**
         * @en Number of slices on the X-axis (horizontal).
         * @zh X轴（横向）切片数量。
         */
        get clipX(): number;
        set clipX(value: number);
        /**
         * @en Number of slices on the Y-axis (vertical).
         * @zh Y轴(竖向)切片数量。
         */
        get clipY(): number;
        set clipY(value: number);
        /**
         * @en Width of each slice when dividing horizontally. Takes precedence over `clipX` when set together with `clipX`.
         * @zh 横向分割时每个切片的宽度，与 `clipX` 同时设置时优先级高于 `clipX` 。
         */
        get clipWidth(): number;
        set clipWidth(value: number);
        /**
        * @en Height of each slice when dividing vertically. Takes precedence over `clipY` when set together with `clipY`.
        * @zh 竖向分割时每个切片的高度，与 `clipY` 同时设置时优先级高于 `clipY` 。
        */
        get clipHeight(): number;
        set clipHeight(value: number);
        /**
         * @en Source data.
         * @zh 源数据。
         */
        get sources(): Texture[];
        set sources(value: Texture[]);
        /**
        * @en Resource group.
        * @zh 资源分组。
        */
        get group(): string;
        set group(value: string);
        /**
         * @en The size grid of the texture.
         * The size grid is a 3x3 division of the texture, allowing it to be scaled without distorting the corners and edges.
         * The array contains five values representing the top, right, bottom, and left margins, and whether to repeat the fill (0: no repeat, 1: repeat).
         * The values are separated by commas. For example: "6,6,6,6,1".
         * @zh 纹理的九宫格数据。
         * 九宫格是一种将纹理分成3x3格的方式，使得纹理缩放时保持角和边缘不失真。
         * 数组包含五个值，分别代表上边距、右边距、下边距、左边距以及是否重复填充（0：不重复填充，1：重复填充）。
         * 值以逗号分隔。例如："6,6,6,6,1"。
         */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * @en Current frame index.
         * @zh 当前帧索引。
         */
        get index(): number;
        set index(value: number);
        /**
         * @en Total frames of the slice animation.
         * @zh 切片动画的总帧数。
         */
        get total(): number;
        /**
         * @en Indicates whether the slice animation is automatically played. If true, the slice animation is automatically played; otherwise, it is not.
         * It can control the playback and stop of the slice animation.
         * @zh 是否自动播放切片动画，若自动播放值为true,否则值为false。
         * 可控制切片动画的播放、停止。
         */
        get autoPlay(): boolean;
        set autoPlay(value: boolean);
        /**
         * @en Indicates the interval (in milliseconds) at which the slice animation is played.
         * @zh 切片动画播放间隔时间（以毫秒为单位）。
         */
        get interval(): number;
        set interval(value: number);
        /**
         * @en Indicates the current playback state of the slice animation.
         * If the slice animation is playing, the value is true; otherwise, it is false.
         * @zh 切片动画的当前播放状态。
         * 如果切片动画正在播放中，则为true，否则为false。
         */
        get isPlaying(): boolean;
        set isPlaying(value: boolean);
        /**
         * @en 'Clip' constructor.
         * @param url Resource address.
         * @param clipX Number of divisions in the X direction.
         * @param clipY Number of divisions in the Y direction.
         * @zh  `Clip` 构造函数。
         * @param url 资源地址。
         * @param clipX X方向分割数量。
         * @param clipY Y方向分割数量。
         */
        constructor(url?: string, clipX?: number, clipY?: number);
        protected _onDisplay(e?: boolean): void;
        protected _skinLoaded(): void;
        protected _setClipChanged(): void;
        protected _loop(): void;
        protected createChildren(): void;
        /**
         * @en Changes the resources and size of the slices.
         * @zh 改变切片的资源、切片的大小。
         */
        protected changeClip(): void;
        /**
         * @en Callback function when the sliced image resources are loaded.
         * @param url Resource URL.
         * @param img Texture.
         * @zh 加载切片图片资源完成函数。
         * @param url 资源地址。
         * @param img 纹理。
         */
        protected loadComplete(url: string, img: Texture): void;
        protected measureWidth(): number;
        protected measureHeight(): number;
        /**
         * @en Plays the slice animation.
         * @param from Start index.
         * @param to End index, -1 is not limited.
         * @zh 播放切片动画。
         * @param	from	开始索引
         * @param	to		结束索引，-1为不限制
         */
        play(from?: number, to?: number): void;
        /**
         * @en Stops the slice animation.
         * @zh 停止切片动画。
         */
        stop(): void;
        set_dataSource(value: any): void;
    }
    /**
     * @en The `ColorPicker` component displays a color palette from which the user can select a color.
     * @zh `ColorPicker` 组件将显示包含多个颜色样本的列表，用户可以从中选择颜色。
     */
    class ColorPicker extends UIComponent {
        /**
         * @en Specifies the width and height of each color cell (in pixels).
         * @zh 指定每个正方形的颜色小格子的宽高（以像素为单位）。
         */
        protected _gridSize: number;
        /**
         * @en The background color value of the color palette panel.
         * @zh 表示颜色样本列表面板的背景颜色值。
         */
        protected _bgColor: string;
        /**
         * @en The border color value of the color palette panel.
         * @zh 表示颜色样本列表面板的边框颜色值。
         */
        protected _borderColor: string;
        /**
         * @en Represents the color value selected or input in the color sample list panel.
         * @zh 表示颜色样本列表面板选择或输入的颜色值。
         */
        protected _inputColor: string;
        /**
         * @en The background color value of the color input box.
         * @zh 表示颜色输入框的背景颜色值。
         */
        protected _inputBgColor: string;
        /**
         * @en Represents the color palette panel.
         * @zh 表示颜色样本列表面板。
         */
        protected _colorPanel: Box;
        /**
         * @en Represents the color grid.
         * @zh 表示颜色网格。
         */
        protected _colorTiles: Sprite;
        /**
         * @en Represents the color block display object.
         * @zh 表示颜色块显示对象。
         */
        protected _colorBlock: Sprite;
        /**
         * @en Represents the color input box control `Input`.
         * @zh 表示颜色输入框控件 `Input`。
         */
        protected _colorInput: Input;
        /**
         * @en Represents the button control `Button` that displays the color palette panel when clicked.
         * @zh 表示点击后显示颜色样本列表面板的按钮控件 `Button`。
         */
        protected _colorButton: Button;
        /**
        * @en Represents the list of color values.
        * @zh 表示颜色值列表。
        */
        protected _colors: any[];
        /**
         * @en Represents the selected color value.
         * @zh 表示选择的颜色值。
         */
        protected _selectedColor: string;
        protected _panelChanged: boolean;
        /**
         * @en The function handler executed when the color changes.
         * The default return parameter is `color`: the color value string.
         * @zh 当颜色发生改变时执行的函数处理器。
         * 默认返回参数color：颜色值字符串。
         */
        changeHandler: Handler;
        /**
         * @en The selected color value.
         * @zh 表示选择的颜色值。
         */
        get selectedColor(): string;
        set selectedColor(value: string);
        /**
         * @en The skin URL of the color picker.
         * @zh 颜色选择器的皮肤地址。
         */
        get skin(): string;
        set skin(value: string);
        /**
         * @en The background color value of the color palette panel.
         * @zh 表示颜色样本列表面板的背景颜色值。
         */
        get bgColor(): string;
        set bgColor(value: string);
        /**
         * @en The border color value of the color palette panel.
         * @zh 表示颜色样本列表面板的边框颜色值。
         */
        get borderColor(): string;
        set borderColor(value: string);
        /**
         * @en The color value selected or entered in the color palette panel.
         * @zh 表示颜色样本列表面板选择或输入的颜色值。
         */
        get inputColor(): string;
        set inputColor(value: string);
        /**
         * @en The background color value of the color input box.
         * @zh 表示颜色输入框的背景颜色值。
         */
        get inputBgColor(): string;
        set inputBgColor(value: string);
        constructor(createChildren?: boolean);
        protected _setPanelChanged(): void;
        protected createChildren(): void;
        protected initialize(): void;
        private onPanelMouseDown;
        /**
         * @en Changes the color palette panel.
         * @zh 改变颜色样本列表面板。
         */
        protected changePanel(): void;
        /**
         * @en Handles the `Event.MOUSE_DOWN` event of the color button.
         * @param e The event object.
         * @zh 颜色样本列表面板显示按钮的 `Event.MOUSE_DOWN` 事件侦听处理函数。
         * @param e 事件对象。
         */
        private onColorButtonClick;
        /**
         * @en Handles the `Event.MOUSE_DOWN` event of the stage to close the color palette panel.
         * @param e (Optional) The event object.
         * @zh 处理舞台的 `Event.MOUSE_DOWN` 事件侦听处理函数，关闭颜色面板。
         * @param e (可选) 事件对象。
         */
        private removeColorBox;
        /**
         * @en Handles the `Event.KEY_DOWN` event of the color input field.
         * @param e The event object.
         * @zh 处理颜色输入框的 `Event.KEY_DOWN` 事件侦听处理函数。
         * @param e 事件对象。
         */
        private onColorFieldKeyDown;
        /**
         * @en Handles the `Event.CHANGE` event of the color input field.
         * @param e (Optional) The event object.
         * @zh 处理颜色输入框的 `Event.CHANGE` 事件侦听处理函数。
         * @param e (可选) 事件对象。
         */
        private onColorInputChange;
        /**
         * @en Handles the `Event.CLICK` event of the color tiles.
         * @param e The event object.
         * @zh 处理颜色格子的 `Event.CLICK` 事件侦听处理函数。
         * @param e 事件对象。
         */
        private onColorTilesClick;
        /**
         * @en Handles the `Event.MOUSE_MOVE` event of the color tiles.
         * @param e The event object.
         * @zh 处理颜色格子的 `Event.MOUSE_MOVE` 事件侦听处理函数。
         * @param e 事件对象。
         */
        private onColorTilesMouseMove;
        /**
         * @en Gets the color value of the corresponding color block based on the mouse position.
         * @zh 通过鼠标位置取对应的颜色块的颜色值。
         */
        protected getColorByMouse(): string;
        /**
         * @en Draws the color block.
         * @param color The color value to draw.
         * @zh 绘制颜色块。
         * @param color 要绘制的颜色值。
         */
        private drawBlock;
        /**
         * @en Changes the color.
         * @zh 改变颜色。
         */
        private changeColor;
        /**
         * @en Opens the color palette panel.
         * @zh 打开颜色样本列表面板。
         */
        open(): void;
        /**
         * @en Closes the color palette panel.
         * @zh 关闭颜色样本列表面板。
         */
        close(): void;
        /**
         * @en Destroys the color picker component.
         * @param destroyChild Indicates whether to destroy the component's children as well. Default value is true.
         * @zh 销毁颜色选择器组件。
         * @param destroyChild 是否同时销毁子项。默认为 true。
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * @en The `ComboBox` component contains a drop-down list from which the user can select a single value.
     * - `change` event: Dispatched when the user changes the selected content in `ComboBox` component.
     * @zh `ComboBox` 组件包含一个下拉列表，用户可以从该列表中选择单个值。
     * - `change`事件：当用户更改 `ComboBox` 组件中的选定内容时调度。
     */
    class ComboBox extends UIComponent {
        protected _visibleNum: number;
        protected _button: Button;
        protected _list: List;
        protected _isOpen: boolean;
        protected _itemColors: string[];
        protected _itemPadding: number[];
        protected _itemSize: number;
        protected _labels: string[];
        /**
         * 下拉提示文本
         */
        protected _defaultLabel: string;
        protected _selectedIndex: number;
        protected _selectHandler: Handler;
        protected _itemHeight: number;
        protected _listHeight: number;
        protected _listChanged: boolean;
        protected _itemChanged: boolean;
        protected _scrollBarSkin: string;
        protected _scrollType: ScrollType;
        protected _isCustomList: boolean;
        /**
         * @en Rendering item, used to display a dropdown list to display objects
         * @zh 渲染项，用来显示下拉列表展示对象
         */
        itemRender: any;
        /**
         * @en The skin resource address of the object. Supports single state, two states and three states, set with the `stateNum` property.
         * @zh 对象的皮肤纹理资源地址。 支持单态，两态和三态，用 `stateNum` 属性设置
         */
        get skin(): string;
        set skin(value: string);
        /**
         * @en The padding of the drop-down list text.
         * - The format is: top, right, bottom, left
         * @zh 下拉列表文本的边距。
         * - 格式：上边距,右边距,下边距,左边距
         */
        get itemPadding(): string;
        set itemPadding(value: string);
        /**
         * @en The string of label collection.
         * @zh 标签集合字符串。
         */
        get labels(): string;
        set labels(value: string);
        /**
         * @en Indicates the index of the selected drop-down list item.
         * @zh 表示选择的下拉列表项的索引。
         */
        get selectedIndex(): number;
        set selectedIndex(value: number);
        /**
         * @en The default drop-down prompt text.
         * @zh 默认的下拉提示文本。
         */
        get defaultLabel(): string;
        set defaultLabel(value: string);
        /**
         * @en The handler to be executed when changing the selection of the drop-down list (default returns parameter index:int).
         * @zh 改变下拉列表的选择项时执行的处理器(默认返回参数index:int)。
         */
        get selectHandler(): Handler;
        set selectHandler(value: Handler);
        /**
         * @en Indicates the label of the selected drop-down list item.
         * @zh 表示选择的下拉列表项的的标签。
         */
        get selectedLabel(): string;
        set selectedLabel(value: string);
        /**
         * @en Gets or sets the maximum number of rows that can be displayed in the drop-down list without a scrollbar.
         * @zh 获取或设置没有滚动条的下拉列表中可显示的最大行数。
         */
        get visibleNum(): number;
        set visibleNum(value: number);
        /**
         * @en The height of the drop-down list item.
         * @zh 下拉列表项的高度。
         */
        get itemHeight(): number;
        set itemHeight(value: number);
        /**
         * @en The color of drop-down list items.
         * The format is: "background color when hovering or selected, label color when hovering or selected, label color, border color, background color"
         * @zh 下拉列表项颜色。
         * 格式：悬停或被选中时背景颜色,悬停或被选中时标签颜色,标签颜色,边框颜色,背景颜色"。
         */
        get itemColors(): string;
        set itemColors(value: string);
        /**
         * @en The font size of the drop-down list item label.
         * @zh 下拉列表项标签的字体大小。
         */
        get itemSize(): number;
        set itemSize(value: number);
        /**
         * @en Indicates the open state of the drop-down list.
         * @zh 表示下拉列表的打开状态。
         */
        get isOpen(): boolean;
        set isOpen(value: boolean);
        /**
         * @en The scroll type.
         * @zh 滚动类型。
         */
        get scrollType(): ScrollType;
        set scrollType(value: ScrollType);
        /**
         * @en The scrollbar skin.
         * @zh 滚动条皮肤。
         */
        get scrollBarSkin(): string;
        set scrollBarSkin(value: string);
        /**
         * @en The size grid of the texture.
         * The size grid is a 3x3 division of the texture, allowing it to be scaled without distorting the corners and edges.
         * The array contains five values representing the top, right, bottom, and left margins, and whether to repeat the fill (0: no repeat, 1: repeat).
         * The values are separated by commas. For example: "6,6,6,6,1".
         * @zh 纹理的九宫格数据。
         * 九宫格是一种将纹理分成3x3格的方式，使得纹理缩放时保持角和边缘不失真。
         * 数组包含五个值，分别代表上边距、右边距、下边距、左边距以及是否重复填充（0：不重复填充，1：重复填充）。
         * 值以逗号分隔。例如："6,6,6,6,1"。
         */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * @en a reference to the `VScrollBar` scrollbar component contained in the `ComboBox` component.
         * @zh `ComboBox` 组件所包含的 `VScrollBar` 滚动条组件的引用。
         */
        get scrollBar(): VScrollBar;
        /**
         * @en a reference to the `Button` component contained in the `ComboBox` component.
         * @zh `ComboBox` 组件所包含的 `Button` 组件的引用。
         */
        get button(): Button;
        /**
         * @en a reference to the `List` list component contained in the `ComboBox` component.
         * @zh `ComboBox` 组件所包含的 `List` 列表组件的引用。
         */
        get list(): List;
        set list(value: List);
        /**
         * @en the text label color of the `Button` component contained in the `ComboBox` component.
         * The format is: upColor,overColor,downColor
         * @zh  `ComboBox` 组件所包含的 `Button` 组件的文本标签颜色。
         * 格式：upColor,overColor,downColor
         */
        get labelColors(): string;
        set labelColors(value: string);
        /**
         * @en the text margin of the `Button` component contained in the `ComboBox` component.
         * The format is: top, right, bottom, left
         * @zh `ComboBox` 组件所包含的 `Button` 组件的文本边距。
         * 格式：上边距,右边距,下边距,左边距
         */
        get labelPadding(): string;
        set labelPadding(value: string);
        /**
        * @en the label font size of the `Button` component contained in the `ComboBox` component.
        * @zh `ComboBox` 组件所包含的 `Button` 组件的标签字体大小。
        */
        get labelSize(): number;
        set labelSize(value: number);
        /**
        * @en Indicates whether the button text label is bold.
        * @zh 表示按钮文本标签是否为粗体字。
        */
        get labelBold(): boolean;
        set labelBold(value: boolean);
        /**
         * @en Indicates the font name of the button text label, expressed as a string.
         * @zh 表示按钮文本标签的字体名称，以字符串形式表示。
         */
        get labelFont(): string;
        set labelFont(value: string);
        /**
         * @en Indicates the state value of the button.
         * @zh 表示按钮的状态值。
         */
        get stateNum(): number;
        set stateNum(value: number);
        /**
         * @en `ComboBox` constructor.
         * @param skin The skin resource address.
         * @param labels The string of the label collection in the drop-down list. Separated by commas, such as "item0,item1,item2,item3,item4,item5".
         * @zh  `ComboBox` UI组件的构造函数。
         * @param skin 皮肤资源地址。
         * @param labels 下拉列表的标签集字符串。以逗号做分割，如"item0,item1,item2,item3,item4,item5"。
         */
        constructor(skin?: string, labels?: string);
        protected createChildren(): void;
        private _createList;
        private _setListEvent;
        private _onStageMouseWheel;
        /**
         * @en Close the drop-down list of ComboBox.
         * @zh 关闭下拉列表。
         */
        protected removeList(e: Event): void;
        private onListDown;
        private onScrollBarDown;
        private onButtonMouseDown;
        protected measureWidth(): number;
        protected measureHeight(): number;
        protected changeList(): void;
        /**
         * @en Handles mouse events on a list item. This method manages the visual state of the list item based on mouse interaction, such as hover and click.
         * @param e The mouse event.
         * @param index The index of the list item.
         * @zh 处理列表项的鼠标事件。该方法根据鼠标交互（如悬停和点击）管理列表项的视觉状态。
         * @param e 鼠标事件。
         * @param index 列表项的索引。
         */
        protected onlistItemMouse(e: Event, index: number): void;
        private switchTo;
        /**
         * @en Changing the open state of the drop-down list.
         * @zh 更改下拉列表的打开状态。
         */
        protected changeOpen(): void;
        /**
         * @en Updates the items in the list and adjusts its visual representation. This method recalculates the list height, updates the background if it's not a custom list, and populates the list with new data.
         * @zh 更新列表中的项目并调整其视觉表现。此方法重新计算列表高度，如果不是自定义列表，则更新背景，并使用新数据填充列表。
         */
        protected changeItem(): void;
        private changeSelected;
        /**
         * @en Destroy the component and release the memory occupied by the component. Destroy the child objects of the component at the same time by default.
         * @param destroyChild Whether to simultaneously destroy the child objects of the component. The default value is true.
         * @zh 销毁组件并释放组件所占用的内存。默认会同时销毁组件的子对象。
         * @param destroyChild 是否同时销毁组件的子对象。默认值为true。
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @en Set the data source of the ComboBox.
         * @param value The new data source.
         * @zh 设置下拉选项框的数据源。
         * @param value 新的数据源。
         */
        set_dataSource(value: any): void;
    }
    /**
     * @en The `Dialog` component is a pop-up dialog box that implements the functionality of popping up, dragging, and modal windows.
     * You can set the background transparency of the pop-up box through the `UIConfig`, and whether to close the window when clicking the edge in modal mode.
     * By setting the `zOrder` property, you can change the popup hierarchy.
     * By setting the `popupEffect` and `closeEffect`, you can set the popup and close effects. If you don't want any popup or close effects, you can set the aforementioned properties to empty.
     * @zh `Dialog` 组件是一个弹出对话框，实现对话框弹出，拖动，模式窗口功能。
     * 可以通过 `UIConfig` 设置弹出框背景透明度，模式窗口点击边缘是否关闭等。
     * 通过设置 `zOrder` 属性，可以更改弹出的层次。
     * 通过设置 `popupEffect` 和 `closeEffect` 可以设置弹出效果和关闭效果，如果不想有任何弹出关闭效果，可以设置前述属性为空。
     */
    class Dialog extends View {
        /**
         * @en If a button in the dialog is named `close`, clicking it will close the dialog.
         * @zh 对话框内的某个按钮命名为 `close`，点击此按钮则会关闭对话框。
         */
        static CLOSE: string;
        /**
         * @en If a button in the dialog is named `cancel`, clicking it will close the dialog.
         * @zh 对话框内的某个按钮命名为 `cancel`，点击此按钮则会关闭对话框。
         */
        static CANCEL: string;
        /**
         * @en If a button in the dialog is named `sure`, clicking it will close the dialog.
         * @zh 对话框内的某个按钮命名为 `sure`，点击此按钮则会关闭对话框。
         */
        static SURE: string;
        /**
         * @en If a button in the dialog is named `no`, clicking it will close the dialog.
         * @zh 对话框内的某个按钮命名为 `no`，点击此按钮则会关闭对话框。
         */
        static NO: string;
        /**
         * @en If a button in the dialog is named `yes`, clicking it will close the dialog.
         * @zh 对话框内的某个按钮命名为 `yes`，点击此按钮则会关闭对话框。
         */
        static YES: string;
        /**
         * @en If a button in the dialog is named `ok`, clicking it will close the dialog.
         * @zh 对话框内的某个按钮命名为 `ok`，点击此按钮则会关闭对话框。
         */
        static OK: string;
        /** 表示对话框管理器。*/
        private static _manager;
        /**
         * @en
         * The dialog management container. All dialogs are inside this container and managed by the manager.
         * You can customize your own manager to change the window management process.
         * Any dialog opened or closed will trigger the `open` and `close` events of the management class.
         * @zh
         * 对话框管理容器，所有的对话框都在该容器内，并且受管理器管理，可以自定义自己的管理器，来更改窗口管理的流程。
         * 任意对话框打开和关闭，都会触发管理类的 `open` 和 `close` 事件。
         */
        static get manager(): DialogManager;
        static set manager(value: DialogManager);
        /**
         * @en Set the lock view. Display the lock view before the interface is ready, and remove the lock layer after it is ready.
         * If it is empty, nothing will be displayed.
         * @param view The content of the lock view.
         * @zh 设置锁定界面，在界面未准备好前显示锁定界面，准备完毕后则移除锁定层，如果为空则什么都不显示
         * @param view 锁定界面内容
         */
        static setLockView(view: UIComponent): void;
        /**
         * @en Lock all layers, display loading information, and prevent the content below from being clicked.
         * @param value Whether to lock.
         * @zh 锁定所有层，显示加载条信息，防止下面内容被点击。
         * @param value 是否锁定
         */
        static lock(value: boolean): void;
        /**
         * @en Close all dialogs.
         * @zh 关闭所有对话框。
         */
        static closeAll(): void;
        /**
         * @en Get the dialog collection by group.
         * @param group The group name.
         * @returns The dialog array.
         * @zh 根据组获取对话框集合。
         * @param group 组名称
         * @returns 对话框数组
         */
        static getDialogsByGroup(group: string): any[];
        /**
         * @en Close all pop-up boxes by group.
         * @param group The group name that needs to be closed.
         * @returns The closed dialogs.
         * @zh 根据组关闭所有弹出框。
         * @param group 需要关闭的组名称
         * @returns 关闭的对话框集合
         */
        static closeByGroup(group: string): any[];
        private _dragArea;
        /**
         * @en The handler function that will be triggered when the dialog is closed.
         * The callback function parameter is the button name clicked by the user, of type `String`.
         * @zh 对话框被关闭时会触发的回调函数处理器。
         * 回调函数参数为用户点击的按钮名字name:String。
         */
        closeHandler: Handler;
        /**
         * @en The popup effect of the dialog. You can set an effect to replace the default popup effect.
         * If you don't want any effect, you can set it to `null`.
         * The default global popup effect can be set via `manager.popupEffect`.
         * @zh 弹出对话框效果，可以设置一个效果代替默认的弹出效果，如果不想有任何效果，可以赋值为null。
         * 全局默认弹出效果可以通过manager.popupEffect修改。
         */
        popupEffect: Handler;
        /**
         * @en The close effect of the dialog. You can set an effect to replace the default close effect.
         * If you don't want any effect, you can set it to `null`.
         * The default global close effect can be set via `manager.closeEffect`.
         * @zh 关闭对话框效果，可以设置一个效果代替默认的关闭效果，如果不想有任何效果，可以赋值为null。
         * 全局默认关闭效果可以通过manager.closeEffect修改。
         */
        closeEffect: Handler;
        /**
         * @en The dialog group name.
         * @zh 组名称。
         */
        group: string;
        /**
         * @en Indicates whether it is a modal dialog.
         * @zh 是否是模式窗口。
         */
        isModal: boolean;
        /**
         * @en Indicates whether to show popup effect.
         * @zh 是否显示弹出效果。
         */
        isShowEffect: boolean;
        /**
         * @en Specifies whether the dialog is popped up at the center.
         * If the value is `true`, the dialog will be centered. Otherwise, it will be displayed based on the object coordinates. The default value is `true`.
         * @zh 指定对话框是否居中弹出。
         * 如果值为true，则居中弹出，否则，则根据对象坐标显示，默认为true。
         */
        isPopupCenter: boolean;
        /**
         * @en The close type. Automatically records the name of the clicked button when its name is `"close"`, `"cancel"`, `"sure"`, `"no"`, `"yes"`, or `"no"`.
         * @zh 关闭类型，点击name为`"close"`，`"cancel"`，`"sure"`，`"no"`，`"yes"`，`"no"`的按钮时，会自动记录点击按钮的名称。
         */
        closeType: string;
        /**
         * @en Used to specify the drag area of the dialog. The default value is `"0,0,0,0"`.
         * The format is a string of `"x,y,width,height"` that represents a rectangle. For example, `"0,0,100,200"`.
         * @zh 用来指定对话框的拖拽区域。默认值为 `"0,0,0,0"`。
         * 格式：构成一个矩形所需的 x,y,width,heith 值，用逗号连接为字符串。例如："0,0,100,200"。
         */
        get dragArea(): string;
        set dragArea(value: string);
        /**
         * @en The display status of the pop-up box. If the pop-up box is being displayed, it is `true`; otherwise, it is `false`.
         * @zh 弹出框的显示状态。如果弹框处于显示中，则为 `true`，否则为 `false`。
         */
        get isPopup(): boolean;
        /**
         * @en The z-order of the dialog.
         * @zh 对话框的层级。
         */
        get zOrder(): number;
        set zOrder(value: number);
        /** @ignore */
        constructor();
        /** 提取拖拽区域*/
        protected _dealDragArea(): void;
        private _onMouseDown;
        /**
         * @en Handle the click event for the dialog box. Close the dialog box based on the button name.
         * @zh 处理对话框的点击事件。根据按钮的名称关闭对话框。
         * @param e 鼠标事件。
         */
        protected _onClick(e: Event): void;
        /**
         * @en Open the dialog.
         * @param closeOther Whether to close other dialogs. If the value is `true`, other dialogs will be closed. The default value is `true`.
         * @param param The parameters to pass to the dialog.
         * @zh 打开对话框。
         * @param closeOther 是否关闭其它的对话框。若值为true则关闭其它对话框。
         * @param param 传递给对话框的参数。
         */
        open(closeOther?: boolean, param?: any): void;
        /**
         * @en Close the dialog.
         * @param type The reason for closing. It will be passed to the `onClosed` function.
         * @zh 关闭对话框。
         * @param type 关闭的原因，会传递给onClosed函数
         * @override
         */
        close(type?: string): void;
        /**
         * @en Destroy the dialog.
         * @param destroyChild Whether to destroy the child objects as well.
         * @zh 销毁对话框。
         * @param destroyChild 是否销毁子对象。
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @en Display the dialog (non-modal).
         * @param closeOther Whether to close other dialogs. If the value is `true`, other dialogs will be closed.
         * @param showEffect Whether to show pop-up effect.
         * @zh 显示对话框（以非模式窗口方式显示）。
         * @param closeOther 是否关闭其它的对话框。若值为true则关闭其它对话框。
         * @param showEffect 是否显示弹出效果
         */
        show(closeOther?: boolean, showEffect?: boolean): void;
        /**
         * @en Display the dialog (modal).
         * @param closeOther Whether to close other dialogs. If the value is `true`, other dialogs will be closed.
         * @param showEffect Whether to show pop-up effect.
         * @zh 显示对话框（以模式窗口方式显示）。
         * @param closeOther 是否关闭其它的对话框。若值为true则关闭其它对话框。
         * @param showEffect 是否显示弹出效果
         */
        popup(closeOther?: boolean, showEffect?: boolean): void;
        protected _open(modal: boolean, closeOther: boolean, showEffect: boolean): void;
    }
    /**
     * @en The `DialogManager` is a container for managing all dialog boxes, which are managed by the manager.
     * Opening and closing any dialog will trigger the manager's open and close events.
     * open event is used for any window after dispatching, and close event is used to dispatch events when closing any dialog.
     * The background transparency of the popup, whether the modal window closes when the edge is clicked, and whether the layer changes when the window is clicked can be set in UIConfig.
     * The layer of the popup can be changed by setting the dialog's zOrder property.
     * @zh DialogManager 对话框管理容器，所有的对话框都在该容器内，并且受管理器管理。
     * 任意对话框打开和关闭，都会触发管理类的 open 和 close 事件。
     * open事件用于任意窗口后调度，close事件用于关闭任意对话框时调度的事件。
     * 可以通过 UIConfig 设置弹出框背景透明度，模式窗口点击边缘是否关闭，点击窗口是否切换层次等。
     * 通过设置对话框的 zOrder 属性，可以更改弹出的层次。
     */
    class DialogManager extends Sprite {
        /**
         * @en Mask layer
         * @zh 遮罩层。
         */
        maskLayer: Sprite;
        /**
         * @en Lock screen layer.
         * @zh 锁屏层。
         */
        lockLayer: Sprite;
        /**
         * @en The global default popup effect for dialogs. You can set an effect to replace the default popup effect.
         * If you do not want any effect, you can assign it to null.
         * @zh 全局默认弹出对话框效果，可以设置一个效果代替默认的弹出效果，如果不想有任何效果，可以赋值为 null。
         */
        popupEffect: (dialog: Dialog) => void;
        /**
         * @en The global default close effect for dialogs. You can set an effect to replace the default close effect.
         * If you do not want any effect, you can assign it to null.
         * @zh 全局默认关闭对话框效果，可以设置一个效果代替默认的关闭效果，如果不想有任何效果，可以赋值为 null。
         */
        closeEffect: (dialog: Dialog) => void;
        /**
         * @en Sets the global default opening effect for the dialog. You can specify an effect to replace the default opening effect.
         * If you do not want any effect, it can be set to null.
         * @zh 设置全局默认的对话框打开效果。可以指定一个效果来替代默认的打开效果，如果不想有任何效果，可以设置为 null。
         */
        popupEffectHandler: Handler;
        /**
         * @en Sets the global default closing effect for the dialog. You can specify an effect to replace the default closing effect.
         * If you do not want any effect, it can be set to null.
         * @zh 设置全局默认的对话框关闭效果。可以指定一个效果来替代默认的关闭效果，如果不想有任何效果，可以设置为 null。
         */
        closeEffectHandler: Handler;
        /** @ignore */
        constructor();
        private _closeOnSide;
        private _onResize;
        private _centerDialog;
        private _clearDialogEffect;
        private _closeAll;
        /**
         * @en Sets the lock view. If no value is provided, the lock layer will be empty and won't display anything.
         * @param value The UIComponent to display on the lock layer, or null for an empty lock layer.
         * @zh 设置锁定界面，如果参数为空则什么都不显示。
         * @param value 要在锁定层上显示的UI组件，空锁定层为null。
         */
        setLockView(value: UIComponent): void;
        /**
         * @en Opens a dialog.
         * @param dialog The Dialog instance to be displayed.
         * @param closeOther Whether to close other dialogs. If true, other dialogs will be closed.
         * @param showEffect Whether to show the popup effect.
         * @zh 打开对话框。
         * @param dialog 需要显示的对话框 Dialog 实例。
         * @param closeOther 是否关闭其他对话框。若为 true，则关闭其他对话框。
         * @param showEffect 是否显示弹出效果。
         */
        open(dialog: Dialog, closeOther?: boolean, showEffect?: boolean): void;
        /**
         * @en Executes the opening of a dialog.
         * @param dialog The Dialog instance that needs to be opened.
         * @zh 执行打开对话框操作。
         * @param dialog 需要打开的对话框 Dialog 实例。
         */
        doOpen(dialog: Dialog): void;
        /**
         * @en Locks all layers, displays loading information, and prevents double-clicking.
         * @param value If true, the lock layer is shown, otherwise it is hidden.
         * @zh 锁定所有层，显示加载信息，防止双击。
         * @param value 如果为true，则显示锁定层，否则隐藏锁定层。
         */
        lock(value: boolean): void;
        /**
         * @en Closes the dialog.
         * @param dialog The Dialog instance that needs to be closed.
         * @zh 关闭对话框。
         * @param dialog 需要关闭的对话框 Dialog 实例。
         */
        close(dialog: Dialog): void;
        /**
         * @en Executes the closing of a dialog.
         * @param dialog The Dialog instance that needs to be closed.
         * @zh 执行关闭对话框操作。
         * @param dialog 需要关闭的对话框 Dialog 实例。
         */
        doClose(dialog: Dialog): void;
        /**
         * @en Closes all dialogs.
         * @zh 关闭所有对话框。
         */
        closeAll(): void;
        /**
         * @en Gets all dialogs by group name.
         * @param group The name of the group.
         * @returns An array of dialogs that belong to the specified group.
         * @zh 根据组名获取所有对话框。
         * @param group 组名。
         * @returns 属于指定组的对话框数组。
         */
        getDialogsByGroup(group: string): any[];
        /**
         * @en Closes all popups by group name.
         * @param group The name of the group to close.
         * @returns An array of dialogs that have been closed.
         * @zh 根据组名关闭所有弹出框。
         * @param group 需要关闭的组名。
         * @returns 已关闭的对话框数组。
         */
        closeByGroup(group: string): any[];
    }
    /**
     * @en Font clipping for simplified bitmap fonts, which can be used by setting a slice image and text content, similar to bitmap fonts.
     * Usage: Set the skin for the bitmap font and the corresponding font content sheet (if multiple lines are needed, use spaces for line breaks).
     * @zh 字体切片，简化版的位图字体，只需设置一个切片图片和文字内容即可使用，效果同位图字体
     * 使用方式：设置位图字体皮肤skin，设置皮肤对应的字体内容sheet（如果多行，可以使用空格换行）
     * 示例：
     * fontClip.skin = "font1.png";//设置皮肤
     * fontClip.sheet = "abc123 456";//设置皮肤对应的内容，空格换行。此皮肤为2行5列（显示时skin会被等分为2行5列），第一行对应的文字为"abc123"，第二行为"456"
     * fontClip.value = "a1326";//显示"a1326"文字
     */
    class FontClip extends Clip {
        /**
         * @en Internal use. The array of values.
         * @zh 内部使用，数值数组。
        */
        protected _valueArr: string;
        /**
         * @en Internal use. The array of text content.
         * @zh 内部使用，文字内容数组。
         */
        protected _indexMap: Record<string, number>;
        /**
         * @en Internal use. The content of the font clip.
         * @zh 内部使用，字体切片内容。
         */
        protected _sheet: string;
        /**
         * @en Internal use. The direction.
         * @zh 内部使用，方向。
         */
        protected _direction: string;
        /**
         * @en Internal use. The gap on the X-axis.
         * @zh 内部使用，X轴方向间隙。
         */
        protected _spaceX: number;
        /**
         * @en Internal use. The gap on the Y-axis.
         * @zh 内部使用，Y轴方向间隙。
         */
        protected _spaceY: number;
        /**
         * @en Internal use. The horizontal alignment method.
         * @zh 内部使用，水平对齐方式。
         */
        private _align;
        /**
         * @en Internal use. The width of the displayed text.
         * @zh 内部使用，显示文字的宽度。
         */
        private _wordsW;
        /**
         * @en Internal use. The height of the displayed text.
         * @zh 内部使用，显示文字的高度。
         */
        private _wordsH;
        /**
         * @en Font clip index.
         * @zh 字体切片索引。
         */
        get index(): number;
        set index(value: number);
        /**
         * @en The content of the font clip, with spaces representing line breaks.
         * @zh 字体切片的内容，空格表示换行符。
         */
        get sheet(): string;
        set sheet(value: string);
        /**
         * @en Gets the display content of the font clip.
         * @zh 字体切片的显示内容。
         */
        get value(): string;
        set value(value: string);
        /**
         * @en Layout direction of the font clip characters.
         * The default value is "horizontal".
         * values:
         * "horizontal": Indicates a horizontal layout.
         * "vertical": Indicates a vertical layout.
         * @zh 字体切片字符的布局方向。
         * 默认值为 "horizontal"。
         * 取值：
         * "horizontal": 表示水平布局。
         * "vertical": 表示垂直布局。
         */
        get direction(): string;
        set direction(value: string);
        /**
         * @en The X-axis spacing between characters in the font clip.
         * @zh 字体切片中字符的X轴方向间隙。
         */
        get spaceX(): number;
        set spaceX(value: number);
        /**
         * @en The Y-axis spacing between characters in the font clip.
         * @zh 字体切片中字符的Y轴方向间隙。
         */
        get spaceY(): number;
        set spaceY(value: number);
        /**
         * @en Horizontal alignment
         * @zh 水平对齐方式。
         */
        get align(): string;
        set align(v: string);
        /**
         * @en Creates an instance of the FontClip.
         * @param skin The skin path for the font clip.
         * @param sheet The content string for the font clip, with spaces representing line breaks.
         * @zh 创建 FontClip 实例。
         * @param skin 字体切片的皮肤路径。
         * @param sheet 字体切片的内容字符串，空格代表换行。
         */
        constructor(skin?: string, sheet?: string);
        /**
         * @override
         * @en Destroys the FontClip instance and optionally its children.
         * @param destroyChild  Whether to destroy the children of the FontClip.
         * @zh 销毁字体切片实例及其子项（如果指定）。
         * @param destroyChild 是否销毁字体切片的子节点。
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * @en The `HBox` class is a horizontal layout container.
     * @zh `HBox` 是一个水平布局容器类。
     */
    class HBox extends LayoutBox {
        /**
         * @en No alignment.
         * @zh 无对齐。
         */
        static NONE: string;
        /**
         * @en Align to the top.
         * @zh 居顶部对齐。
         */
        static TOP: string;
        /**
         * @en Align to the center.
         * @zh 居中对齐。
         */
        static MIDDLE: string;
        /**
         * @en Align to the bottom.
         * @zh 居底部对齐。
         */
        static BOTTOM: string;
        protected sortItem(items: any[]): void;
        protected changeItems(): void;
    }
    /**
     * @en Use the `HScrollBar` (horizontal `ScrollBar`) control to control the displayed data portion when there is too much data to display completely in the display area.
     * @zh 使用 `HScrollBar`（水平 `ScrollBar`）控件，可以在因数据太多而不能在显示区域完全显示时控制显示的数据部分。
     */
    class HScrollBar extends ScrollBar {
        protected initialize(): void;
    }
    /**
     * @en The HSlider control allows the user to select a value by moving a slider between the end points of the slider track.
     * The HSlider control is displayed horizontally. The slider track stretches from left to right, and the labels are displayed at the top or bottom of the track.
     * @zh 使用 HSlider 控件，用户可以通过在滑块轨道的终点之间移动滑块来选择值。
     * HSlider 控件采用水平方向。滑块轨道从左向右扩展，而标签位于轨道的顶部或底部。
     */
    class HSlider extends Slider {
        /**
         * @en Creates an instance of HSlider, and sets the direction to horizontal.
         * @param skin The skin of the HSlider.
         * @zh 创建Slider实例，设置滑动方向为水平，
         * @param skin 皮肤纹理。
         */
        constructor(skin?: string);
    }
    /**
     * @en The Image class represents a bitmap image or drawing graphics display object.
     * Image and Clip are the only two components that support asynchronous loading. For example, `img.skin = "abc/xxx.png"`, other UI components do not support asynchronous loading.
     * Event.LOADED: When the resource is loaded.
     *  @zh Image类是用于表示位图图像或绘制图形的显示对象。
     * Image和Clip组件是唯一支持异步加载的两个组件，比如`img.skin = "abc/xxx.png"`，其他UI组件均不支持异步加载。
     * Event.LOADED：资源加载完成后调度。
     */
    class Image extends UIComponent {
        protected _skin: string;
        protected _group: string;
        protected _useSourceSize: boolean;
        /**
         * @en The skin address of the object, represented as a string.
         * If the resource is not loaded, it will be loaded first and then applied to this object after loading is complete.
         * Note: After the resource is loaded, it will be automatically cached in the resource library.
         * @zh 图片对象的皮肤纹理资源地址，以字符串表示。
         * 如果资源未加载，则先自动加载资源，加载完成后应用于此对象。
         * 注意：资源加载完成后，会自动缓存至资源库中。
         */
        get skin(): string;
        set skin(value: string);
        /**
         * @en The size grid of the texture.
         * The size grid is a 3x3 division of the texture, allowing it to be scaled without distorting the corners and edges.
         * The array contains five values representing the top, right, bottom, and left margins, and whether to repeat the fill (0: no repeat, 1: repeat).
         * The values are separated by commas. For example: "6,6,6,6,1".
         * @zh 纹理的九宫格数据。
         * 九宫格是一种将纹理分成3x3格的方式，使得纹理缩放时保持角和边缘不失真。
         * 数组包含五个值，分别代表上边距、右边距、下边距、左边距以及是否重复填充（0：不重复填充，1：重复填充）。
         * 值以逗号分隔。例如："6,6,6,6,1"。
         */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * @en The texture of the object.
         * Note, this is not the image URL, but the image texture. It is recommended to use the skin property to avoid directly using the texture when the image resource has not finished loading.
         * @zh 图片对象的纹理。
         * 注意，这里不是图片的地址，而是图片的纹理。建议使用skin属性，避免图片资源未加载完成时，直接使用texture。
         */
        get source(): Texture;
        set source(value: Texture);
        /**
         * @en The color of the Image.
         * @zh 图片的纹理颜色。
         */
        get color(): string;
        set color(value: string);
        /**
         * @en The resource group.
         * @zh 资源分组。
         */
        get group(): string;
        set group(value: string);
        /**
         * @en Whether to use the original size of the resource.
         * @zh 是否使用资源的原始大小。
         */
        get useSourceSize(): boolean;
        set useSourceSize(value: boolean);
        /**
         * @en consruct method.
         * @param skin The skin resource address.
         * @zh 构造方法
         * @param skin 皮肤资源地址。
         */
        constructor(skin?: string | null);
        protected measureWidth(): number;
        protected measureHeight(): number;
        protected createChildren(): void;
        /**
         * @en Set the data source of the object.
         * @param value The data source.
         * @zh 设置对象的数据源。
         * @param value 数据源。
         */
        set_dataSource(value: any): void;
        /**
         * @en Destroy the object and release the loaded skin resources.
         * @zh 销毁对象并释放加载的皮肤资源。
         */
        dispose(): void;
    }
    /**
     * @en The ISelect interface, which should be implemented by objects that have a selected property and a clickHandler for selection callback function processing.
     * @zh ISelect 接口，实现对象的 selected属性和clickHandler 选择回调函数处理器。
     */
    interface ISelect extends UIComponent {
        /**
         * @en A boolean value indicating whether the object is selected.
         * @zh 是否被选择。
         */
        selected: boolean;
        /**
         * @en The click event callback function processing handler of the object.
         * @zh 对象的点击事件回调函数处理器。
         */
        clickHandler: Handler;
    }
    type LabelFitContent = "no" | "yes" | "height";
    /**
     * @en The Label class is used to create display objects to display text
     * `change` event is dispatched when the text content changes.
     * @zh Label 类用于创建显示对象以显示文本。
     * `change`事件用于文本内容发生改变后调度。
     */
    class Label extends UIComponent {
        /**
         * @en Text instance.
         * @zh 文本 Text 实例。
         */
        protected _tf: Text;
        protected _fitContent: LabelFitContent;
        private _fitFlag;
        /**
         * @en Current text content string.
         * @zh 当前文本内容字符串。
         */
        get text(): string;
        set text(value: string);
        /**
         * @en Whether the text automatically wraps when it reaches the maximum width.
         * @zh 文本是否在达到最大宽度时自动换行。
         * 值为 true，则该文本字段自动换行；值为 false，则该文本字段不自动换行。
         */
        get wordWrap(): boolean;
        set wordWrap(value: boolean);
        /**
         * @en Color of the text.
         * @zh 文本颜色。
         */
        get color(): string;
        set color(value: string);
        /**
         * @en Font of the text.
         * @zh 文本字体。
         */
        get font(): string;
        set font(value: string);
        /**
         * @en Horizontal alignment of the text within the label.
         * @zh 文本的水平对齐方式。
         */
        get align(): string;
        set align(value: string);
        /**
         * @en Vertical alignment of the text within the label.
         * @zh 文本的垂直对齐方式。
         */
        get valign(): string;
        set valign(value: string);
        /**
         * @en The alignment of images and text when mixed. The optional values are top, middle, and bottom.
         * @zh 图文混排时图片和文字的对齐方式。可选值是top,middle,bottom。
         */
        get alignItems(): string;
        set alignItems(value: string);
        /**
         * @en Whether the text is bold.
         * @zh 文本是否加粗。
         */
        get bold(): boolean;
        set bold(value: boolean);
        /**
         * @en Whether the text is italic.
         * @zh 文本是否斜体。
         */
        get italic(): boolean;
        set italic(value: boolean);
        /**
         * @en Space between lines of text.
         * @zh 文本行之间的间距（以像素为单位）
         */
        get leading(): number;
        set leading(value: number);
        /**
         * @en Font size of the text.
         * @zh 文本的字号大小。
         */
        get fontSize(): number;
        set fontSize(value: number);
        /**
         * @en The margins of the text label.
         * Format: "top,right,bottom,left".
         * @zh 文本标签的边距。
         * 格式："上边距,右边距,下边距,左边距"（以像素为单位）。
         */
        get padding(): string;
        set padding(value: string);
        /**
         * @en Background color of the label.
         * @zh 文本标签的背景颜色。
         */
        get bgColor(): string;
        set bgColor(value: string);
        /**
         * @en Border color of the label.
         * @zh 文本标签的边框颜色。
         */
        get borderColor(): string;
        set borderColor(value: string);
        /**
         * @en Stroke width of the text stroke.
         * @zh 文本描边的宽度（以像素为单位），默认值为0，表示不描边。
         */
        get stroke(): number;
        set stroke(value: number);
        /**
         * @en Color of the text stroke.
         * @zh 文本描边的颜色。
         */
        get strokeColor(): string;
        set strokeColor(value: string);
        /**
         * @en Supporting html syntax.
         * @zh 是否富文本，支持html语法
         */
        get html(): boolean;
        set html(value: boolean);
        /**
         * @en Whether to use UBB syntax to parse text.
         * @zh 是否使用UBB语法解析文本。
         */
        get ubb(): boolean;
        set ubb(value: boolean);
        /**
         * @en The maximum width of the text box. If the text content exceeds this width, it will wrap automatically. Set to 0 to disable this limit.
         * @zh 文本最大宽度，当文本达到最大宽度时，会自动换行，设置为0则此限制不生效。
         */
        get maxWidth(): number;
        set maxWidth(value: number);
        /**
         * @en Sets whether the text content adapts to the container size.
         * Possible values: "yes" (both text width and height adapt), "height" (only text height adapts), "no" (does not adapt).
         * If a boolean value is provided, true corresponds to "yes" and false corresponds to "no".
         * @zh 设置文本内容是否自适应容器大小
         * 可选值："yes"（文本宽度和高度自适应）、"height"（仅文本高度自适应）、"no"（不自适应）
         * 如果传入布尔值，则 true 对应 "yes"，false 对应 "no"
         */
        get fitContent(): LabelFitContent;
        set fitContent(value: LabelFitContent);
        /**
         * @en An instance of the basic text object.
         * @zh 基础文本对象（Text）的实例。
         */
        get textField(): Text;
        /**
         * @en The overflow property of the text, determining how overflow text is handled.
         * Possible values: visible, hidden, scroll, shrink, ellipsis.
         * visible: The text is not constrained by the text width and height, and all text is visible.
         * hidden: Text beyond the width and height is cut off, providing the best performance.
         * scroll: The part of the text that exceeds the width and height is hidden, and can be scrolled to view.
         * shrink: The text automatically adjusts its size to fit within the width and height, always fully visible.
         * ellipsis: When the text exceeds the width and height, the last few characters are replaced with an ellipsis, indicating that there is more content.
         * @zh 文本的溢出属性，决定超出文本如何被处理。
         * 值为: 可见 visible、隐藏 hidden、滚动 scroll、自动收缩 shrink、显示省略号 ellipsis。
         * 作用：
         * 可见，表示文本不受文本宽高约束全部可见；
         * 隐藏，超过文本宽高就会被裁切掉，性能最好；
         * 滚动，表示超出宽高的部分被隐藏，可以通过划动控制显示在宽高内区域；
         * 自动收缩，表示文本会跟随宽高的大小而自动调整文本的大小，始终全部显示在文本宽高内；
         * 显示省略号，表示当文本超出宽高后，未尾的几位字符会替换为省略号，表示当前文本还有未显示的内容。
         */
        get overflow(): string;
        set overflow(value: string);
        /**
         * @en Text decoration style of the text, specifically whether it is underlined.
         * @zh 文本是否显示下划线。
         */
        get underline(): boolean;
        set underline(value: boolean);
        /**
         * @en Color of the text underline.
         * @zh 文本下划线的颜色。
         */
        get underlineColor(): string;
        set underlineColor(value: string);
        /**
         * @en Text decoration style of the text, specifically whether it is underlined.
         * @zh 文本是否显示下划线。
         */
        get strikethrough(): boolean;
        set strikethrough(value: boolean);
        /**
         * @en Color of the text underline.
         * @zh 文本下划线的颜色。
         */
        get strikethroughColor(): string;
        set strikethroughColor(value: string);
        /**
         * @en Whether the text ignores language localization.
         * @zh 文本是否忽略语言本地化。
         */
        get ignoreLang(): boolean;
        set ignoreLang(value: boolean);
        /**
         * @en Text template variables.
         * When set to true, templateVars is set to an empty object;
         * When set to false, templateVars is set to null;
         * When set to a value of type Record<string, any>, templateVars is set to the provided value.
         * @zh 文本模板变量对象
         * 为 true 时，将 templateVars 设置为空对象;
         * 为 false 时，将 templateVars 设置为 null;
         * 为 Record<string, any> 类型时，将 templateVars 设置为传入值（value）;
         */
        get templateVars(): Record<string, any>;
        set templateVars(value: Record<string, any> | boolean);
        /**
         * @en Sets a template variable in the text field, used for dynamic text replacement.
         * @param name The key name of the template variable to set.
         * @param value The value corresponding to the key name of the template variable.
         * @return This label instance.
         * @zh 设置模板变量对象对应的键名与值，用于动态文本替换。
         * @param name 要设置的模板变量对象的键名。
         * @param value 模板变量对象键名对应的值。
         * @return 当前标签实例。
         */
        setVar(name: string, value: any): Label;
        /** @ignore */
        constructor(text?: string);
        protected _onPostLayout(): void;
        protected createChildren(): void;
        protected measureWidth(): number;
        protected measureHeight(): number;
        get_width(): number;
        /**
         * @en Sets the width of the label.
         * @param value The new width value.
         * @zh 设置文本标签的宽度。
         * @param value 新的宽度值。
         */
        set_width(value: number): void;
        get_height(): number;
        /**
         * @en Sets the height of the label.
         * @param value The new height value.
         * @zh 设置文本标签的高度。
         * @param value 新的高度值。
         */
        set_height(value: number): void;
        set_dataSource(value: any): void;
    }
    /**
     * @en LayoutBox is a layout container class.
     * @zh LayoutBox 是一个布局容器类。
     */
    class LayoutBox extends Box {
        protected _space: number;
        protected _align: string;
        protected _itemChanged: boolean;
        /**
         * @en The space between child objects.
         * @zh 子对象的间隔。
         */
        get space(): number;
        set space(value: number);
        /**
         * @en The alignment of child objects.
         * @zh 子对象对齐方式。
         */
        get align(): string;
        set align(value: string);
        protected _setItemChanged(): void;
        /**
         * @en Change the layout of child objects.
         * @zh 改变子对象的布局。
         */
        protected changeItems(): void;
        /**
         * @en Sort the item list. Default sorting rules can be changed by overriding.
         * @param items The item list.
         * @zh 排序项目列表。可通过重写改变默认排序规则。
         * @param items  项目列表。
         */
        protected sortItem(items: any[]): void;
        private onResize;
        /**
         * @en Adds a child object.
         * @param child The child object to add.
         * @returns The added child object.
         * @zh 添加子节点对象。
         * @param child 要添加的子节点对象。
         * @returns 添加的子节点对象。
        */
        addChild<T extends Node>(child: T): T;
        /**
         * @en Adds a child object at a specified index position.
         * @param child The child object to add.
         * @param index The index position to add the child object.
         * @returns The added child object.
         * @zh 在指定的索引位置添加子节点对象。
         * @param child 要添加的子节点对象。
         * @param index 用于添加子节点对象的索引位置。
         * @returns 添加的子节点对象。
        */
        addChildAt(child: Node, index: number): Node;
        /**
         * @en Removes a child object at a specified index position.
         * @param index The index position of the child object.
         * @returns The removed child object.
         * @zh 删除指定索引位置的子节点对象。
         * @param index 子节点对象的索引位置。
         * @returns 删除的子节点对象。
        */
        removeChildAt(index: number): Node;
        /**
         * @en Refresh
         * @zh 刷新
         */
        refresh(): void;
    }
    /**
     * @en The List control can display a list of items. The default is a vertical list. The list can be customized through the UI editor.
     * - Event.RENDER: When rendering the unit item object of a list, it is dispatched.
     * - change event: When the selectedIndex property of an object changes, it is dispatched.
     * @zh List 控件可显示项目列表。默认为垂直方向列表。可通过UI编辑器自定义列表。
     * - Event.RENDER事件: 渲染列表的单元项对象时调度。
     * - change事件: 当对象的 selectedIndex 属性发生变化时调度。
     */
    class List extends Box {
        /**
         * @en The processor executed when changing the selection of a List. (Default return parameters: Item index(index:int))
         * @zh 改变 List 的选择项时执行的处理器。(默认返回参数： 项索引（index:int）)。
         */
        selectHandler: Handler | null;
        /**
         * @en Cell rendering processor(Default return parameters  cell:UIComponent,index:int)
         * @zh 单元格渲染处理器(默认返回参数cell:UIComponent,index:int)。
         */
        renderHandler: Handler | null;
        /**
         * @en Cell Mouse Event Processor(Default return parameters  e:Event,index:int)
         * @zh 单元格鼠标事件处理器(默认返回参数e:Event,index:int)。
         */
        mouseHandler: Handler | null;
        /**
         * @en Specify whether it is selectable. If the value is true, you can choose; Otherwise, you cannot choose.
         * @zh 指定是否可以选择。若值为 true，则可以选择；否则不可以选择。
         * @default false
         */
        selectEnable: boolean;
        /**
         * @en The maximum number of pages for pagination.
         * @zh 最大分页数。
         */
        totalPage: number;
        /**
         * @en Disable scrollbar stop.
         * @zh 禁用滚动条停止。
         */
        disableStopScroll: boolean;
        protected _content: Box;
        protected _scrollBar: ScrollBar | null;
        protected _itemRender: any;
        protected _repeatX: number;
        protected _repeatY: number;
        protected _repeatX2: number;
        protected _repeatY2: number;
        protected _spaceX: number;
        protected _spaceY: number;
        protected _cells: UIComponent[];
        protected _array: any[] | null;
        protected _startIndex: number;
        protected _selectedIndex: number;
        protected _page: number;
        protected _isVertical: boolean;
        protected _cellSize: number;
        protected _cellOffset: number;
        protected _isMoved: boolean;
        protected _createdLine: number;
        protected _cellChanged: boolean;
        protected _offset: Point;
        protected _usedCache: string | null;
        protected _elasticEnabled: boolean;
        protected _scrollType: ScrollType;
        protected _vScrollBarSkin: string;
        protected _hScrollBarSkin: string;
        private _preLen;
        /**
         * @en Determines whether the content is cached for performance optimization.
         * Setting this property to true can greatly improve performance if the data source is small and there are no animations within the list.
         * @zh 是否缓存内容。如果数据源较少，并且列表内无动画，设置此属性为 true 能大大提高性能。
         */
        cacheContent: boolean;
        /**
         * @en The current page number of the list.
         * @zh 列表的当前页码。
         */
        get page(): number;
        set page(value: number);
        /**
         * @en The total number of items in the list.
         * @zh 列表的数据总个数。
         */
        get length(): number;
        /**
         * @en The collection of cells in the list.
         * @zh 单元格集合。
         */
        get cells(): UIComponent[];
        /**
         * @en If the elastic effect is enabled.
         * @zh 是否开启橡皮筋效果。
         */
        get elasticEnabled(): boolean;
        set elasticEnabled(value: boolean);
        /**
         * @en The caching mode for the list.
         * @zh 列表的缓存模式。
         */
        set cacheAs(value: string);
        /**
         * @en The caching mode of the list.
         * @zh 列表的缓存模式。
         */
        get cacheAs(): string;
        /**
         * @en Reference to the content container Box component of the List component.
         * @zh List 组件所包含的内容容器 Box 组件的引用。
         */
        get content(): Box;
        /**
         * @en Scrollbar type. Options include:
          - ScrollType.None (0): No scrollbar
          - ScrollType.Horizontal (1): Horizontal scrollbar.
          - Others: such as ScrollType.Vertical (2) indicates a vertical scrollbar
         * @zh 滚动条类型。可选值包括：
         * - ScrollType.None（0）：无滚动条
         * - ScrollType.Horizontal（1）：水平方向滚动条。
         * - 其它：如 ScrollType.Vertical（2） 表示垂直方向滚动条
         */
        get scrollType(): ScrollType;
        set scrollType(value: ScrollType);
        /**
         * @en The skin of the vertical scroll bar.
         * @zh 垂直方向滚动条皮肤。
         */
        get vScrollBarSkin(): string;
        set vScrollBarSkin(value: string);
        /**
         * @en The skin of the horizontal scroll bar.
         * @zh 水平方向滚动条皮肤。
         */
        get hScrollBarSkin(): string;
        set hScrollBarSkin(value: string);
        /**
         * @en The reference to the ScrollBar component contained within the List component.
         * @zh List 组件所包含的 ScrollBar 组件的引用。
         */
        get scrollBar(): ScrollBar | null;
        set scrollBar(value: ScrollBar | null);
        /**
         * @en The cell renderer for the List component.
         * value:  The value can be a cell class object or a UI JSON description.
         * @zh 单元格渲染器。
         * 取值：单元格类对象 或 UI的JSON描述。
         */
        get itemRender(): any;
        set itemRender(value: any);
        /**
         * @en The number of cells displayed horizontally.
         * @zh 水平方向显示的单元格数量。
         */
        get repeatX(): number;
        set repeatX(value: number);
        /**
         * @en The number of cells displayed vertically.
         * @zh 垂直方向显示的单元格数量。
         */
        get repeatY(): number;
        set repeatY(value: number);
        /**
         * @en The horizontal spacing between cells in pixels.
         * @zh 水平方向显示的单元格之间的间距（以像素为单位）。
         */
        get spaceX(): number;
        set spaceX(value: number);
        /**
         * @en The vertical spacing between cells in pixels.
         * @zh 垂直方向显示的单元格之间的间距（以像素为单位）。
         */
        get spaceY(): number;
        set spaceY(value: number);
        /**
         * @en Represents the index of the currently selected item. Changing the selectedIndex value will cause the list to re-render.
         * @zh 表示当前选择的项索引。selectedIndex值更改会引起列表重新渲染。
         */
        get selectedIndex(): number;
        set selectedIndex(value: number);
        /**
         * @en List data source
         * @zh 列表数据源。
         */
        get array(): any[];
        set array(value: any[]);
        /**
         * @en The data source of the currently selected cell.
         * @zh 当前选中的单元格数据源。
         */
        get selectedItem(): any;
        set selectedItem(value: any);
        /**
         * @en The currently selected cell object.
         * @zh 当前选择的单元格对象。
         */
        get selection(): UIComponent;
        set selection(value: UIComponent);
        /**
         * @en The start index of the currently displayed list of cells.
         * @zh 当前显示的单元格列表的开始索引。
         */
        get startIndex(): number;
        set startIndex(value: number);
        protected createChildren(): void;
        private _getOneCell;
        private _createItems;
        private _bindData;
        protected _sizeChanged(): void;
        protected _setCellChanged(): void;
        private onScrollStart;
        private onScrollEnd;
        protected createItem(): UIComponent;
        /**
         * @en Adds a cell to the list.
         * @param cell The cell object to be added.
         * @zh 添加单元格。
         * @param cell 需要添加的单元格对象。
         */
        protected addCell(cell: UIComponent): void;
        /**
         * @en Handles mouse events for cells.
         * @param e The event object.
         * @zh 单元格的鼠标事件侦听处理函数。
         * @param e 事件对象。
         */
        protected onCellMouse(e: Event): void;
        /**
         * @en Changes the visual state of a cell.
         * @param cell The cell object.
         * @param visible Indicates whether the cell should be visible.
         * @param index The cell's property index value.
         * @zh 改变单元格的可视状态。
         * @param cell 单元格对象
         * @param visible 是否显示。
         * @param index 单元格的属性 index 值。
         */
        protected changeCellState(cell: UIComponent, visible: boolean, index: number): void;
        /**
         * @en Event handler for the scrollbar's Event.CHANGE event.
         * @zh 滚动条的 Event.CHANGE 事件侦听处理函数。
         */
        protected onScrollBarChange(e?: Event | null): void;
        private posCell;
        /**
         * @en Changes the selection state of the cells.
         * @zh 改变单元格的选择状态。
         */
        protected changeSelectStatus(): void;
        /**
         * @en Renders the list of cells.
         * @param from The start index to begin rendering from.
         * @param to The end index to stop rendering. If not provided, it renders to the end of the list.
         * @zh 渲染单元格列表。
         * @param from 渲染开始的索引。
         * @param to 停止渲染的结束索引。如果没有提供，它将渲染到列表末尾。
         */
        protected renderItems(from?: number, to?: number): void;
        /**
         * @en Renders a single cell.
         * @param cell The cell object that needs to be rendered.
         * @param index The index of the cell.
         * @zh 渲染一个单元格。
         * @param cell 需要渲染的单元格对象。
         * @param index 单元格索引。
         */
        protected renderItem(cell: UIComponent, index: number): void;
        protected commitMeasure(): void;
        /**
         * @en Updates the data source without refreshing the entire list, only increasing the scroll length.
         * @param array The data source to update.
         * @zh 更新数据源，不刷新list，只增加滚动长度。
         * @param array 数据源。
         */
        updateArray(array: any[]): void;
        /**
         * @en Called after deserialization to perform additional setup.
         * @zh 反序列化后调用以执行额外的设置。
         */
        onAfterDeserialize(): void;
        /**
         * @en Initializes cell information.
         * @zh 初始化单元格信息。
         */
        initItems(): void;
        /**
         * @en Sets the size of the viewable area.
         * The viewable area is defined by a rectangle with the top-left corner at (0,0) and the specified width and height.
         * @param width The width of the viewable area.
         * @param height The height of the viewable area.
         * @zh 设置可视区域大小。
         * 以（0，0，width参数，height参数）组成的矩形区域为可视区域。
         * @param width 可视区域宽度。
         * @param height 可视区域高度。
         */
        setContentSize(width: number, height: number): void;
        /**
         * @en Sets the data source for the component, overriding the base class's method to handle different data types.
         * @param value The new data source.
         * @zh 设置数据源，覆盖基类方法以处理不同类型的数据。
         * @param value 新的数据源。
         */
        set_dataSource(value: any): void;
        /**
         * @en Refreshes the list data source.
         * @zh 刷新列表数据源。
         */
        refresh(): void;
        /**
         * @en Get the cell data source.
         * @param index The index of the cell.
         * @zh 获取单元格数据源。
         * @param index 单元格索引。
         */
        getItem(index: number): any;
        /**
         * @en Changes the data source of a cell at a specified index.
         * @param index The index of the cell.
         * @param source The data source for the cell.
         * @zh 修改单元格数据源。
         * @param index 单元格索引。
         * @param source 单元格数据源。
         */
        changeItem(index: number, source: any): void;
        /**
         * @en Sets the data source for a cell at a specified index.
         * @param index The cell index.
         * @param source The data source for the cell.
         * @zh 设置单元格数据源。
         * @param index 单元格索引。
         * @param source 单元格数据源。
         */
        setItem(index: number, source: any): void;
        /**
         * @en Adds a new data source to the cell list.
         * @param source The data source to add.
         * @zh 添加单元格数据源。
         * @param source 数据源。
         */
        addItem(source: any): void;
        /**
         * @en Adds a new data source to the cell list at a specified index.
         * @param source The data source to add.
         * @param index The index at which to insert the data source.
         * @zh 添加单元格数据源到对应的数据索引处。
         * @param source 单元格数据源。
         * @param index 索引。
         */
        addItemAt(source: any, index: number): void;
        /**
         * @en Deletes a data source from the cell list by its index.
         * @param index The index of the data source to delete.
         * @zh 通过数据源索引删除单元格数据源。
         * @param index 需要删除的数据源索引值。
         */
        deleteItem(index: number): void;
        /**
         * @en Gets the cell object by its visible index.
         * @param index The visible index of the cell.
         * @return The cell object.
         * @zh 通过可视单元格索引，获取单元格。
         * @param index 可视单元格索引。
         * @return 单元格对象。
         */
        getCell(index: number): UIComponent | null;
        /**
         * @en Scrolls the list so that the cell corresponding to the specified data index becomes the first visible item in the list.
         * @param index The index of the cell in the data list.
         * @zh 滚动列表，以设定的数据索引对应的单元格为当前可视列表的第一项。
         * @param index 单元格在数据列表中的索引。
         */
        scrollTo(index: number): void;
        /**
         * @en Scrolls the list with tweening to make the cell corresponding to the specified data index the first visible item in the list.
         * @param index The index of the cell in the data list.
         * @param time The duration of the tweening effect in milliseconds.
         * @param complete An optional callback function to call when the tweening completes.
         * @zh 缓动滚动列表，以设定的数据索引对应的单元格为当前可视列表的第一项。
         * @param index 单元格在数据列表中的索引。
         * @param time	缓动时间。
         * @param complete	缓动结束回调.
         */
        tweenTo(index: number, time?: number, complete?: Handler | null): void;
        /**
         * @en Destroys the instance and its child elements.
         * @param destroyChild Specifies whether to destroy child elements.
         * @zh 销毁实例及其子元素。
         * @param destroyChild 指定是否销毁子元素。
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * @en OpenDataContext component for displaying OpenData in WeChat mini-games. Instantiate this component directly to optimally display OpenData based on the component's width, height, and position.
     * @zh 微信小游戏开放数据域显示组件，直接实例化本组件，即可根据组件宽高和位置，以最优的方式显示开放数据域数据。
     */
    class OpenDataContextView extends UIComponent {
        private _fps;
        /** @ignore */
        constructor();
        /**
         * @en The frame rate.
         * @zh 帧率。
         */
        get fps(): number;
        set fps(value: number);
        /**
         * @ignore
         */
        _onActive(): void;
        /**
         * @ignore
         */
        _onInActive(): void;
        private _onLoop;
        /**
         * @ignore
         */
        _setWidth(value: number): void;
        /**
         * @ignore
         */
        _setHeight(value: number): void;
        /**
         * @en The x-coordinate of the component.
         * @zh 组件的 x 坐标。
         */
        get x(): number;
        set x(value: number);
        /**
         * @en The y-coordinate of the component.
         * @zh 组件的 y 坐标。
         */
        get y(): number;
        set y(value: number);
        private updateViewPort;
        /**
         * @en Send a message to the OpenData context.
         * @param msg Message to send.
         * @zh 向开放数据域发送消息。
         * @param msg 要发送的消息。
         */
        postMsg(msg: any): void;
    }
    /**
     * @en Panel is a panel container class.
     * @zh Panel 是一个面板容器类。
     */
    class Panel extends Box {
        protected _content: Box;
        protected _vScrollBar: VScrollBar;
        protected _hScrollBar: HScrollBar;
        protected _scrollChanged: boolean;
        protected _usedCache: string;
        protected _elasticEnabled: boolean;
        protected _scrollType: ScrollType;
        protected _vScrollBarSkin: string;
        protected _hScrollBarSkin: string;
        /**
         * @en Creates an instance of Panel, and sets the width and height of it.
         * @zh 创建一个`Panel`实例，属性 `width` 和 `height` 的默认值均为 100。
         */
        constructor();
        /**
         * @en Destroy this object.
         * @param destroyChild Whether to destroy the child objects as well.
         * @zh 销毁此对象。
         * @param destroyChild 是否同时销毁子对象。
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @en Destroy all child objects.
         * @zh 销毁所有的子对象。
         */
        destroyChildren(): void;
        protected createChildren(): void;
        /**
         * @en Add a child object.
         * @param child The child object to add.
         * @returns The added child object.
         * @zh 添加一个节点子对象。
         * @param child 要添加的子节点对象。
         * @returns 添加的子节点对象。
         */
        addChild<T extends Node>(child: T): T;
        /**
        * @en Event handler for the child object's Event.RESIZE event.
        * @zh 子对象的 Event.RESIZE 事件侦听处理函数。
        */
        private onResize;
        /**
         * @en Add a child object at a specific index position.
         * @param child The child object to add.
         * @param index The index position to place the child at.
         * @returns The child object that was added.
         * @zh 在指定的索引位置添加一个子节点对象。
         * @param child 要添加的子节点对象。
         * @param index 子节点对象的索引位置。
         * @returns 添加的子节点对象。
         */
        addChildAt(child: Node, index: number): Node;
        /**
         * @en Remove a child object.
         * @param child The child object to remove.
         * @returns The removed child object.
         * @zh 移除一个子节点对象。
         * @param child 要移除的子节点对象。
         * @returns 移除的子节点对象。
         */
        removeChild(child: Node): Node;
        /**
         * @en Remove a child object at a specific index position.
         * @param index The index position of the child object.
         * @returns The removed child object.
         * @zh 移除指定索引位置的子节点对象。
         * @param index 子节点对象的索引位置。
         * @returns 移除的子节点对象。
         */
        removeChildAt(index: number): Node;
        /**
         * @en Remove a range of children from the object.
         * @param beginIndex The beginning position.
         * @param endIndex The ending position. The default value is 0x7fffffff.
         * @returns The Panel object itself.
         * @zh 移除指定范围的子节点对象。
         * @param beginIndex 开始位置。
         * @param endIndex 结束位置。默认值为 0x7fffffff。
         * @returns 返回对象本身。
         */
        removeChildren(beginIndex?: number, endIndex?: number): Node;
        /**
         * @en Returns the child object at a specific index position.
         * @param index The index position of the child object.
         * @returns The child object at the specified index position.
         * @zh 返回指定索引位置的子节点对象。
         * @param index 子节点对象的索引位置。
         * @returns 指定索引位置处的子节点对象。
         */
        getChildAt(index: number): Node;
        /**
         * @en Returns a child object with a specific name.
         * @param name The name of the child object.
         * @returns The child object with the specified name.
         * @zh 返回具有指定名称的子节点对象。
         * @param name 子节点对象的名称。
         * @returns 具有指定名称的子节点对象。
         */
        getChildByName(name: string): Node;
        /**
         * @en Returns the index position of a specific child object.
         * @param child The child object.
         * @returns The index position of the child object.
         * @zh 返回指定子节点对象的索引位置。
         * @param child 子节点对象。
         * @returns 子节点对象的索引位置。
         */
        getChildIndex(child: Node): number;
        /**
         * @en The number of child objects.
         * @zh 子节点对象数量。
         */
        get numChildren(): number;
        private changeScroll;
        protected _sizeChanged(): void;
        /**
         * @en Get the width of the content area in pixels.
         * @zh 获取内容区域宽度（以像素为单位）。
         */
        get contentWidth(): number;
        /**
         * @en Get the height of the content area in pixels.
         * @zh 获取内容区域高度（以像素为单位）。
         */
        get contentHeight(): number;
        /**
         * @en Sets the width and height of the content (in pixels).
         * @param width The width.
         * @param height The height.
         * @zh 设置内容的宽度、高度（以像素为单位）。
         * @param width 宽度。
         * @param height 高度。
         */
        private setContentSize;
        /**@ignore */
        _setWidth(value: number): void;
        /**@ignore */
        _setHeight(value: number): void;
        /**
         * @en Scroll bar type. The range of values is 0-3.
         * ScrollType.None(0): Does not display any scrollbars
         * ScrollType.Horizontal(1):Displays only the horizontal scrollbar
         * ScrollType.Vertical(2): Displays only the vertical scrollbar
         * ScrollType.Both(3):  Displays both horizontal and vertical scrollbars
         * @zh 滚动条类型。取值范围0-3。
         * ScrollType.None(0): 不显示任何滚动条
         * ScrollType.Horizontal(1): 仅显示水平滚动条
         * ScrollType.Vertical(2): 仅显示垂直滚动条
         * ScrollType.Both(3): 同时显示水平和垂直滚动条
         */
        get scrollType(): ScrollType;
        set scrollType(value: ScrollType);
        private createHScrollBar;
        private createVScrollBar;
        /**
         * @en The skin of the vertical scrollbar.
         * @zh 垂直方向滚动条皮肤。
         */
        get vScrollBarSkin(): string;
        set vScrollBarSkin(value: string);
        /**
         * @en The skin of the horizontal scrollbar.
         * @zh 水平方向滚动条皮肤。
         */
        get hScrollBarSkin(): string;
        set hScrollBarSkin(value: string);
        /**
         * @en The vertical scrollbar object.
         * @zh 垂直方向滚动条对象。
         */
        get vScrollBar(): ScrollBar;
        /**
         * @en The horizontal scrollbar object.
         * @zh 水平方向滚动条对象。
         */
        get hScrollBar(): ScrollBar;
        /**
         * @en Get the content container object.
         * @zh 获取内容容器对象。
         */
        get content(): Sprite;
        /**
         * @en Event.MOUSE_DOWN event handler for the scrollbar.
         * @param scrollBar The scrollbar object.
         * @zh 滚动条的 Event.MOUSE_DOWN 事件侦听处理函数。
         * @param scrollBar 滚动条对象。
         */
        protected onScrollBarChange(scrollBar: ScrollBar): void;
        /**
         * @en Scroll the content container to the specified position of the vertical and horizontal scrollbars.
         * @param x The value of the `value` property of the horizontal scrollbar.
         * @param y The value of the `value` property of the vertical scrollbar.
         * @zh 滚动内容容器至设定的垂直、水平方向滚动条位置。
         * @param x 水平方向滚动条属性value值。滚动条位置数字。
         * @param y 垂直方向滚动条属性value值。滚动条位置数字。
         */
        scrollTo(x?: number, y?: number): void;
        /**
         * @en Refresh the scroll content.
         * @zh 刷新滚动内容。
         */
        refresh(): void;
        get cacheAs(): string;
        set cacheAs(value: string);
        /**
         * @en Whether to enable the elastic effect.
         * @zh 是否开启橡皮筋效果。
         */
        get elasticEnabled(): boolean;
        set elasticEnabled(value: boolean);
        private onScrollStart;
        private onScrollEnd;
        protected _setScrollChanged(): void;
    }
    /**
     * @en The `ProgressBar` component displays the loading progress of content.
     * change event is dispatched when the value changes.
     * @zh `ProgressBar` 组件用于显示内容的加载进度。
     * change事件用于值发生改变后调度。
     */
    class ProgressBar extends UIComponent {
        protected _bg: Image;
        protected _bar: Image;
        protected _skin: string;
        protected _value: number;
        /**
         * @en The handler function that is called when the value of the `ProgressBar` instance's `value` property changes.The progress value. Default to return the `value` property.
         * @zh 当 `ProgressBar` 实例的 `value` 属性发生变化时的函数处理器。默认返回参数 `value` 属性（进度值）。
         */
        changeHandler: Handler;
        /**
         * @en The skin of the progress bar.
         * @zh 进度条的皮肤资源路径。
         */
        get skin(): string;
        set skin(value: string);
        /**
         * @en The current progress value, range from 0 to 1.
         * @zh 当前的进度量，取值范围为 0 到 1 之间。
         */
        get value(): number;
        set value(num: number);
        /**
         * @en The progress bar object.
         * @zh 进度条对象。
         */
        get bar(): Image;
        /**
         * @en The background bar object.
         * @zh 进度背景条对象。
         */
        get bg(): Image;
        /**
          * @en The size grid of the texture.
          * The size grid is a 3x3 division of the texture, allowing it to be scaled without distorting the corners and edges.
          * The array contains five values representing the top, right, bottom, and left margins, and whether to repeat the fill (0: no repeat, 1: repeat).
          * The values are separated by commas. For example: "6,6,6,6,1".
          * @zh 纹理的九宫格数据。
          * 九宫格是一种将纹理分成3x3格的方式，使得纹理缩放时保持角和边缘不失真。
          * 数组包含五个值，分别代表上边距、右边距、下边距、左边距以及是否重复填充（0：不重复填充，1：重复填充）。
          * 值以逗号分隔。例如："6,6,6,6,1"。
          */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * @ignore
         * @en creates an instance of ProgressBar.
         * @param skin The skin URL.
         * @zh 创建一个 ProgresBar 的实例。
         * @param skin 皮肤地址。
         */
        constructor(skin?: string);
        protected createChildren(): void;
        protected _skinLoaded(): void;
        protected measureWidth(): number;
        protected measureHeight(): number;
        /**
         * @en Changes the progress value.
         * @zh 更改进度值的显示。
         */
        protected changeValue(): void;
        /**
         * @en Sets the width of the component.
         * @param value The width value to set.
         * @zh 设置组件的宽度。
         * @param value 要设置的宽度值。
         */
        set_width(value: number): void;
        /**
         * @en Sets the data source for the component.
         * @param value The data source to set. If it's a number or string, it will be converted to a number and set as the component's value.
         * @zh 设置组件的数据源。
         * @param value 要设置的数据源。如果是数字或字符串，将被转换为数字并设置为组件的值。
         */
        set_dataSource(value: any): void;
        /**
         * @en Destroys the component and its child elements.
         * @param destroyChild Whether to destroy child elements. Default is true.
         * @zh 销毁组件及其子元素。
         * @param destroyChild 是否销毁子元素。默认为 true。
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * @en The Radio control allows users to select one option from a mutually exclusive set of choices.
     * Choosing an unselected member of a Radio group will unselect the currently selected `Radio` control within that group.
     * @zh Radio 控件使用户可在一组互相排斥的选择中做出一种选择。
     * 用户一次只能选择 Radio 组中的一个成员。选择未选中的组成员将取消选择该组中当前所选的 Radio 控件。
     */
    class Radio extends Button {
        protected _value: any;
        /**
         * @en The optional user-defined value associated with the Radio.
         * @zh Radio 关联的可选用户定义值。
         */
        get value(): any;
        set value(obj: any);
        /**
         * @en creates an instance of Radio.
         * @param skin The path of the skin to be used for the Radio.
         * @param label The text label to be displayed next to the Radio.
         * @zh 创建一个 Radio 实例。
         * @param skin Radio 的皮肤路径。
         * @param label 显示在 Radio 旁边的文本标签。
         */
        constructor(skin?: string, label?: string);
        /**
         * @en Preinitializes the Radio component by setting properties before initialization.
         * @zh 在初始化前对 Radio 组件进行预初始化，设置相关属性。
         */
        protected preinitialize(): void;
        /**
         * @en Initializes the Radio component, creating text and setting text properties.
         * @zh 初始化 Radio 组件，创建文本并设置文本属性。
         */
        protected initialize(): void;
        /**
         * @en The click event handler for the Radio object.
         * @param e The event object.
         * @zh 对象的Event.CLICK事件侦听处理函数。
         * @param e 事件对象。
         */
        protected onClick(e: Event): void;
        protected changeClips(): void;
    }
    /**
     * @en The RadioGroup control defines a group of mutually exclusive Radio controls, such that only one Radio control can be selected at a time by the user.
     * `change` event is dispatched when the selectedIndex property of a Group instance changes.
     * @zh RadioGroup 控件定义一组 Radio 控件，这些控件相互排斥；因此，用户每次只能选择一个 Radio 控件。
     * `change`事件用于当Group的selectedIndex属性发生变化时调度。
     */
    class RadioGroup extends UIGroup {
        protected createItem(skin: string, label: string): Sprite;
    }
    /**
     * @en The `ScaleBox` is a container that automatically scales its content to fit the stage size while maintaining the original aspect ratio.
     * @zh `ScaleBox` 是一个自适应缩放容器，容器设置大小后，容器大小始终保持舞台大小，子内容按照原始最小宽高比缩放。
     */
    class ScaleBox extends Box {
        private _oldW;
        private _oldH;
        private onResize;
        /**
         * @ignore
         * @en Called when the container is enabled. Adds a resize event listener to the stage.
         * @zh 容器启用时调用。为舞台添加调整大小事件监听器。
         */
        onEnable(): void;
        /**
         * @ignore
         * @en Called when the container is disabled. Removes the resize event listener from the stage.
         * @zh 容器禁用时调用。从舞台移除调整大小事件监听器。
         */
        onDisable(): void;
        /**
         * @en Sets the width of the container and updates the original width.
         * @param value The new width value.
         * @zh 设置容器的宽度并更新原始宽度。
         * @param value 新的宽度值。
         */
        set_width(value: number): void;
        /**
         * @en Sets the height of the container and updates the original height.
         * @param value The new height value.
         * @zh 设置容器的高度并更新原始高度。
         * @param value 新的高度值。
         */
        set_height(value: number): void;
    }
    /**
     * @en The `ScrollBar` component is a scrollbar component.
     * When there is too much data to fit in the display area, the end user can use the `ScrollBar` component to control the portion of data being displayed.
     * A scrollbar consists of four parts: two arrow buttons, a track, and a thumb (slider).
     * - `start` event dispatched when the scrollbar starts to slide.
     * - `end` event dispatched when the scrollbar stops sliding.
     * - `change` event dispatched when the scrollbar thumb position changes.
     * @zh ScrollBar 组件是一个滚动条组件。
     * 当数据太多以至于显示区域无法容纳时，最终用户可以使用 ScrollBar 组件控制所显示的数据部分。
     * 滚动条由四部分组成：两个箭头按钮、一个轨道和一个滑块。
     * - `start` 事件在滚动条开始滑动时调度。
     * - `end` 事件在滚动条滑动结束时调度。
     * - `change` 事件在滚动条滑块位置发生变化时调度。
     */
    class ScrollBar extends UIComponent {
        /**
         * @en Sets the global easing function for scrolling speed changes.
         * @zh 设置全局的滚动速度变化曲线函数
         */
        static easeFunction: typeof Ease.sineOut;
        /**
         * @en The ratio of scroll decay.
         * @zh 滚动衰减系数
         */
        rollRatio: number;
        /**
         * @en Callback when scrolling changes, return value parameter.
         * @zh 滚动变化时回调，回传value参数。
         */
        changeHandler: Handler;
        /**
         * @en Indicates whether to scale the size of the scrollbar, default is true.
         * @zh 是否缩放滑动条的大小，默认值为true。
         */
        scaleBar: boolean;
        /**
         * @en A boolean value that specifies whether to automatically hide the scrollbar when it is not in use, default is false.
         * @zh 一个布尔值，指定是否在无需滚动时自动隐藏滚动条，默认值为false。
         */
        autoHide: boolean;
        /**
         * @en The limit distance for the rubber band effect, 0 means no rubber band effect.
         * @zh 橡皮筋效果极限距离，0表示没有橡皮筋效果。
         */
        elasticDistance: number;
        /**
         * @en The time in milliseconds for the rubber band effect to rebound.
         * @zh 橡皮筋回弹时间，单位为毫秒。
         */
        elasticBackTime: number;
        /**
         * @en The up button.
         * @zh 上按钮。
         */
        upButton: Button;
        /**
         * @en The down button.
         * @zh 下按钮。
         */
        downButton: Button;
        /**
         * @en slider.
         * @zh 滑动条。
         */
        slider: Slider;
        /**
         * @en The top movement limit for the scrollbar. When this limit is reached, the 'dragTopLimit' event is dispatched.
         * This can be used in conjunction with the `stopMoveLimit()` method to allow developers to perform dynamic data updates and other operations.
         * @zh 顶部移动限制。当达到此限制时，会触发 'dragTopLimit' 事件。
         * 它可以与 `stopMoveLimit()` 方法结合使用，以便开发者执行动态数据更新和其他操作。
         */
        topMoveLimit: number;
        /**
         * @en The bottom movement limit for the scrollbar. When this limit is reached, the 'dragBottomLimit' event is dispatched.
         * This can be used in conjunction with the `stopMoveLimit()` method to allow developers to perform dynamic data updates and other operations.
         * @zh 底部移动限制。当达到此限制时，会触发 'dragBottomLimit' 事件。
         * 它可以与 `stopMoveLimit()` 方法结合使用，以便开发者执行动态数据更新和其他操作。
         */
        bottomMoveLimit: number;
        /**
         * @en Determines whether dragging of the content is disabled when the 'stopMoveLimit' method is called.
         * @zh 确定在调用 'stopMoveLimit' 方法时是否禁止内容的拖拽。
         */
        disableDrag: boolean;
        protected _showButtons: boolean;
        protected _scrollSize: number;
        protected _skin: string;
        protected _thumbPercent: number;
        protected _target: Sprite;
        protected _lastPoint: Point;
        protected _lastOffset: number;
        protected _checkElastic: boolean;
        protected _isElastic: boolean;
        protected _value: number;
        protected _hide: boolean;
        protected _clickOnly: boolean;
        protected _offsets: any[];
        protected _touchScrollEnable: boolean;
        protected _mouseWheelEnable: boolean;
        /**
         * @en creates an instance of ScrollBar.
         * @param skin The address of the skin resource.
         * @zh 创建一个 ScrollBar 实例。
         * @param skin 皮肤资源地址。
         */
        constructor(skin?: string);
        destroy(destroyChild?: boolean): void;
        /**
         * @en Creates the child elements of the ScrollBar, such as the slider and buttons.
         * @zh 创建 ScrollBar 的子元素，例如滑块和按钮。
         */
        protected createChildren(): void;
        /**
         * @en Initializes the ScrollBar, setting up the slider and buttons with appropriate event listeners.
         * @zh 初始化 ScrollBar，为滑块和按钮设置适当的事件监听器。
         */
        protected initialize(): void;
        /**
         * @en The change event handler for the slider when its value changes.
         * @zh 滑块值改变时的事件处理函数。
         */
        protected onSliderChange(): void;
        /**
         * @en The mouse down event handler for the up and down buttons.
         * @zh 向上和向下按钮的 Event.MOUSE_DOWN 事件侦听处理函数。
         */
        protected onButtonMouseDown(e: Event): void;
        protected startLoop(isUp: boolean): void;
        protected slide(isUp: boolean): void;
        /**
         * @en The mouse up event handler for the stage.
         * @param e The event object.
         * @zh 舞台的 Event.MOUSE_DOWN 事件侦听处理函数。
         * @param e 事件对象。
         */
        protected onStageMouseUp(e: Event): void;
        /**
         * @en the skin of the scrollbar.
         * @zh 滚动条的皮肤纹理路径。
         */
        get skin(): string;
        set skin(value: string);
        /**
         * @en Asynchronously sets the skin for the scrollbar and its components.
         * @param url The URL of the skin to be set.
         * @zh 异步设置滚动条及其组件的皮肤。
         * @param url 要设置的皮肤的 URL。
         */
        _setSkin(url: string): Promise<void>;
        /**
         * @en Called when the skin is loaded.
         * @zh 皮肤加载完成时调用。
         */
        protected _skinLoaded(): void;
        /**
         * @en Adjust the scroll bar's display state, including the visibility of the buttons and the position of the slider
         * @zh 更改滚动条的显示状态，包括按钮的可见性和滑动条的位置
         */
        protected changeScrollBar(): void;
        protected _sizeChanged(): void;
        private resetPositions;
        protected resetButtonPosition(): void;
        protected measureWidth(): number;
        protected measureHeight(): number;
        /**
         * @en Sets the information for the scrollbar.
         * @param min The minimum position value of the scrollbar.
         * @param max The maximum position value of the scrollbar.
         * @param value The current position value of the scrollbar.
         * @zh 设置滚动条信息。
         * @param min 滚动条最小位置值。
         * @param max 滚动条最大位置值。
         * @param value 滚动条当前位置值。
         */
        setScroll(min: number, max: number, value?: number): void;
        /**
         * @en the numeric value representing the maximum scroll position.
         * @zh 最高滚动位置的数字。
         */
        get max(): number;
        set max(value: number);
        /**
         * @en the numeric value representing the minimum scroll position.
         * @zh 最低滚动位置的数字。
         */
        get min(): number;
        set min(value: number);
        /**
         * @en the numeric value representing the current scroll position.
         * @zh 当前滚动位置的数字。
         */
        get value(): number;
        set value(v: number);
        /**
         * @en Indicates whether the scrollbar is vertical. If true, the scrollbar is vertical; otherwise, it is horizontal.
         * Default value: true.
         * @zh 滚动条是否为垂直滚动。如果值为true，则为垂直滚动，否则为水平滚动。
         * 默认值为：true。
         */
        get isVertical(): boolean;
        set isVertical(value: boolean);
        /**
         * @en The size grid of the texture.
         * The size grid is a 3x3 division of the texture, allowing it to be scaled without distorting the corners and edges.
         * The array contains five values representing the top, right, bottom, and left margins, and whether to repeat the fill (0: no repeat, 1: repeat).
         * The values are separated by commas. For example: "6,6,6,6,1".
         * @zh 纹理的九宫格数据。
         * 九宫格是一种将纹理分成3x3格的方式，使得纹理缩放时保持角和边缘不失真。
         * 数组包含五个值，分别代表上边距、右边距、下边距、左边距以及是否重复填充（0：不重复填充，1：重复填充）。
         * 值以逗号分隔。例如："6,6,6,6,1"。
         */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * @en The minimum unit for page scrolling when the scrollbar track is pressed.
         * @zh 按下滚动条轨道时页面滚动的最小单位
         */
        get scrollSize(): number;
        set scrollSize(value: number);
        set_dataSource(value: any): void;
        /**
         * @en Slider length ratio, with a value between 0 and 1.
         * @zh 滑条长度比例，值为：（0-1）。
         */
        get thumbPercent(): number;
        set thumbPercent(value: number);
        /**
         * @en the target object of the scrollbar.
         * @zh 滚动的对象。
         */
        get target(): Sprite;
        set target(value: Sprite);
        /**
         * @en Determines whether the scrollbar is hidden. If true, the scrollbar is not displayed, but scrolling functions remain active. Default is false.
         * @zh 是否隐藏滚动条，设置为 true 时，不显示滚动条，但可以正常滚动，默认为 false。
         */
        get hide(): boolean;
        set hide(value: boolean);
        /**
         * @en Specifies whether the up and down buttons are displayed. Default is true.
         * @zh 是否显示向上和向下的按钮，默认值为 true，表示显示。
         */
        get showButtons(): boolean;
        set showButtons(value: boolean);
        /**
         * @en Specifies whether touch scrolling is enabled. Default is true.
         * @zh 是否启用触摸滚动，默认值为 true，表示启用。
         */
        get touchScrollEnable(): boolean;
        set touchScrollEnable(value: boolean);
        /**
         * @en Specifies whether mouse wheel scrolling is enabled. Default is true.
         * @zh 是否启用鼠标滚轮滚动，默认值为 true，表示启用。
         */
        get mouseWheelEnable(): boolean;
        set mouseWheelEnable(value: boolean);
        protected onTargetMouseWheel(e: Event): void;
        isLockedFun: Function;
        protected onTargetMouseDown(e: Event): void;
        /**
         * @en Forces a drag action on the scrollbar.
         * Normally, dragging can only be done by holding the scrollbar itself. If you need to force drag outside the scrollbar object, you can achieve this by calling this method.
         * For example, if the mouse is continuously held on a button object outside the scrollbar and this method is called, then sliding the mouse will have the same effect as dragging the scrollbar.
         * @zh 强制拖拽滚动条；
         * 常规情况下只能是按住滚动条本身才可以拖拽，如果需要在滚动条对象之外进行强制拖拽，则可以通过调用此方法来实现。
         * 例如，当鼠标持续按住滚动条之外的某个按钮对象时，调用了该方法，然后进行滑动，也可以实现按住滚动条对象滑动的效果。
         */
        startDragForce(): void;
        private cancelDragOp;
        /**
         * @en Function to be called when the scrollbar is dragged down past its limit.
         * @zh 当滚动条向下拖拽超过其限制时调用的函数。
         */
        triggerDownDragLimit: Function;
        /**
         * @en Function to be called when the scrollbar is dragged up past its limit.
         * @zh 当滚动条向上拖拽超过其限制时调用的函数。
         */
        triggerUpDragLimit: Function;
        /**
         * @en Overloading method for pausing scrolling
         * @zh 暂停滚动的重载方法
         */
        stopMoveLimit: Function;
        private checkTriggers;
        /**
         * @en Gets the last offset value used during the scrollbar's movement.
         * @zh 获取滚动条在移动过程中使用的最后偏移量。
         */
        get lastOffset(): number;
        /**
         * @en Starts a forced tweening (animated) movement for the scrollbar.
         * @param lastOffset The offset to start the tweening movement from.
         * @zh 滚动条的强制缓动移动。
         * @param lastOffset 从该偏移量位置开始缓动移动。
         */
        startTweenMoveForce(lastOffset: number): void;
        protected loop(): void;
        protected onStageMouseUp2(e: Event): void;
        private elasticOver;
        protected tweenMove(maxDistance: number): void;
        /**
         * @en Stops the scrolling action.
         * @zh 停止滑动。
         */
        stopScroll(): void;
        /**
         * @en The minimum increment unit for the slider tick value, with a default value of 1.
         * @zh 滑动条刻度值的最小变动单位，默认值为1。
         */
        get tick(): number;
        set tick(value: number);
        /**
         * @en Restores the scrollbar to its normal elastic bounce-back motion.
         * @zh 恢复到正常的弹性缓动效果。
         */
        backToNormal(): void;
        private _backToNormal;
    }
    /**
     * @en The Slider control allows users to select a value by moving a slider between the end points of the track.
     * The current value of the slider is determined by the relative position of the slider between the end points of the slider (corresponding to the minimum and maximum values of the slider).
     * The slider allows values at specific intervals between the minimum and maximum values. The slider can also display its current value using a data tip.
     * - `changed` event is dispatched when the movement of the slider is completed (when the user releases the mouse).
     * - `change` event is dispatched when the movement of the slider.
     * @zh 使用 Slider 控件，用户可以通过在滑块轨道的终点之间移动滑块来选择值。
     * 滑块的当前值由滑块端点（对应于滑块的最小值和最大值）之间滑块的相对位置确定。
     * 滑块允许最小值和最大值之间特定间隔内的值。滑块还可以使用数据提示显示其当前值。
     * - `changed`事件用于移动滑块位置完成（用户鼠标抬起）后调度。
     * - `change`事件用于移动滑块位置时调度。
     */
    class Slider extends UIComponent {
        /**
         * @en Get a reference to the Label component contained within the Slider component.
         * @zh 获取 Slider 组件所包含的 Label 组件的引用。
         */
        static label: Label;
        /**
         * @en Data change handler.
         * The default callback parameter is the slider position property value: Number.
         * @zh 数据变化处理器。
         * 默认回调参数为滑块位置属性 value 的属性值：Number。
         */
        changeHandler: Handler;
        /**
         * @en Whether it is vertical sliding. The default value is true, indicating vertical direction; false indicates horizontal direction.
         * @zh 是否为垂直滑动。默认值为true，表示垂直方向，false为水平方向。
         */
        isVertical: boolean;
        /**
         * @en A Boolean value that indicates whether to display labels.defalut value is true.
         * @zh 是否显示标签。默认值为true。
         */
        showLabel: boolean;
        /**
         * @en A Boolean value that indicates whether to display the progress bar.
         * @zh 是否显示进度条。
         */
        protected _showProgress: boolean;
        protected _allowClickBack: boolean;
        protected _max: number;
        protected _min: number;
        protected _tick: number;
        protected _value: number;
        protected _skin: string;
        protected _bg: Image;
        protected _progress: Image;
        protected _bar: Button;
        protected _tx: number;
        protected _ty: number;
        protected _maxMove: number;
        protected _globalSacle: Point;
        /**
         * @en Creates an instance of Slider.
         * @param skin The skin.
         * @zh 创建一个Silder实例。
         * @param skin 皮肤纹理。
         */
        constructor(skin?: string);
        destroy(destroyChild?: boolean): void;
        protected createChildren(): void;
        protected initialize(): void;
        protected onBarMouseDown(e: Event): void;
        protected showValueText(): void;
        protected hideValueText(): void;
        private mouseUp;
        private mouseMove;
        protected sendChangeEvent(type?: string): void;
        /**
         * @en The skin of the slider.
         * @zh 滑块的皮肤纹理。
         */
        get skin(): string;
        set skin(value: string);
        /**
         * @en A Boolean value that indicates whether to display the progress bar.
         * @zh 是否显示进度条。
         */
        get showProgress(): boolean;
        set showProgress(value: boolean);
        /** @ignore */
        _setSkin(url: string): Promise<void>;
        protected _skinLoaded(): void;
        /**
         * @en Set the position information of the slider.
         * @zh 设置滑块的位置信息。
         */
        protected setBarPoint(): void;
        protected measureWidth(): number;
        protected measureHeight(): number;
        protected _sizeChanged(): void;
        /**
          * @en The size grid of the texture.
          * The size grid is a 3x3 division of the texture, allowing it to be scaled without distorting the corners and edges.
          * The array contains five values representing the top, right, bottom, and left margins, and whether to repeat the fill (0: no repeat, 1: repeat).
          * The values are separated by commas. For example: "6,6,6,6,1".
          * @zh 纹理的九宫格数据。
          * 九宫格是一种将纹理分成3x3格的方式，使得纹理缩放时保持角和边缘不失真。
          * 数组包含五个值，分别代表上边距、右边距、下边距、左边距以及是否重复填充（0：不重复填充，1：重复填充）。
          * 值以逗号分隔。例如："6,6,6,6,1"。
          */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * @en Set the information of the slider.
         * @param min The minimum value of the slider.
         * @param max The maximum value of the slider.
         * @param value The current value of the slider.
         * @zh 设置滑动条的信息。
         * @param min 滑块的最小值。
         * @param max 滑块的最大值。
         * @param value 滑块的当前值。
         */
        setSlider(min: number, max: number, value?: number): void;
        /**
         * @en The minimum increment unit for each change in the slider tick value. The default value is 1.
         * @zh 滑滑动条刻度值每次最小变动的单位。默认值为1
         */
        get tick(): number;
        set tick(value: number);
        /**
         * @en Change the position value of the slider.
         * @zh 改变滑块的位置值。
         */
        changeValue(): void;
        /**
         * @en The number indicating the highest position of slider. The default value is 100.
         * @zh 滑动条最高位置的数字。默认值为 100。
         */
        get max(): number;
        set max(value: number);
        /**
         * @en The number indicating the lowest position of slider. The default value is 0.
         * @zh 滑动条最低位置的数字。默认值为 0。
         */
        get min(): number;
        set min(value: number);
        /**
         * @en The number indicating the current slider position.
         * @zh 滑动条当前滑块位置的数字。
         */
        get value(): number;
        set value(num: number);
        /**
         * @en A Boolean value that specifies whether to allow changing the value property of the Slider by clicking the slider.
         * @zh 是否允许通过点击滑动条改变 Slider 的 value 属性值。
         */
        get allowClickBack(): boolean;
        set allowClickBack(value: boolean);
        /**
         * @en The Event.MOUSE_DOWN event handler of the slider.
         * @zh 滑动条的 Event.MOUSE_DOWN 事件侦听处理函数。
         */
        protected onBgMouseDown(e: Event): void;
        set_dataSource(value: any): void;
        /**
         * @en The reference of the slider button.
         * @zh 滑块按钮的引用。
         */
        get bar(): Button;
    }
    class StatUI implements IStatUI {
        private _txt;
        private _sp;
        private _view;
        private _toggleView;
        private _toggleSprite;
        private _checkBoxArray;
        private _show;
        private _showToggle;
        private createUI;
        private createToggleUI;
        /**
         * @en Display the performance statistics.
         * @param x The X-axis display position.
         * @param y The Y-axis display position.
         * @param views The UI parameter array for displaying statistics.
         * @zh 显示性能统计信息。
         * @param x X轴显示位置。
         * @param y Y轴显示位置。
         * @param views 用于显示统计信息的UI参数数组。
         */
        show(x?: number, y?: number, views?: Array<StatUIParams>): void;
        /**
         * @en Display the toggle UI for performance statistics.
         * @param x The X-axis display position.
         * @param y The Y-axis display position.
         * @param views The toggle UI parameter array for displaying statistics.
         * @zh 显示性能统计的切换UI。
         * @param x X轴显示位置。
         * @param y Y轴显示位置。
         * @param views 用于显示统计信息的切换UI参数数组。
         */
        showToggle(x?: number, y?: number, views?: Array<StatToggleUIParams>): void;
        /**
         * @en Hides performance statistics.
         * @zh 隐藏性能统计信息。
         */
        hide(): void;
        /**
         * @en Update the performance statistics.
         * @zh 更新性能统计信息。
         */
        update(): void;
        /**
         * @en Render the performance statistics.
         * @param ctx The rendering context.
         * @param x The X-axis render position.
         * @param y The Y-axis render position.
         * @zh 渲染性能统计信息。
         * @param ctx 渲染上下文。
         * @param x X轴显示位置。
         * @param y Y轴显示位置。
         */
        render(ctx: any, x: number, y: number): void;
    }
    /**
     * @en The `Styles` class defines common style properties used by components.
     * @zh Styles 定义了组件常用的样式属性。
     */
    class Styles {
        /**
         * @en Default nine-slice grid information.
         * @zh 默认九宫格信息。
         */
        static defaultSizeGrid: any[];
        /**
         * @en The color of the label text.
         * @zh 标签颜色。
         */
        static labelColor: string;
        /**
         * @en The padding of the label, in pixels. Defined as [top, right, bottom, left].
         * @zh 标签的边距，格式为 [上边距，右边距，下边距，左边距]。
         */
        static labelPadding: any[];
        /**
         * @en The padding of the input label, in pixels. Defined as [top, right, bottom, left].
         * @zh 输入框标签的边距，格式为 [上边距，右边距，下边距，左边距]。
         */
        static inputLabelPadding: any[];
        /**
         * @en The number of state skins for a button, which supports 1, 2, or 3 states values.
         * @zh 按钮皮肤的状态数，支持1,2,3三种状态值。
         */
        static buttonStateNum: number;
        /**
         * @en The colors of the button label. Defined as [upColor, overColor, downColor].
         * @zh 按钮标签颜色，格式为 [upColor, overColor, downColor]。
         */
        static buttonLabelColors: any[];
        /**
         * @en The colors of the combo box. Defined as [overBgColor, overLabelColor, outLabelColor, borderColor, bgColor].
         * @zh 下拉框项颜色，格式为 [overBgColor, overLabelColor, outLabelColor, borderColor, bgColor]。
         */
        static comboBoxItemColors: any[];
        /**
         * @en The minimum size of the scrollbar thumb, in pixels.
         * @zh 滚动条的最小值。
         */
        static scrollBarMinNum: number;
        /**
         * @en The delay time before initiating continuous scrolling when a button is held down.
         * @zh 长按按钮后，等待时间使其可激活连续滚动。
         */
        static scrollBarDelayTime: number;
    }
    enum ScrollType {
        None = 0,
        Horizontal = 1,
        Vertical = 2,
        Both = 3
    }
    /**
     * @en The Tab component is used to define tab button groups.
     * The default value of ths property selectedIndex is -1.
     * @zh Tab 组件用来定义选项卡按钮组。
     * 属性selectedIndex 的默认值为-1。
     */
    class Tab extends UIGroup {
        constructor();
        protected createItem(skin: string, label: string): Sprite;
    }
    /**
     * @en The TextArea class is used to create a multi-line text area display object for displaying and inputting text.
     * @zh TextArea 类用于创建多行的文本域显示对象，以显示和输入文本。
     */
    class TextArea extends TextInput {
        protected _scrollType: ScrollType;
        protected _vScrollBarSkin: string;
        protected _hScrollBarSkin: string;
        protected _vScrollBar: VScrollBar;
        protected _hScrollBar: HScrollBar;
        /**
         * @en Scroll bar type. The range of values is 0-3.
         * - ScrollType.None(0): Does not display any scrollbars
         * - ScrollType.Horizontal(1):Displays only the horizontal scrollbar
         * - ScrollType.Vertical(2): Displays only the vertical scrollbar
         * - ScrollType.Both(3):  Displays both horizontal and vertical scrollbars
         * @zh 滚动条类型。取值范围0-3。
         * - ScrollType.None(0): 不显示任何滚动条
         * - ScrollType.Horizontal(1): 仅显示水平滚动条
         * - ScrollType.Vertical(2): 仅显示垂直滚动条
         * - ScrollType.Both(3): 同时显示水平和垂直滚动条
         */
        get scrollType(): ScrollType;
        set scrollType(value: ScrollType);
        /**
         * @en The vertical scrollbar instance.
         * @zh 垂直滚动条实例。
         */
        get vScrollBar(): VScrollBar;
        /**
         * @en The horizontal scrollbar instance.
         * @zh 水平滚动条实例。
         */
        get hScrollBar(): HScrollBar;
        /**
         * @en The maximum vertical scroll value.
         * @zh 最大垂直滚动值。
         */
        get maxScrollY(): number;
        /**
         * @en The vertical scroll position.
         * @zh 垂直滚动位置。
         */
        get scrollY(): number;
        /**
         * @en The maximum horizontal scroll value.
         * @zh 最大水平滚动值。
         */
        get maxScrollX(): number;
        /**
         * @en The horizontal scroll position.
         * @zh 当前的水平滚动位置。
         */
        get scrollX(): number;
        /**
         * @en The skin for the vertical scrollbar.
         * @zh 垂直方向滚动条的皮肤 。
         */
        get vScrollBarSkin(): string;
        set vScrollBarSkin(value: string);
        /**
         * @en The skin for the horizontal scrollbar.
         * @zh 水平方向滚动条的皮肤。
         */
        get hScrollBarSkin(): string;
        set hScrollBarSkin(value: string);
        /**
         * @en Creates an instance of TextArea.
         * @param text Text content string.
         * @zh 创建一个TextArea实例。
         * @param text 文本内容字符串。
         */
        constructor(text?: string);
        protected _onPostLayout(): void;
        protected initialize(): void;
        private createHScrollBar;
        private createVScrollBar;
        protected onVBarChanged(e: Event): void;
        protected onHBarChanged(e: Event): void;
        private changeScroll;
        /**
         * @en Scroll to a certain position
         * @zh 滚动到某个位置。
         */
        scrollTo(y: number): void;
        /**
         * @en Destroys the instance.
         * @param destroyChild Whether to destroy child elements as well. Defaults to true.
         * @zh 销毁实例。
         * @param destroyChild 是否同时销毁子元素，默认为 true。
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * @en The TextInput class is used to create an input text display object.
     * - Event.INPUT event: When the input text after dispatching.
     * - Event.ENTER event: When the input box presses enter key after dispatching.
     * - Event.FOCUS event: When the input box gets focus.
     * - Event.BLUR event: When the input box loses focus.
     * @zh TextInput类用于创建输入文本显示对象。
     * - Event.INPUT事件：当输入文本后调度。
     * - Event.ENTER事件：当输入框内敲回车键后调度。
     * - Event.FOCUS事件：当输入框获得焦点时调度。
     * - Event.BLUR事件：当输入框失去焦点时调度。
     */
    class TextInput extends Label {
        protected _skin: string;
        /**
         * @en The URL of the skin for the TextInput UIComponent.
         * @zh TextInput组件的皮肤地址。
         */
        get skin(): string;
        set skin(value: string);
        /**
          * @en The size grid of the texture.
          * The size grid is a 3x3 division of the texture, allowing it to be scaled without distorting the corners and edges.
          * The array contains five values representing the top, right, bottom, and left margins, and whether to repeat the fill (0: no repeat, 1: repeat).
          * The values are separated by commas. For example: "6,6,6,6,1".
          * @zh 纹理的九宫格数据。
          * 九宫格是一种将纹理分成3x3格的方式，使得纹理缩放时保持角和边缘不失真。
          * 数组包含五个值，分别代表上边距、右边距、下边距、左边距以及是否重复填充（0：不重复填充，1：重复填充）。
          * 值以逗号分隔。例如："6,6,6,6,1"。
          */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * @en Whether it is a text area.
         * True means it is a text area, otherwise it is not.
         * @zh 是否是文本域。
         * 值为true表示当前是文本域，否则不是文本域。
         */
        get multiline(): boolean;
        set multiline(value: boolean);
        /**
         * @en whether it is editable.
         * @zh 是否可编辑。
         */
        get editable(): boolean;
        set editable(value: boolean);
        /**
         * @en The pattern that restricts the input.
         * @zh 限制输入的字符。
         */
        get restrict(): string;
        set restrict(pattern: string);
        /**
         * @en The prompt text of the input.
         * @zh 输入框的提示文本。
         */
        get prompt(): string;
        set prompt(value: string);
        /**
         * @en The prompt color of the input.
         * @zh 输入框的提示文字颜色。
         */
        get promptColor(): string;
        set promptColor(value: string);
        /**
         * @en The maximum number of characters allowed in the input.
         * @zh 输入框允许的最大字符数。
         */
        get maxChars(): number;
        set maxChars(value: number);
        /**
         * @en The focus state of the input.
         * @zh 输入框的焦点状态。
         */
        get focus(): boolean;
        set focus(value: boolean);
        /**
         * @en The type of the input box. Refer to the HTML5 input tag for types.
         * Common types include:
         * - text
         * - password
         * - email
         * - number
         * - date
         * - time
         * @zh 输入框的类型。可参照HTML5的input标签。
         * 常用标签例如：
         * - text
         * - password
         * - email
         * - number
         * - date
         * - time
         */
        get type(): string;
        set type(value: string);
        /**
         * @en Constructor method
         * @param text Text content.
         * @zh 构造方法
         * @param text 文本内容。
         */
        constructor(text?: string);
        protected _skinLoaded(source: any): void;
        protected preinitialize(): void;
        protected createChildren(): void;
        protected initialize(): void;
        /**
         * @en Select the text in the input box
         * @zh 选中输入框内的文本。
         */
        select(): void;
        /**
         * @en Sets the start and end index of the selected text within the input field.
         * @param startIndex The index of the first selected character.
         * @param endIndex The index of the character following the last selected character.
         * @zh 在输入字段内设置选中文本的起始和结束索引。
         * @param startIndex 选中文本的光标起始位置。
         * @param endIndex 选中文本的光标结束位置。
         */
        setSelection(startIndex: number, endIndex: number): void;
    }
    /**
     * @en Mouse Tip Management Class
     * @zh 鼠标提示管理类
     */
    class TipManager extends UIComponent {
        /**
         * @en X-axis offset of the tooltip
         * @zh 提示框X轴偏移量
         */
        static offsetX: number;
        /**
         * @en Y-axis offset of the tooltip
         * @zh 提示框Y轴偏移量
         */
        static offsetY: number;
        /**
         * @en Text color of the tooltip
         * @zh 提示文本颜色
         */
        static tipTextColor: string;
        /**
         * @en Background color of the tooltip
         * @zh 提示框背景颜色
         */
        static tipBackColor: string;
        /**
         * @en Delay before showing the tooltip
         * @zh 显示提示框前的延迟时间
         */
        static tipDelay: number;
        private _tipBox;
        private _tipText;
        private _defaultTipHandler;
        /**
         * @en Default mouse prompt function
         * @zh 默认鼠标提示函数
         */
        get defaultTipHandler(): Function;
        set defaultTipHandler(value: Function);
        /** @ignore */
        constructor();
        private _onStageHideTip;
        private _onStageShowTip;
        private _showTip;
        private _onStageMouseDown;
        private _onStageMouseMove;
        private _showToStage;
        private _showDefaultTip;
        /**
         * @en Closes all tooltips and removes event listeners related to mouse actions.
         * @zh 关闭所有鼠标提示并移除与鼠标动作相关的事件监听器。
         */
        closeAll(): void;
        /**
         * @en Displays a tooltip Sprite on the stage.
         * @param tip The Sprite object to be displayed as a tooltip.
         * @zh 显示对象提示条的显示。
         * @param tip 要显示的提示条精灵对象。
         */
        showDislayTip(tip: Sprite): void;
    }
    /**
     * @en The `Tree` UI component allows users to view hierarchical data arranged in an expandable tree format.
     * @zh `Tree` UI组件使用户可以查看排列为可扩展树的层次结构数据。
     */
    class Tree extends Box {
        protected _list: List;
        protected _source: any[];
        protected _renderHandler: Handler;
        protected _spaceLeft: number;
        protected _spaceBottom: number;
        protected _keepStatus: boolean;
        /**
         * @en Determines whether to maintain the previous open state after the data source changes. The default value is true.
         * - true: Maintain the previous open state.
         * - false: Do not maintain the previous open state.
         * @zh 数据源发生变化后，是否保持之前打开状态，默认为true。
         * - true：保持之前打开状态。
         * - false：不保持之前打开状态。
         */
        get keepStatus(): boolean;
        set keepStatus(value: boolean);
        /**
         * @en The list data source, including only the data of currently visible nodes.
         * @zh 列表数据源，只包含当前可视节点数据。
         */
        get array(): any[];
        set array(value: any[]);
        /**
         * @en The data source containing all node data.
         * @zh 数据源，全部节点数据。
         */
        get source(): any[];
        /**
         * @en The `List` instance contained within this object.
         * @zh 此对象包含的 `List` 实例对象。
         */
        get list(): List;
        /**
         * @en The cell renderer for the List instance contained in this object.
         * Possible values:
         * Cell class object.
         * JSON description of the UI.
         * @zh 此对象包含的List实例的单元格渲染器。
         * 取值：
         * 单元格类对象。
         *  UI 的 JSON 描述。
         */
        get itemRender(): any;
        set itemRender(value: any);
        /**
         * @en The skin of the scroll bar.
         * @zh 滚动条皮肤。
         */
        get scrollBarSkin(): string;
        set scrollBarSkin(value: string);
        /**
         * @en The scroll bar.
         * @zh 滚动条。
         */
        get scrollBar(): ScrollBar;
        /**
         * @en Handler for cell mouse events. Default returns parameters (e:Event,index:int).
         * @zh 单元格鼠标事件处理器。默认返回参数（e:Event,index:int）。
         */
        get mouseHandler(): Handler;
        set mouseHandler(value: Handler);
        /**
         * @en The render handler for the `Tree` instance.
         * @zh `Tree` 实例的渲染处理器。
         */
        get renderHandler(): Handler;
        set renderHandler(value: Handler);
        /**
         * @en The left indentation distance in pixels.
         * @zh 左侧缩进距离（以像素为单位）。
         */
        get spaceLeft(): number;
        set spaceLeft(value: number);
        /**
         * @en The space between each item in pixels.
         * @zh 每一项之间的间隔距离（以像素为单位）。
         */
        get spaceBottom(): number;
        set spaceBottom(value: number);
        /**
         * @en The index of the currently selected item.
         * @zh 表示当前选择的项索引。
         */
        get selectedIndex(): number;
        set selectedIndex(value: number);
        /**
         * @en The data source of the currently selected item.
         * @zh 当前选中的项对象的数据源。
         */
        get selectedItem(): any;
        set selectedItem(value: any);
        /**
         * @en The data source in XML structure.
         * @zh XML 结构的数据源。
         */
        set xml(value: XML);
        /**
         * @en The value of the `path` property of the selected tree node item.
         * @zh 表示选择的树节点项的 `path` 属性值。
         */
        get selectedPath(): string;
        /**
         * @en Creats an instance of `Tree`.
         * The `width` and `height` properties are both set to 200 in the `Tree` constructor.
         * @zh 创建一个 `Tree` 实例。
         * 在`Tree`构造函数中设置属性width、height的值默认都为200。
         */
        constructor();
        protected createChildren(): void;
        /**
         * @en this object contains the List instance's Event.CHANGE event listener function.
         * @zh 此对象包含的List实例的Event.CHANGE事件侦听处理函数。
         */
        protected onListChange(e?: Event): void;
        /**
         * @en Get the data source collection.
         * @zh 获取数据源集合。
         */
        protected getArray(): any[];
        /**
         * @en Get item object's depth.
         * @zh 获取项对象的深度。
         */
        protected getDepth(item: any, num?: number): number;
        /**
         * @en Get item object's parent open status.
         * @zh 获取项对象的上一级的打开状态。
         */
        protected getParentOpenStatus(item: any): boolean;
        /**
         * @en Renders a item object.
         * @param cell a item object.
         * @param index item's index.
         * @zh 渲染一个项对象。
         * @param cell 一个项对象。
         * @param index 项的索引。
         */
        protected renderItem(cell: Box, index: number): void;
        private onArrowClick;
        /**
         * @en parse data source of XML type.
         * @zh 解析并处理XML类型的数据源。
         */
        protected parseXml(xml: XML, source: any[], nodeParent: any, isRoot: boolean): void;
        /**
         * @en Handle the open state of the data items.
         * @zh 处理数据项的打开状态。
         */
        protected parseOpenStatus(oldSource: any[], newSource: any[]): void;
        /**
         * @en Determine whether the two item objects have the same parent node in the tree structure.
         * @param item1 Item object.
         * @param item2 Item object.
         * @returns If the parent node is the same, the value of true. Otherwise, false.
         * @zh 判断两个项对象在树结构中的父节点是否相同。
         * @param item1 项对象。
         * @param item2 项对象。
         * @returns 如果父节点相同值为true，否则值为false。
         */
        protected isSameParent(item1: any, item2: any): boolean;
        /**
         * @en Retrieve the value of a specified key from the data source.
         * @zh 获取数据源中指定键名的值。
         */
        private getFilterSource;
        /**
         * @en Set the open state of an item object by index.
         * @param index The item index.
         * @param isOpen Whether the item is open.
         * @zh 设置指定项索引的项对象的打开状态。
         * @param index 项索引。
         * @param isOpen 是否处于打开状态。
         */
        setItemState(index: number, isOpen: boolean): void;
        /**
         * @en Refresh the list.
         * @zh 刷新项列表。
         */
        fresh(): void;
        /**
         * @en Set the data source.
         * @param value The data source.
         * @zh 设置数据源。
         * @param value The data source.
         */
        set_dataSource(value: any): void;
        /**
         * @en Update the list to show items with the specified key name.
         * @param key The key name.
         * @zh 更新项列表，显示指定键名的数据项。
         * @param key 键名。
         */
        filter(key: string): void;
        /**
         * @en Destroy the object.
         * @param destroyChild Whether to destroy the child objects as well.
         * @zh 销毁对象。
         * @param destroyChild 是否销毁子对象。
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * @en UIComponent is the base class of UI Component.
     * Life cycle: preinitialize > createChildren > initialize > constructor of component
     * @zh UIComponent 是UI组件类的基类。
     * 生命周期：preinitialize > createChildren > initialize > 组件构造函数
     */
    class UIComponent extends Sprite {
        /**
         * @en The data source of the UIComponent.
         * @zh UI组件的数据源。
         */
        protected _dataSource: any;
        /**
         * @en Mouse hover prompt
         * @zh 鼠标悬停提示
         */
        protected _toolTip: any;
        /**
         * @en Disabled
         * @zh 禁用
         */
        protected _disabled: boolean;
        /**
         * @en Grayed out
         * @zh 变灰
         */
        protected _gray: boolean;
        /**
         * @en Relative layout component
         * @zh 相对布局组件
         */
        protected _widget: Widget;
        /**
        * @en The vertical distance in pixels from the top edge of the component to the top edge of its parent.
        * This property is used for relative layout, which means the component's position is always relative to its parent's top edge.
        * @zh 组件顶边距离父节点顶边的垂直距离（以像素为单位）。
        * 此属性用于相对布局,意味着组件的位置始终相对于父节点的顶部边缘。
        */
        get top(): number;
        set top(value: number);
        /**
         * @en The vertical distance in pixels from the bottom edge of the component to the bottom edge of its parent.
         * This property is used for relative layout, which means the component's position is always relative to its parent's bottom edge.
         * @zh 组件底边距离父节点底边的垂直距离（以像素为单位）。
         * 此属性用于相对布局,意味着组件的位置始终相对于父节点的底部边缘。
         */
        get bottom(): number;
        set bottom(value: number);
        /**
         * @en The horizontal distance in pixels from the left edge of the component to the left edge of its parent.
         * This property is used for relative layout, which means the component's position is always relative to its parent's left edge.
         * @zh 组件左边距离父节点左边的水平距离（以像素为单位）。
         * 此属性用于相对布局,意味着组件的位置始终相对于父节点的左侧边缘。
         */
        get left(): number;
        set left(value: number);
        /**
         * @en The horizontal distance in pixels from the right edge of the component to the right edge of its parent.
         * This property is used for relative layout, which means the component's position is always relative to its parent's right edge.
         * @zh 组件右边距离父节点右边的水平距离（以像素为单位）。
         * 此属性用于相对布局,意味着组件的位置始终相对于父节点的右侧边缘。
         */
        get right(): number;
        set right(value: number);
        /**
         * @en The distance in pixels from the center axis of this object in the horizontal direction to the center line of the parent container in the horizontal direction.
         * @zh 在父容器中，此对象的水平方向中轴线与父容器的水平方向中心线的距离（以像素为单位）。
         */
        get centerX(): number;
        set centerX(value: number);
        /**
         * @en The distance in pixels from the center axis of this object in the vertical direction to the center line of the parent container in the vertical direction.
         * @zh 在父容器中，此对象的垂直方向中轴线与父容器的垂直方向中心线的距离（以像素为单位）。
         */
        get centerY(): number;
        set centerY(value: number);
        /**
         * @en Data assignment, control UI display logic by assigning UI.
         * Simple assignment will change the default properties of the component, and curly braces can be used to assign any property of the component.
         * @zh 数据源赋值，通过对UI赋值来控制UI显示逻辑。
         * 简单赋值会更改组件的默认属性，使用大括号可以指定组件的任意属性进行赋值。
         * @example
           //Default property assignment
           dataSource = {label1: "Label changed", checkbox1: true};//(Change the text property value of label1, change the selected property of checkbox1).
           //Any property assignment
           dataSource = {label2: {text:"Label changed",size:14}, checkbox2: {selected:true,x:10}};
         */
        get dataSource(): any;
        set dataSource(value: any);
        /**
         * @en Mouse hover prompt.
         * It can be assigned as text `String` or function `Handler` to implement custom style mouse prompts and parameter carrying, etc.
         * @zh 鼠标悬停提示。
         * 可以赋值为文本`String`或函数`Handler`，用来实现自定义样式的鼠标提示和参数携带等。
         * @example
         * private var _testTips:TestTipsUI = new TestTipsUI();
         * private function testTips():void {
           //Simple mouse prompt
         * btn2.toolTip = "This is a mouse tip&lt;b&gt;Bold&lt;/b&gt;&lt;br&gt;New line";
           //Custom mouse prompt
         * btn1.toolTip = showTips1;
           //Custom mouse prompt with parameters
         * clip.toolTip = new Handler(this,showTips2, ["clip"]);
         * }
         * private function showTips1():void {
         * _testTips.label.text = "This is button[" + btn1.label + "]";
         * tip.addChild(_testTips);
         * }
         * private function showTips2(name:String):void {
         * _testTips.label.text = "This is " + name;
         * tip.addChild(_testTips);
         * }
         */
        get toolTip(): any;
        set toolTip(value: any);
        /**
         * @en Whether it is grayed out.
         * @zh 是否变灰。
         */
        get gray(): boolean;
        set gray(value: boolean);
        /**
         * @en Whether the page is disabled, it will turn gray and disable the mouse when set to true.
         * @zh 是否禁用页面，设置为true后，会变灰并且禁用鼠标。
         */
        get disabled(): boolean;
        set disabled(value: boolean);
        /**
         * @en The constructor function that is called when creating a new instance of the UIComponent.
         * It calls a series of initialization methods in sequence. Subclasses inheriting from this class can override these methods directly to implement their own initialization logic.
         * If these initialization methods are not needed, `createChildren` can be set to `false` to skip them and reduce unnecessary overhead.
         * @param createChildren Whether to execute the initialization methods, default is true.
         * @zh 创建UI组件新实例时调用的构造函数。
         * 它将依次调用一系列初始化方法。继承该类的子类可以直接重写这些方法,实现自己的初始化逻辑。
         * 如果不需要这些初始化方法,可以将 `createChildren` 设置为 `false`,以跳过它们并减少不必要的开销。
         * @param createChildren 是否执行子对象初始化方法,默认为 true。
         */
        constructor(createChildren?: boolean);
        /**
         * @en Called when the layout should be refreshed.
         * This method will call the `_sizeChanged` method later to perform the actual layout refresh.
         * @zh 当需要刷新布局时调用。
         * 这个方法会在稍后调用 `_sizeChanged` 方法来执行实际的布局刷新。
         */
        protected _shouldRefreshLayout(): void;
        /**
         * @en Callback function when the component size changes.
         * @zh 组件尺寸变化时的回调函数。
         */
        protected _sizeChanged(): void;
        /**
        * @en Callback when a child node changes.
        * @param child The child node that has changed.
        * @zh 子节点发生变化时的回调。
        * @param child 发生变化的子节点。
        */
        protected _childChanged(child?: Node): void;
        /**
         * @en Get the layout style of the object. Please do not modify this object directly.
         * @zh 获取对象的布局样式。请不要直接修改此对象。
         */
        private _getWidget;
        /**
         * @en Pre-initialization.
         * Subclasses can set and modify default property values in this function.
         * @zh 预初始化。
         * 子类可在此函数内设置、修改属性默认值。
         */
        protected preinitialize(): void;
        /**
         * @en Create and add UIComponent child nodes.
         * Subclasses can create and add child nodes in this function.
         * @zh 创建并添加UI组件的子节点。
         * 子类可在此函数内创建并添加子节点。
         */
        protected createChildren(): void;
        /**
         * @en UIComponent initialization.
         * Child objects have been created at this point and can be modified.
         * @zh UI组件初始化。
         * 在此子对象已被创建，可以对子对象进行修改。
         */
        protected initialize(): void;
        /**
         * @en The actual display area width of the object (in pixels).
         * @zh 显示对象的实际显示区域宽度（以像素为单位）。
         */
        protected measureWidth(): number;
        /**
         * @en Immediately execute the delayed call function that affects the width and height measurement.
         * Use the 'runCallLater' function to immediately execute the delayed running function that affects the width and height measurement (set using 'callLater').
         * @zh 立即执行影响宽高度量的延迟调用函数。
         * 使用 'runCallLater' 函数，立即执行影响宽高度量的延迟运行函数(使用 'callLater' 设置延迟执行函数)。
         */
        protected commitMeasure(): void;
        /**
         * @en The actual display area height of the object (in pixels).
         * @zh 显示对象的实际显示区域高度（以像素为单位）。
         */
        protected measureHeight(): number;
        /**
         * @en The event handler for the 'Event.MOUSE_OVER' event, triggered when the mouse enters the component (the node object to which the component belongs).
         * When the 'toolTip' property is set, this method is invoked to dispatch the 'UIEvent.SHOW_TIP' event with the '_toolTip' property as the parameter.
         * @param e The event object.
         * @zh 'Event.MOUSE_OVER' 事件的事件处理程序,在鼠标进入组件(组件所属的节点对象)时触发。
         * 当 'toolTip' 属性被设置时,该方法会被调用以派发 'UIEvent.SHOW_TIP' 事件,并将 '_toolTip' 属性作为参数传递。
         * @param e 事件对象。
         */
        private onMouseOver;
        /**
         * @en The event handler for the 'Event.MOUSE_OUT' event, triggered when the mouse leaves the component (the node object to which the component belongs).
         * When the 'toolTip' property is set, this method is invoked to dispatch the 'UIEvent.HIDE_TIP' event with the '_toolTip' property as the parameter.
         * @param e The event object.
         * @zh 'Event.MOUSE_OUT' 事件的事件处理程序,在鼠标离开组件(组件所属的节点对象)时触发。
         * 当 'toolTip' 属性被设置时,该方法会被调用以派发 'UIEvent.HIDE_TIP' 事件,并将 '_toolTip' 属性作为参数传递。
         * @param e 事件对象。
         */
        private onMouseOut;
        /**
         * @en The method to be invoked when the component is resized.
         * It handles the logic for when the component's size changes.
         * @zh 组件大小调整时调用的方法。
         * 它处理组件大小发生变化时的逻辑。
         */
        protected onCompResize(): void;
        /**
         * @en Get the width of the object.
         * @zh 获取对象的宽度。
         */
        get_width(): number;
        /**
         * @en Get the height of the object.
         * @zh 获取对象的高度。
         */
        get_height(): number;
        /**
         * @en Get the top margin of the object.
         * @zh 获取对象的上边距。
         */
        get_top(): number;
        /**
         * @en Set the top margin of the object.
         * @param value The top margin value.
         * @zh 设置对象的上边距。
         * @param value 上边距的值。
         */
        set_top(value: number): void;
        /**
         * @en Get the bottom margin of the object.
         * @zh 获取对象的下边距。
         */
        get_bottom(): number;
        /**
         * @en Set the bottom margin of the object.
         * @param value The bottom margin value.
         * @zh 设置对象的下边距。
         * @param value 下边距的值。
         */
        set_bottom(value: number): void;
        /**
         * @en Get the data source of the object.
         * @zh 获取对象的数据源。
         */
        get_dataSource(): any;
        /**
         * @en Set the data source of the object.
         * @param value The data source.
         * @zh 设置对象的数据源。
         * @param value 数据源。
         */
        set_dataSource(value: any): void;
        /**
         * @en Recalculate and update the layout of the object.
         * This method will reset the horizontal and vertical layout of the object based on the `_widget` property.
         * It will calculate the position and size of the object according to the layout rules specified by the `_widget` property,
         * such as `left`, `right`, `top`, `bottom`, `centerX`, and `centerY`.
         * @zh 重新计算并更新对象的布局。
         * 这个方法将根据 `_widget` 属性重置对象的水平和垂直布局。
         * 它会根据 `_widget` 属性指定的布局规则,如 `left`、`right`、`top`、`bottom`、`centerX` 和 `centerY`,计算对象的位置和大小。
         */
        freshLayout(): void;
        /**
         * @en Destroy the object.
         * @param destroyChild Whether to destroy child nodes, default is true.
         * @zh 销毁对象。
         * @param destroyChild 是否销毁子节点,默认为 true。
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * @en The UIEvent class is used to define the event types of UI component classes.
     * @zh UIEvent 类用来定义UI组件类的事件类型。
     */
    class UIEvent {
        /**
         * @en Display prompt information.
         * @zh 显示提示信息。
         */
        static SHOW_TIP: string;
        /**
         * @en Hide prompt information.
         * @zh 隐藏提示信息。
         */
        static HIDE_TIP: string;
    }
    /**
     * @en UIGroup is an item collection control that can be automatically laid out.
     * The default item object for UIGroup is a Button class instance.
     * UIGroup is the base class for Tab and RadioGroup.
     * @zh UIGroup 是一个可以自动布局的项集合控件。
     * UIGroup 的默认项对象为 Button 类实例。
     * UIGroup是 Tab 和 RadioGroup 的基类。
     */
    class UIGroup extends Box {
        protected _items: ISelect[];
        protected _selectedIndex: number;
        protected _skin: string;
        protected _direction: string;
        protected _space: number;
        protected _labels: string;
        protected _labelColors: string;
        private _labelFont;
        protected _labelStrokeColor: string;
        protected _strokeColors: string;
        protected _labelStroke: number;
        protected _labelSize: number;
        protected _labelBold: boolean;
        protected _labelPadding: string;
        protected _labelAlign: string;
        protected _stateNum: number;
        protected _labelChanged: boolean;
        /**
         * @en The processor executed when changing the selection of the Group, (Default return parameter: item index (index: int)).
         * @zh 改变 Group 的选择项时执行的处理器，(默认返回参数： 项索引（index:int）)。
         */
        selectHandler: Handler;
        /**
         * @en Indicates the index of the currently selected item. The default value is -1.
         * @zh 表示当前选择的项索引。默认值为-1。
         */
        get selectedIndex(): number;
        set selectedIndex(value: number);
        /**
         * @en The URL of the skin for the component.
         * @zh 组件的皮肤URL。
         */
        get skin(): string;
        set skin(value: string);
        /**
         * @en The labels string, separated by commas, such as "item0,item1,item2,item3,item4,item5".
         * @zh 标签集合字符串。以逗号做分割，如"item0,item1,item2,item3,item4,item5"。
         */
        get labels(): string;
        set labels(value: string);
        /**
         * @en The label colors string for the component.
         * @zh 组件的标签颜色字符串。
         */
        get labelColors(): string;
        set labelColors(value: string);
        /**
         * @en The stroke width (in pixels) for the label.
         * The default value is 0, indicating no stroke.
         * @zh 描边宽度（以像素为单位）。
         * 默认值0，表示不描边。
         */
        get labelStroke(): number;
        set labelStroke(value: number);
        /**
         * @en The stroke color for the label, represented as a string.
         * The default color is "#000000" (black).
         * @zh 描边颜色，以字符串表示。
         * 默认值为 "#000000"（黑色）;
         */
        get labelStrokeColor(): string;
        set labelStrokeColor(value: string);
        /**
         * @en The stroke colors in various states.
         * @zh 各个状态下的描边颜色
         */
        get strokeColors(): string;
        set strokeColors(value: string);
        /**
         * @en The font size of the button's text label.
         * @zh 按钮文本标签的字体大小。
         */
        get labelSize(): number;
        set labelSize(value: number);
        /**
         * @en The number of states the button has, represented as a number. The default is 3 states.
         * @zh 按钮的状态值，以数字表示，默认为3态。
         */
        get stateNum(): number;
        set stateNum(value: number);
        /**
         * @en Whether the button's text label is bold.
         * @zh 按钮文本标签是否为粗体字。
         */
        get labelBold(): boolean;
        set labelBold(value: boolean);
        /**
         * @en The font name of the button's text label, represented as a string.
         * @zh 按钮文本标签的字体名称，以字符串形式表示。
         */
        get labelFont(): string;
        set labelFont(value: string);
        /**
         * @en The padding of the button's text label.
         * Format: "Top,Right,Bottom,Left".
         * @zh 按钮文本标签的边距。
         * 格式："上边距,右边距,下边距,左边距"。
         */
        get labelPadding(): string;
        set labelPadding(value: string);
        /**
         * @en The layout direction. The default value is "horizontal".
         * Possible values:
         * "horizontal": Indicates a horizontal layout.
         * "vertical": Indicates a vertical layout.
         * @zh 布局方向。 默认值为"horizontal"。
         * 取值：
         * "horizontal"：表示水平布局。
         * "vertical"：表示垂直布局。
         */
        get direction(): string;
        set direction(value: string);
        /**
         * @en The space between items in pixels.
         * @zh 项对象们之间的间隔（以像素为单位）。
         */
        get space(): number;
        set space(value: number);
        /**
         * @en The array where the item objects are stored.
         * @zh 项对象们的存放数组。
         */
        get items(): ISelect[];
        /**
         * @en The currently selected item object.
         * @zh 当前选择的项对象。
         */
        get selection(): ISelect;
        set selection(value: ISelect);
        /**
         * @en Creates an instance of UIGroup.
         * @param labels A string of labels separated by commas, e.g., "item0,item1,item2,item3,item4,item5".
         * @param skin The skin.
         * @zh 创建一个 UIGroup 的实例。
         * @param labels 标签集字符串，以逗号分隔，例如 "item0,item1,item2,item3,item4,item5"。
         * @param skin 皮肤。
         */
        constructor(labels?: string, skin?: string);
        protected _skinLoaded(): void;
        protected _setLabelChanged(): void;
        /**
         * @en The item object's click event listener function, used to set the current selected item index.
         * @param index The item index.
         * @zh 项对象的点击事件侦听处理函数，用于设置当前选择的项索引
         * @param index 项索引。
         */
        protected itemClick(index: number): void;
        /**
         * @en Creates an item display object.
         * @param skin The skin path for the item object.
         * @param label The text label for the item object.
         * @zh 创建一个项显示对象。
         * @param skin 项对象的皮肤路径。
         * @param label 项对象的文本标签。
         */
        protected createItem(skin: string, label: string): Sprite;
        /**
         * @en Change the property value of an item object.
         * @zh 更改项对象的属性值。
         */
        protected changeLabels(): void;
        protected commitMeasure(): void;
        /**
         * @en Sets the `selected`property value of an item object by its index.
         * @param index The index of the item object to be set.
         * @param selected Indicates the selected state of the item object.
         * @zh 通过对象的索引设置项对象的 `selected`属性值。
         * @param index 需要设置的项对象的索引。
         * @param selected 表示项对象的选中状态。
         */
        protected setSelect(index: number, selected: boolean): void;
        protected preinitialize(): void;
        /**
         * @en Destroys this instance.
         * @param destroyChild Whether to destroy the child components.
         * @zh 销毁此实例。
         * @param destroyChild 是否销毁子组件。
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @en Adds an item object.
         * @param item The item object to be added.
         * @param autoLayout Whether to automatically layout the item. If true, the position of the item will be calculated based on the direction and space properties.
         * @returns returns the index ID of this item object.
         * @zh 添加一个项对象。
         * @param item 需要添加的项对象。
         * @param autoLayout 是否自动布局，如果为true，会根据 direction 和 space 属性计算item的位置。
         * @returns 返回添加的项对象的索引ID。
         */
        addItem(item: ISelect, autoLayout?: boolean): number;
        /**
         * @en Removes an item object.
         * @param item The item object to be added.
         * @param autoLayout Whether to automatically layout the item. If true, the position of the item will be calculated based on the direction and space properties. Default is true.
         * @zh 删除一个项对象。
         * @param item 需要删除的项对象。
         * @param autoLayout 是否自动布局，如果为true，会根据 direction 和 space 属性计算item的位置。
         */
        delItem(item: ISelect, autoLayout?: boolean): void;
        /**
         * @en This method is called after deserialization of this instance.
         * @zh 反序列化后调用此方法。
         */
        onAfterDeserialize(): void;
        /**
         * @en Initializes the item objects.
         * @zh 初始化项对象们。
         */
        initItems(): void;
        /**
         * @en Sets the data source for this component.
         * @zh 设置此组件的数据源。
         */
        set_dataSource(value: any): void;
    }
    /**
     * @en The `UIUtils` class is a collection of text utility functions.
     * @zh `UIUtils` 是文本工具集。
     */
    class UIUtils {
        private static grayFilter;
        private static _funMap;
        /**
         * @en Fill an array with a string and return a copy of the array.
         * @param arr The source array.
         * @param str A string of comma-separated values, such as "p1,p2,p3,p4".
         * @param type If the value is not null, it indicates the type of the newly added value.
         * @returns The filled array.
         * @zh 用字符串填充数组，并返回数组副本。
         * @param arr 源数组对象。
         * @param str 用逗号连接的字符串。如"p1,p2,p3,p4"。
         * @param type 如果值不为null，则填充的是新增值得类型。
         * @returns 填充后的数组。
         */
        static fillArray(arr: any[], str: string, type?: typeof Number | typeof String): any[];
        /**
         * @en Convert a uint color value to a string color value.
         * @param color The uint color value.
         * @returns The string color value.
         * @zh 转换 uint 类型颜色值为字符型颜色值。
         * @param color uint颜色值。
         * @returns 字符型颜色值。
         */
        static toColor(color: number): string;
        /**
         * @en Add or remove a grayscale filter to the specified target display object.
         * @param target The target display object.
         * @param isGray If true, add a grayscale filter, otherwise remove the grayscale filter.
         * @zh 给指定的目标显示对象添加或移除灰度滤镜。
         * @param target 目标显示对象。
         * @param isGray 如果值true，则添加灰度滤镜，否则移除灰度滤镜。
         */
        static gray(target: Sprite, isGray?: boolean): void;
        /**
         * @en Get the function expression based on the string.
         * @param value The string value.
         * @returns The function expression.
         * @zh 根据字符串，返回函数表达式。
         * @param value 字符串值。
         * @return 函数表达式。
         */
        static getBindFun(value: string): Function;
    }
    /**
     * @en VBox is a vertical layout container class.
     * @zh VBox 是一个垂直布局容器类。
     */
    class VBox extends LayoutBox {
        /**
         * @en No alignment.
         * @zh 无对齐。
         */
        static NONE: string;
        /**
         * @en Left aligned.
         * @zh 左对齐。
         */
        static LEFT: string;
        /**
         * @en Center alignment.
         * @zh 居中对齐。
         */
        static CENTER: string;
        /**
         * @en Right aligned.
         * @zh 右对齐。
         */
        static RIGHT: string;
        /**
         * @en Compatible with previous changeItems logic, whether to use sortItem to sort all items when changes occur.
         * @zh 兼容以前的changeItems逻辑，是否在发生变动时，使用 sortItem 排序所有item。
        */
        isSortItem: boolean;
        protected changeItems(): void;
    }
    /**
     * @en The View class represents a view component.
     * - In LayaAir 2.x, View inherited from the Scene class. However, in 3.x, Scene represents a broader concept encompassing both 2D and 3D. Therefore, in 3.x, understanding Scene as just a 2D scene view node is not appropriate. Scene has been retained for compatibility purposes, but the concept of a scene should be understood as encompassing both 2D and 3D scene data files.
     * @zh View 是一个视图类。
     * - 在 LayaAir 2.x 里，View 继承自 Scene 类，但在 3.x 里，Scene 是一个 2D+3D 的场景概念，所以在 3.x 里，把 Scene 类理解为场景是不合理的。Scene 是为了兼容而保留的 2D 场景视图节点，请忽略引擎中的 Scene 概念，场景概念统一理解为包含了 2D 与 3D 的场景数据文件。
     */
    class View extends Scene {
        /**
         * @en Compatible with older versions.
         * @zh 兼容老版本
         */
        static uiMap: any;
        /**
         * @en Compatible with older versions.Registers UI configuration information. For example, it registers a page with the path "test/TestPage", where the UI content is a JSON generated by the IDE.
         * @param url The path to the UI.
         * @param json The UI content in JSON format.
         * @zh 兼容老版本，注册UI配置信息。比如注册一个路径为"test/TestPage"的页面，UI内容是IDE生成的json
         * @param	url		UI的路径
         * @param	json	UI内容
         */
        static regUI(url: string, json: any): void;
        /**
         * @en The data source.
         * @zh 数据源。
         */
        protected _dataSource: any;
        /** @ignore */
        constructor();
        changeData(key: string): void;
        /**
         * @en Sets the data source for the control and updates the child components accordingly.
         * @param value The new data source to be set.
         * @zh 设置控件的数据源，并相应地更新子组件。
         * @param value 要设置的新数据源。
         */
        set_dataSource(value: any): void;
    }
    /**
     * @en The ViewStack class is used for the View Stack class, which is used for setting and processing the display of views.
     * @zh ViewStack 类用于视图堆栈类，用于视图的显示等设置处理。
     */
    class ViewStack extends Box {
        /**
         * @en The index of the current view.
         * @zh 当前视图的索引。
         */
        get selectedIndex(): number;
        set selectedIndex(value: number);
        /**
         * @en The currently selected item object.
         * @zh 当前选中的项对象。
         */
        get selection(): Node;
        set selection(value: Node);
        /**
         * @en Index setting processor.
         * Default callback parameters: index:int
         * @zh 索引设置处理器。
         * 默认回调参数：index:int
         */
        get setIndexHandler(): Handler;
        set setIndexHandler(value: Handler);
        /**
         * @en The array of view items.
         * @zh 视图集合数组。
         */
        get items(): any[];
        /** @ignore */
        constructor();
        /**
         * @en Sets the `selected` property value of an item object by its index.
         * @param index The index of the object to be set.
         * @param selected Indicates the selected state of the object.
         * @zh 通过对象的索引设置项对象的 `selected` 属性值。
         * @param index 需要设置的对象的索引。
         * @param selected 表示对象的选中状态。
         */
        protected setSelect(index: number, selected: boolean): void;
        /**
         * 设置属性<code>selectedIndex</code>的值。
         * @param index 选中项索引值。
         */
        protected setIndex(index: number): void;
        /**
         * @en Sets the view items in batch.
         * @param views An array of view objects to be set.
         * @zh 批量设置视图对象。
         * @param views 视图对象数组。
         */
        setItems(views: any[]): void;
        /**
         * @en Adds a view to the ViewStack.Sets the name property of the view object to facilitate identification.
         * @param view The view object to be added.
         * @zh 添加视图对象到 ViewStack，并设置此视图对象的 `name` 属性。
         * @param view 需要添加的视图对象。
         */
        addItem(view: Node): void;
        /**
         * @en This method is called after the object has been deserialized, and it initializes the view items.
         * @zh 反序列化后调用此方法，用以初始化视图项。
         */
        onAfterDeserialize(): void;
        _afterInited(): void;
        /**
         * @en Initialize the collection of view objects.
         * @zh 初始化视图对象集合。
         */
        initItems(): void;
        /**
         * @en Sets the data source for the ViewStack, updating the selectedIndex or properties accordingly.
         * @zh 为 ViewStack 设置数据源，相应地更新 selectedIndex 或属性。
         */
        set_dataSource(value: any): void;
    }
    /**
     * @en The vertical scrollbar (VScrollBar) is used to scroll and view all content in the vertical direction when there is too much data to fit in the display area.
     * @zh 垂直滚动条（VScrollBar）用于垂直方向因数据过多而超出显示区域时滚动查看全部内容。
     */
    class VScrollBar extends ScrollBar {
    }
    /**
     * @en A VSlider control allows the user to select a value by moving the slider thumb between the endpoints of the slider track. The VSlider control is oriented vertically. The slider track extends from bottom to top, and the label is positioned on the left and right sides of the track.
     * @zh 使用 VSlider 控件，用户可以通过在滑块轨道的终点之间移动滑块来选择值。VSlider 控件采用垂直方向。滑块轨道从下往上扩展，而标签位于轨道的左右两侧。
     */
    class VSlider extends Slider {
    }
    /**
     * @en A utility class for Base64 encoding and decoding operations.
     * @zh Base64 编码和解码操作的实用工具类。
     */
    class Base64Tool {
        /**
         * @en The character set used for Base64 encoding.
         * @zh 用于 Base64 编码的字符集。
         */
        static chars: string;
        /**
         * @en Regular expression for validating Base64 encoded strings, including data URIs.
         * @zh 用于验证 Base64 编码字符串（包括数据 URI）的正则表达式。
         */
        static reg: RegExp;
        /**
         * @en Regular expression for matching the header of a data URI.
         * @zh 用于匹配数据 URI 头部的正则表达式。
         */
        static reghead: RegExp;
        /**
         * @en Use a lookup table to find the index.
         * @zh 使用查找表查找索引。
         */
        static lookup: Uint8Array;
        /**
         * @en Initializes the lookup table for Base64 decoding.
         * @zh 初始化用于 Base64 解码的查找表。
         */
        static init(): void;
        /**
         * @en Determines if a string is a base64 encoded string.
         * @param str The string to check.
         * @zh 判断字符串是否是 base64 编码的字符串。
         * @param str 需要检查的字符串。
         */
        static isBase64String(str: string): boolean;
        /**
         * @en Encodes an ArrayBuffer to a base64 string.
         * @param arraybuffer The ArrayBuffer to encode.
         * @zh 对 ArrayBuffer 进行编码，返回 base64 字符串。
         * @param arraybuffer 需要编码的 ArrayBuffer。
         */
        static encode(arraybuffer: ArrayBuffer): string;
        /**
         * @en Decodes a base64 string to an ArrayBuffer.
         * @param base64 The base64 string to decode.
         * @zh 对 base64 字符串进行解码，返回 ArrayBuffer。
         * @param base64 需要解码的 base64 字符串。
         */
        static decode(base64: string): ArrayBuffer;
    }
    /**
     * @en Browser is a browser proxy class. Encapsulate some of the features provided by the browser and native JavaScript.
     * @zh Browser 是浏览器代理类。封装浏览器及原生 js 提供的一些功能。
     */
    class Browser {
        /**
         * @en Browser proxy information.
         * @zh 浏览器代理信息。
         */
        static userAgent: string;
        /**
         * @en Indicates whether the current environment is a mobile device, including iOS and Android devices.
         * @zh 表示当前环境是否为移动设备，包括 iOS 和 Android 设备。
         */
        static onMobile: boolean;
        /**
         * @en Indicates whether the current environment is within an iOS device.
         * @zh 表示当前环境是否在 IOS 设备内。
         */
        static onIOS: boolean;
        /**
         * @en Indicates whether the current environment is a Mac device.
         * @zh 表示当前环境是否为 Mac 设备。
         */
        static onMac: boolean;
        /**
         * @en Indicates whether the current environment is within an iPhone.
         * @zh 表示当前环境是否在 iPhone 内。
         */
        static onIPhone: boolean;
        /**
         * @en Indicates whether the current environment is within an iPad.
         * @zh 表示当前环境是否在 iPad 内。
         */
        static onIPad: boolean;
        /**
         * @en Indicates whether the current environment is within an Android device.
         * @zh 表示当前环境是否在 Android 设备内。
         */
        static onAndroid: boolean;
        /**
         * @en Indicates whether the current environment is within an OpenHarmonyOS device.
         * @zh 表示当前环境是否在 OpenHarmonyOS 设备内。
         */
        static onOpenHarmonyOS: boolean;
        /**
         * @en Indicates whether the current environment is within a Windows Phone device.
         * @zh 表示当前环境是否在 Windows Phone 设备内。
         */
        static onWP: boolean;
        /**
         * @en Indicates whether the current environment is within the QQ browser.
         * @zh 表示当前环境是否在 QQ 浏览器内。
         */
        static onQQBrowser: boolean;
        /**
         * @en Indicates whether the current environment is within the mobile QQ or QQ browser.
         * @zh 表示当前环境是否在移动 QQ 或 QQ 浏览器内。
         */
        static onMQQBrowser: boolean;
        /**
         * @en Indicates whether the current environment is within Safari.
         * @zh 表示当前环境是否在 Safari 内。
         */
        static onSafari: boolean;
        /**
         * @en Indicates whether the current environment is within Chrome.
         * @zh 表示当前环境是否在 Chrome 内。
         */
        static onChrome: boolean;
        /**
         * @en Indicates whether the current environment is within the Internet Explorer browser.
         * @zh 表示当前环境是否在 Internet Explorer 浏览器内。
         */
        static onIE: boolean;
        /**
         * @en Indicates whether the current environment is within WeChat.
         * @zh 表示当前环境是否在微信内。
         */
        static onWeiXin: boolean;
        /**
         * @en Indicates whether the current environment is a PC.
         * @zh 表示当前环境是否为 PC。
         */
        static onPC: boolean;
        /**
         * @en Indicates whether the current environment is a WeChat mini-game.
         * @zh 表示当前环境是否是微信小游戏。
         */
        static onMiniGame: boolean;
        /**
         * @en Indicates whether the current environment is a Baidu mini-game.
         * @zh 表示当前环境是否是百度小游戏。
         */
        static onBDMiniGame: boolean;
        /**
         * @en Indicates whether the current environment is a Xiaomi mini-game.
         * @zh 表示当前环境是否是小米小游戏。
         */
        static onKGMiniGame: boolean;
        /**
         * @en Indicates whether the current environment is an OPPO mini-game.
         * @zh 表示当前环境是否是 OPPO 小游戏。
         */
        static onQGMiniGame: boolean;
        /**
         * @en Indicates whether the current environment is a VIVO mini-game.
         * @zh 表示当前环境是否是 vivo 小游戏。
         */
        static onVVMiniGame: boolean;
        /**
         * @en Indicates whether the current environment is an Alipay mini-game.
         * @zh 表示当前环境是否是支付宝小游戏。
         */
        static onAlipayMiniGame: boolean;
        /**
         * @en Indicates whether the current environment is a QQ mini-game on mobile.
         * @zh 表示当前环境是否是手机 QQ 小游戏。
         */
        static onQQMiniGame: boolean;
        /**
         * @en Indicates whether the current environment is a BILIBILI mini-game.
         * @zh 表示当前环境是否是 BILIBILI 小游戏。
         */
        static onBLMiniGame: boolean;
        /**
         * @en Indicates whether the current environment is a TikTok (Douyin) mini-game.
         * @zh 表示当前环境是否是抖音小游戏。
         */
        static onTTMiniGame: boolean;
        /**
         * @en Indicates whether the current environment is a Huawei mini-game.
         * @zh 表示当前环境是否是华为快游戏。
         */
        static onHWMiniGame: boolean;
        /**
         * @en Indicates whether the current environment is a Taobao mini-game.
         * @zh 表示当前环境是否是淘宝小游戏。
         */
        static onTBMiniGame: boolean;
        /**
         * @private
         * @en Indicates whether the current environment is the Firefox browser.
         * @zh 表示当前环境是否是 Firefox 浏览器。
         */
        static onFirefox: boolean;
        /**
         * @en Indicates whether the current environment is the Edge browser.
         * @zh 表示当前环境是否是 Edge 浏览器。
         */
        static onEdge: boolean;
        /**
         * @private
         * @en Indicates whether the current environment is running on LayaAir Native Runtime.
         * @zh 表示当前环境是否运行在 LayaAir Native Runtime。
         */
        static onLayaRuntime: boolean;
        /**
         * @en The actual platform type, OnMobile and others are determined through UserAgent, which may be faked.
         * @zh 真实平台类型，onMobile等是通过UserAgent判断，可能具有欺骗性
         */
        static platform: number;
        static PLATFORM_PC: number;
        static PLATFORM_ANDROID: number;
        static PLATFORM_IOS: number;
        /**
         * @en Indicates whether the environment supports WebAudio.
         * @zh 表示环境是否支持 WebAudio。
         */
        static supportWebAudio: boolean;
        /**
         * @en Indicates whether the environment supports LocalStorage.
         * @zh 表示环境是否支持 LocalStorage。
         */
        static supportLocalStorage: boolean;
        /**
         * @en The global offline canvas (not the main canvas), used primarily for measuring text and obtaining image data.
         * @zh 全局离线画布（非主画布），主要用来测量文本和获取图像数据。
         */
        static canvas: any;
        /**
         * @en The rendering context of the global offline canvas (not the main canvas).
         * @zh 全局离线画布上绘图的环境（非主画布）。
         */
        static context: CanvasRenderingContext2D;
        /**
         * @en The service object for mini-game platform services.
         * @zh 小游戏平台服务对象。
         */
        static miniGameContext: any;
        /**
         * @en The loaded bundles.
         * @zh 已载入的脚本集。
         */
        static bundles: Map<string, any>;
        /** @private */
        private static _window;
        /** @private */
        private static _document;
        /** @private */
        private static _container;
        /** @private */
        private static _pixelRatio;
        /** @private */
        private static _clientWidth;
        /** @private */
        private static _clientHeight;
        /** @private */
        static mainCanvas: any;
        /**@private */
        private static hanzi;
        /**@private */
        private static fontMap;
        /**@private */
        static measureText: Function;
        /**
         * @en Gets whether it is a mini game environment
         * @returns onMiniGame || onBDMiniGame || onQGMiniGame || onKGMiniGame || onVVMiniGame || onAlipayMiniGame || onQQMiniGame || onBLMiniGame || onTTMiniGame || onHWMiniGame || onTBMiniGame
         * @zh 获取是否为小游戏环境
         * @returns onMiniGame || onBDMiniGame || onQGMiniGame || onKGMiniGame || onVVMiniGame || onAlipayMiniGame || onQQMiniGame || onBLMiniGame || onTTMiniGame || onHWMiniGame || onTBMiniGame
         */
        static get _isMiniGame(): boolean;
        /**
         * @en Creates a native browser element of the specified type.
         * @param type The type of node to create.
         * @return A reference to the created node object.
         * @zh 创建指定类型的浏览器原生节点。
         * @param type 要创建的节点类型。
         * @return 创建的节点对象的引用。
         */
        static createElement(type: string): any;
        /**
         * @en Returns a reference to the first object in the Document object with the specified id.
         * @param id The id of the node.
         * @return The node object.
         * @zh 返回 Document 对象中拥有指定 id 的第一个对象的引用。
         * @param id 节点的 id。
         * @return 节点对象。
         */
        static getElementById(id: string): any;
        /**
         * @en Removes the specified native browser node object from the DOM.
         * @param ele The node object to be removed.
         * @zh 移除指定的浏览器原生节点对象。
         * @param ele 要移除的节点对象。
         */
        static removeElement(ele: any): void;
        /**
         * @en Gets the current timestamp in milliseconds since the epoch.
         * @zh 获取浏览器当前时间戳，单位为毫秒。
         */
        static now(): number;
        /**
         * @en The viewport width of the browser window.
         * The method analyzes the browser information to determine the width, with a priority given to `window.innerWidth` (includes scrollbar width) > `document.body.clientWidth` (does not include scrollbar width).
         * If the former is 0 or undefined, the latter is chosen.
         * @zh 浏览器窗口的可视宽度。
         * 通过分析浏览器信息获得。浏览器多个属性值优先级为：window.innerWidth(包含滚动条宽度) > document.body.clientWidth(不包含滚动条宽度)，
         * 如果前者为 0 或未定义，则选择后者。
         */
        static get clientWidth(): number;
        static set clientWidth(value: number);
        /**
         * @en The viewport height of the browser window.
         * The method analyzes the browser information to determine the height, with a priority given to `window.innerHeight` (includes scrollbar height) > `document.body.clientHeight` (excluding scrollbar height) > `document.documentElement.clientHeight` (both do not include scrollbar height).
         * If the former is 0 or undefined, it falls back to the latter.
         * @zh 浏览器窗口的可视高度。
         * 通过分析浏览器信息获得。浏览器多个属性值优先级为：window.innerHeight(包含滚动条高度) > document.body.clientHeight(不包含滚动条高度) > document.documentElement.clientHeight，
         * 如果前者为 0 或未定义，则选择后者。
         */
        static get clientHeight(): number;
        static set clientHeight(value: number);
        /**
         * @en The physical width of the browser window, taking into account the device pixel ratio.
         * @zh 浏览器窗口的物理宽度，考虑了设备像素比。
         */
        static get width(): number;
        /**
         * @en The physical height of the browser window, taking into account the device pixel ratio.
         * @zh 浏览器窗口的物理高度，考虑了设备像素比。
         */
        static get height(): number;
        /**
         * @en The device pixel ratio of the current environment.
         * @zh 当前环境的设备像素比。
         */
        static get pixelRatio(): number;
        /**
         * @en The canvas container that holds the canvas element, facilitating control over the canvas.
         * @zh 用来存放画布元素的容器，方便对画布进行控制。
         */
        static get container(): any;
        static set container(value: any);
        /**
         * @en Reference to the browser native window object.
         * @zh 浏览器原生 window 对象的引用。
         */
        static get window(): any;
        /**
         * @en Reference to the browser native document object.
         * @zh 浏览器原生 document 对象的引用。
         */
        static get document(): any;
        /**
         * @en Gets the value of a URL parameter.
         * @param name The name of the parameter.
         * @return The value of the parameter.
         * @zh 获取 URL 参数的值。
         * @param name 参数的名称。
         * @return 参数的值。
         */
        static getQueryString(name: string): string;
        /**
         * @en Safari landscape toolbar offset
         * @zh Safari横屏工具栏偏移
         */
        static getSafariToolbarOffset(): number;
        /**
         * @en Dynamically loads a JavaScript library from the specified source.
         * @zh 从指定源动态加载 JavaScript 库。
         */
        static loadLib(src: string): Promise<void>;
    }
    function arrayBufferSlice(this: ArrayBuffer, start: number, end: number): ArrayBuffer;
    function uint8ArraySlice(this: Uint8Array): Uint8Array;
    function float32ArraySlice(this: Float32Array): Float32Array;
    function uint16ArraySlice(this: Uint16Array, ...arg: any[]): Uint16Array;
    /**
     * @en The Byte class provides methods and properties for optimizing the reading, writing, and handling of binary data. The Byte class is suitable for advanced developers who need to access data at the byte level.
     * @zh Byte 类提供用于优化读取、写入以及处理二进制数据的方法和属性。Byte 类适用于需要在字节层访问数据的高级开发人员。
     */
    class Byte {
        /**
         * @en Host byte order, which represents the two different sequences in which a CPU can store data: little-endian and big-endian. Use getSystemEndian to obtain the byte order of the current system.
         * BIG_ENDIAN byte order: The lower address stores, the higher bits of the value, and the higher address stores the lower bits. It is sometimes referred to as network byte order.
         * LITTLE_ENDIAN byte order: The lower address stores, the lower bits of the value, and the higher address stores the higher bits.
         * @zh 主机字节序，是 CPU 存放数据的两种不同顺序：小端字节序和大端字节序。使用 getSystemEndian 获取当前系统的字节序。
         * BIG_ENDIAN：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。
         * LITTLE_ENDIAN： 小端字节序，地址低位存储值的低位，地址高位存储值的高位。
         */
        static BIG_ENDIAN: string;
        /**
         * @en Host byte order, which represents the two different sequences in which a CPU can store data: little-endian and big-endian. Use getSystemEndian to obtain the byte order of the current system.
         * LITTLE_ENDIAN byte order: The lower address stores the lower bits of the value, and the higher address stores the higher bits.
         * BIG_ENDIAN byte order: The lower address stores the higher bits of the value, and the higher address stores the lower bits. It is sometimes referred to as network byte order.
         * @zh 主机字节序，是 CPU 存放数据的两种不同顺序：小端字节序和大端字节序。使用 getSystemEndian 获取当前系统的字节序。
         * LITTLE_ENDIAN ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。
         * BIG_ENDIAN：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。
         */
        static LITTLE_ENDIAN: string;
        /**@private */
        private static _sysEndian;
        /**@private 是否为小端数据。*/
        protected _xd_: boolean;
        /**@private */
        private _allocated_;
        /**@private 原始数据。*/
        protected _d_: any;
        /**@private DataView*/
        protected _u8d_: any;
        /**@private */
        protected _pos_: number;
        /**@private */
        protected _length: number;
        /**
         * @en Get the byte order of the current host.
         * The host byte order refers to the two different sequences in which a CPU stores data, which includes little-endian and big-endian.
         * BIG_ENDIAN: Big-endian byte order, where the lower address stores the higher bits of the value, and the higher address stores the lower bits. It is sometimes also called network byte order.
         * LITTLE_ENDIAN: Little-endian byte order, where the lower address stores the lower bits of the value, and the higher address stores the higher bits.
         * @returns The byte order of the current system.
         * @zh 获取当前主机的字节序。
         * 主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。
         * BIG_ENDIAN：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。
         * LITTLE_ENDIAN：小端字节序，地址低位存储值的低位，地址高位存储值的高位。
         * @return 当前系统的字节序。
         */
        static getSystemEndian(): string;
        /**
         * @en Constructor method.
         * @param data Specifies the number of elements for initialization, or a TypedArray object or ArrayBuffer object for initialization. If null, allocate a certain amount of memory in advance. When available space is not enough, use this part of the memory first, and reallocate the required memory if it is still not enough.
         * @zh 构造方法
         * @param data 用于指定初始化的元素数目，或者用于初始化的TypedArray对象、ArrayBuffer对象。如果为 null ，则预分配一定的内存空间，当可用空间不足时，优先使用这部分内存，如果还不够，则重新分配所需内存。
         */
        constructor(data?: any);
        /**
         * @en The ArrayBuffer data of this object, which contains only the valid data part.
         * @zh 此对象的 ArrayBuffer 数据，数据只包含有效数据部分。
         */
        get buffer(): ArrayBuffer;
        /**
         * @en The byte order of the `Byte` instance. Possible values are `BIG_ENDIAN` or `LITTLE_ENDIAN`.
         * The host byte order is one of two sequences used by the CPU to store data, which includes little-endian and big-endian byte orders.The current system's byte order can be obtained using `getSystemEndian`.
         * `BIG_ENDIAN`: Big-endian byte order, where the lower memory address stores the higher-order bits of a number, and is sometimes referred to as network byte order.
         * `LITTLE_ENDIAN`: Little-endian byte order, where the lower memory address stores the lower-order bits of a number.
         * @zh `Byte` 实例的字节序。取值为 `BIG_ENDIAN` 或 `LITTLE_ENDIAN`。
         * 主机字节序是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。可以通过 `getSystemEndian` 获取当前系统的字节序。
         * BIG_ENDIAN ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。
         * LITTLE_ENDIAN ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。
         */
        get endian(): string;
        set endian(value: string);
        /**
         * @private
         * @en The length of the `Byte` object, measured in bytes.
         * When setting the length to a value greater than the current length, the byte array is right-padded with zeros. If the length is set to a value less than the current length, the byte array is truncated.
         * If the length to be set exceeds the current allocated memory space, the memory is reallocated to the larger of either the new length or twice the current allocated length, and the original data is copied to the new memory space. If the length to be set is less than the current allocated memory space, the memory is reallocated to the new length, and the original data is truncated from the beginning to fit the new length.
         * @zh `Byte` 对象的长度（以字节为单位）。
         * 如果将长度设置为大于当前长度的值，则用零填充字节数组的右侧；如果将长度设置为小于当前长度的值，将会截断该字节数组。
         * 如果要设置的长度大于当前已分配的内存空间的字节长度，则重新分配内存空间，大小为以下两者较大者：要设置的长度、当前已分配的长度的2倍，并将原有数据拷贝到新的内存空间中；如果要设置的长度小于当前已分配的内存空间的字节长度，也会重新分配内存空间，大小为要设置的长度，并将原有数据从头截断为要设置的长度存入新的内存空间中。
         */
        set length(value: number);
        get length(): number;
        /**@private */
        private _resizeBuffer;
        /**
         * @private
         * @en Commonly used to parse a byte stream in a fixed format.
         * First, read a `Uint16` value from the current byte offset of the byte stream, and then read a string of this length.
         * @returns The read string.
         * @zh 常用于解析固定格式的字节流。
         * 先从字节流的当前字节偏移位置处读取一个 `Uint16` 值，然后以此值为长度，读取此长度的字符串。
         * @return 读取的字符串。
         */
        getString(): string;
        /**
         * @en Commonly used to parse a byte stream in a fixed format.
         * First, read a `Uint16` value from the current byte offset of the byte stream, and then read a string of this length.
         * @returns The read string.
         * @zh 常用于解析固定格式的字节流。
         * 先从字节流的当前字节偏移位置处读取一个 `Uint16` 值，然后以此值为长度，读取此长度的字符串。
         * @return 读取的字符串
         */
        readString(): string;
        /**
         * @private
         * @en Reads a number of bytes specified by the `len` parameter from the byte stream starting at the position indicated by the `start` parameter, and creates a `Float32Array` object from the data.
         * Note: The returned `Float32Array` object is a native HTML5 `Float32Array` object in the JavaScript environment. Reading operations on this object are based on the current host byte order of the machine running the program. This order may differ from the actual byte order of the data. If you use this object for reading, you need to be aware of the actual data's byte order and the current host byte order. If they are the same, you can read normally; otherwise, you need to wrap the actual data (`Float32Array.buffer`) with a `DataView` object to read according to the specified byte order.
         * @param start The starting position.
         * @param len The number of bytes to read. If the length to be read exceeds the readable range, only the values within the readable range are returned.
         * @returns The read `Float32Array` object.
         * @zh 从字节流中 `start` 参数指定的位置开始，读取 `len` 参数指定的字节数的数据，用于创建一个 `Float32Array` 对象并返回此对象。
         * 注意：返回的 Float32Array 对象，在 JavaScript 环境下，是原生的 HTML5 Float32Array 对象，对此对象的读取操作都是基于运行此程序的当前主机字节序，此顺序可能与实际数据的字节序不同，如果使用此对象进行读取，需要用户知晓实际数据的字节序和当前主机字节序，如果相同，可正常读取，否则需要用户对实际数据(Float32Array.buffer)包装一层 DataView ，使用 DataView 对象可按照指定的字节序进行读取。
         * @param	start	开始位置。
         * @param	len		需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
         * @return  读取的 Float32Array 对象。
         */
        getFloat32Array(start: number, len: number): any;
        /**
         * @en Reads a number of bytes specified by the `len` parameter from the byte stream starting at the position indicated by the `start` parameter, and creates a `Float32Array` object from the data.
         * @param start The starting position.
         * @param len The number of bytes to read. If the length to be read exceeds the readable range, only the values within the readable range are returned.
         * @returns The read `Float32Array` object.
         * @zh 从字节流中 `start` 参数指定的位置开始，读取 `len` 参数指定的字节数的数据，用于创建一个 `Float32Array` 对象并返回此对象。
         * @param	start	开始位置。
         * @param	len		需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
         * @return  读取的 Float32Array 对象。
         */
        readFloat32Array(start: number, len: number): any;
        /**
         * @private
         * @en Reads a number of bytes specified by the `len` parameter from the byte stream starting at the position indicated by the `start` parameter, and creates a `Uint8Array` object from the data.
         * @param start The starting position.
         * @param len The number of bytes to read. If the length to be read exceeds the readable range, only the values within the readable range are returned.
         * @returns The read `Uint8Array` object.
         * @zh 从字节流中 `start` 参数指定的位置开始，读取 `len` 参数指定的字节数的数据，用于创建一个 `Uint8Array` 对象并返回此对象。
         * @param	start	开始位置。
         * @param	len		需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
         * @return  读取的 Uint8Array 对象。
         */
        getUint8Array(start: number, len: number): Uint8Array;
        /**
         * @en Reads a number of bytes specified by the `len` parameter from the byte stream starting at the position indicated by the `start` parameter, and creates a `Uint8Array` object from the data.
         * @param start The starting position.
         * @param len The number of bytes to read. If the length to be read exceeds the readable range, only the values within the readable range are returned.
         * @returns The read `Uint8Array` object.
         * @zh 从字节流中 `start` 参数指定的位置开始，读取 `len` 参数指定的字节数的数据，用于创建一个 `Uint8Array` 对象并返回此对象。
         * @param	start	开始位置。
         * @param	len		需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
         * @return  读取的 Uint8Array 对象。
         */
        readUint8Array(start: number, len: number): Uint8Array;
        /**
         * @private
         * @en Reads a number of bytes specified by the `len` parameter from the byte stream starting at the position indicated by the `start` parameter, and creates an `Int16Array` object from the data.
         * Note: The returned `Int16Array` object is a native HTML5 `Int16Array` object in the JavaScript environment. Reading operations on this object are based on the current host byte order. This order may differ from the actual byte order of the data. If you use this object for reading, you must be aware of the actual data's byte order and the current host byte order. If they match, you can read normally; otherwise, you need to wrap the actual data (`Int16Array.buffer`) with a `DataView` object to read according to the specified byte order.
         * @param start The byte offset from the start of the stream to begin reading.
         * @param len The number of bytes to read. Only values within the readable range are returned if the length exceeds the range.
         * @returns The created `Int16Array` object.
         * @zh 从字节流中 `start` 参数指定的位置开始，读取 `len` 参数指定的字节数的数据，用于创建一个 `Int16Array` 对象并返回此对象。
         * 注意：返回的 `Int16Array` 对象是 JavaScript 环境下原生的 HTML5 `Int16Array` 对象，对此对象的读取操作都是基于运行此程序的当前主机字节序。此顺序可能与实际数据的字节序不同，如果使用此对象进行读取，需要用户知晓实际数据的字节序和当前主机字节序，如果相同，可正常读取，否则需要用户对实际数据 (`Int16Array.buffer`) 包装一层 `DataView` 对象，使用 `DataView` 对象可按照指定的字节序进行读取。
         * @param	start	开始读取的字节偏移量位置。
         * @param	len		需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
         * @return  读取的 Int16Array 对象。
         */
        getInt16Array(start: number, len: number): any;
        /**
         * @en Reads a number of bytes specified by the `len` parameter from the byte stream starting at the position indicated by the `start` parameter, and creates an `Int16Array` object from the data.
         * @param start The byte offset from the start of the stream to begin reading.
         * @param len The number of bytes to read. Only values within the readable range are returned if the length exceeds the range.
         * @returns The created `Int16Array` object.
         * @zh 从字节流中 `start` 参数指定的位置开始，读取 `len` 参数指定的字节数的数据，用于创建一个 `Int16Array` 对象并返回此对象。
         * @param	start	开始读取的字节偏移量位置。
         * @param	len		需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
         * @return  读取的 Uint8Array 对象。
         */
        readInt16Array(start: number, len: number): any;
        /**
         * @private
         * @en Reads a 32-bit floating-point number from the current position in the byte stream using IEEE 754 format.
         * @returns The 32-bit floating-point number.
         * @zh 从字节流的当前字节偏移位置处读取一个 IEEE 754 单精度（32 位）浮点数。
         * @return 单精度（32 位）浮点数。
         */
        getFloat32(): number;
        /**
         * @en Reads a 32-bit floating-point number from the current position in the byte stream using IEEE 754 format.
         * @returns The 32-bit floating-point number.
         * @zh 从字节流的当前字节偏移位置处读取一个 IEEE 754 单精度（32 位）浮点数。
         * @return 单精度（32 位）浮点数。
         */
        readFloat32(): number;
        /**
         * @private
         * @en Reads a 64-bit floating-point number from the current position in the byte stream using IEEE 754 format.
         * @returns The 64-bit floating-point number.
         * @zh 从字节流的当前字节偏移量位置处读取一个 IEEE 754 双精度（64 位）浮点数。
         * @return 双精度（64 位）浮点数。
         */
        getFloat64(): number;
        /**
         * @en Reads a 64-bit floating-point number from the current position in the byte stream using IEEE 754 format.
         * @returns The 64-bit floating-point number.
         * @zh 从字节流的当前字节偏移量位置处读取一个 IEEE 754 双精度（64 位）浮点数。
         * @return 双精度（64 位）浮点数。
         */
        readFloat64(): number;
        /**
         * @en Writes an IEEE 754 single-precision (32-bit) floating point number to the byte stream at the current position.
         * @param value The single-precision (32-bit) floating point number to be written.
         * @zh 在字节流的当前字节偏移量位置处写入一个 IEEE 754 单精度（32 位）浮点数。
         * @param value 需要写入的单精度（32 位）浮点数。
         */
        writeFloat32(value: number): void;
        /**
         * @en Writes an IEEE 754 double-precision (64-bit) floating point number to the byte stream at the current position.
         * @param value  The double-precision (64-bit) floating point number to be written.
         * @zh 在字节流的当前字节偏移量位置处写入一个 IEEE 754 双精度（64 位）浮点数。
         * @param value  需要写入的双精度（64 位）浮点数。
         */
        writeFloat64(value: number): void;
        /**
         * @private
         * @en Reads an Int32 value from the current position in the byte stream.
         * @returns The Int32 value that was read.
         * @zh 从字节流的当前字节偏移量位置处读取一个 Int32 值。
         * @returns  读取的 Int32 值。
         */
        getInt32(): number;
        /**
         * @en Reads an Int32 value from the current position in the byte stream.
         * @returns The Int32 value that was read.
         * @zh 从字节流的当前字节偏移量位置处读取一个 Int32 值。
         * @returns 读取的 Int32 值。
         */
        readInt32(): number;
        /**
         * @private
         * @en Reads a Uint32 value from the current position in the byte stream.
         * @returns The Uint32 value that was read.
         * @zh 从字节流的当前字节偏移量位置处读取一个 Uint32 值。
         * @returns 读取的 Uint32 值。
         */
        getUint32(): number;
        /**
         * @en Reads a Uint32 value from the current position in the byte stream.
         * @returns The Uint32 value that was read.
         * @zh 从字节流的当前字节偏移量位置处读取一个 Uint32 值。
         * @returns 读取的 Uint32 值。
         */
        readUint32(): number;
        /**
         * @en Writes the specified Int32 value to the byte stream at the current position.
         * @param value The Int32 value to be written.
         * @zh 在字节流的当前字节偏移量位置处写入指定的 Int32 值。
         * @param value 需要写入的 Int32 值。
         */
        writeInt32(value: number): void;
        /**
         * @en Writes the specified Uint32 value to the byte stream at the current position.
         * @param value The Uint32 value to be written.
         * @zh 在字节流的当前字节偏移量位置处写入 Uint32 值。
         * @param value 需要写入的 Uint32 值。
         */
        writeUint32(value: number): void;
        /**
         * @private
         * @en Reads an Int16 value from the current byte offset in the byte stream.
         * @returns The Int16 value that was read.
         * @zh 从字节流的当前字节偏移量位置处读取一个 Int16 值。
         * @returns 读取的 Int16 值。
         */
        getInt16(): number;
        /**
         * @en Reads an Int16 value from the current byte offset in the byte stream.
         * @returns The Int16 value that was read.
         * @zh 从字节流的当前字节偏移量位置处读取一个 Int16 值。
         * @returns 读取的 Int16 值。
         */
        readInt16(): number;
        /**
         * @private
         * @en Reads a Uint16 value from the current byte offset in the byte stream.
         * @returns The Uint16 value that was read.
         * @zh 从字节流的当前字节偏移量位置处读取一个 Uint16 值。
         * @returns 读取的 Uint16 值。
         */
        getUint16(): number;
        /**
         * @en Reads a Uint16 value from the current byte offset in the byte stream.
         * @returns The Uint16 value that was read.
         * @zh 从字节流的当前字节偏移量位置处读取一个 Uint16 值。
         * @returns 读取的 Uint16 值。
         */
        readUint16(): number;
        /**
         * @en Writes the specified Uint16 value to the byte stream at the current byte offset.
         * @param value The Uint16 value to be written.
         * @zh 在字节流的当前字节偏移量位置处写入指定的 Uint16 值。
         * @param value 需要写入的 Uint16 值。
         */
        writeUint16(value: number): void;
        /**
         * @en Writes the specified Int16 value to the byte stream at the current byte offset.
         * @param value The Int16 value to be written.
         * @zh 在字节流的当前字节偏移量位置处写入指定的 Int16 值。
         * @param value 需要写入的 Int16 值。
         */
        writeInt16(value: number): void;
        /**
         * @private
         * @en Reads a Uint8 value from the current byte offset in the byte stream.
         * @returns The Uint8 value that was read.
         * @zh 从字节流的当前字节偏移量位置处读取一个 Uint8 值。
         * @returns 读取的 Uint8 值。
         */
        getUint8(): number;
        /**
         * @en Reads a Uint8 value from the current byte offset in the byte stream.
         * @returns The Uint8 value that was read.
         * @zh 从字节流的当前字节偏移量位置处读取一个 Uint8 值。
         * @returns 读取的 Uint8 值。
         */
        readUint8(): number;
        /**
         * @en Writes the specified Uint8 value to the byte stream at the current byte offset.
         * @param value The Uint8 value to be written.
         * @zh 在字节流的当前字节偏移量位置处写入指定的 Uint8 值。
         * @param value 需要写入的 Uint8 值。
         */
        writeUint8(value: number): void;
        /**
         * @private
         * 读取指定长度的 UTF 型字符串。
         * @param	len 需要读取的长度。
         * @return 读取的字符串。
         */
        private _rUTF;
        /**
         * @private
         * @en Reads a string of the specified length.
         * @param len The length of the string to read.
         * @returns The string of the specified length.
         * @zh 读取指定长度的字符串。
         * @param len 要读取的字符串的长度。
         * @returns 指定长度的字符串。
         */
        getCustomString(len: number): string;
        /**
         * @private
         * @en Reads a string of the specified length.
         * @param len The length of the string to read.
         * @returns The string of the specified length.
         * @zh 读取指定长度的字符串。
         * @param len 要读取的字符串的长度。
         * @returns 指定长度的字符串。
         */
        readCustomString(len: number): string;
        /**
         * @en The current position of the Byte object's read/write pointer (in bytes).
         * When reading, the next read operation will start at this position. When writing, the next write operation will start at this position.
         * @zh Byte对象的读写指针的当前位置（以字节为单位）。
         * 下一次调用读取方法时将在此位置开始读取，或者下一次调用写入方法时将在此位置开始写入。
         */
        get pos(): number;
        set pos(value: number);
        /**
         * @en The number of bytes available to read from the current position to the end of the byte stream.
         * @zh 从当前位置到字节流末尾可读取的数据的字节数。
         */
        get bytesAvailable(): number;
        /**
         * @en Clears the content of the byte array and resets the length and pos properties to 0. Calling this method will release the memory occupied by the Byte instance.
         * @zh 清除字节数组的内容，并将 length 和 pos 属性重置为 0。调用此方法将释放 Byte 实例占用的内存。
         */
        clear(): void;
        /**
         * @en Writes a UTF-8 string to the byte stream. Similar to the writeUTF() method, but writeUTFBytes() does not prefix the string with a 16-bit length word.
         * The corresponding reading method is getUTFBytes.
         * @param value The string to write.
         * @zh 将 UTF-8 字符串写入字节流。类似于 writeUTF() 方法，但 writeUTFBytes() 不使用 16 位长度的字节为字符串添加前缀。
         * 对应的读取方法为： getUTFBytes 。
         * @param value 要写入的字符串。
         */
        writeUTFBytes(value: string): void;
        /**
         * @en Writes a UTF-8 string to the byte stream. First, the length of the UTF-8 string in bytes is written (as a 16-bit integer), followed by the bytes representing the string characters.
         * The corresponding reading method is getUTFString.
         * @param value The string value to write.
         * @zh 将 UTF-8 字符串写入字节流。先写入以字节表示的 UTF-8 字符串长度（作为 16 位整数），然后写入表示字符串字符的字节。
         * 对应的读取方法为： getUTFString 。
         * @param value 要写入的字符串值。
         */
        writeUTFString(value: string): void;
        /**
         * @en Writes a UTF-8 string to the byte stream. First, the length of the UTF-8 string in bytes is written (as a 32-bit integer), followed by the bytes representing the string characters.
         * @param value The string value to write.
         * @zh 将 UTF-8 字符串写入字节流。先写入以字节表示的 UTF-8 字符串长度（作为 32 位整数），然后写入表示字符串字符的字节。
         * @param value 要写入的字符串值。
         */
        writeUTFString32(value: string): void;
        /**
         * @private
         * @en Reads a UTF-8 string.
         * @returns The read string.
         * @zh 读取 UTF-8 字符串。
         * @returns 读取的字符串。
         */
        readUTFString(): string;
        /**
         * @private
         * @en Reads a UTF-8 string that was written with the writeUTFString32() method.
         * @zh 读取由 writeUTFString32() 方法写入的 UTF-8 字符串。
         */
        readUTFString32(): string;
        /**
         * @en Reads a UTF-8 string from the byte stream, assuming the string is prefixed with an unsigned short indicating the length to read.
         * The corresponding writing method is writeUTFString.
         * @returns The read string.
         * @zh 从字节流中读取一个 UTF-8 字符串，假定字符串的前缀是一个无符号的短整型（以此字节表示要读取的长度）。
         * 对应的写入方法为：writeUTFString。
         * @returns 读取的字符串。
         */
        getUTFString(): string;
        /**
         * @private
         * @en Reads a string that must have been written with the writeUTFBytes method.
         * @param len The length of the buffer to read. If set to -1, all data in the buffer will be read.
         * @returns The read string.
         * @zh 读字符串，必须是 writeUTFBytes 方法写入的字符串。
         * @param len 要读的buffer长度，默认将读取缓冲区全部数据。
         * @returns 读取的字符串。
         */
        readUTFBytes(len?: number): string;
        /**
         * @en Reads a UTF-8 byte sequence of a specified length from the byte stream and returns a string.
         * Typically used to read strings written with the writeUTFBytes method.
         * @param len The length of the buffer to read. If set to -1, all data in the buffer will be read.
         * @returns The read string.
         * @zh 从字节流中读取一个由 length 参数指定的长度的 UTF-8 字节序列，并返回一个字符串。
         * 一般读取的是由 writeUTFBytes 方法写入的字符串。
         * @param len 要读的buffer长度，默认将读取缓冲区全部数据。
         * @returns 读取的字符串。
         */
        getUTFBytes(len?: number): string;
        /**
         * @en Writes a byte to the byte stream. Only the lower 8 bits of the parameter are used. The higher 24 bits are ignored.
         * @param value The byte to write (0-255).
         * @zh 在字节流中写入一个字节。只使用参数的低 8 位。忽略高 24 位。
         * @param value 要写入的字节（0-255）。
         */
        writeByte(value: number): void;
        /**
         * @en Reads a signed byte from the byte stream. The return value is in the range of -128 to 127.
         * @returns An integer between -128 and 127.
         * @zh 从字节流中读取带符号的字节。返回值的范围是从 -128 到 127。
         * @returns 介于 -128 和 127 之间的整数。
         */
        readByte(): number;
        /**
         * @private
         * @en Reads a signed byte from the byte stream.
         * @zh 从字节流中读取带符号的字节。
         */
        getByte(): number;
        /**
         * @en Writes a byte sequence from the specified arraybuffer object into the byte stream, starting at the offset and with the specified length.
         * If the length parameter is omitted, the default length of 0 is used, and the method writes the entire buffer from the offset, if the offset is also omitted, the entire buffer is written.
         * The function will throw an exception if the offset or length is less than 0.
         * @param arraybuffer The ArrayBuffer object to write from.
         * @param offset The offset index of the ArrayBuffer object (in bytes).
         * @param length The length to write from the ArrayBuffer object into the Byte object (in bytes).
         * @zh 将指定 arraybuffer 对象中的以 offset 为起始偏移量，length 为长度的字节序列写入字节流。
         * 如果省略 length 参数，则使用默认长度 0，该方法将从 offset 开始写入整个缓冲区；如果还省略了 offset 参数，则写入整个缓冲区。
         * 如果 offset 或 length 小于0，本函数将抛出异常。
         * @param arraybuffer 需要写入的 Arraybuffer 对象。
         * @param offset Arraybuffer 对象的索引的偏移量（以字节为单位）。
         * @param length 从 Arraybuffer 对象写入到 Byte 对象的长度（以字节为单位）。
         */
        writeArrayBuffer(arraybuffer: any, offset?: number, length?: number): void;
        /**
         * @en Reads an ArrayBuffer of the specified length from the byte stream.
         * @param length The length of the ArrayBuffer to read.
         * @zh 读取ArrayBuffer数据，长度由参数指定。
         * @param length 要读取的ArrayBuffer的长度。
         */
        readArrayBuffer(length: number): ArrayBuffer;
    }
    /**
     * @private
     * @en The Cache Manager is a centralized management class for object caching.
     * @zh 对象缓存统一管理类。
     */
    class CacheManger {
        /**
         * @en The maximum allowable execution time for a single cleanup check, in milliseconds.
         * @zh 单次清理检测允许执行的时间，单位ms。
         */
        static loopTimeLimit: number;
        /**
         * @private
         */
        private static _cacheList;
        /**
         * @private
         * 当前检测的索引
         */
        private static _index;
        constructor();
        /**
         * @en Register a cache management function.
         * @param disposeFunction The function used to dispose of the cache, with the signature fun(force:Boolean).
         * @param getCacheListFunction The function used to retrieve the cache list, with the signature fun():Array.
         * @zh 注册cache管理函数。
         * @param disposeFunction 释放函数， fun(force:Boolean)。
         * @param getCacheListFunction 获取cache列表函数， fun():Array。
         */
        static regCacheByFunction(disposeFunction: Function, getCacheListFunction: Function): void;
        /**
         * @en Unregister a cache management function.
         * @param disposeFunction Release function fun(force:Boolean)
         * @param getCacheListFunction Get cache list function fun():Array
         * @zh 移除cache管理函数。
         * @param disposeFunction 释放函数 fun(force:Boolean)
         * @param getCacheListFunction 获取cache列表函数fun():Array
         */
        static unRegCacheByFunction(disposeFunction: Function, getCacheListFunction: Function): void;
        /**
         * @en Force the disposal of all managed caches.
         * @zh 强制清理所有管理器。
         */
        static forceDispose(): void;
        /**
         * @en Start the check loop with a specified interval time.
         * @param waitTime The interval time between checks, in milliseconds.
         * @zh 开始检测循环。
         * @param waitTime 检测间隔时间，单位毫秒。
         */
        static beginCheck(waitTime?: number): void;
        /**
         * @en Stop the check loop.
         * @zh 停止检测循环。
         */
        static stopCheck(): void;
        /**
         * @private
         * 检测函数
         */
        private static _checkLoop;
    }
    /**
     * @private
     * @en The CallLater class is responsible for managing delayed function calls.
     * @zh CallLater 类用于管理延迟执行的函数调用。
     */
    class CallLater {
        /**
         * @en Instance of CallLater.
         * @zh CallLater的实例。
         */
        static I: CallLater;
        /**@private */
        private _pool;
        /**@private */
        private _map;
        /**@private */
        private _laters;
        /** @private */
        private _getHandler;
        /**
         * @en Delay execution
         * @param caller The execution context (this).
         * @param method Timer callback function.
         * @param args The arguments to be passed to the callback function.
         * @zh 延迟执行。
         * @param caller 执行域（this）。
         * @param method 定时器回调函数。
         * @param args 要传递给回调函数的参数。
         */
        callLater(caller: any, method: Function, args?: any[]): void;
        /**
         * @en Immediately execute a scheduled callLater.
         * @param caller The execution context (this).
         * @param method The callback function to be executed.
         * @zh 立即执行 callLater。
         * @param caller 执行域（this）。
         * @param method 要执行的回调函数。
         */
        runCallLater(caller: any, method: Function): void;
        /**
         * @en Clear the specified callLater.
         * @param caller The execution context (this).
         * @param method The callback function to be cleared.
         * @zh 清除指定的 callLater。
         * @param caller 执行域（this）。
         * @param method 要清除的回调函数。
         */
        clear(caller: any, method: Function): boolean;
        /**
         * @en Clear all scheduled callLater for a specific caller.
         * @param caller The caller object to clear all scheduled calls for.
         * @zh 清除指定执行域中的所有callLater。
         * @param caller 执行域（this）。
         */
        clearAll(caller: any): void;
    }
    /**
     * @en The ClassUtils is a utility class for class operations.
     * @zh ClassUtils 是一个类工具的类。
     */
    class ClassUtils {
        static _classMap: Record<string, any>;
        /**
         * @en Registers a class mapping for easy retrieval during class reflection.
         * @param className The name or alias for the class mapping.
         * @param classDef The full name of the class or a reference to the class.
         * @zh 注册 Class 映射，方便在类反射时获取。
         * @param className 映射的名字或者别名。
         * @param classDef 类的全名或者类的引用，全名比如："laya.Sprite"。
         */
        static regClass(className: string, classDef: any): void;
        /**
         * @en Returns the class object based on the class name.
         * @param className The class name (e.g., "laya.display.Sprite") or a registered alias (e.g., "Sprite").
         * @return The class object.
         * @zh 根据类名返回类对象。
         * @param className 类名（比如 "laya.display.Sprite"）或者注册的别名（比如 "Sprite"）。
         * @return 类对象。
         */
        static getClass(className: string): any;
        /**
         * @en Creates an instance of a class based on the class name.
         * @param className The class name (e.g., "laya.display.Sprite") or a registered alias (e.g., "Sprite").
         * @return An instance of the class.
         * @zh 根据名称创建 Class 实例。
         * @param className 类名（比如 "laya.display.Sprite"）或者注册的别名（比如 "Sprite"）。
         * @return 返回类的实例。
         */
        static getInstance(className: string): any;
    }
    /**
     * @private
     * @en The ColorUtils is a class for color value processing.
     * @zh ColorUtils 是一个用于处理颜色值的类。
     */
    class ColorUtils {
        /**@private */
        static _SAVE: any;
        /**@private */
        static _SAVE_SIZE: number;
        /**@private */
        /**@private */
        private static _DEFAULT;
        /**
         * @en An array representing the color in RGBA format, Value range 0-1
         * @zh 以 RGBA 格式表示颜色的数组，取值范围0-1
         */
        arrColor: any[];
        /**
         * @en The string representation of the color value.
         * @zh 字符串型颜色值。
         */
        strColor: string;
        /**
         * @en The uint representation of the color value.
         * @zh uint 型颜色值。
         */
        numColor: number;
        /**
         * @en Constructor method.
         * @param value The color value, which can be a string (e.g., "#ff0000") or a hexadecimal color (e.g., 0xff0000).
         * @zh 构造方法
         * @param value 颜色值，可以是字符串（例如 "#ff0000"）或16进制颜色值（例如 0xff0000）。
         */
        constructor(value: any);
        /**@private */
        static _initDefault(): any;
        /**
         * @private
         * @en Clears the cache if it gets too large.
         * @zh 如果缓存太大，则清理缓存。
         */
        static _initSaveMap(): void;
        /**
         * @en Creates and returns an instance of the Color class based on the specified color value.
         * @param value The color value, which can be a string (e.g., "#ff0000") or a hexadecimal color (e.g., 0xff0000).
         * @returns An instance of the Color class.
         * @zh 根据指定的颜色值创建并返回一个 Color 类的实例，可以是字符串（例如 "#ff0000"）或16进制颜色值（例如 0xff0000）。
         * @param value 颜色值，可以是字符串："#ff0000"或者16进制颜色 0xff0000。
         * @returns Color 类的一个实例。
         */
        static create(value: any): ColorUtils;
    }
    /**
     * @en Delegate class for managing and invoking callbacks
     * This class provides functionality to add, remove, and invoke callback functions.
     * It supports one-time callbacks and can manage callbacks with different targets and arguments.
     * @zh Delegate类，用于管理和调用回调函数
     * 这个类提供了添加、移除和调用回调函数的功能。
     * 它支持一次性回调，并且可以管理具有不同目标对象和参数的回调函数。
     */
    class Delegate {
        private _flag;
        private _items;
        constructor();
        /**
         * @en Add a callback function
         * @param callback The callback function
         * @param target The target object of the callback
         * @param args Arguments for the callback
         * @zh 添加回调函数
         * @param callback 回调函数
         * @param target 回调函数的目标对象
         * @param args 回调函数的参数
         */
        add(callback: Function, target?: any, args?: any[]): void;
        /**
         * @en Add a callback function that will only be executed once
         * @param callback The callback function
         * @param target The target object of the callback
         * @param args Arguments for the callback
         * @zh 添加只执行一次的回调函数
         * @param callback 回调函数
         * @param target 回调函数的目标对象
         * @param args 回调函数的参数
         */
        once(callback: Function, target?: any, args?: any[]): void;
        /**
         * @en Remove a callback function
         * @param callback The callback function to remove
         * @param target The target object of the callback
         * @zh 移除回调函数
         * @param callback 要移除的回调函数
         * @param target 回调函数的目标对象
         */
        remove(callback: Function, target?: any): void;
        /**
         * @en Clear all callback functions
         * @zh 清除所有回调函数
         */
        clear(): void;
        /**
         * @en Clear all callback functions for a specific target
         * @param target The target object
         * @zh 清除指定目标对象的所有回调函数
         * @param target 目标对象
         */
        clearForTarget(target: any): void;
        /**
         * @en Get the number of callback functions
         * @zh 获取回调函数的数量
         */
        get count(): number;
        /**
         * @en Invoke all callback functions
         * @param args Arguments for the invocation
         * @zh 调用所有回调函数
         * @param args 调用参数
         */
        invoke(...args: any[]): void;
    }
    /**
     * @private
     * @en The `Dragging` class is a touch sliding control.
     * @zh `Dragging` 类是触摸滑动控件。
     */
    class Dragging {
        /**
         * @en The object being dragged.
         * @zh 被拖动的对象。
         */
        target: Sprite;
        /**
         * @en The damping ratio for easing.
         * @zh 缓动衰减系数。
         */
        ratio: number;
        /**
         * @en The maximum offset per frame.
         * @zh 单帧最大偏移量。
         */
        maxOffset: number;
        /**
         * @en The sliding area.
         * @zh 滑动范围。
         */
        area: Rectangle;
        /**
         * @en Indicates whether the dragging has inertia.
         * @zh 表示拖动是否有惯性。
         */
        hasInertia: boolean;
        /**
         * @en The maximum elastic distance.
         * @zh 橡皮筋最大值。
         */
        elasticDistance: number;
        /**
         * @en The time for elastic back in milliseconds.
         * @zh 橡皮筋回弹时间，单位为毫秒。
         */
        elasticBackTime: number;
        /**
         * @en The event data carried along.
         * @zh 事件携带数据。
         */
        data: any;
        private _dragging;
        private _clickOnly;
        private _elasticRateX;
        private _elasticRateY;
        private _lastX;
        private _lastY;
        private _offsetX;
        private _offsetY;
        private _offsets;
        private _tween;
        private _parent;
        /**
         * @en Start dragging.
         * @param target The Sprite object to be dragged.
         * @param area The area within which the object can be dragged.
         * @param hasInertia Indicates whether the dragging has inertia.
         * @param elasticDistance The maximum elastic distance allowed for the drag.
         * @param elasticBackTime The time in milliseconds for the elastic back effect.
         * @param data Any data to be carried with the event.
         * @param ratio The damping ratio for inertia.
         * @zh 开始拖拽。
         * @param target 待拖拽的 Sprite 对象。
         * @param area 滑动范围。
         * @param hasInertia 拖动是否有惯性。
         * @param elasticDistance 橡皮筋最大值。
         * @param elasticBackTime 橡皮筋回弹时间，单位为毫秒。
         * @param data 事件携带数据。
         * @param ratio 惯性阻尼系数。
         */
        start(target: Sprite, area: Rectangle, hasInertia: boolean, elasticDistance: number, elasticBackTime: number, data: any, ratio?: number): void;
        /**
         * 清除计时器。
         */
        private clearTimer;
        /**
         * @en Stop dragging
         * @zh 停止拖拽。
         */
        stop(): void;
        /**
         * 拖拽的循环处理函数。
         */
        private loop;
        /**
         * 拖拽区域检测。
         */
        private checkArea;
        /**
         * 移动至设定的拖拽区域。
         */
        private backToArea;
        /**
         * 舞台的抬起事件侦听函数。
         * @param	e Event 对象。
         */
        private onStageMouseUp;
        /**
         * 橡皮筋效果检测。
         */
        private checkElastic;
        /**
         * 移动。
         */
        private tweenMove;
        /**
         * 结束拖拽。
         */
        private clear;
    }
    /**
     * @en The `Ease` class defines easing functions for Tween animations to achieve various transition effects.
     * @zh `Ease` 类定义了缓动函数，用于实现 Tween 动画的缓动效果，以便于创建各种转换效果。
     */
    class Ease {
        /**
         * @en Define continuous motion without acceleration.
         * @param t Current time between 0 and the duration (inclusive).
         * @param b The initial value of the animated property.
         * @param c The total change in the animated property.
         * @param d The duration of the motion.
         * @returns The value of the interpolated property at the specified time.
         * @zh 定义无加速持续运动。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static linearNone(t: number, b: number, c: number, d: number): number;
        /**
         * @en Define continuous motion without acceleration.
         * @param t Current time between 0 and the duration (inclusive).
         * @param b The initial value of the animated property.
         * @param c The total change in the animated property.
         * @param d The duration of the motion.
         * @returns The value of the interpolated property at the specified time.
         * @zh 定义无加速持续运动。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static linearIn(t: number, b: number, c: number, d: number): number;
        /**
         * @en Define continuous motion without acceleration.
         * @param t Current time between 0 and the duration (inclusive).
         * @param b The initial value of the animated property.
         * @param c The total change in the animated property.
         * @param d The duration of the motion.
         * @returns The value of the interpolated property at the specified time.
         * @zh 定义无加速持续运动。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static linearInOut(t: number, b: number, c: number, d: number): number;
        /**
         * @en Define continuous motion without acceleration.
         * @param t Current time between 0 and the duration (inclusive).
         * @param b The initial value of the animated property.
         * @param c The total change in the animated property.
         * @param d The duration of the motion.
         * @returns The value of the interpolated property at the specified time.
         * @zh 定义无加速持续运动。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static linearOut(t: number, b: number, c: number, d: number): number;
        /**
         * @en Starts the motion with zero velocity, then accelerates the motion.
         * The motion is similar to a ball falling towards the floor and bouncing back with decreasing rebounds.
         * @param t Current time between 0 and the duration (inclusive).
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @returns The value of the interpolated property at the specified time.
         * @zh 方法以零速率开始运动，然后在执行时加快运动速度。
         * 它的运动是类似一个球落向地板又弹起后，几次逐渐减小的回弹运动。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static bounceIn(t: number, b: number, c: number, d: number): number;
        /**
         * @en Starts the motion with zero velocity, accelerates, and then decelerates to zero velocity.
         * The motion is similar to a ball falling towards the floor and bouncing back with decreasing rebounds.
         * @param t Current time between 0 and the duration (inclusive).
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @returns The value of the interpolated property at the specified time.
         * @zh 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * 它的运动是类似一个球落向地板又弹起后，几次逐渐减小的回弹运动。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static bounceInOut(t: number, b: number, c: number, d: number): number;
        /**
         * @en Begins the motion at a faster velocity, then decelerates until the velocity is zero.
         * The motion is similar to a ball falling towards the floor and bouncing back with decreasing rebounds.
         * @param t Current time between 0 and the duration (inclusive).
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @returns The value of the interpolated property at the specified time.
         * @zh 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * 它的运动是类似一个球落向地板又弹起后，几次逐渐减小的回弹运动。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static bounceOut(t: number, b: number, c: number, d: number): number;
        /**
         * @en Starts the motion with a backward movement, then moves towards the target in the opposite direction, overshoots, and then returns.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animation property at the start.
         * @param c The total change in the property's value that occurs during the animation.
         * @param d The total duration of the motion.
         * @param s The overshoot amount. The larger the value, the greater the overshoot.
         * @returns The value of the interpolation attribute for the specified time.
         * @zh 开始时往后运动，然后反向朝目标移动。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @param	s 指定过冲量，此处数值越大，过冲越大。
         * @return 指定时间的插补属性的值。
         */
        static backIn(t: number, b: number, c: number, d: number, s?: number): number;
        /**
         * @en Starts the motion with a backward movement, then moves towards the target, overshoots slightly, reverses direction again, and finally moves towards the target.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animation property at the start.
         * @param c The total change in the property's value that occurs during the animation.
         * @param d The total duration of the motion.
         * @param s The overshoot amount. The larger the value, the greater the overshoot.
         * @returns The value of the interpolation attribute for the specified time.
         * @zh 开始运动时是向后跟踪，再倒转方向并朝目标移动，稍微过冲目标，然后再次倒转方向，回来朝目标移动。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @param	s 指定过冲量，此处数值越大，过冲越大。
         * @return 指定时间的插补属性的值。
         */
        static backInOut(t: number, b: number, c: number, d: number, s?: number): number;
        /**
         * @en Starts the motion towards the target, overshoots slightly, then reverses direction and moves back towards the target.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animation property at the start.
         * @param c The total change in the property's value that occurs during the animation.
         * @param d The total duration of the motion.
         * @param s The overshoot amount. The larger the value, the greater the overshoot.
         * @returns The value of the interpolation attribute for the specified time.
         * @zh 开始运动时是朝目标移动，稍微过冲，再倒转方向回来朝着目标。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @param	s 指定过冲量，此处数值越大，过冲越大。
         * @return 指定时间的插补属性的值。
         */
        static backOut(t: number, b: number, c: number, d: number, s?: number): number;
        /**
         * @en Starts the motion from zero velocity, then accelerates.
         * The motion is defined by a sine wave that elastically decays in an exponential manner.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @param a The amplitude of the sine wave.
         * @param p The period of the sine wave in milliseconds.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 方法以零速率开始运动，然后在执行时加快运动速度。
         * 其中的运动由按照指数方式衰减的正弦波来定义。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @param	a 指定正弦波的幅度。
         * @param	p 指定正弦波的周期。
         * @return 指定时间的插补属性的值。
         */
        static elasticIn(t: number, b: number, c: number, d: number, a?: number, p?: number): number;
        /**
         * @en Starts the motion with zero velocity, accelerates, and then decelerates to zero velocity.
         * The motion is defined by a sine wave that elastically decays in an exponential manner.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @param a The amplitude of the sine wave.
         * @param p The period of the sine wave in milliseconds.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * 其中的运动由按照指数方式衰减的正弦波来定义。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @param	a 指定正弦波的幅度。
         * @param	p 指定正弦波的周期。
         * @return 指定时间的插补属性的值。
         */
        static elasticInOut(t: number, b: number, c: number, d: number, a?: number, p?: number): number;
        /**
         * @en Starts the motion at a faster velocity, then decelerates until the velocity reaches zero.
         * The motion is defined by a sine wave that decays in an exponential manner.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @param a The amplitude of the sine wave.
         * @param p The period of the sine wave in milliseconds.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * 其中的运动由按照指数方式衰减的正弦波来定义。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @param	a 指定正弦波的幅度。
         * @param	p 指定正弦波的周期。
         * @return 指定时间的插补属性的值。
         */
        static elasticOut(t: number, b: number, c: number, d: number, a?: number, p?: number): number;
        /**
         * @en Starts the motion from zero velocity and then accelerates rapidly.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 以零速率开始运动，然后在执行时加快运动速度。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static strongIn(t: number, b: number, c: number, d: number): number;
        /**
         * @en At the beginning of the motion, the velocity is zero. Accelerate the motion first, then decelerate until the velocity is zero.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static strongInOut(t: number, b: number, c: number, d: number): number;
        /**
         * @en Start moving at a faster speed, then slow down the motion speed during execution until the speed reaches zero.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static strongOut(t: number, b: number, c: number, d: number): number;
        /**
         * @en Starts the motion with zero velocity, accelerates the motion, and then decelerates to zero velocity.
         * The motion acceleration in the Sine slow motion equation is smaller than that in the Quad equation.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * Sine 缓动方程中的运动加速度小于 Quad 方程中的运动加速度。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static sineInOut(t: number, b: number, c: number, d: number): number;
        /**
         * @en Starts the motion from zero velocity, then accelerates the motion.
         * The motion acceleration in the Sine slow motion equation is smaller than that in the Quad equation.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 以零速率开始运动，然后在执行时加快运动速度。
         * Sine 缓动方程中的运动加速度小于 Quad 方程中的运动加速度。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static sineIn(t: number, b: number, c: number, d: number): number;
        /**
         * @en Starts the motion at a faster pace, then decelerates until the velocity reaches zero.
         * The motion acceleration in the Sine slow motion equation is smaller than that in the Quad equation.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * Sine 缓动方程中的运动加速度小于 Quad 方程中的运动加速度。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static sineOut(t: number, b: number, c: number, d: number): number;
        /**
         * @en Start moving at zero speed and then accelerate the motion speed during execution.
         * The motion acceleration of the Quint slow motion equation is greater than that of the Quart slow motion equation.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 以零速率开始运动，然后在执行时加快运动速度。
         * Quint 缓动方程的运动加速大于 Quart 缓动方程。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static quintIn(t: number, b: number, c: number, d: number): number;
        /**
         * @en At the beginning of the motion, the velocity is zero. Accelerate the motion first, then decelerate until the velocity is zero.
         * The motion acceleration of the Quint slow motion equation is greater than that of the Quart slow motion equation.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * Quint 缓动方程的运动加速大于 Quart 缓动方程。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static quintInOut(t: number, b: number, c: number, d: number): number;
        /**
         * @en Start moving at a faster speed, then slow down the motion speed during execution until the speed reaches zero.
         * The motion acceleration of the Quint slow motion equation is greater than that of the Quart slow motion equation.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * Quint 缓动方程的运动加速大于 Quart 缓动方程。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static quintOut(t: number, b: number, c: number, d: number): number;
        /**
         * @en The method starts at zero speed and then accelerates the motion speed during execution.
         * The motion acceleration of the Quart slow motion equation is greater than that of the Cubic slow motion equation.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 方法以零速率开始运动，然后在执行时加快运动速度。
         * Quart 缓动方程的运动加速大于 Cubic 缓动方程。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static quartIn(t: number, b: number, c: number, d: number): number;
        /**
         * @en At the beginning of the motion, the velocity is zero. Accelerate the motion first, then decelerate until the velocity is zero.
         * The motion acceleration of the Quart slow motion equation is greater than that of the Cubic slow motion equation.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * Quart 缓动方程的运动加速大于 Cubic 缓动方程。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static quartInOut(t: number, b: number, c: number, d: number): number;
        /**
         * @en Start moving at a faster speed, then slow down the motion speed during execution until the speed reaches zero.
         * The motion acceleration of the Quart slow motion equation is greater than that of the Cubic slow motion equation.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * Quart 缓动方程的运动加速大于 Cubic 缓动方程。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static quartOut(t: number, b: number, c: number, d: number): number;
        /**
         * @en The method starts at zero speed and then accelerates the motion speed during execution.
         * The motion acceleration of the Quart slow motion equation is greater than that of the Cubic slow motion equation.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 方法以零速率开始运动，然后在执行时加快运动速度。
         * Cubic 缓动方程的运动加速大于 Quad 缓动方程。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static cubicIn(t: number, b: number, c: number, d: number): number;
        /**
         * @en At the beginning of the motion, the velocity is zero. Accelerate the motion first, then decelerate until the velocity is zero.
         * The motion acceleration of the Quart slow motion equation is greater than that of the Cubic slow motion equation.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * Cubic 缓动方程的运动加速大于 Quad 缓动方程。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static cubicInOut(t: number, b: number, c: number, d: number): number;
        /**
         * @en Start moving at a faster speed, then slow down the motion speed during execution until the speed reaches zero.
         * The motion acceleration of the Quart slow motion equation is greater than that of the Cubic slow motion equation.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * Cubic 缓动方程的运动加速大于 Quad 缓动方程。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static cubicOut(t: number, b: number, c: number, d: number): number;
        /**
         * @en The method starts at zero speed and then accelerates the motion speed during execution.
         * The motion acceleration in the Quad deceleration equation is equal to the motion acceleration between the 100% deceleration time axis and is significantly smaller than the motion acceleration in the Cubic deceleration equation.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 方法以零速率开始运动，然后在执行时加快运动速度。
         * Quad 缓动方程中的运动加速度等于 100% 缓动的时间轴补间的运动加速度，并且显著小于 Cubic 缓动方程中的运动加速度。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static quadIn(t: number, b: number, c: number, d: number): number;
        /**
         * @en Starts the motion with zero velocity, accelerates the motion, and then decelerates to zero velocity.
         * The motion acceleration in the Quad deceleration equation is equal to the motion acceleration between the 100% deceleration time axis and is significantly smaller than the motion acceleration in the Cubic deceleration equation.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * Quad 缓动方程中的运动加速度等于 100% 缓动的时间轴补间的运动加速度，并且显著小于 Cubic 缓动方程中的运动加速度。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static quadInOut(t: number, b: number, c: number, d: number): number;
        /**
         * @en Start moving at a faster speed, then slow down the motion speed during execution until the speed reaches zero.
         * The motion acceleration in the Quad deceleration equation is equal to the motion acceleration between the 100% deceleration time axis and is significantly smaller than the motion acceleration in the Cubic deceleration equation.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * Quad 缓动方程中的运动加速度等于 100% 缓动的时间轴补间的运动加速度，并且显著小于 Cubic 缓动方程中的运动加速度。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static quadOut(t: number, b: number, c: number, d: number): number;
        /**
         * @en Starts the motion with zero velocity, then accelerates the motion.
         * Each time interval is the remaining distance minus a fixed proportion.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 方法以零速率开始运动，然后在执行时加快运动速度。
         * 其中每个时间间隔是剩余距离减去一个固定比例部分。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static expoIn(t: number, b: number, c: number, d: number): number;
        /**
         * @en At the beginning of the motion, the velocity is zero. Accelerate the motion first, then decelerate until the velocity is zero.
         * Each time interval is the remaining distance minus a fixed proportion.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * 其中每个时间间隔是剩余距离减去一个固定比例部分。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static expoInOut(t: number, b: number, c: number, d: number): number;
        /**
         * @en Start moving at a faster speed, then slow down the motion speed during execution until the speed reaches zero.
         * Each time interval is the remaining distance minus a fixed proportion.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * 其中每个时间间隔是剩余距离减去一个固定比例部分。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static expoOut(t: number, b: number, c: number, d: number): number;
        /**
         * @en The method starts at zero speed and then accelerates the motion speed during execution.
         * The acceleration of the slow motion equation will result in a sudden change in velocity.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 方法以零速率开始运动，然后在执行时加快运动速度。
         * 缓动方程的运动加速会产生突然的速率变化。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static circIn(t: number, b: number, c: number, d: number): number;
        /**
         * @en At the beginning of the motion, the velocity is zero. Accelerate the motion first, then decelerate until the velocity is zero.
         * The acceleration of the slow motion equation will result in a sudden change in velocity.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * 缓动方程的运动加速会产生突然的速率变化。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static circInOut(t: number, b: number, c: number, d: number): number;
        /**
         * @en Start moving at a faster speed, then slow down the motion speed during execution until the speed reaches zero.
         * The acceleration of the slow motion equation will result in a sudden change in velocity.
         * @param t Current time between 0 and the duration, inclusive.
         * @param b The initial value of the animated property.
         * @param c The total change in the property's value.
         * @param d The duration of the motion.
         * @return The value of the interpolation attribute for the specified time.
         * @zh 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * 缓动方程的运动加速会产生突然的速率变化。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static circOut(t: number, b: number, c: number, d: number): number;
    }
    class NotImplementedError extends Error {
        constructor();
    }
    class OutOfRangeError extends Error {
        constructor(index: number);
    }
    class NotReadableError extends Error {
        constructor();
    }
    /**
     * @en Set the font format and parse the fontInfo.
     * @zh 设置字体格式与解析字体模型。
     */
    class FontInfo {
        private static _cache;
        /**
         * @en Parses a font string into a FontInfo object.
         * @param font The font string to parse.
         * @zh 解析字体字符串为 FontInfo 对象。
         * @param font 要解析的字体字符串
         */
        static parse(font: string): FontInfo;
        constructor(font: string | null);
        /**
         * @en Sets the font format based on the given value string.
         * @param value The font value string to set.
         * @zh 根据给定的值字符串设置字体格式。
         * @param value 要设置的字体值字符串。
         */
        setFont(value: string): void;
    }
    /**
     * @en The HalfFloatUtils class is used to create the HalfFloat tool.
     * @zh HalfFloatUtils 类用于创建HalfFloat工具。
     */
    class HalfFloatUtils {
        /**
         * @en round a number to a half float number bits.
         * @param num The number to round.
         * @zh 将数字四舍五入到最接近的半浮点数。
         * @param num 要舍入的数字。
         */
        static roundToFloat16Bits(num: number): number;
        /**
         * @en Converts a half-precision floating-point number in bits to a JavaScript number.
         * @param float16bits  half float number bits
         * @zh 将半精度浮点数的位转换为 JavaScript 数字。
         * @param float16bits 半精度浮点数
         */
        static convertToNumber(float16bits: number): number;
    }
    /**
     * @en The `Handler` class is an event handler class.
     * It is recommended to create a `Handler` object from the object pool using the `Handler.create()` method to reduce the overhead of object creation. When a `Handler` object is no longer needed, it can be recovered to the object pool using `Handler.recover()`. Do not use this object after recovery, as doing so may lead to unpredictable errors.
     * Note: Since mouse events also use this object pool, improper recovery and invocation may affect the execution of mouse events.
     * @zh Handler 是事件处理器类。
     * 推荐使用 Handler.create() 方法从对象池创建，减少对象创建消耗。创建的 Handler 对象不再使用后，可以使用 Handler.recover() 将其回收到对象池，回收后不要再使用此对象，否则会导致不可预料的错误。
     * 注意：由于鼠标事件也用本对象池，不正确的回收及调用，可能会影响鼠标事件的执行。
     */
    class Handler {
        /**@private handler对象池*/
        protected static _pool: Handler[];
        /**@private */
        private static _gid;
        /**
         * @en The scope of the object (this).
         * @zh 执行域(this)。
         */
        caller: Object | null;
        /**
         * @en The handling method.
         * @zh 处理方法。
         */
        method: Function | null;
        /**
         * @en Arguments passed to the handler method.
         * @zh 参数。
         */
        args: any[] | null;
        /**
         * @en Indicates whether the handler should be executed only once. If true, the handler will be recovered after execution.After recycling, it will be reused, default to false.
         * @zh 表示是否只执行一次。如果为true，回调后执行recover()进行回收。回收后会被再利用，默认为false
         */
        once: boolean;
        /**@private */
        protected _id: number;
        /**
         * @en Constructor method.
         * @param caller The execution context.
         * @param method The handling function.
         * @param args Function arguments.
         * @param once Whether it should be executed only once.
         * @zh 构造方法
         * @param caller 执行域。
         * @param method 处理函数。
         * @param args 函数参数。
         * @param once 是否只执行一次。
         */
        constructor(caller?: Object | null, method?: Function | null, args?: any[] | null, once?: boolean);
        /**
         * @en Sets the specified property values for this object.
         * @param caller The scope of the object (this).
         * @param method The callback method.
         * @param args The arguments to be passed to the method.
         * @param once Whether the handler should be executed only once. If true, the handler will be recovered after execution.
         * @returns Returns the handler itself.
         * @zh 设置此对象的指定属性值。
         * @param caller 执行域(this)。
         * @param method 回调方法。
         * @param args 携带的参数。
         * @param once 是否只执行一次，如果为true，执行后执行recover()进行回收。
         * @returns 返回 handler 本身。
         */
        setTo(caller: any, method: Function | null, args: any[] | null, once?: boolean): Handler;
        /**
         * @en Executes the handler.
         * @zh 执行处理器。
         */
        run(): any;
        /**
         * @en Executes the handler with additional data.
         * @param data Additional callback data, can be a single data or an Array (as multiple arguments).
         * @zh 执行处理器，并携带额外数据。
         * @param data 附加的回调数据，可以是单个数据或者数组（作为多参）。
         */
        runWith(data: any): any;
        /**
         * @en Clears the references of the object.
         * @zh 清理对象引用。
         */
        clear(): Handler;
        /**
         * @en Clears the handler and recovers it to the Handler object pool.
         * @zh 清理并回收到 Handler 对象池内。
         */
        recover(): void;
        /**
         * @en Creates a Handler from the object pool. By default, the handler will execute once and then be recovered immediately. If automatic recovery is not desired, set the `once` parameter to false.
         * @param caller The scope of the object (this).
         * @param method The callback method.
         * @param args The arguments to be passed to the callback method.
         * @param once Whether the handler should be executed only once. If true, the handler will be recovered after execution.
         * @returns Return the created handler instance.
         * @zh 从对象池内创建一个 Handler，默认会执行一次并立即回收。如果不需要自动回收，设置 `once` 参数为 false。
         * @param caller 执行域(this)。
         * @param method 回调方法。
         * @param args 回调方法的参数。
         * @param once 是否只执行一次，如果为true，回调后执行 recover() 进行回收，默认为true。
         * @return 返回创建的handler实例。
         */
        static create(caller: any, method: Function | null, args?: any[] | null, once?: boolean): Handler;
    }
    /**
     * @en The `HitArea` class represents a mouse click area that can be defined by a series of vector shapes for clickable and non-clickable regions (currently only supports circles, rectangles, and polygons).
     * @zh `HitArea` 类表示一个鼠标点击区域，可以通过一系列矢量图形定义为可点击和非可点击区域（目前仅支持圆形、矩形和多边形）。
     */
    class HitArea implements IHitArea {
        /**
         * @en Checks whether the object contains a specified point.
         * @param x The x-coordinate of the point (horizontal position).
         * @param y The y-coordinate of the point (vertical position).
         * @param sp The Sprite object that contains the point.
         * @returns true if the object contains the specified point; otherwise false.
         * @zh 检测对象是否包含指定的点。
         * @param x 点的 X 轴坐标值（水平位置）。
         * @param y 点的 Y 轴坐标值（垂直位置）。
         * @param sp 包含该点的 Sprite 对象。
         * @returns 如果包含指定的点，则值为 true；否则为 false。
         */
        contains(x: number, y: number, sp: Sprite): boolean;
        /**
         * @en The Graphics object that defines the clickable area.(currently only supports circles, rectangles, and polygons).
         * @zh 定义可点击区域的 Graphics 对象。（目前只支持圆形，矩形，多边形）
         */
        get hit(): Graphics;
        set hit(value: Graphics);
        /**
         * @en The Graphics object that defines the non-clickable area,(currently only supports circles, rectangles, and polygons).
         * @zh 定义不可点击区域的 Graphics 对象。（目前只支持圆形，矩形，多边形）
         */
        get unHit(): Graphics;
        set unHit(value: Graphics);
        /**
         * @en Called after deserialization.
         * @zh 序列化后调用。
         */
        onAfterDeserialize(): void;
    }
    /**
     * @private
     * @en IClone resource cloning interface.
     * @zh IClone 资源克隆接口。
     */
    interface IClone {
        clone(): any;
        cloneTo(destObject: any): void;
    }
    interface IHitArea {
        contains(x: number, y: number, sp?: Sprite): boolean;
    }
    /**
     * @en Image binary processing class
     * @zh 图片二进制处理类
     */
    class ImgUtils {
        /**
         * @en Storage data pool
         * @zh 存储数据池
         */
        static data: any;
        /**
         * @en Whether to save the used data
         * @zh 是否保存使用的数据
         */
        static isSavaData: boolean;
        /**
         * 比较版本内容
         * @param curVersion 当前版本
         * @param needVersion 要求的版本
         * @returns
         */
        private static compareVersion;
        /**
         * @en Checks if data preprocessing is supported.
         * @zh 检查是否支持数据预处理。
         */
        static get isSupport(): boolean;
        /**
         * @en Gets a URL object from an ArrayBuffer.
         * @param url The base URL string.
         * @param arrayBuffer The ArrayBuffer to convert.
         * @returns A new URL string representing the binary data.
         * @zh 从 ArrayBuffer 获取 URL 对象。
         * @param url 基础 URL 字符串。
         * @param arrayBuffer 要转换的 ArrayBuffer。
         * @returns 表示二进制数据的新 URL 字符串。
         */
        static arrayBufferToURL(url: string, arrayBuffer: ArrayBuffer): any;
        static _arrayBufferToURL(arrayBuffer: ArrayBuffer): string;
        /**
         * @en Destroys the binary memory data associated with a specified URL.
         * @param url The URL to destroy the binary data for.
         * @zh 销毁与指定 URL 相关联的二进制内存数据。
         * @param url 要销毁二进制数据的 URL。
         */
        static destroy(url: string): void;
    }
    type StatUnit = "M" | "K" | "int";
    type StatColor = "yellow" | "white" | "red";
    type StatMode = "summit" | "average";
    interface StatUIParams {
        title: string;
        value: string;
        color: StatColor;
        units: StatUnit;
        mode: StatMode;
    }
    interface StatToggleUIParams {
        title: string;
        value: string;
        color: StatColor;
    }
    /**
     * @en Interface for displaying and managing performance statistics.
     * @zh 用于显示和管理性能统计信息的接口。
     */
    interface IStatUI {
        /**
         * @en Displays performance statistics.
         * @param x The X-axis display position.
         * @param y The Y-axis display position.
         * @param views The array of views to be displayed.
         * @zh 显示性能统计信息。
         * @param x X轴显示位置。
         * @param y Y轴显示位置。
         * @param views 显示的视图数组。
         */
        show(x?: number, y?: number, views?: Array<StatUIParams>): void;
        /**
         * @en Toggles the display of performance statistics.
         * @param x The X-axis display position.
         * @param y The Y-axis display position.
         * @param views The array of views to be toggled.
         * @zh 切换性能统计信息的显示。
         * @param x X轴显示位置。
         * @param y Y轴显示位置。
         * @param views 切换的视图数组。
         */
        showToggle(x?: number, y?: number, views?: Array<StatToggleUIParams>): void;
        /**
         * @en Hides performance statistics.
         * @zh 隐藏性能统计信息。
         */
        hide(): void;
        /**
         * @en Interface for updating each frame.
         * @zh 每帧更新的调用接口。
         */
        update(): void;
        /**
        * @en Rendering interface.
        * @param ctx The rendering context.
        * @param x The X-axis position.
        * @param y The Y-axis position.
        * @zh 渲染接口。
        * @param ctx 渲染上下文。
        * @param x X轴位置。
        * @param y Y轴位置。
        */
        render(ctx: any, x: number, y: number): void;
    }
    /**
     * @en The `Log` class is used to display log information in the interface.
     * Note: This cannot be used in the LayaAir Native Runtime.
     * @zh `Log` 类用于在界面内显示日志记录信息。
     * 注意：在LayaAir Native Runtime内不可使用
     */
    class Log {
        /**@private */
        private static _logdiv;
        /**@private */
        private static _btn;
        /**@private */
        private static _count;
        /**
         * @en Maximum number of log messages to display before auto-cleaning.
         * @zh 最大打印数量，超过这个数量则自动清理一次，默认为50次。
         */
        static maxCount: number;
        /**
         * @en Whether to automatically scroll to the bottom of the log.
         * @zh 是否自动滚动到日志底部，默认为true。
         */
        static autoScrollToBottom: boolean;
        /**
         * @en Enables the Log system.
         * @zh 启用Log系统
         */
        static enable(): void;
        /**
         * @en Hides or shows the log panel.
         * @zh 隐藏或显示日志面板。
         */
        static toggle(): void;
        /**
         * @en Adds log content.
         * @param value The log content to add.
         * @zh 增加日志内容。
         * @param value 需要增加的日志内容。
         */
        static print(value: string): void;
        /**
         * @en Clears the log.
         * @zh 清理日志。
         */
        static clear(): void;
    }
    /**
     * @en The `Mouse` class is used to control the style of the mouse cursor.
     * @zh `Mouse` 类用于控制鼠标光标的样式。
     */
    class Mouse {
        /**@private */
        private static _style;
        /**@private */
        private static _preCursor;
        /**
         * @en Sets the style of the mouse cursor.
         * @param cursorStr The cursor style string.
         * For example: auto | move | no-drop | col-resize | all-scroll | pointer | not-allowed | row-resize | crosshair | progress | e-resize | ne-resize | default | text | n-resize | nw-resize | help | vertical-text | s-resize | se-resize | inherit | wait | w-resize | sw-resize
         * @zh 设置鼠标样式
         * @param cursorStr 光标样式字符串。
         * 例如：auto | move | no-drop | col-resize | all-scroll | pointer | not-allowed | row-resize | crosshair | progress | e-resize | ne-resize | default | text | n-resize | nw-resize | help | vertical-text | s-resize | se-resize | inherit | wait | w-resize | sw-resize
         */
        static set cursor(cursorStr: string);
        /**
         * @en The current style of the mouse cursor.
         * @zh 当前鼠标光标的样式。
         */
        static get cursor(): string;
        /**
         * @en Hides the mouse cursor.
         * @zh 隐藏鼠标光标。
         */
        static hide(): void;
        /**
         * @en Shows the mouse cursor.
         * @zh 显示鼠标光标。
         */
        static show(): void;
    }
    /**
     * @en A utility class for parsing JSON strings.
     * @zh 用于解析 JSON 字符串的实用工具类。
     */
    class ParseJSON {
        static parse(str: string): any;
        private static findIndex;
        private static finCurrObj;
        private static formatVal;
        private static len;
        private static ret;
        private static currStr;
        private static currArr;
        private static cobj;
        /**type为0代表没有找到任何状态，1为当前在寻找key，2为当前在寻找val */
        private static type;
        private static finCurrStr;
        private static parseStart;
    }
    /**
     * @en The `Pool` class is an object pooling class used for storing and reusing objects.
     * Reasonable use of the object pool can effectively reduce the overhead of object creation, avoid frequent garbage collection, and thus optimize the smoothness of the game.
     * @zh `Pool` 是对象池类，用于对象的存储和复用。
     * 合理使用对象池可以有效减少对象创建的开销，避免频繁的垃圾回收，从而优化游戏流畅度。
     */
    class Pool {
        /**@private */
        private static _CLSID;
        /**@private */
        private static POOLSIGN;
        /**@private  对象存放池。*/
        private static _poolDic;
        /**
         * @en Get the object pool based on the object type signature.
         * @param sign The object type signature.
         * @returns The object pool.
         * @zh 根据对象类型标识字符获取对象池。
         * @param sign 对象类型标识字符。
         * @returns 对象池。
         */
        static getPoolBySign(sign: string): any[];
        /**
         * @en Clear the objects in the object pool.
         * @param sign The object type signature.
         * @zh 清除对象池中的对象。
         * @param sign 对象类型标识字符。
         */
        static clearBySign(sign: string): void;
        /**
         * @en Put the object into the object pool of the corresponding type signature.
         * @param sign The object type signature.
         * @param item The object.
         * @zh 将对象放到对应类型标识的对象池中。
         * @param sign 对象类型标识字符。
         * @param item 对象。
         */
        static recover(sign: string, item: any): void;
        /**
         * @en Recover by class name if the class has one, if not, do not recover.
         * @param instance The instance of the class.
         * @zh 根据类名进行回收，如果类有类名才进行回收，没有则不回收。
         * @param instance 类的具体实例。
         */
        static recoverByClass(instance: any): void;
        /**
         * 返回类的唯一标识
         */
        private static _getClassSign;
        /**
         * @en Create an object by class.
         * @param cls The class for creating the object.
         * @zh 根据类创建对象。
         * @param cls 用于创建对象的类。
         */
        static createByClass<T>(cls: new () => T): T;
        /**
         * @en Get an object instance of a certain type from the object pool.
         * If there is no object of this type in the pool, a new object will be created and returned.
         * @param sign The object type signature.
         * @param cls The class used to create the object of this type.
         * @returns An object of the specified type.
         * @zh 根据传入的对象类型标识字符，获取对象池中此类型标识的一个对象实例。
         * 如果对象池中无此类型标识的对象时，则根据传入的类型，创建一个新的对象返回。
         * @param sign 对象类型标识字符。
         * @param cls 用于创建该类型对象的类。
         * @returns 此类型标识的一个对象。
         */
        static getItemByClass<T>(sign: string, cls: new () => T): T;
        /**
         * @en Get an object instance of a certain type from the object pool using a creation function.
         * If there is no object of this type in the pool, a new object will be created using the function and returned.
         * @param sign The object type signature.
         * @param createFun The function used to create the object of this type.
         * @param caller The `this` context for the creation function.
         * @returns An object of the specified type.
         * @zh 根据传入的对象类型标识字符和创建函数，获取对象池中此类型标识的一个对象实例。
         * 如果对象池中无此类型标识的对象时，则使用传入的创建此类型对象的函数，新建一个对象返回。
         * @param sign 对象类型标识字符。
         * @param createFun 用于创建该类型对象的方法。
         * @param caller this对象。
         * @returns 此类型标识的一个对象。
         */
        static getItemByCreateFun(sign: string, createFun: Function, caller?: any): any;
        /**
         * @en Get an object from the object pool by the object type signature. If there is no object of this type in the pool, return null.
         * @param sign The object type signature.
         * @returns An object of the specified type or null if none is available.
         * @zh 根据传入的对象类型标识字符，获取对象池中已存储的此类型的一个对象，如果对象池中无此类型的对象，则返回 null。
         * @param sign 对象类型标识字符。
         * @returns 对象池中此类型的一个对象，如果对象池中无此类型的对象，则返回 null。
         */
        static getItem(sign: string): any;
    }
    /**
     * @private
     * @en A manager for object caching based on a count limit.
     * @zh 基于个数的对象缓存管理器
     */
    class PoolCache {
        /**
         * @en The identifier for objects within the Pool.
         * @zh 对象在Pool中的标识。
         */
        sign: string;
        /**
         * @en The maximum number of objects allowed in the cache.
         * @zh 允许缓存的最大数量。
         */
        maxCount: number;
        /**
         * @en Get the list of cached objects.
         * @zh 获取缓存的对象列表。
         */
        getCacheList(): any[];
        /**
         * @en Attempt to clear the cache.
         * @param force If true, force the cache to be cleared.
         * @zh 尝试清理缓存。
         * @param force 如果为 true，则强制清理缓存。
         */
        tryDispose(force: boolean): void;
        /**
         * @en Add a manager for object caching to the pool.
         * @param sign The identifier for objects within the Pool.
         * @param maxCount The maximum number of objects allowed in the cache. Defaults to 100 if not provided.
         * @zh 向池中添加对象缓存管理器。
         * @param sign 对象在Pool中的标识
         * @param maxCount 允许缓存的最大数量，默认为100
         */
        static addPoolCacheManager(sign: string, maxCount?: number): void;
    }
    /**
     * @private
     */
    class RunDriver {
        /**
         * @en Static method to change the width and height of the WebGL context.
         * @zh 用于改变 WebGL宽高信息。
         */
        static changeWebGLSize: Function;
    }
    /**
     * @en The `SingletonList` class is designed to implement a singleton queue.
     * @zh SingletonList 类用于实现单例队列。
     */
    class SingletonList<T> {
        constructor();
        /**
         * @en Finds the index of an element in the list.
         * @param element The element to find.
         * @zh 在列表中查找元素的索引。
         * @param element 要查找的元素。
         */
        indexof(element: T): number;
        /**
         * @en Destroys the list by nullifying the elements array.
         * @zh 通过将元素数组置为 null 来销毁列表。
         */
        destroy(): void;
    }
    class FastSinglelist<T> extends SingletonList<T> {
    }
    class SpriteUtils {
        /**
         * @private
         * @en Returns the smallest rectangular area object composed of two points on the stage coordinate system for the given display object Sprite.
         * @param sprite The display object Sprite.
         * @param x0 The X-axis coordinate of the first point.
         * @param y0 The Y-axis coordinate of the first point.
         * @param x1 The X-axis coordinate of the second point.
         * @param y1 The Y-axis coordinate of the second point.
         * @return The rectangle object Rectangle composed of the two points on the stage coordinate system.
         * @zh 根据传入的显示对象 Sprite 和此显示对象上的两个点，返回这两点在舞台坐标系上组成的最小矩形区域对象。
         * @param sprite 显示对象 Sprite。
         * @param x0 点一的 X 轴坐标。
         * @param y0 点一的 Y 轴坐标。
         * @param x1 点二的 X 轴坐标。
         * @param y1 点二的 Y 轴坐标。
         * @return 两个点在舞台坐标系组成的矩形对象 Rectangle。
         */
        static getGlobalRecByPoints(sprite: Sprite, x0: number, y0: number, x1: number, y1: number): Rectangle;
        /**
         * @en Calculates the global coordinates and scaling values of the specified Sprite display object, and returns a Rectangle object containing the calculated X and Y coordinates as well as the scaleX and scaleY values.
         * @param sprite The Sprite object to calculate.
         * @returns The Rectangle object with the calculated values.
         * @zh 计算传入的显示对象 Sprite 在全局坐标系中的坐标和缩放值，返回一个 Rectangle 对象，存放计算出的坐标 X 值、Y 值、ScaleX 值和 ScaleY 值。
         * @param	sprite Sprite 对象。
         * @return  矩形对象 Rectangle。
         */
        static getGlobalPosAndScale(sprite: Sprite): Rectangle;
        /**
         * @en Retrieves the transform of a specified area relative to the top-left corner of the window.
         * @param coordinateSpace The coordinate space, must not be a Stage reference.
         * @param x The x coordinate relative to the `coordinateSpace`.
         * @param y The y coordinate relative to the `coordinateSpace`.
         * @returns An object containing the transformed x, y coordinates, and scale factor.
         * @zh 获取指定区域内相对于窗口左上角的transform。
         * @param	coordinateSpace	坐标空间，不能是Stage引用
         * @param	x				相对于coordinateSpace的x坐标
         * @param	y				相对于coordinateSpace的y坐标
         * @returns 包含转换后的x、y坐标以及缩放因子的对象
         */
        static getTransformRelativeToWindow(coordinateSpace: Sprite, x: number, y: number): any;
        /**
         * @en Make a DOM element fit within a specific area of the stage.
         * @param dom The reference to the DOM element.
         * @param coordinateSpace The coordinate space. It should not be a reference to Stage.
         * @param x The x coordinate relative to the coordinateSpace.
         * @param y The y coordinate relative to the coordinateSpace.
         * @param width The width of the area.
         * @param height The height of the area.
         * @zh 使DOM元素适应舞台内指定区域。
         * @param	dom				DOM元素引用
         * @param	coordinateSpace	坐标空间，不能是Stage引用
         * @param	x				相对于coordinateSpace的x坐标
         * @param	y				相对于coordinateSpace的y坐标
         * @param	width			宽度
         * @param	height			高度
         */
        static fitDOMElementInArea(dom: any, coordinateSpace: Sprite, x: number, y: number, width: number, height: number): void;
        /**
         * @private
         * @en Reorders the passed array of items based on the Z property of the child items.
         * Returns a Boolean value indicating whether the array has been reordered.
         * @param array The array of child objects.
         * @return A Boolean value indicating if the array has been reordered.
         * @zh 根据子项的 Z 属性值对传入的数组列表进行重新排序。
         * 返回一个 Boolean 值，表示是否已重新排序。
         * @param array 子对象数组。
         * @return Boolean 值，表示是否已重新排序。
         */
        static updateOrder(array: any[]): boolean;
    }
    /**
     * @en The Stat class is a performance statistics panel that provides real-time updates on various performance metrics.
     * The performance metrics included in the statistics are updated approximately every 1 second and are as follows:
     * - FPS: Frames per second (FPS). The higher and more stable the value, the smoother the display.
     * - Sprite: The count of all rendering nodes (including containers). Its size affects the efficiency of the engine's node traversal, data organization, and rendering. The smaller the value, the higher the game's operational efficiency.
     * - DrawCall: This value is a crucial indicator of performance; the smaller the number, the higher the game's operational efficiency. It represents the approximate number of rendering batches submitted per second. Each preparation of data and notification to the GPU for rendering is called one DrawCall. Besides the time-consuming process of notifying the GPU to render, switching materials and shaders are also very time-consuming operations during each DrawCall.
     * - CurMem: Represents memory and video memory usage; the smaller the value, the better.
     * - Shader: indicating the number of Shader submissions per second. The smaller the value, the better.
     * - Canvas: Composed of three values, which are only present after setting CacheAs, with a default of 0/0/0. From left to right, the meanings of the values are: the number of canvases redrawn per frame / the number of canvases with "normal" cache type / the number of canvases with "bitmap" cache type.
     * @zh Stat是一个性能统计面板，可以实时更新相关的性能参数。参与统计的性能参数如下（所有参数都是每大约1秒进行更新）：
     * - FPS(WebGL)：每秒显示的帧数。值越高且越稳定，画面越流畅。
     * - Sprite：统计所有渲染节点（包括容器）的数量。这个数值的大小会影响引擎在节点遍历、数据组织和渲染方面的效率。数值越小，游戏运行效率越高。
     * - DrawCall：此值是决定性能的重要指标，数值越小，游戏运行效率越高。表示大约每1秒的渲染提交批次。每次准备数据并通知 GPU 进行渲染的过程称为1次 DrawCall。在每次 DrawCall 中，除了通知 GPU 渲染比较耗时外，切换材质与 shader 也是非常耗时的操作。
     * - CurMem：表示内存与显存的占用，数值越小越好。
     * - Shader：表示每大约1秒 Shader 提交次数。数值越小越好。
     * - Canvas：由三个数值组成，仅在设置了 CacheAs 之后才会有数值，默认为0/0/0。从左到右数值的意义分别为：每帧重绘的画布数量 / 缓存类型为"normal"的画布数量 / 缓存类型为"bitmap"的画布数量。
     */
    class Stat {
        /**
         * @en The current frame rate.
         * @zh 当前帧率
         */
        static FPSStatUIParams: StatUIParams;
        /**
         * @en Node nums
         * @zh 节点数量
         */
        static NodeStatUIParams: StatUIParams;
        /**
         * @en Sprite3D nums
         * @zh 3D精灵数量
         */
        static Sprite3DStatUIParams: StatUIParams;
        /**
         * @en DrawCall
         * @zh 渲染提交批次
         */
        static DrawCall: StatUIParams;
        /**
         * @en triangleFace
         * @zh 三角形面数量
         */
        static TriangleFace: StatUIParams;
        /**
         * @en RenderNoe
         * @zh 渲染节点数量
         */
        static RenderNode: StatUIParams;
        /**
         * @en SkinRenderNode
         * @zh 蒙皮（骨骼动画）渲染节点数量
         */
        static SkinRenderNode: StatUIParams;
        /**
         * @en ParticleRenderNode
         * @zh 粒子渲染节点数量
         */
        static ParticleRenderNode: StatUIParams;
        /**
         * @en FrustumCulling
         * @zh 视锥体剔除
         */
        static FrustumCulling: StatUIParams;
        /**
         * @en uniformUpload
         * @zh uniform上传
         */
        static UniformUpload: StatUIParams;
        /**
         * @en OpaqueDrawCall
         * @zh 不透明物体渲染提交批次
         */
        static OpaqueDrawCall: StatUIParams;
        /**
         * @en TransformDrawCall
         * @zh 透明物体渲染提交批次
         */
        static TransDrawCall: StatUIParams;
        /**
         * @en DepthCastDrawCall
         * @zh 深度投射渲染提交批次
         */
        static DepthCastDrawCall: StatUIParams;
        /**
        * @en TransformDrawCall
        * @zh 透明物体渲染提交批次
        */
        static ShadowDrawCall: StatUIParams;
        /**
         * @en InstanceDrawCall
         * @zh 实例绘制渲染提交批次
         */
        static InstanceDrawCall: StatUIParams;
        /**
         * @en CMDDrawCall
         * @zh CMD渲染提交批次
         */
        static CMDDrawCall: StatUIParams;
        /**
         * @en BlitDrawCall
         * @zh 位块渲染提交批次
         */
        static BlitDrawCall: StatUIParams;
        /**
         * @en GPU memory
         * @zh GPU 显存
         */
        static GPUMemory: StatUIParams;
        /**
         * @en Texture2D memory
         * @zh 2D纹理内存
         */
        static TextureMemeory: StatUIParams;
        /**
         * @en RenderTexture memory
         * @zh 渲染纹理内存
         */
        static RenderTextureMemory: StatUIParams;
        /**
         * @en BufferMemory
         * @zh Buffer内存
         */
        static BufferMemory: StatUIParams;
        /**
         * @en upload Uniform
         * @zh Uniform上传数量
         */
        static uploadUniformNum: StatUIParams;
        /**
         * @en All Show
         * @zh 所有显示
         */
        static AllShow: Array<StatUIParams>;
        /**
         * @en Memory Show
         * @zh 内存显示
         */
        static memoryShow: Array<StatUIParams>;
        /**
         * @en Rendering Show
         * @zh 渲染显示
         */
        static renderShow: Array<StatUIParams>;
        /**
         * @en AllToggle
         * @zh 所有开关
         */
        static AllToggle: Array<StatToggleUIParams>;
        /**
         * @en Render Mode Toggle
         * @zh 渲染开关
         */
        static RenderModeToggle: Array<StatToggleUIParams>;
        /**
         * @en Render Func Toggle
         * @zh 功能开关
         */
        static RenderFuncToggle: Array<StatToggleUIParams>;
        /**
         * @en Current frames per second (FPS).
         * @zh 当前每秒帧数（FPS）。
         */
        static FPS: number;
        /**
         * @en Count of rendering loops of the main stage Stage.
         * @zh 主舞台 Stage 的渲染次数计数。
         */
        static loopCount: number;
        /**
         * @en Number of Sprites that use cache for rendering.
         * @zh 精灵渲染使用缓存 Sprite 的数量。
         */
        static spriteRenderUseCacheCount: number;
        /**
         * @en Number of times the canvas has used standard rendering.
         * @zh 画布 canvas 使用标准渲染的次数。
         */
        static canvasNormal: number;
        /**
         * @en Number of times the canvas has used bitmap rendering.
         * @zh 画布 canvas 使用位图渲染的次数。
         */
        static canvasBitmap: number;
        /**
         * @en Number of times the canvas buffer has been repainted.
         * @zh 画布 canvas 缓冲区重绘次数。
         */
        static canvasReCache: number;
        /**
         * @en Indicates whether the current rendering mode is slow.
         * @zh 表示当前使用的是否为慢渲染模式。
         */
        static renderSlow: boolean;
        /**
         * @en Accumulated memory managed by the resource manager, in bytes.
         * @zh 资源管理器所管理资源的累计内存，以字节为单位。
         */
        static cpuMemory: number;
        static draw2D: number;
        static blitDrawCall: number;
        static renderPassStatArray: number[];
        static enableRenderPassStatArray: boolean;
        /**
         * @en The cumulative memory of the resources managed by the resource manager, in bytes.
         * @zh 资源管理器所管理资源的累计内存，以字节为单位。
         */
        static gpuMemory: number;
        /**
         * @en The count of dynamic rigid bodies in the physics system.
         * @zh 物理系统中动态刚体的数量。
         */
        static physics_dynamicRigidBodyCount: number;
        /**
         * @en The count of static rigid bodies in the physics system.
         * @zh 物理系统中静态刚体的数量。
         */
        static physics_staticRigidBodyCount: number;
        /**
         * @en The count of kinematic rigid bodies in the physics system.
         * @zh 物理系统中运动学刚体的数量。
         */
        static phyiscs_KinematicRigidBodyCount: number;
        /**
         * @en The count of character controllers in the physics system.
         * @zh 物理系统中角色控制器的数量。
         */
        static physics_CharacterControllerCount: number;
        /**
         * @en The count of joints in the physics system.
         * @zh 物理系统中关节的数量。
         */
        static physics_jointCount: number;
        /**
         * @en The count of physics events.
         * @zh 物理事件的数量。
         */
        static phyiscs_EventCount: number;
        /**
         * @en Enables or disables shadows.
         * @zh 开启或关闭阴影效果。
         */
        static enableShadow: boolean;
        /**
         * @en Enables or disables multiple light sources.
         * @zh 开启或关闭多光源效果。
         */
        static enableMulLight: boolean;
        /**
         * @en Enables or disables light sources.
         * @zh 开启或关闭光源效果。
         */
        static enableLight: boolean;
        /**
         * @en Enables or disables CMD.
         * @zh 开启或关闭CMD。
         */
        static enableCameraCMD: boolean;
        /**
         * @en Enables or disables post-processing effects.
         * @zh 开启或关闭后期处理效果。
         */
        static enablePostprocess: boolean;
        /**
         * @en Enables or disables skin rendering.
         * @zh 开启或关闭skin渲染。
         */
        static enableSkin: boolean;
        /**
         * @en Enables or disables transparent rendering.
         * @zh 开启或关闭透明渲染。
         */
        static enableTransparent: boolean;
        /**
         * @en Enables or disables particle rendering.
         * @zh 开启或关闭粒子渲染。
         */
        static enableParticle: boolean;
        /**
         * @en Enables or disables animation updates.
         * @zh 开启或关闭动画更新。
         */
        static enableAnimatorUpdate: boolean;
        /**
         * @en Enables or disables physics updates.
         * @zh 开启或关闭物理更新。
         */
        static enablePhysicsUpdate: boolean;
        /**
         * @en Enables or disables MSAA.
         * @zh 开启或关闭 MSAA。
         */
        static enablemsaa: boolean;
        /**
         * @en Enables or disables rendering of opaque objects.
         * @zh 开启或关闭不透明物体渲染。
         */
        static enableOpaque: boolean;
        static _statUI: IStatUI;
        /**
         * @en Displays performance statistics information on the screen.
         * To be effective, it should be called at the very beginning of the application.
         * @param x The X-coordinate position where the statistics should be displayed.
         * @param y The Y-coordinate position where the statistics should be displayed.
         * @param views An optional array of StatUIParams that defines which statistics to display.
         * @zh 在屏幕上显示性能统计信息。
         * 为了有效，它应该在应用程序最开始时调用。
         * @param x 统计信息显示的 X 轴坐标位置。
         * @param y 统计信息显示的 Y 轴坐标位置。
         * @param views 可选的 StatUIParams 数组，定义要显示哪些统计信息。
         */
        static show(x?: number, y?: number, views?: Array<StatUIParams>): void;
        /**
         * @en Shows the performance statistics information with toggle functionality.
         * @param x The x-coordinate of the display position. Optional.
         * @param y The y-coordinate of the display position. Optional.
         * @param views An array of StatToggleUIParams objects defining the toggle views to display. Optional.
         * @zh 显示带有切换功能的性能统计信息。
         * @param x 显示位置的 x 坐标。可选。
         * @param y 显示位置的 y 坐标。可选。
         * @param views 定义要显示的切换视图的 StatToggleUIParams 对象数组。可选。
         */
        static showToggle(x?: number, y?: number, views?: Array<StatToggleUIParams>): void;
        private static checkUI;
        /**
         * @en Hides the performance statistics information from the screen.
         * @zh 从屏幕上隐藏性能统计信息。
         */
        static hide(): void;
        /**
         * @private
         * @en Performance statistics parameter calculation loop processing function.
         * @zh 性能统计参数计算循环处理函数。
         */
        static loop(): void;
        /**
         * @en Updates the engine data for statistics such as triangle count, draw call count, and memory usage.
         * @zh 更新引擎数据，包括三角形数量、绘制调用计数和内存使用情况等统计信息。
         */
        static updateEngineData(): void;
        /**
         * @private
         * @en Resets the performance statistics calculation related data to zero.
         * @zh 清零性能统计计算相关的数据。
         */
        static clear(): void;
        static render(ctx: any, x: number, y: number): void;
    }
    /**
     * @private
     * @en The StringKey class is used to access the number corresponding to a string.
     * @zh StringKey 类用于存取字符串对应的数字。
     */
    class StringKey {
        private _strsToID;
        private _idToStrs;
        private _length;
        /**
         * @en Adds a string.
         * @param str The string to be added as a key which will be associated with a generated number.
         * @returns The numerical identifier associated with the string.
         * @zh 添加一个字符。
         * @param	str 字符，将作为key 存储相应生成的数字。
         * @returns 返回与此字符串对应的数字。
         */
        add(str: string): number;
        /**
         * @en Retrieves the identifier for a specified string.
         * @param str The string for which to get the identifier.
         * @returns The identifier for the string, or -1 if the string does not exist.
         * @zh 根据指定的字符串获取其标识符。
         * @param	str 字符。
         * @return 返回此字符串对应的ID，如果字符串不存在则返回-1。
         */
        getID(str: string): number;
        /**
         * @en Retrieves a string based on its identifier.
         * @zh 根据指定的ID获取对应的字符串。
         * @param  id ID。
         * @returns The string associated with the identifier, or undefined if no string is associated.
         * @zh 根据指定的ID获取对应的字符串。
         * @param  id ID。
         * @returns 返回与此ID对应的字符串。
         */
        getName(id: number): string;
    }
    /**
     * @en When the entire slow motion ends, it will be scheduled
     * @zh 整个缓动结束的时候会调度
     * @eventType Event.COMPLETE
     */
    /**
     * @en When the slow motion reaches the label, it will be scheduled
     * @zh 当缓动到达标签时会调度。
     * @eventType Event.LABEL
     */
    /**
     * @en TimeLine is a class used to create timeline animations.
     * @zh TimeLine 是一个用来创建时间轴动画的类。
     */
    class TimeLine extends EventDispatcher {
        private _labelDic;
        private _tweenDic;
        private _tweenDataList;
        private _endTweenDataList;
        private _currTime;
        private _lastTime;
        private _startTime;
        /**当前动画数据播放到第几个了*/
        private _index;
        /**为TWEEN创建属于自己的唯一标识，方便管理*/
        private _gidIndex;
        /**保留所有对象第一次注册动画时的状态（根据时间跳转时，需要把对象的恢复，再计算接下来的状态）*/
        private _firstTweenDic;
        /**是否需要排序*/
        private _startTimeSort;
        private _endTimeSort;
        /**是否循环*/
        private _loopKey;
        /**
         * @en Scaling the speed of animation playback.
         * @zh 缩放动画播放的速度。
         */
        scale: number;
        private _frameRate;
        private _frameIndex;
        private _total;
        /**
         * @en Controls an object to move to a target position.
         * @param target The object to be controlled.
         * @param props The properties of the object to be controlled.
         * @param duration The duration of the TWEEN for the object.
         * @param ease The type of easing.
         * @param offset The time offset relative to the previous object (in milliseconds).
         * @returns An instance of TimeLine.
         * @zh 控制一个对象，从当前位置移动到目标位置。
         * @param	target		要控制的对象。
         * @param	props		要控制对象的属性。
         * @param	duration	对象TWEEN的时间。
         * @param	ease		缓动类型
         * @param	offset		相对于上一个对象，偏移多长时间（单位：毫秒）。
         */
        static to(target: any, props: any, duration: number, ease?: Function, offset?: number): TimeLine;
        /**
         * @en From the props attribute, slow down to the current state.
         * @param target The target object whose properties will be changed.
         * @param props The properties to control the object.
         * @param duration The duration of the TWEEN for the object.
         * @param ease The type of easing function.
         * @param offset The time offset relative to the previous object (in milliseconds).
         * @zh 从 props 属性，缓动到当前状态。
         * @param	target		target 目标对象(即将更改属性值的对象)
         * @param	props		要控制对象的属性
         * @param	duration	对象TWEEN的时间
         * @param	ease		缓动类型
         * @param	offset		相对于上一个对象，偏移多长时间（单位：毫秒）
         */
        static from(target: any, props: any, duration: number, ease?: Function, offset?: number): TimeLine;
        /**
         * @en Controls an object to move to a target position.
         * @param target The object to be controlled.
         * @param props The properties to be changed during the TWEEN.
         * @param duration The duration of the TWEEN for the object.
         * @param ease The easing function to be used.
         * @param offset The time offset from the start of the previous TWEEN (in milliseconds).
         * @returns An instance of TimeLine.
         * @zh 控制一个对象，从当前位置移动到目标位置。
         * @param	target		要控制的对象。
         * @param	props		要控制对象的属性。
         * @param	duration	对象TWEEN的时间。
         * @param	ease		缓动类型
         * @param	offset		相对于上一个对象，偏移多长时间（单位：毫秒）。
         */
        to(target: any, props: any, duration: number, ease?: Function, offset?: number): TimeLine;
        /**
         * @en From the props attribute, slow down to the current state.
         * @param target The target object whose properties are to be tweened.
         * @param props The properties to be controlled and their target values.
         * @param duration The duration of the tween for the target object.
         * @param ease The type of easing function to be used for the tween.
         * @param offset The time offset in milliseconds to delay the start of the tween relative to the previous tween.
         * @zh 从 props 属性，缓动到当前状态。
         * @param target 目标对象，其属性将被缓动。
         * @param props 要控制的对象属性及其目标值。
         * @param duration 对象缓动的持续时间。
         * @param ease 缓动类型，用于指定缓动效果的函数。
         * @param offset 相对于上一个缓动，延迟启动当前缓动的时间偏移量（单位：毫秒）。。
         */
        from(target: any, props: any, duration: number, ease?: Function, offset?: number): TimeLine;
        /** @private */
        private _create;
        /**
         * @en Adds a label to the timeline at a specified offset from the previous animation.
         * @param label The name of the label to add.
         * @param offset The offset time in milliseconds from the previous animation.
         * @zh 在时间队列中加入一个标签，相对于上一个动画的偏移时间。
         * @param	label	标签名称。
         * @param	offset	标签相对于上个动画的偏移时间(单位：毫秒)。
         */
        addLabel(label: string, offset: number): TimeLine;
        /**
         * @en Removes a specified label from the timeline.
         * @param label The label to remove
         * @zh 移除指定的标签。
         * @param label 要删除的标签.
         */
        removeLabel(label: string): void;
        /**
         * @en Jumps to a specific time in the animation.
         * @param time The time in milliseconds to jump to within the animation.
         * @zh 动画从整个动画的某一时间开始。
         * @param time 在动画中跳转到的时间（以毫秒为单位）。
         */
        gotoTime(time: number): void;
        /**
         * @en Jump to a specific label and start playing from there.
         * @param Label The name of the label to jump to.
         * @zh 跳转到指定的标签并从那里开始播放。
         * @param Label 要跳转的标签名。
         */
        gotoLabel(Label: string): void;
        /**
         * @en Pause the entire animation.
         * @zh 暂停整个动画。
         */
        pause(): void;
        /**
         * @en Resume playing of a paused animation.
         * @zh 恢复暂停的动画播放。
         */
        resume(): void;
        /**
         * @en Play the animation from a specified time point or label.
         * @param timeOrLabel The time point or label name to start playing from.
         * @param loop Whether to loop the playback.
         * @zh 从指定的时间点或标签名播放动画。
         * @param timeOrLabel 开始播放的时间点或标签名。
         * @param loop 是否循环播放。
         */
        play(timeOrLabel?: any, loop?: boolean): void;
        /**
         * 更新当前动画。
         */
        private _update;
        /**
         * 指定的动画索引处的动画播放完成后，把此动画从列表中删除。
         * @param	index
         */
        private _animComplete;
        /** @private */
        private _complete;
        /**
         * @private
         * @en frame index
         * @zh 帧索引
         */
        get index(): number;
        set index(value: number);
        /**
         * @en The total number of frames
         * @zh 总帧数。
         */
        get total(): number;
        /**
         * @en Resets all objects, used when reusing objects.
         * @zh 重置所有对象，复用对象时使用。
         */
        reset(): void;
        /**
         * @en Completely destroys this object.
         * @zh 彻底销毁此对象。
         */
        destroy(): void;
    }
    /**
     * @en The `Timer` class is responsible for time management. It is a singleton and should not be instantiated manually. Access it via `Laya.timer`
     * @zh Timer 是时钟管理类。它是一个单例，不要手动实例化此类，应该通过 Laya.timer 访问。
     */
    class Timer {
        /**@private */
        static gSysTimer: Timer;
        /**@private */
        private static _pool;
        /**@private */
        static _mid: number;
        /**
         * @en Scale of the clock hand.
         * @zh 时针的缩放比例。
         */
        scale: number;
        /**
         * @en The start time of the current frame.
         * @zh 当前帧的开始时间。
         */
        currTimer: number;
        /**
         * @en The current frame count.
         * @zh 当前的帧数。
         */
        currFrame: number;
        /**@private */
        private _map;
        /**@private */
        private _handlers;
        /**@private */
        private _temp;
        /**@private */
        private _count;
        /**
         * @en Constructor method
         * @zh 构造方法
         */
        constructor(autoActive?: boolean);
        /**
         * @en The time interval between two frames, in milliseconds.
         * @zh 两帧之间的时间间隔，单位毫秒。
         */
        get delta(): number;
        /** @private */
        private _clearHandlers;
        /** @private */
        private _recoverHandler;
        /**
         * @private
         * @en get now time data.
         * @returns reutrn time data.
         * @zh 立即获取时间数据
         * @returns 返回时间数据
         */
        _getNowData(): number;
        /** @private */
        private _indexHandler;
        /**
         * Executes once after a delay.
         * @param delay The delay time in milliseconds.
         * @param caller The scope of the object (this).
         * @param method The callback function to be executed by the timer.
         * @param args The arguments to pass to the callback function.
         * @param coverBefore Whether to overwrite previous delayed execution, default is true.
         * @zh 定时执行一次。
         * @param delay 延迟时间(单位为毫秒)。
         * @param caller 执行域(this)。
         * @param method 定时器回调函数。
         * @param args 回调参数。
         * @param coverBefore 是否覆盖之前的延迟执行，默认为 true 。
         */
        once(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean): void;
        /**
         * Repeatedly executes at intervals.
         * @param delay The interval time in milliseconds.
         * @param caller The scope of the object (this).
         * @param method The callback function to be executed by the timer.
         * @param args The arguments to pass to the callback function.
         * @param coverBefore Whether to overwrite previous delayed execution, default is true.
         * @param jumpFrame Whether to jump frames. For time-based callbacks, if multiple callbacks can be executed within a given time interval, the engine defaults to executing once for performance reasons. Setting `jumpFrame` to true will allow multiple executions in quick succession.
         * @zh 定时重复执行。
         * @param delay 间隔时间(单位毫秒)。
         * @param caller 执行域(this)。
         * @param method 定时器回调函数。
         * @param args 回调参数。
         * @param coverBefore 是否覆盖之前的延迟执行，默认为 true 。
         * @param jumpFrame 时钟是否跳帧。基于时间的循环回调，单位时间间隔内，如能执行多次回调，出于性能考虑，引擎默认只执行一次，设置jumpFrame=true后，则回调会连续执行多次。
         */
        loop(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean, jumpFrame?: boolean): void;
        /**
         * Executes once after a delay in frames.
         * @param delay The delay time in frames.
         * @param caller The scope of the object (this).
         * @param method The callback function to be executed by the timer.
         * @param args The arguments to pass to the callback function.
         * @param coverBefore Whether to overwrite previous delayed execution, default is true.
         * @zh 定时执行一次（基于帧率）。
         * @param delay 延迟几帧（单位为帧）。
         * @param caller 执行域（this）。
         * @param method 定时器回调函数。
         * @param args 回调参数。
         * @param coverBefore 是否覆盖之前的延迟执行，默认为 true。
         */
        frameOnce(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean): void;
        /**
         * Repeatedly executes at frame intervals.
         * @param delay The interval time in frames.
         * @param caller The scope of the object (this).
         * @param method The callback function to be executed by the timer.
         * @param args The arguments to pass to the callback function.
         * @param coverBefore Whether to overwrite previous delayed execution, default is true.
         * @zh 定时重复执行（基于帧率）。
         * @param delay 间隔几帧（单位为帧）。
         * @param caller 执行域（this）。
         * @param method 定时器回调函数。
         * @param args 回调参数。
         * @param coverBefore 是否覆盖之前的延迟执行，默认为 true。
         */
        frameLoop(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean): void;
        /**
         * @en Return statistical information
         * @zh 返回统计信息
         */
        toString(): string;
        /**
         * @en Cleaning the timer.
         * @param caller The scope of the object (this).
         * @param method Timer callback function.
         * @zh 清理定时器。
         * @param caller 执行域（this）。
         * @param method 定时器回调函数。
         */
        clear(caller: any, method: Function): void;
        /**
         * @en Clears all timers associated with the object.
         * @param caller The scope of the object (this).
         * @zh 清理对象身上的所有定时器。
         * @param caller  执行域(this)。
         */
        clearAll(caller: any): void;
        /** @private */
        private _getHandler;
        /**
         * @en Delays the execution.
         * @param caller The scope of the object (this).
         * @param method The timer callback function.
         * @param args The callback arguments. Default is null.
         * @zh 延迟执行。
         * @param	caller 执行域(this)。
         * @param	method 定时器回调函数。
         * @param	args 回调参数。
         */
        callLater(caller: any, method: Function, args?: any[]): void;
        /**
         * @en Immediately executes the callLater.
         * @param caller The scope of the object (this).
         * @param method The callback function for the timer.
         * @zh 立即执行 callLater。
         * @param	caller 执行域(this)。
         * @param	method 定时器回调函数。
         */
        runCallLater(caller: any, method: Function): void;
        /**
         * @en Cancels the execution of callLater.
         * @param caller The scope of the object (this).
         * @param method The callback function for the timer.
         * @zh 取消执行 callLater。
         * @param	caller 执行域(this)。
         * @param	method 定时器回调函数。
         */
        clearCallLater(caller: any, method: Function): void;
        /**
         * @en Immediately advance the timer, execute it, and then remove it from the queue.
         * @param caller The scope of the object (this).
         * @param method Timer callback function.
         * @zh 立即提前执行定时器，执行后从队列中删除。
         * @param caller 执行域(this)。
         * @param method 定时器回调函数。
         */
        runTimer(caller: any, method: Function): void;
        /**
         * @en Pause the clock.
         * @zh 暂停时钟。
         */
        pause(): void;
        /**
         * @en Resume the clock.
         * @zh 恢复时钟。
         */
        resume(): void;
        /**
         * @en Destroy the timer, and clear all events on the timer.
         * @zh 删除定时器，同时清理定时器上的所有事件。
         */
        destroy(): void;
    }
    /**
     * @en The `Tween` class is an easing class. It is used to implement the interpolation of properties of a target object.
     * @zh `Tween` 类是一个缓动类。使用此类能够实现对目标对象属性的渐变。
     */
    class Tween {
        /**@private */
        private static tweenMap;
        /**@private */
        private _complete;
        /**@private */
        private _target;
        /**@private */
        private _ease;
        /**@private */
        private _props;
        /**@private */
        private _duration;
        /**@private */
        private _delay;
        /**@private */
        private _startTimer;
        /**@private */
        private _usedTimer;
        /**@private */
        private _usedPool;
        /**@private */
        private _delayParam;
        /**
         * @private
         * @en Unique identifier used by TimeLintLite.
         * @zh 唯一标识，由 TimeLintLite 使用。
         */
        gid: number;
        /**
         * @en Update callback, when the buffering value changes, the value of the callback changes
         * @zh 更新回调，缓动数值发生变化时，回调变化的值。
         */
        update: Handler;
        /**
         * @en The number of times to replay the tween. If set to 0, it indicates an infinite loop.
         * @zh 重播次数，如果设置为 0，则表示无限循环播放。
         */
        repeat: number;
        /**当前播放次数*/
        private _count;
        /**
         * @en Tweens the object's properties to the target values.
         * @param target The target object whose properties will be tweened.
         * @param props The list of properties to change, e.g., {x:100, y:20, ease:Ease.backOut, complete:Handler.create(this,onComplete), update:new Handler(this,onUpdate)}.
         * @param duration The time taken for the tween in milliseconds.
         * @param ease The type of easing, defaults to linear motion.
         * @param complete The callback function when the tween completes.
         * @param delay The delay before the tween starts.
         * @param coverBefore Whether to override the previous tween.
         * @param autoRecover Whether to automatically recover after the tween ends, defaults to true.
         * @returns Returns the Tween object.
         * @zh 缓动对象的props属性到目标值。
         * @param	target 目标对象(即将更改属性值的对象)。
         * @param	props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。
         * @param	duration 花费的时间，单位毫秒。
         * @param	ease 缓动类型，默认为匀速运动。
         * @param	complete 结束回调函数。
         * @param	delay 延迟执行时间。
         * @param	coverBefore 是否覆盖之前的缓动。
         * @param	autoRecover 是否自动回收，默认为true，缓动结束之后自动回收到对象池。
         * @return	返回Tween对象。
         */
        static to(target: any, props: any, duration: number, ease?: Function | null, complete?: Handler | null, delay?: number, coverBefore?: boolean, autoRecover?: boolean): Tween;
        /**
         * @en From the props attribute, tween to the current state.
         * @param target The target object whose properties will be tweened.
         * @param props The list of properties to change, e.g., {x:100, y:20, ease:Ease.backOut, complete:Handler.create(this,onComplete), update:new Handler(this,onUpdate)}.
         * @param duration The time taken for the tween in milliseconds.
         * @param ease The type of easing, defaults to linear motion.
         * @param complete The callback function when the tween completes.
         * @param delay The delay before the tween starts.
         * @param coverBefore Whether to override the previous tween.
         * @param autoRecover Whether to automatically recover after the tween ends, defaults to true.
         * @returns Returns the Tween object.
         * @zh 从props属性，缓动到当前状态。
         * @param	target 目标对象(即将更改属性值的对象)。
         * @param	props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。
         * @param	duration 花费的时间，单位毫秒。
         * @param	ease 缓动类型，默认为匀速运动。
         * @param	complete 结束回调函数。
         * @param	delay 延迟执行时间。
         * @param	coverBefore 是否覆盖之前的缓动。
         * @param	autoRecover 是否自动回收，默认为true，缓动结束之后自动回收到对象池。
         * @return	返回Tween对象。
         */
        static from(target: any, props: any, duration: number, ease?: Function, complete?: Handler, delay?: number, coverBefore?: boolean, autoRecover?: boolean): Tween;
        /**
         * @en Tweens the props attribute of the object to the target value.
         * @param target The target object whose properties will be tweened.
         * @param props The list of properties to change, e.g., {x:100, y:20, ease:Ease.backOut, complete:Handler.create(this,onComplete), update:new Handler(this,onUpdate)}.
         * @param duration The time taken for the tween in milliseconds.
         * @param ease The type of easing, defaults to linear motion.
         * @param complete The callback function when the tween completes.
         * @param delay The delay before the tween starts.
         * @param coverBefore Whether to override the previous tween.
         * @returns Returns the Tween object.
         * @zh 缓动对象的props属性到目标值。
         * @param	target 目标对象(即将更改属性值的对象)。
         * @param	props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。
         * @param	duration 花费的时间，单位毫秒。
         * @param	ease 缓动类型，默认为匀速运动。
         * @param	complete 结束回调函数。
         * @param	delay 延迟执行时间。
         * @param	coverBefore 是否覆盖之前的缓动。
         * @return	返回Tween对象。
         */
        to(target: any, props: any, duration: number, ease?: Function, complete?: Handler, delay?: number, coverBefore?: boolean): Tween;
        /**
         * @en From the props attribute, slow down to the current state.
         * @param target The target object (the object whose property values will be changed).
         * @param props A list of changing properties, such as {x:100, y:20, ease:Ease.backOut, complete:Handler.create(this,onComplete), update:new Handler(this,onComplete)}.
         * @param duration The time spent, in milliseconds.
         * @param ease The easing type, default is uniform motion. Default value is null.
         * @param complete The callback function at the end. Default value is null.
         * @param delay The delay time before execution. Default value is 0.
         * @param coverBefore Whether to cover the previous tween. Default value is false.
         * @returns Returns a Tween object.
         * @zh 从props属性，缓动到当前状态。
         * @param	target 目标对象(即将更改属性值的对象)。
         * @param	props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。
         * @param	duration 花费的时间，单位毫秒。
         * @param	ease 缓动类型，默认为匀速运动。
         * @param	complete 结束回调函数。
         * @param	delay 延迟执行时间。
         * @param	coverBefore 是否覆盖之前的缓动。
         * @return	返回Tween对象。
         */
        from(target: any, props: any, duration: number, ease?: Function | null, complete?: Handler | null, delay?: number, coverBefore?: boolean): Tween;
        private firstStart;
        private _initProps;
        private _beginLoop;
        /**执行缓动**/
        private _doEase;
        /**
         * @en Set the current execution progress ratio.
         * @zh 设置当前执行进度比例。
         */
        set progress(v: number);
        /**
         * @en Immediately complete the tween and reach the end point.
         * @zh 立即结束缓动并到达终点。
         */
        complete(): void;
        /**
         * @en Pause the tween. It can be resumed using resume() or restart().
         * @zh 暂停缓动。可以通过 resume() 或 restart() 重新开始。
         */
        pause(): void;
        /**
         * @en Set the start time of the tween.
         * @param startTime The start time.
         * @zh 设置缓动的开始时间。
         * @param startTime 开始时间。
         */
        setStartTime(startTime: number): void;
        /**
         * @en Clear all tweens on the specified target object.
         * @param target The target object.
         * @zh 清理指定目标对象上的所有缓动。
         * @param target 目标对象。
         */
        static clearAll(target: any): void;
        /**
         * @en Clear a specific tween.
         * @param tween The tween object to clear.
         * @zh 清理某个特定的缓动。
         * @param tween 要清理的缓动对象。
         */
        static clear(tween: Tween): void;
        /**@private 同clearAll，废弃掉，尽量别用。*/
        static clearTween(target: any): void;
        /**
         * @en Stop and clear the current tween.
         * @zh 停止并清理当前缓动。
         */
        clear(): void;
        /**
         * @en Recycle to the object pool.
         * @zh 回收到对象池。
         */
        recover(): void;
        private _remove;
        /**
         * @en Restart the paused tween.
         * @zh 重新开始已暂停的缓动。
         */
        restart(): void;
        /**
         * @en Resume the paused tween.
         * @zh 恢复已暂停的缓动。
         */
        resume(): void;
        private static easeNone;
    }
    /**
     * @en Utils is a utility class.
     * @zh Utils 是工具类。
     */
    class Utils {
        /**
         * @en Converts an angle to radians.
         * @param angle The angle value.
         * @returns The radian value.
         * @zh 将角度转换为弧度。
         * @param	angle 角度值。
         * @return	返回弧度值。
         */
        static toRadian(angle: number): number;
        /**
         * @en Converts radians to an angle.
         * @param radian The radian value.
         * @returns The angle value in degrees.
         * @zh 将弧度转换为角度。
         * @param	radian 弧度值。
         * @return	返回角度值。
         */
        static toAngle(radian: number): number;
        /**
         * @en Converts an unsigned integer color value to a string representation.
         * @param color The color value.
         * @returns A string representation of the color value.
         * @zh 将 uint 类型的颜色值转换为字符串型颜色值。
         * @param color 颜色值。
         * @return 字符串型颜色值。
         */
        static toHexColor(color: number): string;
        /**
         * @en Converts a string color value to a number color.
         * @param value The string color value.
         * @returns The color value as a number.
         * @zh 将字符串型颜色值转换为数字型颜色值。
         * @param value 字符串颜色值
         * @returns 作为数字的颜色值
         */
        static fromStringColor(value: string): number;
        /**
         * @en Gets a globally unique ID.
         * @zh 获取一个全局唯一ID。
         */
        static getGID(): number;
        /**
         * @private
         * @en Clears the source array and copies the values from the array parameter.
         * @param source The array to be assigned values.
         * @param array The new values to be copied into the source array.
         * @returns The copied source array.
         * @zh 清空 source 数组，并复制 array 数组的值。
         * @param	source 需要赋值的数组。
         * @param	array 新的数组值。
         * @return 	复制后的数据 source 。
         */
        static copyArray(source: any[], array: any[]): any[];
        /**
         * @private
         * @en Batch translates point coordinates by the specified offsets.
         * @param points The list of point coordinates.
         * @param x The offset to translate along the x-axis.
         * @param y The offset to translate along the y-axis.
         * @zh 批量移动点坐标，按照指定的偏移量。
         * @param points 坐标列表。
         * @param x x轴偏移量。
         * @param y y轴偏移量。
         */
        static transPointList(points: any[], x: number, y: number): void;
        /**
         * @en Parses a string and returns an integer. Unlike the native JavaScript parseInt, if the string is empty or not a number, this method returns 0 instead of NaN.
         * @param str The string to be parsed.
         * @param radix The radix for parsing the number (between 2 and 36). Defaults to 0, which means decimal. The other values range from 2 to 36. If it starts with "0xX" or "0X", it will be based on 16. If the parameter is not within the above range, this method returns 0.
         * @returns The parsed number.
         * @zh 解析字符串并返回一个整数。与 JavaScript 原生的 parseInt 不同，如果字符串为空或非数字，这里返回 0 而不是 NaN。
         * @param	str		要被解析的字符串。
         * @param	radix	表示要解析的数字的基数。默认值为0，表示10进制，其他值介于 2 ~ 36 之间。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数不在上述范围内，则此方法返回 0。
         * @return	返回解析后的数字。
         */
        static parseInt(str: string, radix?: number): number;
        /**
         * @en Gets the base name of the file from the specified path, including the extension.
         * @zh 从指定路径中获取文件名（包含扩展名）。
         */
        static getBaseName(path: string): string;
        /**
         * @en Gets the file extension from the specified path and converts it to lowercase. For example, "1. abc" will return abc.
         * @zh 从指定路径获取文件扩展名，并转换为小写字母。例如"1.abc"将返回abc。
         */
        static getFileExtension(path: string): string;
        /**
         * @en Changes the file extension of the specified path.
         * @param path The file path.
         * @param newExt The new file extension.
         * @param excludeDot Whether to exclude the dot prefix in the new extension. Default is false.
         * @returns The path with the new file extension.
         * @zh 更改指定路径的文件扩展名。
         * @param path 文件路径。
         * @param newExt 新的文件扩展名。
         * @param excludeDot 是否在新扩展中排除点前缀。默认值为false。
         * @returns 具有新文件扩展名的路径。
         */
        static replaceFileExtension(path: string, newExt: string, excludeDot?: boolean): string;
        /**
         *
         * @param str 判断一个字符串是否UUID格式
         * @returns
         */
        static isUUID(str: string): boolean;
        /**
         * @deprecated 请使用uint8ArrayToArrayBufferAsync函数代替
         * @en Converts a RenderTexture to a Base64 encoded string.
         * @param rendertexture The RenderTexture to convert.
         * @returns The converted Base64 string
         * @zh 将RenderTexture转换为Base64
         * @param rendertexture 要转换的RenderTexture
         * @returns 转换后的Base64字符串
         */
        static uint8ArrayToArrayBuffer(rendertexture: RenderTexture | RenderTexture2D): string;
        /**
        * @en Converts a RenderTexture to a Base64 encoded string.
        * @param rendertexture The RenderTexture to convert.
        * @returns A promise that resolves to a Base64 string representing the RenderTexture.
        * @zh 将 RenderTexture 转换为 Base64 编码的字符串。
        * @param rendertexture 要转换的 RenderTexture。
        * @returns 一个 Promise，该 Promise 将解析为表示 RenderTexture 的 Base64 字符串。
        */
        static uint8ArrayToArrayBufferAsync(rendertexture: RenderTexture | RenderTexture2D): Promise<string>;
    }
    /**
     * @private
     * @en VectorGraphManager class for managing vector graphics.
     * @zh 用于管理矢量图形的 VectorGraphManager 类。
     */
    class VectorGraphManager {
        /**
         * @en Singleton instance of VectorGraphManager.
         * @zh VectorGraphManager 的单例实例。
         */
        static instance: VectorGraphManager;
        /**
         * @en Dictionary to track the usage of shapes.
         * @zh 用于跟踪形状使用情况的字典。
         */
        useDic: any;
        /**
         * @en Dictionary to store shapes.
         * @zh 用于存储形状的字典。
         */
        shapeDic: any;
        /**
         * @en Dictionary to store shape lines.
         * @zh 用于存储形状线条的字典。
         */
        shapeLineDic: any;
        private _id;
        private _checkKey;
        private _freeIdArray;
        constructor();
        /**
         * @en Get the singleton instance of VectorGraphManager.
         * @returns The singleton instance of VectorGraphManager.
         * @zh 获取 VectorGraphManager 的单例实例。
         * @returns VectorGraphManager 的单例实例。
         */
        static getInstance(): VectorGraphManager;
        /**
         * @en Get an available ID.
         * @returns An available ID.
         * @zh 获取一个可用的 ID。
         * @returns 一个可用的 ID。
         */
        getId(): number;
        /**
         * @en Add a shape to the list.
         * @param id The ID of the shape.
         * @param shape The shape object.
         * @zh 将一个形状添加到列表中。
         * @param id 形状的 ID。
         * @param shape 形状对象。
         */
        addShape(id: number, shape: any): void;
        /**
         * @en Add a line shape to the list.
         * @param id The ID of the line shape.
         * @param Line The line shape object.
         * @zh 将一个线形状添加到列表中。
         * @param id 线形状的 ID。
         * @param Line 线形状对象。
         */
        addLine(id: number, Line: any): void;
        /**
         * @en Check if an object is in use.
         * @param id The ID of the object to check.
         * @zh 检查一个对象是否正在使用中。
         * @param id 要检查的对象的 ID。
         */
        getShape(id: number): void;
        /**
         * @en Delete a shape object.
         * @param id The ID of the shape to delete.
         * @zh 删除一个形状对象。
         * @param id 要删除的形状的 ID。
         */
        deleteShape(id: number): void;
        /**
         * @en Get the cache list.
         * @returns An array of cached objects.
         * @zh 获取缓存列表。
         * @returns 缓存对象的数组。
         */
        getCacheList(): any[];
        /**
         * @en Start the disposal process, preparing for destruction.
         * @zh 开始清理过程，准备销毁。
         */
        startDispose(key: boolean): void;
        /**
         * @en Confirm destruction.
         * @zh 确认销毁。
         */
        endDispose(): void;
    }
    class WasmAdapter {
        static instantiateWasm: (url: string, imports: any) => Promise<any>;
        static locateFile: (path: string, dir: string, webDir: string) => string;
        static Memory: {
            new (descriptor: WebAssembly.MemoryDescriptor): WebAssembly.Memory;
            prototype: WebAssembly.Memory;
        };
        static create(module: Function, wasmFile?: string): Function;
    }
    /**
     * 封装弱引用WeakMap
     * 如果支持WeakMap，则使用WeakMap，如果不支持，则用Object代替
     * 注意：如果采用Object，为了防止内存泄漏，则采用定时清理缓存策略
     *
     * 这里的设计是错误的，为了兼容，先不删掉这个类，直接采用Object
     */
    class WeakObject {
        /**是否支持WeakMap*/
        static supportWeakMap: boolean;
        /**如果不支持WeakMap，则多少时间清理一次缓存，默认10分钟清理一次*/
        static delInterval: number;
        /**全局WeakObject单例*/
        static I: WeakObject;
        /**@private */
        private static _maps;
        /**清理缓存，回收内存*/
        static clearCache(): void;
        constructor();
        /**
         * 设置缓存
         * @param	key kye对象，可被回收
         * @param	value object对象，可被回收
         */
        set(key: any, value: any): void;
        /**
         * 获取缓存
         * @param	key kye对象，可被回收
         */
        get(key: any): any;
        /**
         * 删除缓存
         */
        del(key: any): void;
        /**
         * 是否有缓存
         */
        has(key: any): boolean;
    }
    /**
     * @private
     * @en WordText class for managing text content and rendering.
     * @zh WordText 类，用于管理文本内容和渲染。
     */
    class WordText {
        /**
         * @en The text content.
         * @zh 文本内容。
         */
        text: string;
        /**
         * @en The width of the entire WordText. -1 indicates it hasn't been calculated yet.
         * @zh 整个 WordText 的宽度。-1 表示还没有计算。
         */
        width: number;
        /**
         * @en The text information saved by grouping the characters of this object into texture groups. Inside is another array. The specific meaning can be found in the place of use.
         * @zh 把本对象的字符按照texture分组保存的文字信息。里面又是一个数组。具体含义见使用的地方。
         */
        pageChars: any[];
        /**
         * @en The ctx used for caching above. When crossing ctx (such as drawToTexture), it needs to be cleaned up, (because the settings for different ctx are different?). Set to any to indicate no concern for specific types, only for comparison purposes
         * @zh 上面缓存的时候用的ctx。跨ctx的时候（例如drawToTexture）要清理，（因为不同的ctx的设置不同？）。设置为any表示不关心具体类型，只是用来比较的
         */
        pagecharsCtx: any;
        /**
         * @en Horizontal scale cached during rendering.
         * @zh 渲染时缓存的水平缩放。
         */
        scalex: number;
        /**
         * @en Vertical scale cached during rendering.
         * @zh 渲染时缓存的垂直缩放。
         */
        scaley: number;
        _nativeObj: any;
        _splitRender: boolean;
        constructor();
        /**
         * @en Set the text content.
         * @param txt The text to set.
         * @zh 设置文本内容。
         * @param txt 要设置的文本。
         */
        setText(txt: string): void;
        /**
         * @en Convert the WordText to a string.
         * @returns The text content.
         * @zh 将 WordText 转换为字符串。
         * @returns 文本内容。
         */
        toString(): string;
        /**
         * @en The length of the text.
         * @zh 文本的长度。
         */
        get length(): number;
        /**
         * @en Clean the cache. This method will delete associated textures.
         * It's okay not to do it, textrender will automatically clean up the unused ones
         * @zh 清理缓存。此方法会删除关联的贴图。
         * 不做也可以，textrender会自动清理不用的
         * TODO 重用
         */
        cleanCache(): void;
        /**
         * @en The split render status.
         * @zh 拆分渲染状态。
         */
        get splitRender(): boolean;
        set splitRender(value: boolean);
    }
    class BlendMode {
        static activeBlendFunction: Function;
        static NORMAL: string;
        static MASK: string;
        static LIGHTER: string;
        static fns: any[];
        static targetFns: any[];
        static BlendNormal(): void;
        static BlendAdd(): void;
        static BlendMultiply(): void;
        static BlendScreen(): void;
        static BlendOverlay(): void;
        static BlendLight(): void;
        static BlendNormalTarget(): void;
        static BlendAddTarget(): void;
        static BlendMultiplyTarget(): void;
        static BlendScreenTarget(): void;
        static BlendOverlayTarget(): void;
        static BlendLightTarget(): void;
        static BlendMask(): void;
        static BlendDestinationOut(): void;
        static BlendSourceAlpha(): void;
    }
    class DrawStyle {
        static DEFAULT: DrawStyle;
        static _Defaultinit(): void;
        _color: ColorUtils;
        static create(value: ColorUtils | string): DrawStyle;
        constructor(value: any);
        setValue(value: any): void;
        reset(): void;
        toInt(): number;
        equal(value: any): boolean;
        toColorStr(): string;
    }
    class Path {
        paths: any[];
        private _curPath;
        constructor();
        beginPath(convex: boolean): void;
        closePath(): void;
        newPath(): void;
        addPoint(pointX: number, pointY: number): void;
        push(points: any[], convex: boolean): void;
        reset(): void;
    }
    interface ISaveData {
        isSaveMark(): boolean;
        restore(context: Context): void;
    }
    class SaveBase implements ISaveData {
        static TYPE_ALPHA: number;
        static TYPE_FILESTYLE: number;
        static TYPE_FONT: number;
        static TYPE_LINEWIDTH: number;
        static TYPE_STROKESTYLE: number;
        static TYPE_MARK: number;
        static TYPE_TRANSFORM: number;
        static TYPE_TRANSLATE: number;
        static TYPE_ENABLEMERGE: number;
        static TYPE_TEXTBASELINE: number;
        static TYPE_TEXTALIGN: number;
        static TYPE_GLOBALCOMPOSITEOPERATION: number;
        static TYPE_CLIPRECT: number;
        static TYPE_CLIPRECT_STENCIL: number;
        static TYPE_IBVB: number;
        static TYPE_SHADER: number;
        static TYPE_FILTERS: number;
        static TYPE_FILTERS_TYPE: number;
        static TYPE_COLORFILTER: number;
        private static POOL;
        private static _namemap;
        private _valueName;
        private _value;
        private _dataObj;
        private _newSubmit;
        constructor();
        isSaveMark(): boolean;
        restore(context: Context): void;
        static save(context: Context, type: number, dataObj: any, newSubmit: boolean): void;
    }
    class SaveClipRect implements ISaveData {
        private static POOL;
        _globalClipMatrix: Matrix;
        _clipInfoID: number;
        _clipRect: Rectangle;
        isSaveMark(): boolean;
        restore(context: Context): void;
        static save(context: Context): void;
    }
    class SaveMark implements ISaveData {
        private static POOL;
        constructor();
        isSaveMark(): boolean;
        restore(context: Context): void;
        static Create(context: Context): SaveMark;
    }
    class SaveTransform implements ISaveData {
        private static POOL;
        constructor();
        isSaveMark(): boolean;
        restore(context: Context): void;
        static save(context: Context): void;
    }
    class SaveTranslate implements ISaveData {
        private static POOL;
        isSaveMark(): boolean;
        restore(context: Context): void;
        static save(context: Context): void;
    }
    /**
     * 对象 cacheas normal的时候，本质上只是想把submit缓存起来，以后直接执行
     * 为了避免各种各样的麻烦，这里采用复制相应部分的submit的方法。执行环境还是在原来的context中
     * 否则包括clip等都非常难以处理
     */
    class WebGLCacheAsNormalCanvas {
        submitStartPos: number;
        submitEndPos: number;
        context: Context;
        touches: CharRenderInfo[];
        submits: any[];
        sprite: Sprite | null;
        private _pathMesh;
        private _triangleMesh;
        meshlist: Sprite2DGeometry[];
        private _oldMesh;
        private _oldPathMesh;
        private _oldTriMesh;
        private _oldMeshList;
        private cachedClipInfo;
        private oldTx;
        private oldTy;
        private static matI;
        invMat: Matrix;
        constructor(ctx: Context, sp: Sprite);
        startRec(): void;
        endRec(): void;
        isTextNeedRestore(): boolean;
        flushsubmit(): void;
        releaseMem(): void;
    }
    class Shader2D {
        /**
         * primitive Mesh Descript
         */
        static readonly primitiveAttribute: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        };
        /**
         * TextureSV Mesh Descript
         */
        static readonly textureAttribute: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        };
        /**
         * init 2D internal Shader
         */
        static __init__(): void;
    }
    class ShaderDefines2D {
        static UNIFORM_CLIPMATDIR: number;
        static UNIFORM_CLIPMATPOS: number;
        static UNIFORM_MMAT2: number;
        static UNIFORM_SIZE: number;
        static UNIFORM_VERTALPHA: number;
        static UNIFORM_MVPMatrix: number;
        static UNIFORM_SPRITETEXTURE: number;
        static UNIFORM_STRENGTH_SIG2_2SIG2_GAUSS1: number;
        static UNIFORM_BLURINFO: number;
        static UNIFORM_COLORALPHA: number;
        static UNIFORM_COLORMAT: number;
        static UNIFORM_COLOR: number;
        static UNIFORM_BLURINFO1: number;
        static UNIFORM_BLURINFO2: number;
        static UNIFORM_COLORADD: number;
        static UNIFORM_TEXRANGE: number;
        static __init__(): void;
        static initSprite2DCommandEncoder(): void;
    }
    class PrimitiveSV extends Value2D {
        constructor();
        protected initialize(): void;
        reinit(): void;
    }
    class TextureSV extends Value2D {
        private _blurInfo;
        private _u_blurInfo1;
        private _u_blurInfo2;
        private _u_TexRange;
        private _colorMat;
        private _colorAlpha;
        private _strength_sig2_2sig2_gauss1;
        constructor();
        protected initialize(): void;
        reinit(): void;
        get blurInfo(): Vector2;
        set blurInfo(value: Vector2);
        get u_blurInfo1(): Vector4;
        set u_blurInfo1(value: Vector4);
        get u_blurInfo2(): Vector4;
        set u_blurInfo2(value: Vector4);
        get u_TexRange(): Vector4;
        set u_TexRange(value: Vector4);
        get colorMat(): Matrix4x4;
        set colorMat(value: Matrix4x4);
        get colorAlpha(): Vector4;
        set colorAlpha(value: Vector4);
        get strength_sig2_2sig2_gauss1(): Vector4;
        set strength_sig2_2sig2_gauss1(value: Vector4);
    }
    enum RenderSpriteData {
        Zero = 0,
        Texture2D = 1,
        Primitive = 2
    }
    class Value2D {
        protected static _cache: any[];
        protected static _typeClass: any;
        static _compileDefine: IDefineDatas;
        _needRelease: boolean;
        shaderData: ShaderData;
        _defaultShader: Shader3D;
        private mainID;
        private ref;
        private _cacheID;
        filters: any[];
        private _textureHost;
        constructor(mainID: RenderSpriteData);
        protected initialize(): void;
        reinit(): void;
        static _initone(type: number, classT: any): void;
        /**
         * 对象池概念
         * @param mainType
         * @returns
         */
        static create(mainType: RenderSpriteData): Value2D;
        get size(): Vector2;
        set vertAlpha(value: number);
        get vertAlpha(): number;
        get u_MvpMatrix(): Matrix4x4;
        get textureHost(): Texture | BaseTexture;
        set textureHost(value: Texture | BaseTexture);
        set color(value: Vector4);
        get color(): Vector4;
        set colorAdd(value: Vector4);
        get colorAdd(): Vector4;
        set clipMatDir(value: Vector4);
        get clipMatDir(): Vector4;
        set clipMatPos(value: Vector2);
        get clipMatPos(): Vector2;
        upload(material: Material | null, shaderData: ShaderData): void;
        setFilter(value: ColorFilter): void;
        clear(): void;
        blendNormal(): void;
        blendPremulAlpha(): void;
        blendAdd(): void;
        blendMask(): void;
        release(): void;
    }
    class Value2DManager {
    }
    class BasePoly {
        private static _checkMinAngle;
        /**
         * 构造线的三角形数据。根据一个位置数组生成vb和ib
         * @param	p
         * @param	indices
         * @param	lineWidth
         * @param	indexBase				顶点开始的值，ib中的索引会加上这个
         * @param	outVertex
         * @return
         */
        static createLine2(p: any[], indices: any[], lineWidth: number, indexBase: number, outVertex: any[], loop: boolean): any[];
        private static _setMiddleVertexs;
        static getNormal(x1: number, y1: number, x2: number, y2: number, w: number, out?: Vector2): Vector2;
        /**
         * 相邻的两段线，边界会相交，这些交点可以作为三角形的顶点。有两种可选，一种是采用左左,右右交点，一种是采用 左右，左右交点。当两段线夹角很小的时候，如果采用
         * 左左，右右会产生很长很长的交点，这时候就要采用左右左右交点，相当于把尖角截断。
         * 当采用左左右右交点的时候，直接用切线的垂线。采用左右左右的时候，用切线
         * 切线直接采用两个方向的平均值。不能用3-1的方式，那样垂线和下一段可能都在同一方向（例如都在右方）
         * 注意把重合的点去掉
         * @param	path
         * @param	color
         * @param	width
         * @param	loop
         * @param	outvb
         * @param	vbstride  顶点占用几个float,(bytelength/4)
         * @param	outib
         * test:
         * 横线
         * [100,100, 400,100]
         * 竖线
         * [100,100, 100,400]
         * 直角
         * [100,100, 400,100, 400,400]
         * 重合点
         * [100,100,100,100,400,100]
         * 同一直线上的点
         * [100,100,100,200,100,3000]
         * 像老式电视的左边不封闭的图形
         * [98,176,  163,178, 95,66, 175,177, 198,178, 252,56, 209,178,  248,175,  248,266,  209,266, 227,277, 203,280, 188,271,  150,271, 140,283, 122,283, 131,268, 99,268]
         *
         */
        static createLineTriangle(path: any[], color: number, width: number, loop: boolean, outvb: Float32Array, vbstride: number, outib: Uint16Array): void;
    }
    class Earcut {
        static earcut(data: any, holeIndices: any, dim: any): any;
        static linkedList(data: any, start: any, end: any, dim: any, clockwise: any): any;
        static filterPoints(start: any, end: any): any;
        static earcutLinked(ear: any, triangles: any, dim: any, minX: any, minY: any, invSize: any, pass?: any): any;
        static isEar(ear: any): any;
        static isEarHashed(ear: any, minX: any, minY: any, invSize: any): boolean;
        static cureLocalIntersections(start: any, triangles: any, dim: any): any;
        static splitEarcut(start: any, triangles: any, dim: any, minX: any, minY: any, invSize: any): void;
        static eliminateHoles(data: any, holeIndices: any, outerNode: any, dim: any): any;
        static compareX(a: any, b: any): any;
        static eliminateHole(hole: any, outerNode: any): void;
        static findHoleBridge(hole: any, outerNode: any): any;
        static indexCurve(start: any, minX: any, minY: any, invSize: any): void;
        static sortLinked(list: any): any;
        static zOrder(x: any, y: any, minX: any, minY: any, invSize: any): any;
        static getLeftmost(start: any): any;
        static pointInTriangle(ax: any, ay: any, bx: any, by: any, cx: any, cy: any, px: any, py: any): boolean;
        static isValidDiagonal(a: any, b: any): boolean;
        static area(p: any, q: any, r: any): any;
        static equals(p1: any, p2: any): boolean;
        static intersects(p1: any, q1: any, p2: any, q2: any): boolean;
        static intersectsPolygon(a: any, b: any): boolean;
        static locallyInside(a: any, b: any): boolean;
        static middleInside(a: any, b: any): boolean;
        static splitPolygon(a: any, b: any): any;
        static insertNode(i: any, x: any, y: any, last: any): any;
        static removeNode(p: any): void;
        static signedArea(data: any, start: any, end: any, dim: any): any;
    }
    class EarcutNode {
        i: any;
        x: any;
        y: any;
        prev: any;
        next: any;
        z: any;
        prevZ: any;
        nextZ: any;
        steiner: any;
        constructor(i: any, x: any, y: any);
    }
    class SubmitBase {
        static KEY_ONCE: number;
        static KEY_FILLRECT: number;
        static KEY_DRAWTEXTURE: number;
        static KEY_VG: number;
        static KEY_TRIANGLES: number;
        static RENDERBASE: SubmitBase;
        static ID: number;
        clipInfoID: number;
        blendType: number;
        protected _id: number;
        _mesh: Sprite2DGeometry;
        material: Material;
        _colorFiler: ColorFilter;
        shaderValue: Value2D;
        constructor();
        static create(context: Context, mesh: Sprite2DGeometry, sv: Value2D): SubmitBase;
    }
    /**
     * ...
     * @author xie
     */
    class SubmitKey {
        blendShader: number;
        submitType: number;
        other: number;
        constructor();
        clear(): void;
    }
    /**
     * 阿拉伯文的转码。把unicode的阿拉伯文字母编码转成他们的老的能描述不同写法的编码。
     *  这个是从GitHub上 Javascript-Arabic-Reshaper 项目转来的
     * https://github.com/louy/Javascript-Arabic-Reshaper/blob/master/src/index.js
     */
    /**
     * Javascript Arabic Reshaper by Louy Alakkad
     * https://github.com/louy/Javascript-Arabic-Reshaper
     * Based on (http://git.io/vsnAd)
     */
    class ArabicReshaper {
        characterMapContains(c: number): boolean;
        getCharRep(c: number): boolean;
        getCombCharRep(c1: number, c2: number): boolean;
        isTransparent(c: number): boolean;
        getOriginalCharsFromCode(code: number): string;
        /**
         * 转换函数。从normal转到presentB
         * 这个返回的字符串可以直接按照从左到右的顺序渲染。
         * 例如
         * graphics.fillText(convertArabic('سلام'),....)
         *
        */
        convertArabic(normal: any): string;
        convertArabicBack(apfb: any): string;
    }
    class AtlasGrid {
        atlasID: number;
        private _width;
        private _height;
        private _texCount;
        private _rowInfo;
        private _cells;
        _used: number;
        constructor(width?: number, height?: number, id?: number);
        addRect(type: number, width: number, height: number, pt: Point): boolean;
        private _release;
        private _init;
        private _get;
        private _fill;
        private _check;
        private _clear;
    }
    class CharRender_Canvas extends ICharRender {
        private static canvas;
        private ctx;
        private lastScaleX;
        private lastScaleY;
        private maxTexW;
        private maxTexH;
        private scaleFontSize;
        private showDbgInfo;
        private supportImageData;
        constructor(maxw: number, maxh: number, scalefont?: boolean, useImageData?: boolean, showdbg?: boolean);
        /**
         * @override
         */
        get canvasWidth(): number;
        /**
         * @override
         */
        set canvasWidth(w: number);
        /**
         *
         * @param font
         * @param str
         * @override
         */
        getWidth(font: string, str: string): number;
        /**
         *
         * @param sx
         * @param sy
         * @override
         */
        scale(sx: number, sy: number): void;
        /**
         *TODO stroke
         * @param	char
         * @param	font
         * @param	cri  修改里面的width。
         * @return
         * @override
         */
        getCharBmp(char: string, font: string, lineWidth: number, colStr: string, strokeColStr: string, cri: CharRenderInfo, margin_left: number, margin_top: number, margin_right: number, margin_bottom: number, rect?: any[] | null): ImageData | null;
        getCharCanvas(char: string, font: string, lineWidth: number, colStr: string, strokeColStr: string, cri: CharRenderInfo, margin_left: number, margin_top: number, margin_right: number, margin_bottom: number): ImageData;
    }
    /**
     * TODO如果占用内存较大,这个结构有很多成员可以临时计算
     */
    class CharRenderInfo implements IAutoExpiringResource {
        isRandomTouch: boolean;
        char: string;
        texture: TextTexture;
        deleted: boolean;
        uv: number[];
        pos: number;
        width: number;
        height: number;
        bmpWidth: number;
        bmpHeight: number;
        orix: number;
        oriy: number;
        touchTick: number;
        isSpace: boolean;
        touch(): void;
    }
    /**
     * ...
     * @author laoxie
     */
    class CharSubmitCache {
        private static __posPool;
        private static __nPosPool;
        private _data;
        private _ndata;
        private _tex;
        private _imgId;
        private _clipid;
        private _clipMatrix;
        constructor(ctx: Context);
        clear(): void;
        destroy(): void;
        add(ctx: Context, tex: Texture, imgid: number, pos: any[], uv: ArrayLike<number>, color: number): void;
        getPos(): any[];
        enable(value: boolean, ctx: Context): void;
        submit(ctx: Context): void;
    }
    class ICharRender {
        fontsz: number;
        getWidth(font: string, str: string): number;
        scale(sx: number, sy: number): void;
        get canvasWidth(): number;
        set canvasWidth(w: number);
        /**
         *TODO stroke
         * @param	char
         * @param	font
         * @param	size  返回宽高
         * @return
         */
        getCharBmp(char: string, font: string, lineWidth: number, colStr: string, strokeColStr: string, size: CharRenderInfo, margin_left: number, margin_top: number, margin_right: number, margin_bottom: number, rect?: any[] | null): ImageData | null;
    }
    interface IFontMeasure {
        getFontSizeInfo(font: string, size: number): number;
    }
    class MeasureFont implements IFontMeasure {
        private bmpData32;
        private charRender;
        constructor(charRender: ICharRender);
        getFontSizeInfo(font: string, size: number): number;
        /**
         * 检查当前线是否存在数据
         * @param	data
         * @param	l
         * @param	sx
         * @param	ex
         * @return
         */
        private checkBmpLine;
        /**
         * 根据bmp数据和当前的包围盒，更新包围盒
         * 由于选择的文字是连续的，所以可以用二分法
         * @param	data
         * @param	curbbx 	[l,t,r,b]
         * @param   onlyH 不检查左右
         */
        private updateBbx;
    }
    /**
     *  文字贴图的大图集。
     */
    class TextAtlas {
        texWidth: number;
        texHeight: number;
        private atlasgrid;
        texture: TextTexture | null;
        charMaps: {
            [key: string]: CharRenderInfo;
        };
        static atlasGridW: number;
        constructor();
        setProtecteDist(d: number): void;
        /**
         * 如果返回null，则表示无法加入了
         * 分配的时候优先选择最接近自己高度的节点
         * @param	w
         * @param	h
         * @return
         */
        getAEmpty(w: number, h: number, pt: Point): boolean;
        /**
         * 大图集格子单元的占用率，老的也算上了。只是表示这个大图集还能插入多少东西。
         */
        get usedRate(): number;
        destroy(): void;
        printDebugInfo(): void;
    }
    class TextRender extends EventDispatcher {
        static useOldCharBook: boolean;
        static atlasWidth: number;
        static noAtlas: boolean;
        static forceSplitRender: boolean;
        static forceWholeRender: boolean;
        static scaleFontWithCtx: boolean;
        static maxFontScale: number;
        static standardFontSize: number;
        static destroyAtlasDt: number;
        static checkCleanTextureDt: number;
        static destroyUnusedTextureDt: number;
        static cleanMem: number;
        static isWan1Wan: boolean;
        static showLog: boolean;
        static debugUV: boolean;
        /**
         * fontSizeInfo
         * 记录每种字体的像素的大小。标准是32px的字体。由4个byte组成，分别表示[xdist,ydist,w,h]。
         * xdist,ydist 是像素起点到排版原点的距离，都是正的，表示实际数据往左和上偏多少，如果实际往右和下偏，则算作0，毕竟这个只是一个大概
         * 例如 [Arial]=0x00002020, 表示宽高都是32
         */
        private fontSizeInfo;
        charRender: ICharRender;
        private mapFont;
        private fontID;
        private fontScaleX;
        private fontScaleY;
        private _curStrPos;
        static textRenderInst: TextRender;
        textAtlases: TextAtlas[];
        private isoTextures;
        private static imgdtRect;
        private lastFont;
        private fontSizeW;
        private fontSizeH;
        private fontSizeOffX;
        private fontSizeOffY;
        private renderPerChar;
        private fontStr;
        static simClean: boolean;
        private _fontMeasure;
        constructor();
        set fontMeasure(m: IFontMeasure);
        get fontMeasure(): IFontMeasure;
        private _wan1wansz;
        private getFontSizeInfo;
        /**
         * 设置当前字体，获得字体的大小信息。
         * @param	font
         */
        setFont(font: FontInfo): void;
        /**
         * 从string中取出一个完整的char，例如emoji的话要多个
         * 会修改 _curStrPos
         * TODO 由于各种文字中的组合写法，这个需要能扩展，以便支持泰文等
         * @param	str
         * @param	start	开始位置
         */
        getNextChar(str: string): string | null;
        filltext(ctx: Context, data: string | WordText, x: number, y: number, fontStr: string, color: string, strokeColor: string, lineWidth: number, textAlign: string): void;
        _fast_filltext(ctx: Context, data: string | WordText | null, x: number, y: number, font: FontInfo, color: string, strokeColor: string | null, lineWidth: number, textAlign: number): void;
        /**
         * 画出重新按照贴图顺序分组的文字。
         * @param	samePagesData
         * @param  startx 保存的数据是相对位置，所以需要加上这个偏移。用相对位置更灵活一些。
         * @param y {int} 因为这个只能画在一行上所以没有必要保存y。所以这里再把y传进来
         */
        protected _drawResortedWords(ctx: Context, startx: number, starty: number, samePagesData: {
            [key: number]: any;
        }): void;
        /**
         * 检查 txts数组中有没有被释放的资源
         * @param	txts {{ri:CharRenderInfo,...}[][]}
         * @param	startid
         * @return
         */
        hasFreedText(txts: any[]): boolean;
        getCharRenderInfo(str: string, font: FontInfo, color: string, strokeColor: string | null, lineWidth: number, isoTexture?: boolean): CharRenderInfo;
        /**
         * 添加数据到大图集
         * @param	w
         * @param	h
         * @return
         */
        addBmpData(data: ImageData, ri: CharRenderInfo): TextAtlas;
        /**
         * 清理利用率低的大图集
         */
        GC(): void;
        /**
         * 尝试清理大图集
         */
        cleanAtlases(): void;
        printDbgInfo(): void;
        showAtlas(n: number, bgcolor: string, x: number, y: number, w: number, h: number): Sprite;
    }
    /**
     * 保存文字的贴图
     */
    class TextTexture extends Texture2D {
        private static pool;
        private static poolLen;
        private static cleanTm;
        static EVENT_REUSE: string;
        genID: number;
        curUsedCovRate: number;
        curUsedCovRateAtlas: number;
        lastTouchTm: number;
        ri: CharRenderInfo;
        constructor(textureW?: number, textureH?: number);
        /**
         * 添加一个文字位图
         * @param	data
         * @param	x			拷贝位置。
         * @param	y
         * @param  uv
         * @return uv数组  如果uv不为空就返回传入的uv，否则new一个数组
         */
        addChar(data: ImageData, x: number, y: number, uv?: any[]): any[];
        /**
         * 添加一个文字
         * 玩一玩不支持 getImageData，只能用canvas的方式
         * @param	canv
         * @param	x
         * @param	y
         */
        addCharCanvas(canv: any, x: number, y: number, uv?: any[]): any[];
        /**
         * 填充白色。调试用。
         */
        fillWhite(): void;
        discard(): void;
        static getTextTexture(w: number, h: number): TextTexture;
        /**
         * 定期清理
         * 为了简单，只有发生 getAPage 或者 discardPage的时候才检测是否需要清理
         *
         * 暂时先不用这个了。
         */
        static clean(): void;
        /**
         * 这个贴图被当前帧使用了。
         * 这个是基于贴图的，更简单，效率更高
         */
        touchTexture(): void;
        touchRect(ri: CharRenderInfo, frame: number): void;
    }
    /**
     * <code>BufferState</code> 类用于实现渲染所需的Buffer状态集合。
     */
    class BufferState {
        private static vertexBufferArray;
        /**@private [只读]*/
        _deviceBufferState: IBufferState;
        /**
         * 创建一个 <code>BufferState</code> 实例。
         */
        constructor();
        applyState(vertexBuffers: VertexBuffer3D[], indexBuffer: IndexBuffer3D | null): void;
        /**
         * @private
         */
        destroy(): void;
    }
    class IncludeFile {
        static splitToWords(str: string, block: ShaderNode): any[];
        script: string;
        codes: any;
        funs: any;
        curUseID: number;
        funnames: string;
        constructor(txt: string);
        getWith(name?: string | null): string;
        getFunsScript(funsdef: string): string;
    }
    class MatirxArray {
        /**
         * 4*4矩阵数组相乘。
         * o=a*b;
         * @param	a 4*4矩阵数组。
         * @param	b 4*4矩阵数组。
         * @param	o 4*4矩阵数组。
         */
        static ArrayMul(a: any[], b: any[], o: any[]): void;
        static copyArray(f: any[], t: any[]): void;
    }
    /**
     * drawImage，fillRect等会用到的简单的mesh。每次添加必然是一个四边形。
     */
    class MeshQuadTexture extends Sprite2DGeometry {
        static const_stride: number;
        private static _fixib;
        private static _maxIB;
        static VertexDeclarition: VertexDeclaration;
        private _vbFloat32Array;
        private _curVBPos;
        static __int__(): void;
        constructor(vballoc?: number);
        protected onVBRealloc(buff: ArrayBuffer): void;
        protected onIBRealloc(buff: ArrayBuffer): void;
        /**
         *
         * @param pos 顶点坐标
         * @param uv 纹理坐标
         * @param color 顶点颜色
         * @param useTex 是否使用贴图。false的话是给fillRect用的
         */
        addQuad(pos: ArrayLike<number>, uv: ArrayLike<number>, color: number, useTex: boolean): void;
        clearMesh(): void;
        get ibBuffer(): ArrayBuffer;
        get vertexDeclarition(): VertexDeclaration;
    }
    /**
     * 与MeshQuadTexture基本相同。不过index不是固定的
     */
    class MeshTexture extends Sprite2DGeometry {
        static const_stride: number;
        static VertexDeclarition: VertexDeclaration;
        private _vbFloat32Array;
        private _ibU16Array;
        static __init__(): void;
        constructor();
        protected onVBRealloc(buff: ArrayBuffer): void;
        protected onIBRealloc(buff: ArrayBuffer): void;
        /**
         * 增加四个顶点
         * @param vertices
         * @param uvs
         * @param idx
         * @param matrix
         * @param rgba
         */
        addData(vertices: Float32Array, uvs: Float32Array, idx: Uint16Array, matrix: Matrix, rgba: number, uvrect?: number[]): void;
        get vertexDeclarition(): VertexDeclaration;
    }
    /**
     * 用来画矢量的mesh。顶点格式固定为 x,y,rgba
     */
    class MeshVG extends Sprite2DGeometry {
        static const_stride: number;
        static vertexDeclaration: VertexDeclaration;
        private _vbFloat32Array;
        static __init__(): void;
        constructor();
        protected onVBRealloc(buff: ArrayBuffer): void;
        protected onIBRealloc(buff: ArrayBuffer): void;
        /**
         * 往矢量mesh中添加顶点和index。会把rgba和points在mesh中合并。
         * @param	points	顶点数组，只包含x,y。[x,y,x,y...]
         * @param	rgba	rgba颜色
         * @param	ib		index数组。
         */
        addVertAndIBToMesh(points: number[], rgba: number, ib: any[]): void;
        get vertexDeclarition(): VertexDeclaration;
    }
    class RenderState2D {
        static worldMatrix4: number[];
        static worldMatrix: Matrix;
        static matWVP: any;
        static worldAlpha: number;
        static worldScissorTest: boolean;
        static worldShaderDefines: ShaderDefines2D;
        static worldFilters: ColorFilter[];
        static width: number;
        static height: number;
        static InvertY: boolean;
        static restoreTempArray(): void;
        static clear(): void;
    }
    interface IShaderCompiledObj {
        vsNode: ShaderNode;
        psNode: ShaderNode;
        includeNames: Set<string>;
        defs: Set<string>;
    }
    /**
     * @private
     * <code>ShaderCompile</code> 类用于实现Shader编译。
     */
    class ShaderCompile {
        static IFDEF_NO: number;
        static IFDEF_YES: number;
        static IFDEF_ELSE: number;
        static IFDEF_PARENT: number;
        static includes: Record<string, IncludeFile>;
        static loadIncludeFileSync: (fileName: string) => void;
        static addInclude(fileName: string, txt: string, allowReplace?: boolean): IncludeFile;
        static compile(vs: string, ps: string, basePath?: string): IShaderCompiledObj;
        static compileAsync(vs: string, ps: string, basePath: string): Promise<IShaderCompiledObj>;
        private static _loadIncludesDeep;
        /**
         * @private
         */
        private static _compileToTree;
        static getRenderState(obj: Record<string, string | boolean | number | string[]>, renderState: RenderState): void;
    }
    class ShaderProcessInfo {
        defineString: string[];
        vs: ShaderNode;
        ps: ShaderNode;
        attributeMap: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        };
        uniformMap: UniformMapType;
        is2D: boolean;
    }
    class ShaderCompileDefineBase {
        constructor(owner: any, name: string, compiledObj: IShaderCompiledObj);
    }
    class ShaderNode {
        private static __id;
        private static __noCompileEnable;
        childs: any[];
        text: string;
        parent: ShaderNode;
        name: string;
        noCompile: boolean;
        includefiles: any[];
        condition: any;
        conditionType: number;
        useFuns: string;
        z: number;
        src: string;
        constructor(includefiles: any[]);
        setParent(parent: ShaderNode): void;
        setCondition(condition: string, type: number): void;
        toscript(def: any, out: any[]): any[];
        private _toscript;
    }
    /**
     * Mesh2d只是保存数据。描述attribute用的。本身没有webgl数据。
     */
    abstract class Sprite2DGeometry implements ISprite2DGeometry {
        protected _stride: number;
        protected _vertNum: number;
        protected _indexNum: number;
        protected _VBBuff: ArrayBuffer;
        protected _IBBuff: ArrayBuffer;
        /**
         * @param	stride
         * @param	vballoc  vb预分配的大小。主要是用来提高效率。防止不断的resizebfufer
         * @param	iballoc
         */
        constructor(stride: number, vballoc: number, iballoc: number);
        get vbBuffer(): ArrayBuffer;
        get ibBuffer(): ArrayBuffer;
        get indexNum(): number;
        get vertexNum(): number;
        abstract get vertexDeclarition(): VertexDeclaration;
        clearMesh(): void;
        protected abstract onVBRealloc(buff: ArrayBuffer): void;
        protected abstract onIBRealloc(buff: ArrayBuffer): void;
        /**
        * 在当前的基础上需要多大空间，单位是byte
        * @param	sz
        */
        protected expVBSize(len: number): void;
        protected expIBSize(len: number): void;
    }
    /**
     * @private
     */
    class WebGL {
        static isNativeRender_enable: boolean;
        static _nativeRender_enable(): void;
        static enable(): boolean;
        static onStageResize(width: number, height: number): void;
    }
    class LayaEnv {
        /**
         * @en The version of the engine.
         * @zh 引擎的版本。
         */
        static version: string;
        /**
         * @en Whether the engine is running in the editor. If it is false, it indicates that the engine is running in the scene view of the IDE, otherwise it is true.
         * @zh 区分引擎是在编辑模式还是播放模式，在IDE的场景视图编辑时，此值为 false，否则为 true。
         */
        static isPlaying: boolean;
        /**
         * @en Whether the engine is running in the preview mode or the product mode. If it is false, it indicates that the engine is running after the release, otherwise it is true.
         * @zh 区分引擎是在预览模式还是产品模式。如果发布后运行，此值为 false，否则为 true。
         */
        static isPreview: boolean;
        /**
         * @en Whether the engine is running in the native platform.
         * @zh 引擎是否正在运行在原生平台。
         */
        static isConch: boolean;
        /**
         * @en Whether the engine is running in the editor. The engine may have two states in the editor, one is running in the scene view of the editor, and the other is running in the game view of the editor. Please distinguish these two states through isPlaying.
         * @zh 引擎是否正在运行在编辑器下。引擎在编辑器下可能有两种状态，一种是运行在编辑器的场景视图，一种是运行在编辑器的游戏视图，请通过isPlaying区别这两种情况。
         */
        static isEditor: boolean;
        /** @deprecated Uses Laya.addBeforeInitCallback */
        static beforeInit: (stageConfig: IStageConfig) => void;
        /** @deprecated Use Laya.addAfterInitCallback */
        static afterInit: () => void;
    }
    interface IStageConfig {
        designWidth?: number;
        designHeight?: number;
        scaleMode?: string;
        screenMode?: string;
        alignV?: string;
        alignH?: string;
        backgroundColor?: string;
    }
    /**
     * @en Global UI configuration settings.
     * @zh 全局配置
     */
    class UIConfig {
        /**
         * @en Enable touch scrolling (for scroll bars).
         * @zh 是否开启触摸滚动（针对滚动条）
         */
        static touchScrollEnable: boolean;
        /**
         * @en Enable mouse wheel scrolling (for scroll bars).
         * @zh 是否开启滑轮滚动（针对滚动条）
         */
        static mouseWheelEnable: boolean;
        /**
         * @en Show scroll bar buttons.
         * @zh 是否显示滚动条按钮
         */
        static showButtons: boolean;
        /**
         * @en Background color for pop-up dialogs.
         * @zh 弹出框背景颜色
         */
        static popupBgColor: string;
        /**
         * @en Background transparency for pop-up dialogs.
         * @zh 弹出框背景透明度
         */
        static popupBgAlpha: number;
        /**
         * @en Whether clicking on the edge of a modal window will close it. The default is to close the window.
         * @zh 模式窗口点击边缘，是否关闭窗口，默认是关闭的
         */
        static closeDialogOnSide: boolean;
    }
}
